{"task_id": "MBPP/954", "completion": "def profit_amount(actual_cost, sale_amount):\n    \"\"\"\n    Calculate the profit amount based on actual cost and sale amount.\n    \n    If the sale amount is greater than the actual cost, return the profit amount.\n    Otherwise, return None.\n    \n    Parameters:\n    actual_cost (float): The cost price of the item.\n    sale_amount (float): The selling price of the item.\n    \n    Returns:\n    float or None: The profit amount if there is a profit, otherwise None.\n    \"\"\"\n    # Calculate profit\n    profit = sale_amount - actual_cost\n    \n    # Check if there is a profit\n    if profit > 0:\n        return profit\n    else:\n        return None\n\n# Test cases\nassert profit_amount(1500, 1200) is None  # No profit\nassert profit_amount(1500, 1800) == 300   # Profit of 300\nassert profit_amount(1000, 1000) is None  # No profit\nassert profit_amount(500, 700) == 200      # Profit of 200\nassert profit_amount(0, 100) == 100        # Profit of 100 when cost is 0"}
{"task_id": "MBPP/460", "completion": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist from the given list of lists.\n\n    Parameters:\n    lst (list of list): A list containing sublists.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n\n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    # Using list comprehension to extract the first element of each sublist\n    return [sublist[0] for sublist in lst if sublist]  # Check if sublist is not empty\n\n# Test case to validate the function\nassert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\nassert Extract([[10], [20, 30], [40, 50, 60]]) == [10, 20, 40]\nassert Extract([[], [1, 2], [3]]) == [1, 3]  # Handling empty sublist\nassert Extract([[], [], []]) == []  # All sublists are empty\nassert Extract([]) == []  # Input list is empty\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/865", "completion": "def ntimes_list(nums, n):\n    \"\"\"\n    Multiplies each element in the list 'nums' by 'n' using the map function.\n    \n    Parameters:\n    nums (list): A list of numbers to be multiplied.\n    n (int): The multiplier.\n    \n    Returns:\n    list: A new list with each element multiplied by 'n'.\n    \n    Example:\n    >>> ntimes_list([1, 2, 3, 4, 5, 6, 7], 3)\n    [3, 6, 9, 12, 15, 18, 21]\n    \"\"\"\n    # Use map to multiply each element in nums by n\n    return list(map(lambda x: x * n, nums))\n\n# Test case to verify the correctness of the function\nassert ntimes_list([1, 2, 3, 4, 5, 6, 7], 3) == [3, 6, 9, 12, 15, 18, 21]"}
{"task_id": "MBPP/173", "completion": "import re\n\ndef remove_splchar(text):\n    \"\"\"\n    Remove everything except alphanumeric characters from a string.\n    \n    Parameters:\n    text (str): The input string from which to remove special characters.\n    \n    Returns:\n    str: A string containing only alphanumeric characters.\n    \"\"\"\n    # Use regex to substitute non-alphanumeric characters with an empty string\n    cleaned_text = re.sub(r'[^a-zA-Z0-9]', '', text)\n    return cleaned_text\n\n# Test case to validate the function\nassert remove_splchar('python \u00c2\u00a0@#&^%$*program123') == 'pythonprogram123'\nassert remove_splchar('Hello, World! 2023') == 'HelloWorld2023'\nassert remove_splchar('1234567890') == '1234567890'\nassert remove_splchar('') == ''\nassert remove_splchar('NoSpecialChars') == 'NoSpecialChars'\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/495", "completion": "import re\n\ndef remove_lowercase(str1):\n    \"\"\"\n    Remove all lowercase substrings from the given string using regex.\n    \n    Parameters:\n    str1 (str): The input string from which lowercase letters will be removed.\n    \n    Returns:\n    str: A new string with all lowercase letters removed.\n    \"\"\"\n    # Use regex to substitute all lowercase letters with an empty string\n    result = re.sub(r'[a-z]', '', str1)\n    return result\n\n# Test case to verify the function works as expected\nassert remove_lowercase('KDeoALOklOOHserfLoAJSIskdsf') == 'KDALOOOHLAJSI'\n\n# Additional test cases\nassert remove_lowercase('HelloWorld') == 'HW'\nassert remove_lowercase('Python3.8') == 'P3.'\nassert remove_lowercase('123abcXYZ') == '123XYZ'\nassert remove_lowercase('') == ''  # Edge case: empty string\nassert remove_lowercase('ALLUPPERCASE') == 'ALLUPPERCASE'  # Edge case: all uppercase\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/131", "completion": "def reverse_vowels(str1):\n    \"\"\"\n    Reverse only the vowels of a given string.\n    \n    Parameters:\n    str1 (str): The input string to process.\n    \n    Returns:\n    str: The string with vowels reversed.\n    \"\"\"\n    # Define a set of vowels for quick lookup\n    vowels = set('aeiouAEIOU')\n    \n    # Extract vowels from the string\n    vowel_list = [char for char in str1 if char in vowels]\n    \n    # Reverse the list of vowels\n    vowel_list.reverse()\n    \n    # Iterator for the reversed vowels\n    vowel_iter = iter(vowel_list)\n    \n    # Build the result string\n    result = []\n    for char in str1:\n        if char in vowels:\n            # Replace with the next vowel from the reversed list\n            result.append(next(vowel_iter))\n        else:\n            # Keep the consonant as is\n            result.append(char)\n    \n    return ''.join(result)\n\n# Test cases to verify the correctness of the function\nassert reverse_vowels(\"Python\") == \"Python\"  # No vowels to reverse\nassert reverse_vowels(\"hello\") == \"holle\"    # 'e' and 'o' are reversed\nassert reverse_vowels(\"leetcode\") == \"leotcede\"  # 'e's and 'o' are reversed\nassert reverse_vowels(\"aA\") == \"Aa\"            # 'a' and 'A' are reversed\nassert reverse_vowels(\" \") == \" \"              # Space remains unchanged\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/801", "completion": "def test_three_equal(x, y, z):\n    \"\"\"\n    Count the number of equal numbers from three given integers.\n    \n    Parameters:\n    x (int): First integer\n    y (int): Second integer\n    z (int): Third integer\n    \n    Returns:\n    int: The count of equal integers among the three inputs\n    \"\"\"\n    # Initialize a counter for equal numbers\n    count = 0\n    \n    # Check for equality among the three integers\n    if x == y == z:\n        count = 3  # All three are equal\n    elif x == y or y == z or x == z:\n        count = 2  # Two are equal\n    else:\n        count = 0  # All are different\n    \n    return count\n\n# Test cases to verify the correctness of the function\nassert test_three_equal(1, 1, 1) == 3, \"Test case 1 failed\"\nassert test_three_equal(1, 1, 2) == 2, \"Test case 2 failed\"\nassert test_three_equal(1, 2, 2) == 2, \"Test case 3 failed\"\nassert test_three_equal(1, 2, 3) == 0, \"Test case 4 failed\"\nassert test_three_equal(0, 0, 0) == 3, \"Test case 5 failed\"\nassert test_three_equal(-1, -1, 1) == 2, \"Test case 6 failed\"\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/929", "completion": "def count_tuplex(tuplex, value):\n    \"\"\"\n    Count the number of times a specific value appears in a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple in which to count occurrences.\n    value: The value to count in the tuple.\n\n    Returns:\n    int: The count of occurrences of the value in the tuple.\n    \n    Example:\n    >>> count_tuplex((2, 4, 5, 6, 2, 3, 4, 4, 7), 4)\n    3\n    \"\"\"\n    # Validate input types\n    if not isinstance(tuplex, tuple):\n        raise ValueError(\"The first argument must be a tuple.\")\n    \n    # Count occurrences of the value in the tuple\n    return tuplex.count(value)\n\n# Test case\nassert count_tuplex((2, 4, 5, 6, 2, 3, 4, 4, 7), 4) == 3"}
{"task_id": "MBPP/645", "completion": "def find_k_product(test_list, K):\n    \"\"\"\n    Find the product of the elements at the Kth index in the given list of tuples.\n\n    Parameters:\n    test_list (list of tuples): A list containing tuples from which to extract elements.\n    K (int): The index of the elements to be multiplied.\n\n    Returns:\n    int: The product of the elements at the Kth index.\n\n    Raises:\n    IndexError: If K is out of bounds for the tuples in the list.\n    ValueError: If the input list is empty.\n    \"\"\"\n    # Validate input\n    if not test_list:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    # Check if K is a valid index for the tuples\n    if any(len(tup) <= K for tup in test_list):\n        raise IndexError(f\"K={K} is out of bounds for the tuples in the list.\")\n\n    # Calculate the product of the Kth elements\n    product = 1\n    for tup in test_list:\n        product *= tup[K]\n    \n    return product\n\n# Test cases\nassert find_k_product([(5, 6, 7), (1, 3, 5), (8, 9, 19)], 2) == 665  # 7 * 5 * 19 = 665\nassert find_k_product([(2, 4, 6), (1, 3, 5), (8, 9, 10)], 1) == 108  # 4 * 3 * 9 = 108\nassert find_k_product([(1, 2), (3, 4), (5, 6)], 0) == 15  # 1 * 3 * 5 = 15\n\n# Edge case: empty list\ntry:\n    find_k_product([], 0)\nexcept ValueError as e:\n    print(e)  # Expected output: \"The input list cannot be empty.\"\n\n# Edge case: K out of bounds\ntry:\n    find_k_product([(1, 2), (3, 4)], 2)\nexcept IndexError as e:\n    print(e)  # Expected output: \"K=2 is out of bounds for the tuples in the list.\""}
{"task_id": "MBPP/402", "completion": "def factorial_mod(n, p):\n    \"\"\"Compute factorials % p for all numbers from 0 to n.\"\"\"\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = (fact[i - 1] * i) % p\n    return fact\n\ndef mod_inverse(a, p):\n    \"\"\"Compute the modular inverse of a under modulo p using Fermat's Little Theorem.\"\"\"\n    return pow(a, p - 2, p)\n\ndef ncr_modp(n, r, p):\n    \"\"\"\n    Compute nCr % p using precomputed factorials and their inverses.\n    \n    Parameters:\n    n (int): The total number of items.\n    r (int): The number of items to choose.\n    p (int): The modulus.\n    \n    Returns:\n    int: The value of nCr % p.\n    \"\"\"\n    if r > n:\n        return 0  # nCr is 0 if r > n\n    \n    # Step 1: Compute all factorials % p\n    fact = factorial_mod(n, p)\n    \n    # Step 2: Compute the modular inverses of the factorials\n    inv_fact = [1] * (n + 1)\n    for i in range(n + 1):\n        inv_fact[i] = mod_inverse(fact[i], p)\n    \n    # Step 3: Calculate nCr % p\n    nCr = (fact[n] * inv_fact[r] % p) * inv_fact[n - r] % p\n    return nCr\n\n# Test case\nassert ncr_modp(10, 2, 13) == 6"}
{"task_id": "MBPP/4_4", "completion": "def rotate_matrix(matrix):\n    \"\"\"\n    Rotate a given matrix by 90 degrees clockwise.\n    \n    Args:\n    matrix (list of list of int): A 2D list representing the matrix to be rotated.\n    \n    Returns:\n    list of list of int: The rotated matrix.\n    \"\"\"\n    # Step 1: Transpose the matrix\n    transposed = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n    \n    # Step 2: Reverse each row\n    rotated = [row[::-1] for row in transposed]\n    \n    return rotated\n\n# Test case\nassert rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]"}
{"task_id": "MBPP/4_2", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the reference\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:  # If prefix becomes empty\n                return \"\"\n    \n    return prefix\n\n# Test cases\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'\nassert longest_common_prefix(['dog', 'racecar', 'car']) == ''\nassert longest_common_prefix(['a']) == 'a'\nassert longest_common_prefix([]) == ''\nassert longest_common_prefix(['']) == ''\nassert longest_common_prefix(['ab', 'a']) == 'a'\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_1", "completion": "def fibonacci(n):\n    \"\"\"\n    Returns the n-th Fibonacci number.\n    \n    Parameters:\n    n (int): The index of the Fibonacci number to return. Must be a non-negative integer.\n    \n    Returns:\n    int: The n-th Fibonacci number.\n    \n    Raises:\n    ValueError: If n is a negative integer.\n    \n    Example:\n    >>> fibonacci(5)\n    5\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Initialize the first two Fibonacci numbers\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b  # Update to the next Fibonacci numbers\n    \n    return b\n\n# Test cases\nassert fibonacci(0) == 0  # F(0) = 0\nassert fibonacci(1) == 1  # F(1) = 1\nassert fibonacci(2) == 1  # F(2) = 1\nassert fibonacci(3) == 2  # F(3) = 2\nassert fibonacci(4) == 3  # F(4) = 3\nassert fibonacci(5) == 5  # F(5) = 5\nassert fibonacci(6) == 8  # F(6) = 8\nassert fibonacci(7) == 13 # F(7) = 13\nassert fibonacci(8) == 21 # F(8) = 21\nassert fibonacci(9) == 34 # F(9) = 34\nassert fibonacci(10) == 55 # F(10) = 55\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_7", "completion": "def max_value(arr):\n    \"\"\"\n    Find the maximum value in a list of integers.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The maximum integer in the list.\n\n    Raises:\n    ValueError: If the input is not a list or if the list is empty.\n    TypeError: If the list contains non-integer elements.\n    \"\"\"\n    # Validate input\n    if not isinstance(arr, list):\n        raise ValueError(\"Input must be a list.\")\n    if len(arr) == 0:\n        raise ValueError(\"List must not be empty.\")\n    if not all(isinstance(x, int) for x in arr):\n        raise TypeError(\"All elements in the list must be integers.\")\n\n    # Use the built-in max function to find the maximum value\n    return max(arr)\n\n# Test cases\nassert max_value([1, 2, 3, 4, 5]) == 5\nassert max_value([-1, -2, -3, -4, -5]) == -1\nassert max_value([0, 0, 0]) == 0\nassert max_value([10]) == 10\nassert max_value([1, 3, 2, 5, 4]) == 5\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_3", "completion": "def gcd(a, b):\n    \"\"\"\n    Calculate the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.\n    \n    Parameters:\n    a (int): First non-negative integer.\n    b (int): Second non-negative integer.\n    \n    Returns:\n    int: The GCD of a and b.\n    \n    Raises:\n    ValueError: If a or b is negative.\n    \"\"\"\n    # Input validation\n    if a < 0 or b < 0:\n        raise ValueError(\"Both numbers must be non-negative integers.\")\n    \n    # Euclidean algorithm\n    while b != 0:\n        a, b = b, a % b\n    return a\n\n# Test case\nassert gcd(48, 18) == 6, \"Test case failed!\"\nprint(\"Test case passed!\")"}
{"task_id": "MBPP/4_9", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Take the first string as the reference\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:  # If prefix is empty, return \"\"\n                return \"\"\n    \n    return prefix\n\n# Test cases\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'\nassert longest_common_prefix(['dog', 'racecar', 'car']) == ''\nassert longest_common_prefix(['interspecies', 'interstellar', 'interstate']) == 'inters'\nassert longest_common_prefix(['a']) == 'a'\nassert longest_common_prefix([]) == ''\nassert longest_common_prefix(['']) == ''\nassert longest_common_prefix(['abc', 'ab', 'a']) == 'a'\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_6", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string among an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Take the first string as the reference\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:  # If prefix becomes empty\n                return \"\"\n    \n    return prefix\n\n# Test cases\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'\nassert longest_common_prefix(['dog', 'racecar', 'car']) == ''\nassert longest_common_prefix(['a']) == 'a'\nassert longest_common_prefix(['']) == ''\nassert longest_common_prefix(['abc', 'ab', 'a']) == 'a'\nassert longest_common_prefix([]) == ''"}
{"task_id": "MBPP/4_8", "completion": "def longest_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Take the first string as the reference\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:  # If prefix becomes empty\n                return \"\"\n    \n    return prefix\n\n# Test cases\nassert longest_prefix(['flower', 'flow', 'flight']) == 'fl'\nassert longest_prefix(['dog', 'racecar', 'car']) == ''\nassert longest_prefix(['interspecies', 'interstellar', 'interstate']) == 'inters'\nassert longest_prefix(['a']) == 'a'\nassert longest_prefix([]) == ''\nassert longest_prefix(['']) == ''\nassert longest_prefix(['abc', 'ab', 'a']) == 'a'\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_5", "completion": "def longest_common_substring(s1, s2):\n    \"\"\"\n    Find the length of the longest common substring between two strings.\n    \n    :param s1: First string\n    :param s2: Second string\n    :return: Length of the longest common substring\n    \"\"\"\n    # Initialize the lengths of the strings\n    len1, len2 = len(s1), len(s2)\n    \n    # Create a 2D array to store lengths of longest common suffixes\n    dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]\n    \n    # Variable to keep track of the maximum length of common substring\n    max_length = 0\n    \n    # Build the dp array\n    for i in range(1, len1 + 1):\n        for j in range(1, len2 + 1):\n            if s1[i - 1] == s2[j - 1]:  # Characters match\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                max_length = max(max_length, dp[i][j])  # Update max_length\n            else:\n                dp[i][j] = 0  # Reset if characters do not match\n    \n    return max_length\n\n# Test cases\nassert longest_common_substring('abcdef', 'zcdemf') == 2  # 'cd' is the longest common substring\nassert longest_common_substring('hello', 'yell') == 3    # 'ell' is the longest common substring\nassert longest_common_substring('abc', 'xyz') == 0        # No common substring\nassert longest_common_substring('abcde', 'abfce') == 2    # 'ab' is the longest common substring\nassert longest_common_substring('', 'abc') == 0            # One string is empty\nassert longest_common_substring('abc', '') == 0            # One string is empty"}
{"task_id": "MBPP/4_10", "completion": "def longest_common_subsequence(s1, s2):\n    \"\"\"\n    Function to find the length of the longest common subsequence of two strings.\n    \n    Parameters:\n    s1 (str): First string\n    s2 (str): Second string\n    \n    Returns:\n    int: Length of the longest common subsequence\n    \"\"\"\n    # Create a 2D array to store lengths of longest common subsequence\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Build the dp array\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:  # Characters match\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:  # Characters do not match\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    # The length of the longest common subsequence is in the bottom-right cell\n    return dp[m][n]\n\n# Test case\nassert longest_common_subsequence('abcde', 'ace') == 3\n\n# Additional test cases\nassert longest_common_subsequence('abc', 'abc') == 3  # Full match\nassert longest_common_subsequence('abc', 'def') == 0  # No match\nassert longest_common_subsequence('abcde', 'abc') == 3  # Subsequence at the start\nassert longest_common_subsequence('abcde', 'cde') == 3  # Subsequence at the end\nassert longest_common_subsequence('', 'abc') == 0  # One string is empty\nassert longest_common_subsequence('abc', '') == 0  # One string is empty\nassert longest_common_subsequence('', '') == 0  # Both strings are empty\n\nprint(\"All test cases passed!\")"}
