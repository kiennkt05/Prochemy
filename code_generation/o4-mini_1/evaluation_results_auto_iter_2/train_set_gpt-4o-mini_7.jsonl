{"task_id": "MBPP/495", "completion": "import re\n\ndef remove_lowercase(str1):\n    \"\"\"\n    Remove all lowercase substrings from the given string using regex.\n    \n    Parameters:\n    str1 (str): The input string from which lowercase letters will be removed.\n    \n    Returns:\n    str: The modified string with all lowercase substrings removed.\n    \"\"\"\n    # Use regex to substitute all lowercase letters with an empty string\n    result = re.sub(r'[a-z]+', '', str1)\n    return result\n\n# Test case\nassert remove_lowercase('KDeoALOklOOHserfLoAJSIskdsf') == 'KDALOOOHLAJSI'\n\n# Additional test cases\nprint(remove_lowercase('HelloWorld'))  # Expected: 'HW'\nprint(remove_lowercase('PythonIsFun'))  # Expected: 'PIF'\nprint(remove_lowercase('123abcXYZ'))  # Expected: '123XYZ'\nprint(remove_lowercase('NoLowercaseHere'))  # Expected: 'NoLowercaseHere'\nprint(remove_lowercase(''))  # Expected: ''"}
{"task_id": "MBPP/865", "completion": "def ntimes_list(nums, n):\n    \"\"\"\n    Multiplies each element in the list 'nums' by 'n' using the map function.\n    \n    Parameters:\n    nums (list): A list of numbers to be multiplied.\n    n (int): The multiplier.\n    \n    Returns:\n    list: A new list containing the results of the multiplication.\n    \n    Example:\n    >>> ntimes_list([1, 2, 3, 4, 5, 6, 7], 3)\n    [3, 6, 9, 12, 15, 18, 21]\n    \"\"\"\n    # Use map to apply the multiplication to each element in the list\n    return list(map(lambda x: x * n, nums))\n\n# Test case\nassert ntimes_list([1, 2, 3, 4, 5, 6, 7], 3) == [3, 6, 9, 12, 15, 18, 21]\n\n# Additional test cases\nassert ntimes_list([0, 1, 2], 5) == [0, 5, 10]\nassert ntimes_list([-1, -2, -3], 2) == [-2, -4, -6]\nassert ntimes_list([10], 10) == [100]\nassert ntimes_list([], 5) == []"}
{"task_id": "MBPP/173", "completion": "import re\n\ndef remove_splchar(text):\n    \"\"\"\n    Remove everything except alphanumeric characters from a string.\n    \n    Parameters:\n    text (str): The input string from which to remove special characters.\n    \n    Returns:\n    str: A string containing only alphanumeric characters.\n    \"\"\"\n    # Use regular expression to replace non-alphanumeric characters with an empty string\n    cleaned_text = re.sub(r'[^a-zA-Z0-9]', '', text)\n    return cleaned_text\n\n# Test case to verify the functionality of the remove_splchar function\nif __name__ == \"__main__\":\n    # Example test case\n    assert remove_splchar('python \u00c2\u00a0@#&^%$*program123') == 'pythonprogram123'\n    print(\"Test case passed!\")"}
{"task_id": "MBPP/460", "completion": "def Extract(lst):\n    \"\"\"\n    Extract the first element of each sublist from a list of lists.\n\n    Parameters:\n    lst (list of list): A list containing sublists.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n\n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    # Use a list comprehension to get the first element of each sublist\n    return [sublist[0] for sublist in lst if sublist]  # Check if sublist is not empty\n\n# Test case to validate the function\nassert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6], \"Test case failed!\"\nassert Extract([[10], [20, 30], [40, 50, 60]]) == [10, 20, 40], \"Test case failed!\"\nassert Extract([[], [1, 2], [3]]) == [1, 3], \"Test case failed!\"  # Handles empty sublist\nassert Extract([]) == [], \"Test case failed!\"  # Handles empty list of lists\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/801", "completion": "def test_three_equal(x, y, z):\n    \"\"\"\n    Count the number of equal numbers from three given integers.\n    \n    Parameters:\n    x (int): First integer\n    y (int): Second integer\n    z (int): Third integer\n    \n    Returns:\n    int: The count of equal integers among the three provided.\n    \n    Example:\n    >>> test_three_equal(1, 1, 1)\n    3\n    >>> test_three_equal(1, 2, 1)\n    2\n    >>> test_three_equal(1, 2, 3)\n    0\n    \"\"\"\n    count = 0\n    if x == y:\n        count += 1\n    if y == z:\n        count += 1\n    if x == z:\n        count += 1\n    \n    # If all three are equal, we should return 3, otherwise return the count\n    return count if count < 3 else 3\n\n# Example test cases\nif __name__ == \"__main__\":\n    assert test_three_equal(1, 1, 1) == 3\n    assert test_three_equal(1, 2, 1) == 2\n    assert test_three_equal(1, 2, 3) == 0\n    assert test_three_equal(5, 5, 5) == 3\n    assert test_three_equal(4, 4, 5) == 2\n    assert test_three_equal(7, 8, 9) == 0\n    \n    print(\"All test cases passed!\")"}
{"task_id": "MBPP/929", "completion": "def count_tuplex(tuplex, value):\n    \"\"\"\n    Count the occurrences of a specified value in a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple in which to count occurrences.\n    value: The value to count in the tuple.\n\n    Returns:\n    int: The number of times the value appears in the tuple.\n\n    Example:\n    >>> count_tuplex((2, 4, 5, 6, 2, 3, 4, 4, 7), 4)\n    3\n    \"\"\"\n    # Check if the input is a tuple\n    if not isinstance(tuplex, tuple):\n        raise TypeError(\"The first argument must be a tuple.\")\n    \n    # Count the occurrences of the value in the tuple\n    return tuplex.count(value)\n\n# Example test cases\nif __name__ == \"__main__\":\n    # Test case 1\n    assert count_tuplex((2, 4, 5, 6, 2, 3, 4, 4, 7), 4) == 3\n    # Test case 2\n    assert count_tuplex((1, 1, 1, 1, 1), 1) == 5\n    # Test case 3\n    assert count_tuplex((1, 2, 3, 4, 5), 6) == 0\n    # Test case 4\n    assert count_tuplex((), 1) == 0  # Empty tuple\n    # Test case 5\n    assert count_tuplex((True, False, True), True) == 2\n\n    print(\"All test cases passed!\")"}
{"task_id": "MBPP/954", "completion": "def profit_amount(actual_cost, sale_amount):\n    \"\"\"\n    Calculate the profit amount from the actual cost and sale amount.\n    \n    If the sale amount is greater than the actual cost, return the profit amount.\n    Otherwise, return None.\n    \n    Parameters:\n    actual_cost (float): The cost price of the item.\n    sale_amount (float): The selling price of the item.\n    \n    Returns:\n    float or None: The profit amount if there is a profit, otherwise None.\n    \"\"\"\n    # Calculate profit\n    profit = sale_amount - actual_cost\n    \n    # Return profit if it's positive, otherwise return None\n    return profit if profit > 0 else None\n\n# Example test case\nassert profit_amount(1500, 1200) is None  # No profit, should return None\nassert profit_amount(1500, 1800) == 300   # Profit of 300, should return 300\nassert profit_amount(1000, 1000) is None  # No profit, should return None\nassert profit_amount(500, 700) == 200      # Profit of 200, should return 200\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/131", "completion": "def reverse_vowels(str1):\n    \"\"\"\n    Reverse only the vowels of a given string.\n    \n    Parameters:\n    str1 (str): The input string to process.\n    \n    Returns:\n    str: The string with vowels reversed.\n    \"\"\"\n    # Define a set of vowels for easy lookup\n    vowels = set(\"aeiouAEIOU\")\n    \n    # Extract vowels from the string\n    vowel_list = [char for char in str1 if char in vowels]\n    \n    # Reverse the list of vowels\n    vowel_list.reverse()\n    \n    # Iterator for the reversed vowels\n    vowel_iter = iter(vowel_list)\n    \n    # Rebuild the string with reversed vowels\n    result = []\n    for char in str1:\n        if char in vowels:\n            result.append(next(vowel_iter))  # Replace with the next reversed vowel\n        else:\n            result.append(char)  # Keep the consonant as is\n    \n    return ''.join(result)\n\n# Example test cases\nassert reverse_vowels(\"Python\") == \"Python\"  # No vowels to reverse\nassert reverse_vowels(\"hello\") == \"holle\"    # 'e' and 'o' are reversed\nassert reverse_vowels(\"leetcode\") == \"leotcede\"  # 'e', 'e', 'o' are reversed\nassert reverse_vowels(\"aA\") == \"Aa\"  # 'a' and 'A' are reversed\nassert reverse_vowels(\"racecar\") == \"racecar\"  # Palindrome, remains the same\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/402", "completion": "def factorial_mod(n, p):\n    \"\"\"Compute factorials % p for all numbers from 0 to n.\"\"\"\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = (fact[i - 1] * i) % p\n    return fact\n\ndef mod_inverse(a, p):\n    \"\"\"Compute the modular inverse of a under modulo p using Fermat's Little Theorem.\"\"\"\n    return pow(a, p - 2, p)\n\ndef ncr_modp(n, r, p):\n    \"\"\"\n    Compute nCr % p using precomputed factorials and their inverses.\n    \n    Parameters:\n    n (int): The total number of items.\n    r (int): The number of items to choose.\n    p (int): The modulus.\n    \n    Returns:\n    int: The value of nCr % p.\n    \"\"\"\n    if r > n:\n        return 0  # nCr is 0 if r > n\n    \n    # Precompute factorials and their inverses\n    fact = factorial_mod(n, p)\n    \n    # Calculate nCr % p\n    numerator = fact[n]\n    denominator = (fact[r] * fact[n - r]) % p\n    \n    # Use modular inverse for the denominator\n    denominator_inv = mod_inverse(denominator, p)\n    \n    return (numerator * denominator_inv) % p\n\n# Example test case\nassert ncr_modp(10, 2, 13) == 6\n\n# Additional test cases\nassert ncr_modp(5, 2, 7) == 3  # 5C2 % 7 = 10 % 7 = 3\nassert ncr_modp(10, 5, 100) == 252  # 10C5 % 100 = 252\nassert ncr_modp(0, 0, 13) == 1  # 0C0 % 13 = 1\nassert ncr_modp(10, 11, 13) == 0  # 10C11 % 13 = 0 (r > n)"}
{"task_id": "MBPP/645", "completion": "def find_k_product(test_list, K):\n    \"\"\"\n    Function to find the product of the elements at the K-th index in the given tuples.\n    \n    Parameters:\n    test_list (list of tuples): A list containing tuples of integers.\n    K (int): The index of the elements to multiply.\n    \n    Returns:\n    int: The product of the elements at the K-th index.\n    \n    Raises:\n    IndexError: If K is out of bounds for the tuples in the list.\n    ValueError: If the input list is empty.\n    \"\"\"\n    \n    # Check if the input list is empty\n    if not test_list:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    # Initialize the product variable\n    product = 1\n    \n    # Iterate through each tuple in the list\n    for tup in test_list:\n        # Check if K is a valid index for the current tuple\n        if K >= len(tup):\n            raise IndexError(f\"K={K} is out of bounds for tuple {tup}.\")\n        \n        # Multiply the product by the K-th index element\n        product *= tup[K]\n    \n    return product\n\n# Example test cases\nif __name__ == \"__main__\":\n    # Test case 1\n    result = find_k_product([(5, 6, 7), (1, 3, 5), (8, 9, 19)], 2)\n    print(result)  # Expected output: 665\n\n    # Additional test cases\n    print(find_k_product([(2, 3, 4), (1, 5, 6), (7, 8, 9)], 1))  # Expected output: 120 (3 * 5 * 8)\n    print(find_k_product([(1, 2), (3, 4)], 0))  # Expected output: 3 (1 * 3)\n    \n    # Edge case: empty list\n    try:\n        print(find_k_product([], 0))\n    except ValueError as e:\n        print(e)  # Expected output: \"The input list cannot be empty.\"\n    \n    # Edge case: K out of bounds\n    try:\n        print(find_k_product([(1, 2)], 2))\n    except IndexError as e:\n        print(e)  # Expected output: \"K=2 is out of bounds for tuple (1, 2).\""}
{"task_id": "MBPP/4_3", "completion": "def gcd(a, b):\n    \"\"\"\n    Return the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.\n    \n    Parameters:\n    a (int): First number\n    b (int): Second number\n    \n    Returns:\n    int: The GCD of the two numbers\n    \n    Raises:\n    ValueError: If either a or b is not a non-negative integer\n    \"\"\"\n    # Validate inputs\n    if not (isinstance(a, int) and isinstance(b, int)) or a < 0 or b < 0:\n        raise ValueError(\"Both a and b must be non-negative integers.\")\n    \n    # Implement the Euclidean algorithm\n    while b != 0:\n        a, b = b, a % b\n    return a\n\n# Test cases\nif __name__ == \"__main__\":\n    # Provided test case\n    assert gcd(48, 18) == 6, \"Test case 1 failed\"\n    \n    # Additional test cases\n    assert gcd(56, 98) == 14, \"Test case 2 failed\"\n    assert gcd(101, 10) == 1, \"Test case 3 failed\"\n    assert gcd(0, 5) == 5, \"Test case 4 failed\"\n    assert gcd(5, 0) == 5, \"Test case 5 failed\"\n    assert gcd(0, 0) == 0, \"Test case 6 failed\"  # GCD(0, 0) is undefined, but we can return 0 for this case\n\n    print(\"All test cases passed!\")"}
{"task_id": "MBPP/4_2", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the initial prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Update the prefix until it matches the start of the string\n        while string[:len(prefix)] != prefix and prefix:\n            prefix = prefix[:-1]  # Reduce the prefix by one character\n        if not prefix:  # If prefix becomes empty, return immediately\n            return \"\"\n    \n    return prefix\n\n# Test case\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'\n\n# Additional test cases\nassert longest_common_prefix(['dog', 'racecar', 'car']) == ''\nassert longest_common_prefix(['interspecies', 'interstellar', 'interstate']) == 'inters'\nassert longest_common_prefix(['a']) == 'a'\nassert longest_common_prefix([]) == ''\nassert longest_common_prefix(['', 'b']) == ''\nassert longest_common_prefix(['abc', 'ab', 'a']) == 'a'\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_4", "completion": "def rotate_matrix(matrix):\n    \"\"\"\n    Rotate a given matrix by 90 degrees clockwise.\n    \n    Args:\n    matrix (list of list of int): A 2D list representing the matrix to be rotated.\n    \n    Returns:\n    list of list of int: The rotated matrix.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return matrix  # Return the matrix as is if it's empty or has no columns\n\n    # Step 1: Transpose the matrix\n    transposed = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n    \n    # Step 2: Reverse each row of the transposed matrix\n    rotated = [row[::-1] for row in transposed]\n    \n    return rotated\n\n# Test case\nassert rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n# Additional test cases\nassert rotate_matrix([[1]]) == [[1]]  # Single element\nassert rotate_matrix([[1, 2], [3, 4]]) == [[3, 1], [4, 2]]  # 2x2 matrix\nassert rotate_matrix([[1, 2, 3], [4, 5, 6]]) == [[4, 1], [5, 2], [6, 3]]  # 2x3 matrix\nassert rotate_matrix([]) == []  # Empty matrix\nassert rotate_matrix([[1, 2, 3, 4], [5, 6, 7, 8]]) == [[5, 1], [6, 2], [7, 3], [8, 4]]  # 2x4 matrix\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_1", "completion": "def fibonacci(n):\n    \"\"\"\n    Return the n-th Fibonacci number.\n    \n    Parameters:\n    n (int): The index of the Fibonacci number to return. Must be a non-negative integer.\n    \n    Returns:\n    int: The n-th Fibonacci number.\n    \n    Raises:\n    ValueError: If n is a negative integer.\n    \n    Example:\n    >>> fibonacci(5)\n    5\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Initialize the first two Fibonacci numbers\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b  # Update to the next Fibonacci numbers\n    \n    return b\n\n# Test cases\nif __name__ == \"__main__\":\n    assert fibonacci(0) == 0\n    assert fibonacci(1) == 1\n    assert fibonacci(2) == 1\n    assert fibonacci(3) == 2\n    assert fibonacci(4) == 3\n    assert fibonacci(5) == 5\n    assert fibonacci(6) == 8\n    assert fibonacci(7) == 13\n    assert fibonacci(8) == 21\n    assert fibonacci(9) == 34\n    assert fibonacci(10) == 55\n    \n    print(\"All test cases passed!\")"}
{"task_id": "MBPP/4_7", "completion": "def max_value(arr):\n    \"\"\"\n    Find the maximum value in a list of integers.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The maximum integer in the list.\n\n    Raises:\n    ValueError: If the input is not a list or if the list is empty.\n    \"\"\"\n    # Check if the input is a list\n    if not isinstance(arr, list):\n        raise ValueError(\"Input must be a list.\")\n    \n    # Check if the list is empty\n    if len(arr) == 0:\n        raise ValueError(\"List must not be empty.\")\n    \n    # Initialize max_value with the first element of the list\n    max_val = arr[0]\n    \n    # Iterate through the list to find the maximum value\n    for num in arr:\n        if num > max_val:\n            max_val = num\n            \n    return max_val\n\n# Example test cases\nif __name__ == \"__main__\":\n    # Test case 1: Regular case\n    assert max_value([1, 2, 3, 4, 5]) == 5\n    # Test case 2: Negative numbers\n    assert max_value([-1, -2, -3, -4, -5]) == -1\n    # Test case 3: Mixed positive and negative numbers\n    assert max_value([-1, 0, 1, 2, 3]) == 3\n    # Test case 4: Single element\n    assert max_value([42]) == 42\n    # Test case 5: Large numbers\n    assert max_value([1000000, 999999, 1000001]) == 1000001\n    \n    print(\"All test cases passed!\")"}
{"task_id": "MBPP/4_6", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string among an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the initial prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for s in strs[1:]:\n        # Update the prefix until it matches the start of the string s\n        while not s.startswith(prefix):\n            # Reduce the prefix by one character from the end\n            prefix = prefix[:-1]\n            # If the prefix becomes empty, return immediately\n            if not prefix:\n                return \"\"\n    \n    return prefix\n\n# Test case\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'"}
{"task_id": "MBPP/4_5", "completion": "def longest_common_substring(s1, s2):\n    \"\"\"\n    Find the length of the longest common substring between two strings.\n    \n    Parameters:\n    s1 (str): The first string.\n    s2 (str): The second string.\n    \n    Returns:\n    int: The length of the longest common substring.\n    \"\"\"\n    # Lengths of the input strings\n    len1, len2 = len(s1), len(s2)\n    \n    # Create a 2D array to store lengths of longest common suffixes\n    # Initialize with zeros\n    dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]\n    \n    # Variable to keep track of the maximum length of common substring\n    max_length = 0\n    \n    # Build the dp array\n    for i in range(1, len1 + 1):\n        for j in range(1, len2 + 1):\n            if s1[i - 1] == s2[j - 1]:  # Characters match\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                max_length = max(max_length, dp[i][j])  # Update max_length\n            else:\n                dp[i][j] = 0  # No common substring ends here\n    \n    return max_length\n\n# Test cases\nassert longest_common_substring('abcdef', 'zcdemf') == 2  # 'cd' is the longest common substring\nassert longest_common_substring('hello', 'yell') == 3    # 'ell' is the longest common substring\nassert longest_common_substring('abc', 'def') == 0        # No common substring\nassert longest_common_substring('abcde', 'abfce') == 2    # 'ab' is the longest common substring\nassert longest_common_substring('', 'abc') == 0            # Empty string case\nassert longest_common_substring('abc', '') == 0            # Empty string case"}
{"task_id": "MBPP/4_9", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the initial prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Update the prefix until it matches the start of the current string\n        while not string.startswith(prefix):\n            # Reduce the prefix by one character from the end\n            prefix = prefix[:-1]\n            # If the prefix is empty, return immediately\n            if not prefix:\n                return \"\"\n    \n    return prefix\n\n# Test case\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'\n\n# Additional test cases\nassert longest_common_prefix(['dog', 'racecar', 'car']) == ''\nassert longest_common_prefix(['interspecies', 'interstellar', 'interstate']) == 'inters'\nassert longest_common_prefix(['throne', 'dungeon']) == ''\nassert longest_common_prefix(['cheese', 'cheese', 'cheese']) == 'cheese'\nassert longest_common_prefix([]) == ''\nassert longest_common_prefix(['a']) == 'a'\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_8", "completion": "def longest_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the initial prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:  # If prefix is empty, return immediately\n                return \"\"\n    \n    return prefix\n\n# Test case\nassert longest_prefix(['flower', 'flow', 'flight']) == 'fl'\nprint(\"Test case passed!\")"}
{"task_id": "MBPP/4_10", "completion": "def longest_common_subsequence(s1, s2):\n    \"\"\"\n    Function to find the length of the longest common subsequence of two strings.\n    \n    Parameters:\n    s1 (str): First string\n    s2 (str): Second string\n    \n    Returns:\n    int: Length of the longest common subsequence\n    \"\"\"\n    # Create a 2D array to store lengths of longest common subsequence\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Build the dp array\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:  # Characters match\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:  # Characters do not match\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    # The length of the longest common subsequence is in the bottom-right cell\n    return dp[m][n]\n\n# Example test case\nassert longest_common_subsequence('abcde', 'ace') == 3"}
