{"task_id": "MBPP/645", "completion": "def find_k_product(test_list, K):\n    \"\"\"\n    Function to find the product of the elements at the K-th index in the given tuples.\n    \n    Parameters:\n    test_list (list of tuples): A list containing tuples from which to extract the K-th elements.\n    K (int): The index of the elements to be multiplied.\n    \n    Returns:\n    int: The product of the K-th elements from each tuple.\n    \"\"\"\n    # Extract the K-th elements from each tuple\n    k_elements = [t[K] for t in test_list]\n    \n    # Calculate the product of the K-th elements\n    product = 1\n    for element in k_elements:\n        product *= element\n    \n    return product\n\n# Test case\nassert find_k_product([(5, 6, 7), (1, 3, 5), (8, 9, 19)], 2) == 665"}
{"task_id": "MBPP/460", "completion": "def Extract(lst):\n    \"\"\"\n    Extract the first element of each sublist.\n    \n    Parameters:\n    lst (list of list): A list containing sublists from which to extract the first elements.\n    \n    Returns:\n    list: A list containing the first elements of each sublist.\n    \n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    # Use a list comprehension to extract the first element of each sublist\n    return [sublist[0] for sublist in lst if sublist]  # Check if sublist is not empty\n\n# Test case\nassert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]"}
{"task_id": "MBPP/929", "completion": "def count_tuplex(tuplex, value):\n    \"\"\"\n    Count the occurrences of a specified value in a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple in which to count occurrences.\n    value: The value to count in the tuple.\n\n    Returns:\n    int: The count of occurrences of the value in the tuple.\n    \"\"\"\n    return tuplex.count(value)\n\n# Test case\nassert count_tuplex((2, 4, 5, 6, 2, 3, 4, 4, 7), 4) == 3"}
{"task_id": "MBPP/173", "completion": "import re\n\ndef remove_splchar(text):\n    \"\"\"\n    Remove everything except alphanumeric characters from a string.\n    \n    Parameters:\n    text (str): The input string from which to remove special characters.\n    \n    Returns:\n    str: A string containing only alphanumeric characters.\n    \"\"\"\n    # Use regular expression to replace non-alphanumeric characters with an empty string\n    return re.sub(r'[^a-zA-Z0-9]', '', text)\n\n# Test case\nassert remove_splchar('python \u00c2\u00a0@#&^%$*program123') == 'pythonprogram123'"}
{"task_id": "MBPP/495", "completion": "import re\n\ndef remove_lowercase(str1):\n    \"\"\"\n    Remove all lowercase substrings from the given string using regex.\n    \n    Parameters:\n    str1 (str): The input string from which lowercase letters will be removed.\n    \n    Returns:\n    str: A new string with all lowercase letters removed.\n    \"\"\"\n    # Use regex to substitute all lowercase letters with an empty string\n    result = re.sub(r'[a-z]', '', str1)\n    return result\n\n# Test case\nassert remove_lowercase('KDeoALOklOOHserfLoAJSIskdsf') == 'KDALOOOHLAJSI'\n\n# You can add more test cases to validate the function\nassert remove_lowercase('HelloWorld') == 'HW'\nassert remove_lowercase('Python3.8') == 'P3.'\nassert remove_lowercase('123abcXYZ') == '123XYZ'\nassert remove_lowercase('') == ''\nassert remove_lowercase('ALLUPPERCASE') == 'ALLUPPERCASE'\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/131", "completion": "def reverse_vowels(str1):\n    \"\"\"\n    Reverse only the vowels of a given string.\n    \n    Parameters:\n    str1 (str): The input string to process.\n    \n    Returns:\n    str: The string with vowels reversed.\n    \"\"\"\n    # Define a set of vowels for easy lookup\n    vowels = set(\"aeiouAEIOU\")\n    \n    # Extract vowels from the string\n    vowel_list = [char for char in str1 if char in vowels]\n    \n    # Reverse the list of vowels\n    vowel_list.reverse()\n    \n    # Create an iterator for the reversed vowels\n    vowel_iter = iter(vowel_list)\n    \n    # Build the result string by replacing vowels with reversed ones\n    result = ''.join(next(vowel_iter) if char in vowels else char for char in str1)\n    \n    return result\n\n# Test case\nassert reverse_vowels(\"Python\") == \"Python\"\nassert reverse_vowels(\"hello\") == \"holle\"\nassert reverse_vowels(\"leetcode\") == \"leotcede\"\nassert reverse_vowels(\"aA\") == \"Aa\"\nassert reverse_vowels(\" \") == \" \"\n\n# Additional test cases\nprint(reverse_vowels(\"hello\"))  # Output: \"holle\"\nprint(reverse_vowels(\"leetcode\"))  # Output: \"leotcede\"\nprint(reverse_vowels(\"aA\"))  # Output: \"Aa\"\nprint(reverse_vowels(\" \"))  # Output: \" \""}
{"task_id": "MBPP/865", "completion": "def ntimes_list(nums, n):\n    \"\"\"\n    Write a function to return a list where each element is multiplied by n using the map function.\n    \n    Parameters:\n    nums (list): A list of numbers.\n    n (int): The multiplier.\n    \n    Returns:\n    list: A new list with each element of nums multiplied by n.\n    \n    Example:\n    >>> ntimes_list([1, 2, 3, 4, 5, 6, 7], 3)\n    [3, 6, 9, 12, 15, 18, 21]\n    \"\"\"\n    # Use map to multiply each element in nums by n\n    return list(map(lambda x: x * n, nums))\n\n# Test case\nassert ntimes_list([1, 2, 3, 4, 5, 6, 7], 3) == [3, 6, 9, 12, 15, 18, 21]\n\n# Additional test cases\nassert ntimes_list([0, 1, 2], 5) == [0, 5, 10]\nassert ntimes_list([-1, -2, -3], 2) == [-2, -4, -6]\nassert ntimes_list([10], 10) == [100]\nassert ntimes_list([], 3) == []"}
{"task_id": "MBPP/801", "completion": "def test_three_equal(x, y, z):\n    \"\"\"\n    Count the number of equal numbers from three given integers.\n    \n    Parameters:\n    x (int): First integer\n    y (int): Second integer\n    z (int): Third integer\n    \n    Returns:\n    int: The count of equal integers among x, y, and z\n    \"\"\"\n    # Initialize a count variable\n    count = 0\n    \n    # Check for equality among the three integers\n    if x == y:\n        count += 1\n    if y == z:\n        count += 1\n    if x == z:\n        count += 1\n    \n    # If all three are equal, we should return 3\n    if count == 3:\n        return 3\n    \n    # If two are equal, we should return 2\n    if count == 2:\n        return 2\n    \n    # If none are equal, we return 0\n    return 0\n\n# Test case\nassert test_three_equal(1, 1, 1) == 3  # All three numbers are equal\nassert test_three_equal(1, 1, 2) == 2  # Two numbers are equal\nassert test_three_equal(1, 2, 3) == 0  # No numbers are equal\nassert test_three_equal(2, 2, 2) == 3  # All three numbers are equal\nassert test_three_equal(2, 2, 3) == 2  # Two numbers are equal\nassert test_three_equal(1, 2, 1) == 2  # Two numbers are equal\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/954", "completion": "def profit_amount(actual_cost, sale_amount):\n    \"\"\"\n    Calculate the profit amount from the actual cost and sale amount.\n    \n    If the sale amount is greater than the actual cost, return the profit amount.\n    Otherwise, return None.\n    \n    Parameters:\n    actual_cost (float): The cost price of the item.\n    sale_amount (float): The selling price of the item.\n    \n    Returns:\n    float or None: The profit amount if there is a profit, otherwise None.\n    \"\"\"\n    profit = sale_amount - actual_cost\n    if profit > 0:\n        return profit\n    else:\n        return None\n\n# Test case\nassert profit_amount(1500, 1200) == None  # This should return None since there is no profit\nassert profit_amount(1500, 1800) == 300   # This should return 300 since there is a profit"}
{"task_id": "MBPP/402", "completion": "def factorial_mod(n, p):\n    \"\"\"Compute n! % p using iterative approach.\"\"\"\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % p\n    return result\n\ndef mod_inverse(a, p):\n    \"\"\"Compute the modular inverse of a under modulo p using Fermat's Little Theorem.\"\"\"\n    return pow(a, p - 2, p)\n\ndef ncr_modp(n, r, p):\n    \"\"\"Compute nCr % p.\"\"\"\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    \n    # Calculate n!, r!, and (n-r)!\n    num = factorial_mod(n, p)\n    denom_r = factorial_mod(r, p)\n    denom_n_r = factorial_mod(n - r, p)\n    \n    # Calculate the result using the formula nCr % p\n    denom = (denom_r * denom_n_r) % p\n    denom_inv = mod_inverse(denom, p)\n    \n    return (num * denom_inv) % p\n\n# Test case\nassert ncr_modp(10, 2, 13) == 6"}
{"task_id": "MBPP/4_3", "completion": "def gcd(a, b):\n    \"\"\"\n    Return the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.\n    \n    Parameters:\n    a (int): First number\n    b (int): Second number\n    \n    Returns:\n    int: The GCD of a and b\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b  # Update a and b\n    return a  # When b is 0, a is the GCD\n\n# Test case\nassert gcd(48, 18) == 6  # This should pass"}
{"task_id": "MBPP/4_7", "completion": "def max_value(arr):\n    \"\"\"\n    Find the maximum value in a list of integers.\n\n    Parameters:\n    arr (list of int): A list of integers.\n\n    Returns:\n    int: The maximum integer in the list.\n\n    Example:\n    >>> max_value([1, 2, 3, 4, 5])\n    5\n    \"\"\"\n    # Check if the list is empty\n    if not arr:\n        raise ValueError(\"The input list is empty.\")\n    \n    # Use the built-in max function to find the maximum value\n    return max(arr)\n\n# Test case\nassert max_value([1, 2, 3, 4, 5]) == 5"}
{"task_id": "MBPP/4_4", "completion": "def rotate_matrix(matrix):\n    \"\"\"\n    Rotate a given matrix by 90 degrees clockwise.\n    \n    Args:\n    matrix (list of list of int): A 2D list representing the matrix to be rotated.\n    \n    Returns:\n    list of list of int: The rotated matrix.\n    \"\"\"\n    # Step 1: Transpose the matrix\n    transposed = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n    \n    # Step 2: Reverse each row of the transposed matrix\n    rotated = [row[::-1] for row in transposed]\n    \n    return rotated\n\n# Test case\nassert rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]"}
{"task_id": "MBPP/4_1", "completion": "def fibonacci(n):\n    \"\"\"\n    Return the n-th Fibonacci number.\n    \n    Parameters:\n    n (int): The index of the Fibonacci number to return. Must be a non-negative integer.\n    \n    Returns:\n    int: The n-th Fibonacci number.\n    \n    Example:\n    >>> fibonacci(5)\n    5\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Initialize the first two Fibonacci numbers\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b  # Update to the next Fibonacci numbers\n    \n    return b\n\n# Test case\nassert fibonacci(5) == 5  # This should pass"}
{"task_id": "MBPP/4_2", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the initial prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for s in strs[1:]:\n        # Update the prefix until it matches the start of the string s\n        while not s.startswith(prefix):\n            # Reduce the prefix by one character from the end\n            prefix = prefix[:-1]\n            # If the prefix is empty, return immediately\n            if not prefix:\n                return \"\"\n    \n    return prefix\n\n# Test case\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'"}
{"task_id": "MBPP/4_6", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string among an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the initial prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for s in strs[1:]:\n        # Update the prefix until it matches the start of the string\n        while not s.startswith(prefix):\n            # Reduce the prefix by one character from the end\n            prefix = prefix[:-1]\n            # If the prefix is empty, return immediately\n            if not prefix:\n                return \"\"\n    \n    return prefix\n\n# Test case\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'"}
{"task_id": "MBPP/4_9", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the initial prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:  # If prefix is empty, return immediately\n                return \"\"\n    \n    return prefix\n\n# Test case\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'"}
{"task_id": "MBPP/4_8", "completion": "def longest_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the initial prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for s in strs[1:]:\n        # Update the prefix until it matches the start of the string s\n        while not s.startswith(prefix):\n            # Reduce the prefix by one character from the end\n            prefix = prefix[:-1]\n            # If the prefix is empty, return immediately\n            if not prefix:\n                return \"\"\n    \n    return prefix\n\n# Test case\nassert longest_prefix(['flower', 'flow', 'flight']) == 'fl'"}
{"task_id": "MBPP/4_5", "completion": "def longest_common_substring(s1, s2):\n    \"\"\"\n    Find the length of the longest common substring between two strings.\n    \n    :param s1: First input string\n    :param s2: Second input string\n    :return: Length of the longest common substring\n    \"\"\"\n    # Lengths of the input strings\n    len1, len2 = len(s1), len(s2)\n    \n    # Create a 2D array to store lengths of longest common suffixes\n    dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]\n    \n    # Variable to store the length of the longest common substring\n    longest = 0\n    \n    # Build the dp array\n    for i in range(1, len1 + 1):\n        for j in range(1, len2 + 1):\n            if s1[i - 1] == s2[j - 1]:  # Characters match\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                longest = max(longest, dp[i][j])  # Update longest if needed\n            else:\n                dp[i][j] = 0  # No common substring ends here\n    \n    return longest\n\n# Test cases\nassert longest_common_substring('abcdef', 'zcdemf') == 2  # 'cd' is the longest common substring\nassert longest_common_substring('hello', 'yell') == 3    # 'ell' is the longest common substring\nassert longest_common_substring('abc', 'xyz') == 0        # No common substring\nassert longest_common_substring('abcdxyz', 'xyzabcd') == 4  # 'abcd' is the longest common substring\nassert longest_common_substring('', 'abc') == 0            # Empty string case\nassert longest_common_substring('abc', '') == 0            # Empty string case\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_10", "completion": "def longest_common_subsequence(s1, s2):\n    \"\"\"\n    Find the length of the longest common subsequence of two strings.\n    \n    :param s1: First string\n    :param s2: Second string\n    :return: Length of the longest common subsequence\n    \"\"\"\n    # Create a 2D array to store lengths of longest common subsequence\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Build the dp array\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:  # Characters match\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:  # Characters do not match\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    # The length of the longest common subsequence is in the bottom-right cell\n    return dp[m][n]\n\n# Test case\nassert longest_common_subsequence('abcde', 'ace') == 3"}
