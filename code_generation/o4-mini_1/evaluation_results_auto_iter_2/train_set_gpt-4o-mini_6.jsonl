{"task_id": "MBPP/495", "completion": "import re\n\ndef remove_lowercase(str1):\n    \"\"\"\n    Remove all lowercase substrings from the given string using regex.\n    \n    Parameters:\n    str1 (str): The input string from which lowercase letters will be removed.\n    \n    Returns:\n    str: The modified string with all lowercase letters removed.\n    \"\"\"\n    # Use regex to substitute all lowercase letters with an empty string\n    result = re.sub(r'[a-z]', '', str1)\n    return result\n\n# Test the function with the provided test case\nassert remove_lowercase('KDeoALOklOOHserfLoAJSIskdsf') == 'KDALOOOHLAJSI'\n\n# If the assertion passes, the function works as expected.\nprint(\"Test case passed!\")"}
{"task_id": "MBPP/865", "completion": "def ntimes_list(nums, n):\n    \"\"\"\n    Multiplies each element in the list 'nums' by 'n' using the map function.\n    \n    Parameters:\n    nums (list): A list of numbers to be multiplied.\n    n (int): The multiplier.\n    \n    Returns:\n    list: A new list containing the results of the multiplication.\n    \n    Example:\n    >>> ntimes_list([1, 2, 3, 4, 5, 6, 7], 3)\n    [3, 6, 9, 12, 15, 18, 21]\n    \"\"\"\n    # Use map to apply the multiplication to each element in the list\n    return list(map(lambda x: x * n, nums))\n\n# Test the function with the provided assertion\nassert ntimes_list([1, 2, 3, 4, 5, 6, 7], 3) == [3, 6, 9, 12, 15, 18, 21]\n\n# If the assertion passes, the function works as expected.\nprint(\"Function works correctly.\")"}
{"task_id": "MBPP/645", "completion": "from functools import reduce\nimport operator\n\ndef find_k_product(test_list, K):\n    \"\"\"\n    Find the product of the K-th index elements in the given list of tuples.\n    \n    Parameters:\n    test_list (list of tuples): A list containing tuples from which to extract elements.\n    K (int): The index of the elements to multiply.\n    \n    Returns:\n    int: The product of the K-th index elements.\n    \n    Raises:\n    IndexError: If K is out of bounds for any tuple in the list.\n    \"\"\"\n    # Extract the K-th elements from each tuple\n    try:\n        k_elements = [t[K] for t in test_list]\n    except IndexError:\n        raise IndexError(f\"K={K} is out of bounds for one of the tuples in the list.\")\n    \n    # Calculate the product of the K-th elements\n    product = reduce(operator.mul, k_elements, 1)\n    \n    return product\n\n# Test case\nassert find_k_product([(5, 6, 7), (1, 3, 5), (8, 9, 19)], 2) == 665"}
{"task_id": "MBPP/173", "completion": "import re\n\ndef remove_splchar(text):\n    \"\"\"\n    Remove everything except alphanumeric characters from a string.\n    \n    Parameters:\n    text (str): The input string from which to remove special characters.\n    \n    Returns:\n    str: A string containing only alphanumeric characters.\n    \"\"\"\n    # Use regular expression to replace non-alphanumeric characters with an empty string\n    cleaned_text = re.sub(r'[^a-zA-Z0-9]', '', text)\n    return cleaned_text\n\n# Test case\nassert remove_splchar('python \u00c2\u00a0@#&^%$*program123') == 'pythonprogram123'\n\n# Additional test cases for verification\nassert remove_splchar('Hello, World!') == 'HelloWorld'\nassert remove_splchar('1234!@#$') == '1234'\nassert remove_splchar('') == ''\nassert remove_splchar('NoSpecialChars') == 'NoSpecialChars'\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/954", "completion": "def profit_amount(actual_cost, sale_amount):\n    \"\"\"\n    Calculate the profit amount based on actual cost and sale amount.\n    \n    If the sale amount is greater than the actual cost, return the profit amount.\n    Otherwise, return None.\n    \n    Parameters:\n    actual_cost (float): The actual cost of the item.\n    sale_amount (float): The amount at which the item was sold.\n    \n    Returns:\n    float or None: The profit amount if there is a profit, otherwise None.\n    \"\"\"\n    # Calculate profit\n    profit = sale_amount - actual_cost\n    \n    # Check if there is a profit\n    if profit > 0:\n        return profit\n    else:\n        return None\n\n# Test the function with the provided test case\nassert profit_amount(1500, 1200) == None  # This should return None since there is no profit\nassert profit_amount(1500, 1800) == 300   # This should return 300 since there is a profit\nassert profit_amount(1500, 1500) == None   # This should return None since there is no profit\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/460", "completion": "def Extract(lst):\n    \"\"\"\n    Extract the first element of each sublist from a list of lists.\n    \n    Parameters:\n    lst (list of list): A list containing sublists.\n    \n    Returns:\n    list: A list containing the first element of each sublist.\n    \n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    # Use a list comprehension to extract the first element of each sublist\n    return [sublist[0] for sublist in lst if sublist]  # Check if sublist is not empty\n\n# Test the function with the provided test case\nassert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n\n# Additional test cases\nassert Extract([[10, 20], [30], [40, 50, 60]]) == [10, 30, 40]\nassert Extract([[], [1, 2], [3]]) == [1, 3]  # Testing with an empty sublist\nassert Extract([[], [], []]) == []  # All sublists are empty\nassert Extract([[5]]) == [5]  # Single sublist with one element\n\nprint(\"All tests passed!\")"}
{"task_id": "MBPP/131", "completion": "def reverse_vowels(str1):\n    \"\"\"\n    Reverse only the vowels of a given string.\n    \n    Parameters:\n    str1 (str): The input string to reverse vowels in.\n    \n    Returns:\n    str: The string with vowels reversed.\n    \"\"\"\n    # Define a set of vowels for easy checking\n    vowels = set('aeiouAEIOU')\n    \n    # Convert the string to a list to allow modifications\n    str_list = list(str1)\n    \n    # Find all the vowels in the string\n    vowel_indices = [i for i, char in enumerate(str_list) if char in vowels]\n    vowel_chars = [str_list[i] for i in vowel_indices]\n    \n    # Reverse the list of vowels\n    vowel_chars.reverse()\n    \n    # Replace the vowels in the original list with the reversed vowels\n    for index, char in zip(vowel_indices, vowel_chars):\n        str_list[index] = char\n    \n    # Join the list back into a string and return\n    return ''.join(str_list)\n\n# Test cases\nassert reverse_vowels(\"Python\") == \"Python\"  # No vowels to reverse\nassert reverse_vowels(\"hello\") == \"holle\"    # 'e' and 'o' are reversed\nassert reverse_vowels(\"leetcode\") == \"leotcede\"  # 'e's and 'o' are reversed\nassert reverse_vowels(\"aA\") == \"Aa\"  # 'a' and 'A' are reversed\nassert reverse_vowels(\" \") == \" \"  # Single space, no vowels\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/929", "completion": "def count_tuplex(tuplex, value):\n    \"\"\"\n    Count the number of times a specific value appears in a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple in which to count occurrences.\n    value: The value to count in the tuple.\n\n    Returns:\n    int: The count of occurrences of the value in the tuple.\n    \n    Example:\n    >>> count_tuplex((2, 4, 5, 6, 2, 3, 4, 4, 7), 4)\n    3\n    \"\"\"\n    # Count the occurrences of 'value' in 'tuplex'\n    return tuplex.count(value)\n\n# Test the function with the provided test case\nassert count_tuplex((2, 4, 5, 6, 2, 3, 4, 4, 7), 4) == 3\n\n# Additional test cases for verification\nassert count_tuplex((1, 2, 3, 1, 1, 4), 1) == 3  # 1 appears 3 times\nassert count_tuplex((5, 5, 5, 5, 5), 5) == 5      # 5 appears 5 times\nassert count_tuplex((1, 2, 3), 4) == 0             # 4 does not appear\nassert count_tuplex((), 1) == 0                    # Empty tuple\n\nprint(\"All tests passed!\")"}
{"task_id": "MBPP/801", "completion": "def test_three_equal(x, y, z):\n    \"\"\"\n    Count the number of equal numbers from three given integers.\n    \n    Parameters:\n    x (int): First integer\n    y (int): Second integer\n    z (int): Third integer\n    \n    Returns:\n    int: The count of equal integers among the three inputs.\n    \n    Example:\n    >>> test_three_equal(1, 1, 1)\n    3\n    >>> test_three_equal(1, 2, 1)\n    2\n    >>> test_three_equal(1, 2, 3)\n    0\n    \"\"\"\n    # Initialize a count for equal numbers\n    count = 0\n    \n    # Check for equality among the three integers\n    if x == y and y == z:\n        count = 3  # All three are equal\n    elif x == y or y == z or x == z:\n        count = 2  # Two are equal\n    else:\n        count = 0  # None are equal\n    \n    return count\n\n# Test cases\nassert test_three_equal(1, 1, 1) == 3\nassert test_three_equal(1, 2, 1) == 2\nassert test_three_equal(1, 2, 3) == 0\nassert test_three_equal(5, 5, 5) == 3\nassert test_three_equal(5, 5, 10) == 2\nassert test_three_equal(10, 20, 30) == 0\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/402", "completion": "def factorial_mod(n, p):\n    \"\"\"Compute factorial % p for all numbers from 0 to n.\"\"\"\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = (fact[i - 1] * i) % p\n    return fact\n\ndef mod_inverse(a, p):\n    \"\"\"Compute the modular inverse of a under modulo p using Fermat's Little Theorem.\"\"\"\n    return pow(a, p - 2, p)\n\ndef ncr_modp(n, r, p):\n    \"\"\"\n    Compute nCr % p using the formula nCr = n! / (r! * (n-r)!)\n    and modular arithmetic.\n    \"\"\"\n    if r > n:\n        return 0  # nCr is 0 if r > n\n    \n    # Precompute all factorials % p\n    fact = factorial_mod(n, p)\n    \n    # Calculate nCr % p\n    numerator = fact[n]\n    denominator = (fact[r] * fact[n - r]) % p\n    \n    # Use modular inverse to compute the result\n    result = (numerator * mod_inverse(denominator, p)) % p\n    return result\n\n# Test case\nassert ncr_modp(10, 2, 13) == 6"}
{"task_id": "MBPP/4_1", "completion": "def fibonacci(n):\n    \"\"\"\n    Return the n-th Fibonacci number.\n    \n    Parameters:\n    n (int): The index of the Fibonacci number to return. Must be a non-negative integer.\n    \n    Returns:\n    int: The n-th Fibonacci number.\n    \n    Raises:\n    ValueError: If n is a negative integer.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Iterative approach to calculate Fibonacci numbers\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    \n    return b\n\n# Test case\nassert fibonacci(5) == 5  # This should pass"}
{"task_id": "MBPP/4_7", "completion": "def max_value(arr):\n    \"\"\"\n    Find the maximum value in a list of integers.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The maximum integer in the list.\n\n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    # Check if the input list is empty\n    if not arr:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    # Use the built-in max function to find the maximum value\n    return max(arr)\n\n# Test cases to validate the function\nassert max_value([1, 2, 3, 4, 5]) == 5  # Expected output: 5\nassert max_value([-1, -2, -3, -4, -5]) == -1  # Expected output: -1\nassert max_value([0, 0, 0]) == 0  # Expected output: 0\nassert max_value([10]) == 10  # Expected output: 10\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_8", "completion": "def longest_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    # Check if the input list is empty\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the initial prefix\n    prefix = strs[0]\n    \n    # Iterate through the strings in the list\n    for s in strs[1:]:\n        # Update the prefix by comparing it with the current string\n        while not s.startswith(prefix):\n            # Shorten the prefix by one character from the end\n            prefix = prefix[:-1]\n            # If the prefix becomes empty, return immediately\n            if not prefix:\n                return \"\"\n    \n    return prefix\n\n# Test case\nassert longest_prefix(['flower', 'flow', 'flight']) == 'fl'"}
{"task_id": "MBPP/4_2", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    # Check if the input list is empty\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the initial prefix\n    prefix = strs[0]\n    \n    # Iterate through the strings in the list\n    for string in strs[1:]:\n        # Update the prefix by comparing it with the current string\n        while string[:len(prefix)] != prefix and prefix:\n            # Shorten the prefix by one character from the end\n            prefix = prefix[:-1]\n        \n        # If the prefix is empty, return immediately\n        if not prefix:\n            return \"\"\n    \n    return prefix\n\n# Test case\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'"}
{"task_id": "MBPP/4_3", "completion": "def gcd(a, b):\n    \"\"\"\n    Calculate the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.\n    \n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    \n    Returns:\n    int: The GCD of a and b.\n    \"\"\"\n    # Ensure that a and b are non-negative integers\n    if a < 0 or b < 0:\n        raise ValueError(\"Both numbers must be non-negative integers.\")\n    \n    # Apply the Euclidean algorithm\n    while b != 0:\n        a, b = b, a % b  # Update a and b\n    \n    return a  # When b is 0, a contains the GCD\n\n# Test the function with the provided test case\nassert gcd(48, 18) == 6\n\n# Additional test cases for verification\nassert gcd(56, 98) == 14\nassert gcd(101, 10) == 1\nassert gcd(0, 5) == 5  # GCD of 0 and any number is the number itself\nassert gcd(5, 0) == 5  # GCD of any number and 0 is the number itself\nassert gcd(0, 0) == 0  # GCD of 0 and 0 is defined as 0\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_6", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string among an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    # Check if the input list is empty\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the initial prefix\n    prefix = strs[0]\n    \n    # Iterate through the strings in the list\n    for s in strs[1:]:\n        # Update the prefix by comparing with each string\n        while not s.startswith(prefix):\n            # Reduce the prefix by one character from the end\n            prefix = prefix[:-1]\n            # If the prefix becomes empty, return immediately\n            if not prefix:\n                return \"\"\n    \n    return prefix\n\n# Test cases\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'\nassert longest_common_prefix(['dog', 'racecar', 'car']) == ''\nassert longest_common_prefix(['interspecies', 'interstellar', 'interstate']) == 'inters'\nassert longest_common_prefix(['throne', 'dungeon']) == ''\nassert longest_common_prefix(['cheese', 'cheese', 'cheese']) == 'cheese'\nassert longest_common_prefix([]) == ''\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_4", "completion": "def rotate_matrix(matrix):\n    \"\"\"\n    Rotate a given matrix by 90 degrees clockwise.\n    \n    Args:\n    matrix (list of list of int): The input matrix to be rotated.\n    \n    Returns:\n    list of list of int: The rotated matrix.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return matrix  # Return the matrix as is if it's empty or has no columns\n\n    # Step 1: Transpose the matrix\n    transposed = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n\n    # Step 2: Reverse each row of the transposed matrix\n    rotated = [row[::-1] for row in transposed]\n\n    return rotated\n\n# Test case\nassert rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n# Additional test cases for verification\nassert rotate_matrix([[1]]) == [[1]]  # Single element\nassert rotate_matrix([[1, 2], [3, 4]]) == [[3, 1], [4, 2]]  # 2x2 matrix\nassert rotate_matrix([[1, 2, 3], [4, 5, 6]]) == [[4, 1], [5, 2], [6, 3]]  # 2x3 matrix\nassert rotate_matrix([]) == []  # Empty matrix\nassert rotate_matrix([[]]) == [[]]  # Matrix with empty row\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_9", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the initial prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character from the prefix\n            if not prefix:  # If prefix is empty, return immediately\n                return \"\"\n    \n    return prefix\n\n# Test cases\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'\nassert longest_common_prefix(['dog', 'racecar', 'car']) == ''\nassert longest_common_prefix(['interspecies', 'interstellar', 'interstate']) == 'inters'\nassert longest_common_prefix(['throne', 'dungeon']) == ''\nassert longest_common_prefix(['cheese', 'cheese', 'cheese']) == 'cheese'\nassert longest_common_prefix([]) == ''\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_5", "completion": "def longest_common_substring(s1, s2):\n    \"\"\"\n    Find the length of the longest common substring between two strings.\n    \n    :param s1: First input string\n    :param s2: Second input string\n    :return: Length of the longest common substring\n    \"\"\"\n    # Lengths of the input strings\n    len1, len2 = len(s1), len(s2)\n    \n    # Create a 2D array to store lengths of longest common suffixes\n    dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]\n    \n    # Variable to keep track of the maximum length of common substring\n    max_length = 0\n    \n    # Build the dp array\n    for i in range(1, len1 + 1):\n        for j in range(1, len2 + 1):\n            if s1[i - 1] == s2[j - 1]:  # Characters match\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                max_length = max(max_length, dp[i][j])  # Update max_length\n            else:\n                dp[i][j] = 0  # No common substring ends here\n    \n    return max_length\n\n# Test case\nassert longest_common_substring('abcdef', 'zcdemf') == 2"}
{"task_id": "MBPP/4_10", "completion": "def longest_common_subsequence(s1, s2):\n    \"\"\"\n    Function to find the length of the longest common subsequence of two strings.\n    \n    Parameters:\n    s1 (str): First string\n    s2 (str): Second string\n    \n    Returns:\n    int: Length of the longest common subsequence\n    \"\"\"\n    # Create a 2D array to store lengths of longest common subsequence\n    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n    \n    # Fill the dp array\n    for i in range(1, len(s1) + 1):\n        for j in range(1, len(s2) + 1):\n            if s1[i - 1] == s2[j - 1]:  # Characters match\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:  # Characters do not match\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    # The length of the longest common subsequence is in the bottom-right cell\n    return dp[len(s1)][len(s2)]\n\n# Test case\nassert longest_common_subsequence('abcde', 'ace') == 3"}
