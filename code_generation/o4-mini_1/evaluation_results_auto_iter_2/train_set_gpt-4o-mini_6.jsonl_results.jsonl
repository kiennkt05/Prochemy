{"task_id": "auto/0", "completion": "from typing import List\n\ndef find_duplicates(strings: List[str]) -> List[str]:\n    \"\"\"\n    This function takes a list of strings and returns a list of strings that are duplicates.\n    \n    Parameters:\n    strings (List[str]): A list of strings to check for duplicates.\n    \n    Returns:\n    List[str]: A list of duplicate strings.\n    \"\"\"\n    # Dictionary to hold the count of each string\n    string_count = {}\n    \n    # Count occurrences of each string\n    for string in strings:\n        if string in string_count:\n            string_count[string] += 1\n        else:\n            string_count[string] = 1\n    \n    # Collect strings that have a count greater than 1\n    duplicates = [string for string, count in string_count.items() if count > 1]\n    \n    return duplicates\n\n# Example usage and testing\nif __name__ == \"__main__\":\n    test_strings = [\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"kiwi\"]\n    print(find_duplicates(test_strings))  # Output should be ['apple', 'banana']", "result": "passed", "passed": true}
{"task_id": "auto/2", "completion": "from typing import List\n\ndef sum_negative_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Sums all negative numbers in the provided list of integers.\n\n    Parameters:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    int: The sum of all negative integers in the list.\n    \"\"\"\n    # Initialize the sum variable\n    total = 0\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        # Check if the number is negative\n        if number < 0:\n            total += number  # Add to total if negative\n    \n    return total\n\n# Test cases to validate the function\nif __name__ == \"__main__\":\n    # Example test cases\n    print(sum_negative_numbers([-1, -2, 3, 4]))  # Expected output: -3\n    print(sum_negative_numbers([1, 2, 3, 4]))     # Expected output: 0\n    print(sum_negative_numbers([-5, -10, 5, 10])) # Expected output: -15\n    print(sum_negative_numbers([]))                # Expected output: 0 (empty list)\n    print(sum_negative_numbers([-1, 0, 1]))       # Expected output: -1", "result": "passed", "passed": true}
{"task_id": "auto/7", "completion": "from typing import List\n\ndef calculate_mean(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the mean (average) of a list of numbers.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n    float: The mean of the numbers in the list.\n\n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    # Check if the list is empty\n    if not numbers:\n        raise ValueError(\"The input list is empty. Cannot calculate mean.\")\n\n    # Calculate the sum of the numbers\n    total_sum = sum(numbers)\n    \n    # Calculate the count of numbers\n    count = len(numbers)\n    \n    # Calculate the mean\n    mean = total_sum / count\n    \n    return mean\n\n# Example usage and testing\nif __name__ == \"__main__\":\n    try:\n        # Test with a normal list of numbers\n        numbers = [10.0, 20.0, 30.0, 40.0, 50.0]\n        print(f\"The mean of {numbers} is {calculate_mean(numbers)}\")\n\n        # Test with an empty list to see error handling\n        empty_numbers = []\n        print(f\"The mean of {empty_numbers} is {calculate_mean(empty_numbers)}\")\n    except ValueError as e:\n        print(e)", "result": "failed: ", "passed": false}
{"task_id": "auto/9", "completion": "from typing import List\n\ndef count_negative_numbers(nums: List[int]) -> int:\n    \"\"\"Count the number of negative integers in a given list of integers.\n    \n    Args:\n        nums (List[int]): A list of integers.\n        \n    Returns:\n        int: The count of negative integers in the list.\n        \n    Examples:\n        >>> count_negative_numbers([-1, 2, -3, 4, -5, 6])\n        3\n        >>> count_negative_numbers([1, 2, 3, 4, 5, 6])\n        0\n    \"\"\"\n    # Initialize a counter for negative numbers\n    negative_count = 0\n    \n    # Iterate through the list and count negative numbers\n    for num in nums:\n        if num < 0:\n            negative_count += 1\n            \n    return negative_count\n\n# Testing the function with provided examples\nif __name__ == \"__main__\":\n    # Test cases\n    print(count_negative_numbers([-1, 2, -3, 4, -5, 6]))  # Expected output: 3\n    print(count_negative_numbers([1, 2, 3, 4, 5, 6]))    # Expected output: 0\n    print(count_negative_numbers([]))                      # Expected output: 0 (empty list)\n    print(count_negative_numbers([-1, -2, -3, -4]))       # Expected output: 4 (all negative)\n    print(count_negative_numbers([0, 1, 2, 3]))           # Expected output: 0 (no negatives)", "result": "failed: unterminated triple-quoted string literal (detected at line 60) (<string>, line 26)", "passed": false}
{"task_id": "auto/6", "completion": "from typing import List\n\ndef count_elements(numbers: List[int], target: int) -> int:\n    \"\"\"\n    Count the occurrences of a target integer in a list of integers.\n\n    Parameters:\n    numbers (List[int]): A list of integers to search through.\n    target (int): The integer to count in the list.\n\n    Returns:\n    int: The count of occurrences of the target integer in the list.\n    \"\"\"\n    # Validate input types\n    if not isinstance(numbers, list) or not all(isinstance(num, int) for num in numbers):\n        raise ValueError(\"The 'numbers' parameter must be a list of integers.\")\n    if not isinstance(target, int):\n        raise ValueError(\"The 'target' parameter must be an integer.\")\n\n    # Count occurrences of the target in the list\n    count = 0\n    for num in numbers:\n        if num == target:\n            count += 1\n            \n    return count\n\n# Test cases\nif __name__ == \"__main__\":\n    # Example test cases\n    print(count_elements([1, 2, 3, 4, 2, 2, 5], 2))  # Output: 3\n    print(count_elements([1, 1, 1, 1, 1], 1))        # Output: 5\n    print(count_elements([1, 2, 3, 4, 5], 6))        # Output: 0\n    print(count_elements([], 1))                       # Output: 0\n    print(count_elements([10, 20, 30, 40], 20))       # Output: 1", "result": "passed", "passed": true}
{"task_id": "auto/3", "completion": "from typing import List\n\ndef find_missing_number(nums: List[int]) -> int:\n    # Check if the input list is empty\n    if not nums:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    n = len(nums)  # The length of the list\n    expected_sum = n * (n + 1) // 2  # Calculate the expected sum from 0 to n\n    actual_sum = sum(nums)  # Calculate the actual sum of the numbers in the list\n    \n    # The missing number is the difference between expected and actual sums\n    missing_number = expected_sum - actual_sum\n    \n    return missing_number\n\n# Example test cases\nif __name__ == \"__main__\":\n    # Test case 1: Missing number is 2\n    print(find_missing_number([0, 1, 3]))  # Output: 2\n    \n    # Test case 2: Missing number is 0\n    print(find_missing_number([1, 2, 3]))  # Output: 0\n    \n    # Test case 3: Missing number is 4\n    print(find_missing_number([0, 1, 2, 3]))  # Output: 4\n    \n    # Test case 4: Missing number is 1\n    print(find_missing_number([0]))  # Output: 1\n    \n    # Test case 5: Missing number is 3\n    print(find_missing_number([0, 1, 2, 4]))  # Output: 3", "result": "failed: ", "passed": false}
{"task_id": "auto/4", "completion": "from typing import List\n\ndef find_duplicates(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Find and return a list of duplicate numbers from the input list.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n    List[float]: A list of duplicate numbers found in the input list.\n    \"\"\"\n    seen = set()        # Set to track seen numbers\n    duplicates = set()  # Set to track duplicates\n\n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)  # Add to duplicates if already seen\n        else:\n            seen.add(number)        # Add to seen if not seen before\n\n    return list(duplicates)  # Convert duplicates set to a list\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    # Test cases\n    print(find_duplicates([1.0, 2.0, 3.0, 1.0, 2.0]))  # Output: [1.0, 2.0]\n    print(find_duplicates([1.5, 2.5, 3.5, 4.5]))       # Output: []\n    print(find_duplicates([1.0, 1.0, 1.0, 1.0]))       # Output: [1.0]\n    print(find_duplicates([]))                          # Output: []\n    print(find_duplicates([1.1, 2.2, 3.3, 2.2, 1.1]))  # Output: [1.1, 2.2]", "result": "passed", "passed": true}
{"task_id": "auto/1", "completion": "from typing import List\n\ndef count_consecutive_zeros(nums: List[int]) -> int:\n    \"\"\"\n    Count the maximum number of consecutive zeros in a list of integers.\n\n    Parameters:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The maximum count of consecutive zeros.\n    \"\"\"\n    max_count = 0  # To keep track of the maximum count of consecutive zeros\n    current_count = 0  # To count the current streak of zeros\n\n    for num in nums:\n        if num == 0:\n            current_count += 1  # Increment the count for consecutive zeros\n        else:\n            max_count = max(max_count, current_count)  # Update max_count if needed\n            current_count = 0  # Reset current count if a non-zero is encountered\n\n    # Final check in case the list ends with zeros\n    max_count = max(max_count, current_count)\n\n    return max_count\n\n# Example test cases\nif __name__ == \"__main__\":\n    # Test case 1: A list with consecutive zeros\n    print(count_consecutive_zeros([1, 0, 0, 2, 0, 0, 0, 3]))  # Output: 3\n\n    # Test case 2: A list with no zeros\n    print(count_consecutive_zeros([1, 2, 3, 4]))  # Output: 0\n\n    # Test case 3: A list with only zeros\n    print(count_consecutive_zeros([0, 0, 0, 0]))  # Output: 4\n\n    # Test case 4: A list with mixed values\n    print(count_consecutive_zeros([0, 1, 0, 0, 0, 2, 0, 0]))  # Output: 3\n\n    # Test case 5: An empty list\n    print(count_consecutive_zeros([]))  # Output: 0", "result": "passed", "passed": true}
{"task_id": "auto/5", "completion": "from typing import List\n\ndef reverse_sublists(data: List[int], k: int) -> List[int]:\n    \"\"\"\n    Reverses every contiguous sublist of length k in the given list.\n    \n    Parameters:\n    data (List[int]): The list of integers to process.\n    k (int): The length of the sublists to reverse.\n    \n    Returns:\n    List[int]: The list with the specified sublists reversed.\n    \"\"\"\n    if k <= 0:\n        raise ValueError(\"The length of sublists (k) must be a positive integer.\")\n    \n    n = len(data)\n    result = []\n    \n    for i in range(0, n, k):\n        # Get the sublist of length k\n        sublist = data[i:i + k]\n        # Reverse the sublist and add to the result\n        result.extend(reversed(sublist))\n    \n    return result\n\n# Example usage and testing\nif __name__ == \"__main__\":\n    # Test cases\n    print(reverse_sublists([1, 2, 3, 4, 5, 6], 2))  # Output: [2, 1, 4, 3, 6, 5]\n    print(reverse_sublists([1, 2, 3, 4, 5], 3))     # Output: [3, 2, 1, 4, 5]\n    print(reverse_sublists([1, 2, 3], 1))            # Output: [1, 2, 3]\n    print(reverse_sublists([1, 2, 3, 4, 5], 5))     # Output: [5, 4, 3, 2, 1]\n    print(reverse_sublists([], 2))                   # Output: []", "result": "failed: reverse_sublists() missing 1 required positional argument: 'k'", "passed": false}
{"task_id": "auto/8", "completion": "from typing import List\n\ndef find_max_consecutive_ones(nums: List[int]) -> int:\n    # Initialize counters for current and maximum consecutive ones\n    max_count = 0\n    current_count = 0\n    \n    # Iterate through each number in the list\n    for num in nums:\n        if num == 1:\n            # Increment current count if the number is 1\n            current_count += 1\n        else:\n            # Update max count if current count is greater\n            max_count = max(max_count, current_count)\n            # Reset current count to 0\n            current_count = 0\n    \n    # Final check to update max count in case the array ends with 1s\n    max_count = max(max_count, current_count)\n    \n    return max_count\n\n# Example test cases\nif __name__ == \"__main__\":\n    # Test case 1: Expected output is 3\n    print(find_max_consecutive_ones([1, 1, 0, 1, 1, 1]))  \n    # Test case 2: Expected output is 2\n    print(find_max_consecutive_ones([1, 0, 1, 1, 0, 1]))  \n    # Test case 3: Expected output is 0\n    print(find_max_consecutive_ones([0, 0, 0, 0]))  \n    # Test case 4: Expected output is 5\n    print(find_max_consecutive_ones([1, 1, 1, 1, 1]))  \n    # Test case 5: Expected output is 1\n    print(find_max_consecutive_ones([0, 1, 0, 0, 0, 1]))", "result": "passed", "passed": true}
{"task_id": "HumanEval/10", "completion": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    # Edge case for empty string\n    if not string:\n        return ''\n    \n    # Find the longest palindromic suffix\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            # If the suffix is a palindrome, we take the prefix before it\n            prefix = string[:i]\n            # Append the reverse of the prefix to the original string\n            return string + prefix[::-1]\n    \n    # If no palindromic suffix is found, the whole string is the prefix\n    return string + string[:-1][::-1]  # This handles the case where the entire string is not a palindrome\n\n# Testing the function with provided examples\nif __name__ == \"__main__\":\n    print(make_palindrome(''))        # Output: ''\n    print(make_palindrome('cat'))     # Output: 'catac'\n    print(make_palindrome('cata'))    # Output: 'catac'", "result": "passed", "passed": true}
{"task_id": "HumanEval/77", "completion": "def iscube(a):\n    '''\n    Check if the integer a is a perfect cube.\n    \n    Parameters:\n    a (int): The integer to check.\n    \n    Returns:\n    bool: True if a is a perfect cube, False otherwise.\n    \n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n    # Calculate the cube root of the absolute value of a\n    cube_root = round(abs(a) ** (1/3))\n    \n    # Check if the cube of the rounded cube root equals the absolute value of a\n    return cube_root ** 3 == abs(a)\n\n# Testing the function with provided examples\nprint(iscube(1))    # True\nprint(iscube(2))    # False\nprint(iscube(-1))   # True\nprint(iscube(64))   # True\nprint(iscube(0))    # True\nprint(iscube(180))  # False", "result": "passed", "passed": true}
{"task_id": "HumanEval/75", "completion": "from itertools import combinations\nfrom math import prod\n\ndef is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef generate_primes(limit):\n    \"\"\"Generate a list of prime numbers up to a given limit.\"\"\"\n    return [num for num in range(2, limit) if is_prime(num)]\n\ndef is_multiply_prime(a):\n    \"\"\"Return True if the given number is the multiplication of 3 prime numbers, False otherwise.\"\"\"\n    if a < 1 or a >= 100:\n        raise ValueError(\"Input must be less than 100 and greater than 0.\")\n    \n    primes = generate_primes(100)\n    \n    # Generate all combinations of 3 primes\n    for combo in combinations(primes, 3):\n        if prod(combo) == a:\n            return True\n            \n    return False\n\n# Testing the function with the provided example\nprint(is_multiply_prime(30))  # Expected output: True\nprint(is_multiply_prime(60))  # Expected output: True (3 * 5 * 4, but 4 is not prime, so False)\nprint(is_multiply_prime(1))   # Expected output: False\nprint(is_multiply_prime(97))  # Expected output: False (97 is prime itself)\nprint(is_multiply_prime(70))  # Expected output: True (2 * 5 * 7)", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/32", "completion": "import math\nimport numpy as np\n\ndef poly(xs: list, x: float) -> float:\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    Returns the value of the polynomial at x.\n    \"\"\"\n    return sum(coeff * math.pow(x, i) for i, coeff in enumerate(xs))\n\ndef find_zero(xs: list) -> float:\n    \"\"\"\n    Finds a root of the polynomial defined by coefficients xs.\n    Returns only one root, even if there are multiple roots.\n    The input list xs must have an even number of coefficients\n    and the largest non-zero coefficient guarantees a solution.\n    \n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n    # Check if the input list has an even number of coefficients\n    if len(xs) % 2 != 0:\n        raise ValueError(\"The list of coefficients must have an even number of elements.\")\n    \n    # Use numpy to find the roots of the polynomial\n    roots = np.roots(xs)\n    \n    # Filter out only the real roots\n    real_roots = [r.real for r in roots if np.isreal(r)]\n    \n    # Return the first real root found\n    if real_roots:\n        return real_roots[0]\n    else:\n        raise ValueError(\"No real roots found.\")\n\n# Example test cases\nif __name__ == \"__main__\":\n    print(round(find_zero([1, 2]), 2))  # Expected output: -0.5\n    print(round(find_zero([-6, 11, -6, 1]), 2))  # Expected output: 1.0", "result": "failed: 'NoneType' object is not callable", "passed": false}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    Calculate the number of collisions between two sets of cars\n    moving in opposite directions.\n\n    Parameters:\n    n (int): The number of cars moving left to right and right to left.\n\n    Returns:\n    int: The total number of collisions.\n    \"\"\"\n    # Validate the input\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    # Calculate the number of collisions\n    collisions = n * n\n    return collisions\n\n# Example test cases\nif __name__ == \"__main__\":\n    # Test with 0 cars\n    print(car_race_collision(0))  # Expected output: 0\n\n    # Test with 1 car in each direction\n    print(car_race_collision(1))  # Expected output: 1\n\n    # Test with 2 cars in each direction\n    print(car_race_collision(2))  # Expected output: 4\n\n    # Test with 3 cars in each direction\n    print(car_race_collision(3))  # Expected output: 9\n\n    # Test with a larger number of cars\n    print(car_race_collision(10))  # Expected output: 100", "result": "passed", "passed": true}
{"task_id": "HumanEval/65", "completion": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    \n    >>> circular_shift(12, 1)\n    '21'\n    >>> circular_shift(12, 2)\n    '12'\n    >>> circular_shift(12345, 2)\n    '45123'\n    >>> circular_shift(12345, 5)\n    '54321'\n    >>> circular_shift(12345, 6)\n    '54321'\n    \"\"\"\n    # Convert the integer to a string to work with its digits\n    str_x = str(x)\n    num_digits = len(str_x)\n    \n    # If shift is greater than the number of digits, reverse the string\n    if shift >= num_digits:\n        return str_x[::-1]\n    \n    # Calculate the effective shift\n    effective_shift = shift % num_digits\n    \n    # Perform the circular shift\n    shifted_str = str_x[-effective_shift:] + str_x[:-effective_shift]\n    \n    return shifted_str\n\n# Testing the function with provided examples and additional cases\nif __name__ == \"__main__\":\n    print(circular_shift(12, 1))  # Expected: '21'\n    print(circular_shift(12, 2))  # Expected: '12'\n    print(circular_shift(12345, 2))  # Expected: '45123'\n    print(circular_shift(12345, 5))  # Expected: '54321'\n    print(circular_shift(12345, 6))  # Expected: '54321'", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/84", "completion": "def solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n    # Check if N is within the valid range\n    if not (0 <= N <= 10000):\n        raise ValueError(\"N must be between 0 and 10000 inclusive.\")\n    \n    # Calculate the sum of the digits\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to binary and remove the '0b' prefix\n    binary_sum = bin(digit_sum)[2:]\n    \n    return binary_sum\n\n# Example test cases\nprint(solve(1000))  # Output: \"1\"\nprint(solve(150))   # Output: \"110\"\nprint(solve(147))   # Output: \"1100\"", "result": "passed", "passed": true}
{"task_id": "HumanEval/93", "completion": "def encode(message):\n    \"\"\"\n    Encodes a message by swapping the case of all letters and replacing\n    all vowels with the letter that appears 2 places ahead in the English alphabet.\n    \n    Parameters:\n    message (str): The input message to encode.\n    \n    Returns:\n    str: The encoded message.\n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n    \n    # Define a mapping for vowels to their replacements\n    vowel_replacement = {\n        'a': 'c', 'A': 'C',\n        'e': 'g', 'E': 'G',\n        'i': 'k', 'I': 'K',\n        'o': 'q', 'O': 'Q',\n        'u': 'w', 'U': 'W'\n    }\n    \n    encoded_message = []\n    \n    for char in message:\n        if char.isalpha():  # Check if the character is a letter\n            # Swap case\n            if char in vowel_replacement:\n                # Replace vowel and swap case\n                encoded_message.append(vowel_replacement[char])\n            else:\n                # Just swap case for consonants\n                encoded_message.append(char.swapcase())\n        else:\n            # If it's not a letter, we keep it as is\n            encoded_message.append(char)\n    \n    return ''.join(encoded_message)\n\n# Testing the function with provided examples\nprint(encode('test'))  # Expected output: 'TGST'\nprint(encode('This is a message'))  # Expected output: 'tHKS KS C MGSSCGG'", "result": "failed: This prints if this assert fails 1 (good for debugging!)", "passed": false}
{"task_id": "HumanEval/83", "completion": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \n    Parameters:\n    n (int): The number of digits in the positive integers.\n    \n    Returns:\n    int: The count of n-digit positive integers that start or end with 1.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer.\")\n    \n    # Count of n-digit numbers starting with '1'\n    count_starting_with_1 = 10 ** (n - 1)\n    \n    # Count of n-digit numbers ending with '1'\n    if n == 1:\n        count_ending_with_1 = 1  # Only the number '1'\n    else:\n        count_ending_with_1 = 9 * (10 ** (n - 2))\n    \n    # Count of n-digit numbers both starting and ending with '1'\n    if n == 1:\n        count_both = 1  # Only the number '1'\n    else:\n        count_both = 10 ** (n - 2)\n    \n    # Total count using inclusion-exclusion principle\n    total_count = (count_starting_with_1 + count_ending_with_1 - count_both)\n    \n    return total_count\n\n# Example test cases\nprint(starts_one_ends(1))  # Output: 1 (only the number '1')\nprint(starts_one_ends(2))  # Output: 18 (11, 21, 31, ..., 91, 01, 11)\nprint(starts_one_ends(3))  # Output: 271 (100-199, 101, 111, ..., 191, 201, ..., 901, 911)", "result": "passed", "passed": true}
{"task_id": "HumanEval/94", "completion": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sum_of_digits(n):\n    \"\"\"Return the sum of the digits of a number.\"\"\"\n    return sum(int(digit) for digit in str(n))\n\ndef largest_prime_digit_sum(lst):\n    \"\"\"Find the largest prime in the list and return the sum of its digits.\"\"\"\n    largest_prime = None\n    \n    # Iterate through the list to find the largest prime\n    for number in lst:\n        if is_prime(number):\n            if largest_prime is None or number > largest_prime:\n                largest_prime = number\n    \n    # If no prime number was found, return 0 or handle as needed\n    if largest_prime is None:\n        return 0\n    \n    # Return the sum of the digits of the largest prime\n    return sum_of_digits(largest_prime)\n\n# Example test cases\nprint(largest_prime_digit_sum([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))  # Output: 10\nprint(largest_prime_digit_sum([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))  # Output: 25\nprint(largest_prime_digit_sum([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]))  # Output: 13\nprint(largest_prime_digit_sum([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]))  # Output: 11\nprint(largest_prime_digit_sum([0, 81, 12, 3, 1, 21]))  # Output: 3\nprint(largest_prime_digit_sum([0, 8, 1, 2, 1, 7]))  # Output: 7", "result": "failed: This prints if this assert fails 1 (good for debugging!)", "passed": false}
