{"task_id": "MBPP/173", "completion": "import re\n\ndef remove_splchar(text):\n    \"\"\"\n    Remove everything except alphanumeric characters from a string.\n\n    Parameters:\n    text (str): The input string from which to remove special characters.\n\n    Returns:\n    str: A string containing only alphanumeric characters.\n    \"\"\"\n    # Use regular expression to substitute non-alphanumeric characters with an empty string\n    return re.sub(r'[^a-zA-Z0-9]', '', text)\n\n# Test case\nassert remove_splchar('python \u00c2\u00a0@#&^%$*program123') == 'pythonprogram123'\n\n# Additional test cases\nassert remove_splchar('Hello, World! 2023') == 'HelloWorld2023'\nassert remove_splchar('Special characters: !@#$%^&*()') == ''\nassert remove_splchar('1234567890') == '1234567890'\nassert remove_splchar('') == ''\nassert remove_splchar('abc123!@#') == 'abc123'\n\nprint(\"All tests passed!\")"}
{"task_id": "MBPP/131", "completion": "def reverse_vowels(str1):\n    \"\"\"\n    Reverse only the vowels of a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    str: The string with vowels reversed.\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    # Extract vowels from the string\n    vowel_list = [char for char in str1 if char in vowels]\n    \n    # Reverse the list of vowels\n    vowel_list.reverse()\n    \n    # Iterator for the reversed vowels\n    vowel_iter = iter(vowel_list)\n    \n    # Rebuild the string with reversed vowels\n    result = ''.join(next(vowel_iter) if char in vowels else char for char in str1)\n    \n    return result\n\n# Test cases\nassert reverse_vowels(\"Python\") == \"Python\"  # No vowels to reverse\nassert reverse_vowels(\"hello\") == \"holle\"    # 'e' and 'o' are reversed\nassert reverse_vowels(\"leetcode\") == \"leotcede\"  # 'e's and 'o' are reversed\nassert reverse_vowels(\"aA\") == \"Aa\"          # 'a' and 'A' are reversed\nassert reverse_vowels(\"racecar\") == \"racecar\"  # Palindrome, remains the same\nassert reverse_vowels(\"\") == \"\"                # Empty string\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/865", "completion": "def ntimes_list(nums, n):\n    \"\"\"\n    Multiplies each element in the list 'nums' by 'n' using the map function.\n    \n    Parameters:\n    nums (list): A list of numbers to be multiplied.\n    n (int): The multiplier.\n    \n    Returns:\n    list: A new list containing the results of the multiplication.\n    \n    Example:\n    >>> ntimes_list([1, 2, 3, 4, 5, 6, 7], 3)\n    [3, 6, 9, 12, 15, 18, 21]\n    \"\"\"\n    return list(map(lambda x: x * n, nums))\n\n# Test case\nassert ntimes_list([1, 2, 3, 4, 5, 6, 7], 3) == [3, 6, 9, 12, 15, 18, 21]\n\n# Additional test cases\nassert ntimes_list([0, 1, 2], 5) == [0, 5, 10]\nassert ntimes_list([-1, -2, -3], 2) == [-2, -4, -6]\nassert ntimes_list([10], 10) == [100]\nassert ntimes_list([], 3) == []"}
{"task_id": "MBPP/954", "completion": "def profit_amount(actual_cost, sale_amount):\n    \"\"\"\n    Calculate the profit amount based on actual cost and sale amount.\n    \n    If the sale amount is greater than the actual cost, return the profit amount.\n    Otherwise, return None.\n    \n    Parameters:\n    actual_cost (float): The cost price of the item.\n    sale_amount (float): The selling price of the item.\n    \n    Returns:\n    float or None: The profit amount if there is a profit, otherwise None.\n    \"\"\"\n    if sale_amount > actual_cost:\n        return sale_amount - actual_cost\n    else:\n        return None\n\n# Test case\nassert profit_amount(1500, 1200) is None, \"Test case failed: Expected None for no profit\"\nassert profit_amount(1500, 1800) == 300, \"Test case failed: Expected profit of 300\"\nassert profit_amount(1000, 1000) is None, \"Test case failed: Expected None for no profit\"\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/801", "completion": "def test_three_equal(x, y, z):\n    \"\"\"\n    Count the number of equal numbers from three given integers.\n\n    Parameters:\n    x (int): First integer\n    y (int): Second integer\n    z (int): Third integer\n\n    Returns:\n    int: The count of equal integers among the three provided.\n\n    Examples:\n    >>> test_three_equal(1, 1, 1)\n    3\n    >>> test_three_equal(1, 2, 1)\n    2\n    >>> test_three_equal(1, 2, 3)\n    0\n    >>> test_three_equal(2, 2, 2)\n    3\n    >>> test_three_equal(2, 2, 3)\n    2\n    >>> test_three_equal(1, 1, 2)\n    2\n    \"\"\"\n    # Initialize a count variable\n    count = 0\n    \n    # Compare the integers and count the equal ones\n    if x == y:\n        count += 1\n    if y == z:\n        count += 1\n    if x == z:\n        count += 1\n    \n    # If all three are equal, we should return 3\n    if count == 3:\n        return 3\n    \n    # Return the count of equal pairs\n    return count\n\n# Test cases to validate the function\nassert test_three_equal(1, 1, 1) == 3\nassert test_three_equal(1, 2, 1) == 2\nassert test_three_equal(1, 2, 3) == 0\nassert test_three_equal(2, 2, 2) == 3\nassert test_three_equal(2, 2, 3) == 2\nassert test_three_equal(1, 1, 2) == 2\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/402", "completion": "def factorial_mod(n, p):\n    \"\"\"Compute n! % p for n >= 0.\"\"\"\n    if n == 0:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % p\n    return result\n\ndef mod_inverse(a, p):\n    \"\"\"Compute the modular inverse of a under modulo p using Fermat's Little Theorem.\"\"\"\n    return pow(a, p - 2, p)\n\ndef ncr_modp(n, r, p):\n    \"\"\"\n    Compute nCr % p using the formula nCr = n! / (r! * (n - r)!)\n    and modular arithmetic.\n    \n    Parameters:\n    n (int): The total number of items.\n    r (int): The number of items to choose.\n    p (int): The modulus.\n    \n    Returns:\n    int: The value of nCr % p.\n    \"\"\"\n    if r > n:\n        return 0  # nCr is 0 if r > n\n    if r == 0 or r == n:\n        return 1  # nC0 and nCn are both 1\n\n    # Calculate n!, r!, and (n-r)!\n    num = factorial_mod(n, p)\n    denom = (factorial_mod(r, p) * factorial_mod(n - r, p)) % p\n    \n    # Calculate nCr % p\n    return (num * mod_inverse(denom, p)) % p\n\n# Test cases\nassert ncr_modp(10, 2, 13) == 6\nassert ncr_modp(5, 2, 7) == 3\nassert ncr_modp(10, 5, 100) == 10\nassert ncr_modp(20, 10, 1000) == 184\nassert ncr_modp(0, 0, 7) == 1  # 0C0 is 1\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_3", "completion": "def gcd(a, b):\n    \"\"\"\n    Calculate the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.\n\n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n\n    Returns:\n    int: The GCD of the two numbers.\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return abs(a)  # Return the absolute value of GCD\n\n# Test cases\nif __name__ == \"__main__\":\n    assert gcd(48, 18) == 6, \"Test case 1 failed\"\n    assert gcd(56, 98) == 14, \"Test case 2 failed\"\n    assert gcd(101, 10) == 1, \"Test case 3 failed\"\n    assert gcd(0, 5) == 5, \"Test case 4 failed\"\n    assert gcd(5, 0) == 5, \"Test case 5 failed\"\n    assert gcd(0, 0) == 0, \"Test case 6 failed\"  # GCD(0, 0) is undefined, but we return 0 here\n\n    print(\"All test cases passed!\")"}
{"task_id": "MBPP/495", "completion": "import re\n\ndef remove_lowercase(str1):\n    \"\"\"\n    Remove all lowercase substrings from the given string using regex.\n\n    Parameters:\n    str1 (str): The input string from which lowercase letters will be removed.\n\n    Returns:\n    str: A new string with all lowercase letters removed.\n    \"\"\"\n    # Use regex to substitute all lowercase letters with an empty string\n    result = re.sub(r'[a-z]', '', str1)\n    return result\n\n# Test case\nassert remove_lowercase('KDeoALOklOOHserfLoAJSIskdsf') == 'KDALOOOHLAJSI'\n\n# Additional test cases\nassert remove_lowercase('HelloWorld') == 'HW'\nassert remove_lowercase('Python3.8') == 'P3.'\nassert remove_lowercase('123abcXYZ') == '123XYZ'\nassert remove_lowercase('') == ''\nassert remove_lowercase('ALLUPPERCASE') == 'ALLUPPERCASE'\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_1", "completion": "def fibonacci(n):\n    \"\"\"\n    Return the n-th Fibonacci number.\n\n    Parameters:\n    n (int): The index of the Fibonacci number to return.\n\n    Returns:\n    int: The n-th Fibonacci number.\n\n    Example:\n    >>> fibonacci(5)\n    5\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\n# Test cases\nassert fibonacci(0) == 0\nassert fibonacci(1) == 1\nassert fibonacci(2) == 1\nassert fibonacci(3) == 2\nassert fibonacci(4) == 3\nassert fibonacci(5) == 5\nassert fibonacci(6) == 8\nassert fibonacci(7) == 13\nassert fibonacci(8) == 21\nassert fibonacci(9) == 34\nassert fibonacci(10) == 55\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/929", "completion": "def count_tuplex(tuplex, value):\n    \"\"\"\n    Count the occurrences of a specified value in a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple in which to count occurrences.\n    value: The value to count in the tuple.\n\n    Returns:\n    int: The count of occurrences of the specified value in the tuple.\n\n    Example:\n    >>> count_tuplex((2, 4, 5, 6, 2, 3, 4, 4, 7), 4)\n    3\n    \"\"\"\n    return tuplex.count(value)\n\n# Test case\nassert count_tuplex((2, 4, 5, 6, 2, 3, 4, 4, 7), 4) == 3\n\n# Additional test cases\nassert count_tuplex((1, 1, 1, 1, 1), 1) == 5  # All elements are 1\nassert count_tuplex((1, 2, 3, 4, 5), 6) == 0  # Value not in tuple\nassert count_tuplex((), 1) == 0  # Empty tuple\nassert count_tuplex((1, 2, 3, 2, 2), 2) == 3  # Multiple occurrences of 2\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_2", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    \n    :param strs: List of strings to evaluate\n    :return: The longest common prefix string, or an empty string if there is no common prefix\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:\n                return \"\"  # No common prefix found\n    \n    return prefix\n\n# Test cases\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'\nassert longest_common_prefix(['dog', 'racecar', 'car']) == ''\nassert longest_common_prefix(['interspecies', 'interstellar', 'interstate']) == 'inters'\nassert longest_common_prefix(['throne', 'throne']) == 'throne'\nassert longest_common_prefix(['']) == ''\nassert longest_common_prefix(['a']) == 'a'\nassert longest_common_prefix([]) == ''\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/460", "completion": "def Extract(lst):\n    \"\"\"\n    Extract the first element of each sublist.\n\n    Parameters:\n    lst (list of list): A list containing sublists.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n\n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    return [sublist[0] for sublist in lst if sublist]  # Ensure sublist is not empty\n\n# Test case\nassert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\nassert Extract([[10, 20], [30], [40, 50, 60]]) == [10, 30, 40]\nassert Extract([[], [1, 2], [3]]) == [1, 3]  # Testing with an empty sublist\nassert Extract([[], [], []]) == []  # All empty sublists\nassert Extract([[1], [2], [3]]) == [1, 2, 3]  # Single element sublists\n\nprint(\"All tests passed!\")"}
{"task_id": "MBPP/4_5", "completion": "def longest_common_substring(s1, s2):\n    \"\"\"\n    Find the length of the longest common substring between two strings.\n\n    Parameters:\n    s1 (str): The first string.\n    s2 (str): The second string.\n\n    Returns:\n    int: The length of the longest common substring.\n    \"\"\"\n    # Create a 2D array to store lengths of longest common suffixes\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    longest_length = 0  # To keep track of the longest length found\n\n    # Build the dp array\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                longest_length = max(longest_length, dp[i][j])\n            else:\n                dp[i][j] = 0  # Reset if characters do not match\n\n    return longest_length\n\n# Test case\nassert longest_common_substring('abcdef', 'zcdemf') == 2\n\n# Additional test cases\nassert longest_common_substring('hello', 'yell') == 3  # 'ell'\nassert longest_common_substring('abc', 'def') == 0    # No common substring\nassert longest_common_substring('abcdxyz', 'xyzabcd') == 4  # 'abcd'\nassert longest_common_substring('', 'abc') == 0  # Empty string\nassert longest_common_substring('abc', '') == 0  # Empty string\nassert longest_common_substring('', '') == 0  # Both empty strings\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_4", "completion": "def rotate_matrix(matrix):\n    \"\"\"\n    Rotate a given matrix by 90 degrees clockwise.\n\n    Args:\n    matrix (list of list of int): A 2D list representing the matrix to be rotated.\n\n    Returns:\n    list of list of int: The rotated matrix.\n\n    Example:\n    >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n    \"\"\"\n    # Transpose the matrix\n    transposed = [list(row) for row in zip(*matrix)]\n    # Reverse each row\n    rotated = [row[::-1] for row in transposed]\n    return rotated\n\n# Test case\nassert rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n# Additional test cases\nassert rotate_matrix([[1]]) == [[1]]  # Single element\nassert rotate_matrix([[1, 2], [3, 4]]) == [[3, 1], [4, 2]]  # 2x2 matrix\nassert rotate_matrix([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == \\\n    [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]  # 4x4 matrix\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_7", "completion": "def max_value(arr):\n    \"\"\"\n    Find the maximum value in a list of integers.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The maximum integer in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The list is empty. Cannot determine the maximum value.\")\n    \n    max_val = arr[0]  # Start with the first element as the maximum\n    for num in arr:\n        if num > max_val:\n            max_val = num  # Update max_val if a larger number is found\n    return max_val\n\n# Test cases\nif __name__ == \"__main__\":\n    assert max_value([1, 2, 3, 4, 5]) == 5\n    assert max_value([-1, -2, -3, -4, -5]) == -1\n    assert max_value([10, 20, 30, 40, 50]) == 50\n    assert max_value([5]) == 5\n    assert max_value([1, 3, 2, 5, 4]) == 5\n    print(\"All test cases passed!\")"}
{"task_id": "MBPP/645", "completion": "def find_k_product(test_list, K):\n    \"\"\"\n    Find the product of the elements at the K-th index in the given tuples.\n\n    Parameters:\n    test_list (list of tuples): A list containing tuples from which to extract elements.\n    K (int): The index of the elements to multiply.\n\n    Returns:\n    int: The product of the elements at the K-th index.\n\n    Example:\n    >>> find_k_product([(5, 6, 7), (1, 3, 5), (8, 9, 19)], 2)\n    665\n    \"\"\"\n    # Extract the K-th index elements from each tuple\n    k_elements = [t[K] for t in test_list]\n    \n    # Calculate the product of the extracted elements\n    product = 1\n    for element in k_elements:\n        product *= element\n    \n    return product\n\n# Test case\nassert find_k_product([(5, 6, 7), (1, 3, 5), (8, 9, 19)], 2) == 665\n\n# Additional test cases\nassert find_k_product([(2, 4, 6), (1, 3, 5), (7, 8, 9)], 1) == 96  # 4 * 3 * 8 = 96\nassert find_k_product([(1, 2), (3, 4), (5, 6)], 0) == 15  # 1 * 3 * 5 = 15\nassert find_k_product([(10, 20, 30), (40, 50, 60)], 1) == 1000  # 20 * 50 = 1000\nassert find_k_product([], 0) == 1  # Product of an empty list is conventionally 1"}
{"task_id": "MBPP/4_6", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string among an array of strings.\n    \n    :param strs: List of strings\n    :return: Longest common prefix string or an empty string if there is none\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:\n                return \"\"  # No common prefix found\n    \n    return prefix\n\n# Test case\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'\nassert longest_common_prefix(['dog', 'racecar', 'car']) == ''\nassert longest_common_prefix(['interspecies', 'interstellar', 'interstate']) == 'inters'\nassert longest_common_prefix(['a']) == 'a'\nassert longest_common_prefix([]) == ''\nassert longest_common_prefix(['']) == ''\nassert longest_common_prefix(['abc', 'ab', 'a']) == 'a'\n\nprint(\"All test cases passed!\")"}
{"task_id": "MBPP/4_8", "completion": "def longest_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for s in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not s.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:\n                return \"\"  # No common prefix\n    \n    return prefix\n\n# Test case\nassert longest_prefix(['flower', 'flow', 'flight']) == 'fl'"}
{"task_id": "MBPP/4_9", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n\n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    # Start with the first string as the prefix\n    prefix = strs[0]\n\n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:\n                return \"\"  # No common prefix\n\n    return prefix\n\n# Test case\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'\nprint(\"Test passed!\")"}
{"task_id": "MBPP/4_10", "completion": "def longest_common_subsequence(s1, s2):\n    \"\"\"\n    Find the length of the longest common subsequence of two strings.\n\n    Parameters:\n    s1 (str): The first string.\n    s2 (str): The second string.\n\n    Returns:\n    int: The length of the longest common subsequence.\n    \"\"\"\n    # Create a 2D array to store lengths of longest common subsequence.\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Build the dp array\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]\n\n# Test case\nassert longest_common_subsequence('abcde', 'ace') == 3\n\n# Additional test cases\nassert longest_common_subsequence('abc', 'abc') == 3\nassert longest_common_subsequence('abc', 'def') == 0\nassert longest_common_subsequence('abcde', 'abc') == 3\nassert longest_common_subsequence('a', 'a') == 1\nassert longest_common_subsequence('', 'abc') == 0\nassert longest_common_subsequence('abc', '') == 0\n\nprint(\"All test cases passed!\")"}
