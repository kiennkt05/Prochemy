{"task_id": "auto/2", "completion": "from typing import List\n\ndef sum_negative_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Sums all negative numbers in the provided list of integers.\n\n    Parameters:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    int: The sum of all negative integers in the list. If there are no negative integers, returns 0.\n    \"\"\"\n    # Initialize a variable to hold the sum of negative numbers\n    negative_sum = 0\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        # Check if the number is negative\n        if number < 0:\n            # Add the negative number to the sum\n            negative_sum += number\n            \n    return negative_sum\n\n# Example usage:\nif __name__ == \"__main__\":\n    example_numbers = [1, -2, 3, -4, 5, -6]\n    result = sum_negative_numbers(example_numbers)\n    print(f\"The sum of negative numbers is: {result}\")  # Output: -12", "result": "failed: ", "passed": false}
{"task_id": "auto/1", "completion": "from typing import List\n\ndef count_consecutive_zeros(nums: List[int]) -> int:\n    \"\"\"\n    Count the maximum number of consecutive zeros in a list of integers.\n\n    Args:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The maximum count of consecutive zeros.\n    \"\"\"\n    max_count = 0  # To keep track of the maximum count of consecutive zeros\n    current_count = 0  # To count the current streak of zeros\n\n    for num in nums:\n        if num == 0:\n            current_count += 1  # Increment the count for consecutive zeros\n        else:\n            max_count = max(max_count, current_count)  # Update max_count if needed\n            current_count = 0  # Reset current count for the next sequence\n\n    # Final check in case the list ends with zeros\n    max_count = max(max_count, current_count)\n\n    return max_count\n\n# Example usage:\nif __name__ == \"__main__\":\n    example_list = [1, 0, 0, 2, 0, 0, 0, 3, 0]\n    print(count_consecutive_zeros(example_list))  # Output: 3", "result": "failed: invalid syntax (<string>, line 10)", "passed": false}
{"task_id": "auto/0", "completion": "from typing import List\n\ndef find_duplicates(strings: List[str]) -> List[str]:\n    \"\"\"\n    Find and return a list of duplicate strings from the input list.\n\n    Args:\n    strings (List[str]): A list of strings to check for duplicates.\n\n    Returns:\n    List[str]: A list of duplicate strings found in the input list.\n    \"\"\"\n    seen = set()          # Set to track seen strings\n    duplicates = set()    # Set to track duplicates\n\n    for string in strings:\n        if string in seen:\n            duplicates.add(string)  # Add to duplicates if already seen\n        else:\n            seen.add(string)        # Add to seen if not seen before\n\n    return list(duplicates)  # Convert the set of duplicates to a list and return\n\n# Example usage:\nif __name__ == \"__main__\":\n    example_strings = [\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"grape\"]\n    print(find_duplicates(example_strings))  # Output: ['apple', 'banana']", "result": "failed: ", "passed": false}
{"task_id": "auto/7", "completion": "from typing import List\n\ndef calculate_mean(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the mean (average) of a list of numbers.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n    float: The mean of the numbers. Returns 0.0 if the list is empty.\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        return 0.0  # Return 0.0 for an empty list to avoid division by zero\n\n    total_sum = sum(numbers)  # Calculate the sum of the numbers\n    count = len(numbers)       # Get the count of numbers\n    mean = total_sum / count   # Calculate the mean\n    return mean                # Return the calculated mean", "result": "failed: ", "passed": false}
{"task_id": "auto/4", "completion": "from typing import List\n\ndef find_duplicates(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Find and return a list of duplicate numbers from the given list of floats.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n    List[float]: A list of duplicate numbers found in the input list.\n    \"\"\"\n    seen = set()          # Set to track numbers we have seen\n    duplicates = set()    # Set to track duplicates\n\n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)  # If the number is already seen, add to duplicates\n        else:\n            seen.add(number)        # Otherwise, add it to the seen set\n\n    return list(duplicates)  # Convert the set of duplicates back to a list\n\n# Example usage:\nif __name__ == \"__main__\":\n    example_numbers = [1.0, 2.5, 3.0, 2.5, 4.0, 1.0, 5.0]\n    print(find_duplicates(example_numbers))  # Output: [1.0, 2.5]", "result": "failed: ", "passed": false}
{"task_id": "auto/6", "completion": "from typing import List\n\ndef count_elements(numbers: List[int], target: int) -> int:\n    \"\"\"\n    Count the occurrences of a target integer in a list of integers.\n\n    Parameters:\n    numbers (List[int]): A list of integers to search through.\n    target (int): The integer to count in the list.\n\n    Returns:\n    int: The count of occurrences of the target integer in the list.\n    \"\"\"\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        # If the current number matches the target, increment the counter\n        if number == target:\n            count += 1\n            \n    return count\n\n# Example usage:\nif __name__ == \"__main__\":\n    example_numbers = [1, 2, 3, 4, 2, 2, 5]\n    target_value = 2\n    result = count_elements(example_numbers, target_value)\n    print(f\"The number {target_value} appears {result} times in the list.\")", "result": "failed: ", "passed": false}
{"task_id": "auto/3", "completion": "from typing import List\n\ndef find_missing_number(nums: List[int]) -> int:\n    \"\"\"\n    Find the missing number in a list of integers from 0 to n.\n\n    Args:\n    nums (List[int]): A list of integers containing n distinct numbers\n                      from the range 0 to n.\n\n    Returns:\n    int: The missing number in the list.\n    \"\"\"\n    n = len(nums)  # The length of the list is n\n    expected_sum = n * (n + 1) // 2  # Sum of first n natural numbers\n    actual_sum = sum(nums)  # Sum of the numbers in the list\n\n    # The missing number is the difference between expected and actual sum\n    missing_number = expected_sum - actual_sum\n    return missing_number\n\n# Example usage:\nif __name__ == \"__main__\":\n    nums = [0, 1, 2, 4, 5]  # Example list with a missing number 3\n    print(f\"The missing number is: {find_missing_number(nums)}\")  # Output: 3", "result": "failed: name 'List' is not defined", "passed": false}
{"task_id": "auto/9", "completion": "from typing import List\n\ndef count_negative_numbers(nums: List[int]) -> int:\n    \"\"\"Count the number of negative integers in a given list of integers.\n    \n    Args:\n        nums (List[int]): A list of integers.\n        \n    Returns:\n        int: The count of negative integers in the list.\n    \n    Examples:\n        >>> count_negative_numbers([-1, 2, -3, 4, -5, 6])\n        3\n        >>> count_negative_numbers([1, 2, 3, 4, 5, 6])\n        0\n        >>> count_negative_numbers([])\n        0\n        >>> count_negative_numbers([-1, -2, -3])\n        3\n    \"\"\"\n    # Initialize a counter for negative numbers\n    negative_count = 0\n    \n    # Iterate through each number in the list\n    for num in nums:\n        # Check if the number is negative\n        if num < 0:\n            negative_count += 1  # Increment the counter if negative\n    \n    return negative_count  # Return the total count of negative numbers\n\n# Example test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "result": "failed: ", "passed": false}
{"task_id": "auto/5", "completion": "from typing import List\n\ndef reverse_sublists(data: List[int], chunk_size: int) -> List[int]:\n    \"\"\"\n    Reverses the elements of the input list in chunks of specified size.\n\n    Parameters:\n    data (List[int]): The list of integers to be processed.\n    chunk_size (int): The size of each chunk to reverse.\n\n    Returns:\n    List[int]: A new list with the elements reversed in chunks.\n    \"\"\"\n    if chunk_size <= 0:\n        raise ValueError(\"Chunk size must be a positive integer.\")\n    \n    result = []\n    \n    # Iterate over the list in steps of chunk_size\n    for i in range(0, len(data), chunk_size):\n        # Get the current chunk\n        chunk = data[i:i + chunk_size]\n        # Reverse the current chunk and extend the result list\n        result.extend(reversed(chunk))\n    \n    return result\n\n# Example usage:\nif __name__ == \"__main__\":\n    sample_data = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    chunk_size = 3\n    reversed_data = reverse_sublists(sample_data, chunk_size)\n    print(reversed_data)  # Output: [3, 2, 1, 6, 5, 4, 9, 8, 7]", "result": "failed: ", "passed": false}
{"task_id": "auto/8", "completion": "from typing import List\n\ndef find_max_consecutive_ones(nums: List[int]) -> int:\n    \"\"\"\n    This function finds the maximum number of consecutive 1's in a binary array.\n\n    :param nums: List[int] - A list of integers (0s and 1s).\n    :return: int - The maximum count of consecutive 1's.\n    \"\"\"\n    max_count = 0  # To keep track of the maximum count of consecutive 1's\n    current_count = 0  # To count the current streak of consecutive 1's\n\n    for num in nums:\n        if num == 1:\n            current_count += 1  # Increment the count for consecutive 1's\n        else:\n            max_count = max(max_count, current_count)  # Update max count if needed\n            current_count = 0  # Reset current count for the next streak\n\n    # Final check at the end of the loop in case the array ends with 1's\n    max_count = max(max_count, current_count)\n\n    return max_count", "result": "failed: invalid syntax (<string>, line 9)", "passed": false}
{"task_id": "HumanEval/77", "completion": "def iscube(a):\n    '''\n    Check if the given integer a is a perfect cube.\n    \n    Parameters:\n    a (int): The integer to check.\n    \n    Returns:\n    bool: True if a is a perfect cube, False otherwise.\n    \n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n    # Calculate the cube root of the absolute value of a\n    cube_root = round(abs(a) ** (1/3))\n    \n    # Check if the cube of the rounded cube root equals the absolute value of a\n    return cube_root ** 3 == abs(a)\n\n# Test cases\nprint(iscube(1))    # True\nprint(iscube(2))    # False\nprint(iscube(-1))   # True\nprint(iscube(64))   # True\nprint(iscube(0))    # True\nprint(iscube(180))  # False", "result": "passed", "passed": true}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    Calculate the number of collisions between two sets of cars\n    moving in opposite directions on a straight road.\n\n    Parameters:\n    n (int): The number of cars in each direction.\n\n    Returns:\n    int: The total number of collisions.\n    \"\"\"\n    # Each car moving left to right will collide with each car moving right to left\n    collisions = n * n\n    return collisions\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test the function with a few examples\n    print(car_race_collision(0))  # Expected output: 0\n    print(car_race_collision(1))  # Expected output: 1\n    print(car_race_collision(2))  # Expected output: 4\n    print(car_race_collision(3))  # Expected output: 9", "result": "passed", "passed": true}
{"task_id": "HumanEval/84", "completion": "def solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n    # Step 1: Convert N to string to iterate over each digit\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Step 2: Convert the sum to binary and remove the '0b' prefix\n    binary_sum = bin(digit_sum)[2:]\n    \n    return binary_sum\n\n# Example test cases\nprint(solve(1000))  # Output: \"1\"\nprint(solve(150))   # Output: \"110\"\nprint(solve(147))   # Output: \"1100\"", "result": "passed", "passed": true}
{"task_id": "HumanEval/10", "completion": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" \n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    # If the input string is empty, return it as is\n    if not string:\n        return string\n    \n    # Find the length of the string\n    n = len(string)\n    \n    # Check for the longest palindromic suffix\n    for i in range(n):\n        # Check if the substring from i to the end is a palindrome\n        if is_palindrome(string[i:]):\n            # If it is, we need to append the reverse of the prefix before this suffix\n            prefix = string[:i]\n            return string + prefix[::-1]\n    \n    # If no palindromic suffix is found, the whole string is non-palindromic\n    # In this case, we append the reverse of the entire string except the last character\n    return string + string[:-1][::-1]\n\n# Example usage\nif __name__ == \"__main__\":\n    print(make_palindrome(''))        # Output: ''\n    print(make_palindrome('cat'))     # Output: 'catac'\n    print(make_palindrome('cata'))    # Output: 'catac'", "result": "passed", "passed": true}
{"task_id": "HumanEval/65", "completion": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shifting the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    \n    >>> circular_shift(12, 1)\n    '21'\n    >>> circular_shift(12, 2)\n    '12'\n    >>> circular_shift(12345, 1)\n    '51234'\n    >>> circular_shift(12345, 5)\n    '54321'\n    >>> circular_shift(12345, 6)\n    '54321'\n    \"\"\"\n    # Convert the integer to a string to work with its digits\n    str_x = str(x)\n    num_digits = len(str_x)\n    \n    # If shift is greater than the number of digits, reverse the string\n    if shift >= num_digits:\n        return str_x[::-1]\n    \n    # Calculate the effective shift (in case shift is less than num_digits)\n    effective_shift = shift % num_digits\n    \n    # Perform the circular shift\n    shifted_str = str_x[-effective_shift:] + str_x[:-effective_shift]\n    \n    return shifted_str\n\n# Testing the function with provided examples and additional cases\nif __name__ == \"__main__\":\n    print(circular_shift(12, 1))  # Output: '21'\n    print(circular_shift(12, 2))  # Output: '12'\n    print(circular_shift(12345, 1))  # Output: '51234'\n    print(circular_shift(12345, 5))  # Output: '54321'\n    print(circular_shift(12345, 6))  # Output: '54321'", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/75", "completion": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef generate_primes(limit):\n    \"\"\"Generate a list of prime numbers up to a given limit.\"\"\"\n    return [num for num in range(2, limit) if is_prime(num)]\n\ndef is_multiply_prime(a):\n    \"\"\"Return True if the given number is the multiplication of 3 prime numbers, False otherwise.\n    \n    Args:\n        a (int): The number to check, must be less than 100.\n    \n    Returns:\n        bool: True if a is the product of 3 primes, False otherwise.\n    \"\"\"\n    if a >= 100:\n        raise ValueError(\"Input must be less than 100.\")\n    \n    primes = generate_primes(100)\n    \n    # Check all combinations of three primes\n    for i in range(len(primes)):\n        for j in range(i, len(primes)):\n            for k in range(j, len(primes)):\n                product = primes[i] * primes[j] * primes[k]\n                if product == a:\n                    return True\n                # Since primes are sorted, if product exceeds 'a', we can break early\n                if product > a:\n                    break\n    \n    return False\n\n# Example usage\nprint(is_multiply_prime(30))  # Output: True\nprint(is_multiply_prime(60))  # Output: True (3 * 5 * 4, but 4 is not prime, so False)\nprint(is_multiply_prime(15))  # Output: False", "result": "failed: Input must be less than 100.", "passed": false}
{"task_id": "HumanEval/32", "completion": "import math\nfrom scipy.optimize import bisect\n\ndef poly(xs: list, x: float) -> float:\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    Returns the value of the polynomial at x.\n    \n    :param xs: List of coefficients [a0, a1, a2, ..., an] for the polynomial\n               a0 + a1*x + a2*x^2 + ... + an*x^n\n    :param x: The point at which to evaluate the polynomial\n    :return: The value of the polynomial at x\n    \"\"\"\n    return sum(coeff * math.pow(x, i) for i, coeff in enumerate(xs))\n\ndef find_zero(xs: list) -> float:\n    \"\"\"\n    Finds a root of the polynomial defined by coefficients xs.\n    Assumes xs has an even number of coefficients and the largest\n    non-zero coefficient guarantees a solution.\n    \n    :param xs: List of coefficients of the polynomial\n    :return: A root of the polynomial\n    :raises ValueError: If the number of coefficients is not even\n    :raises RuntimeError: If no root is found within the specified range\n    \"\"\"\n    if len(xs) % 2 != 0:\n        raise ValueError(\"The number of coefficients must be even.\")\n    \n    # Define a function to find the root\n    def f(x):\n        return poly(xs, x)\n    \n    # Use the bisection method to find a root\n    # We need to find a suitable interval [a, b] where f(a) and f(b) have opposite signs\n    a, b = -10, 10  # Initial search interval\n    if f(a) * f(b) > 0:\n        raise RuntimeError(\"No root found in the interval [-10, 10]. Adjust the interval.\")\n    \n    # Use the bisection method to find the root\n    root = bisect(f, a, b)\n    return root\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    print(round(find_zero([1, 2]), 2))  # f(x) = 1 + 2x\n    print(round(find_zero([-6, 11, -6, 1]), 2))  # (x - 1) * (x - 2) * (x - 3)", "result": "failed: No module named 'scipy'", "passed": false}
{"task_id": "HumanEval/93", "completion": "def encode(message):\n    \"\"\"\n    Encodes a message by swapping the case of all letters and replacing\n    all vowels with the letter that appears two places ahead in the English alphabet.\n    \n    Vowels are defined as 'a', 'e', 'i', 'o', 'u' (and their uppercase counterparts).\n    \n    Args:\n    message (str): The input message to encode.\n    \n    Returns:\n    str: The encoded message.\n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n    \n    # Define a mapping for vowels to their replacements\n    vowel_replacement = {\n        'a': 'c', 'A': 'C',\n        'e': 'g', 'E': 'G',\n        'i': 'k', 'I': 'K',\n        'o': 'q', 'O': 'Q',\n        'u': 'w', 'U': 'W'\n    }\n    \n    encoded_message = []\n    \n    for char in message:\n        if char.isalpha():  # Check if the character is a letter\n            # Swap case\n            swapped_char = char.swapcase()\n            # Replace vowel if it's in the mapping\n            if swapped_char in vowel_replacement:\n                swapped_char = vowel_replacement[swapped_char]\n            encoded_message.append(swapped_char)\n        else:\n            # If it's not a letter, keep it as is\n            encoded_message.append(char)\n    \n    return ''.join(encoded_message)\n\n# Test cases\nprint(encode('test'))  # Output: 'TGST'\nprint(encode('This is a message'))  # Output: 'tHKS KS C MGSSCGG'", "result": "passed", "passed": true}
{"task_id": "HumanEval/83", "completion": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \n    Parameters:\n    n (int): The number of digits in the positive integers to consider.\n    \n    Returns:\n    int: The count of n-digit integers that start or end with 1.\n    \"\"\"\n    if n < 1:\n        return 0  # No positive integers exist for n < 1\n\n    # Count of n-digit integers starting with '1'\n    start_with_1 = 10 ** (n - 1)\n    \n    # Count of n-digit integers ending with '1'\n    if n == 1:\n        end_with_1 = 1  # Only the number '1'\n    else:\n        end_with_1 = 9 * (10 ** (n - 2))\n    \n    # Count of n-digit integers starting and ending with '1'\n    if n > 1:\n        both_start_and_end_with_1 = 10 ** (n - 2)\n    else:\n        both_start_and_end_with_1 = 0  # This case is already counted in n = 1\n    \n    # Total count using inclusion-exclusion principle\n    total_count = start_with_1 + end_with_1 - both_start_and_end_with_1\n    \n    return total_count\n\n# Example usage:\nprint(starts_one_ends(1))  # Output: 1\nprint(starts_one_ends(2))  # Output: 18\nprint(starts_one_ends(3))  # Output: 271", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/94", "completion": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sum_of_digits(n):\n    \"\"\"Return the sum of the digits of a number.\"\"\"\n    return sum(int(digit) for digit in str(n))\n\ndef skjkasdkd(lst):\n    \"\"\"Find the largest prime in the list and return the sum of its digits.\"\"\"\n    largest_prime = None\n    \n    # Iterate through the list to find the largest prime\n    for number in lst:\n        if is_prime(number):\n            if largest_prime is None or number > largest_prime:\n                largest_prime = number\n    \n    # If no prime number is found, return 0 (or handle as needed)\n    if largest_prime is None:\n        return 0\n    \n    # Calculate and return the sum of the digits of the largest prime\n    return sum_of_digits(largest_prime)\n\n# Example test cases\nprint(skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))  # Output: 10\nprint(skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))  # Output: 25\nprint(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]))  # Output: 13\nprint(skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]))  # Output: 11\nprint(skjkasdkd([0, 81, 12, 3, 1, 21]))  # Output: 3\nprint(skjkasdkd([0, 8, 1, 2, 1, 7]))  # Output: 7", "result": "passed", "passed": true}
