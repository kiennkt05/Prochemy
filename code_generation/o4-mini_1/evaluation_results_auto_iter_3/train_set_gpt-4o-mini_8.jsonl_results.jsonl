{"task_id": "MBPP/954", "completion": "def profit_amount(actual_cost, sale_amount):\n    \"\"\"\n    Calculate the profit amount based on actual cost and sale amount.\n    \n    If the sale amount is greater than the actual cost, the profit is returned.\n    If there is no profit or a loss, None is returned.\n    \n    Parameters:\n    actual_cost (float): The cost price of the item.\n    sale_amount (float): The selling price of the item.\n    \n    Returns:\n    float or None: The profit amount if there is a profit, otherwise None.\n    \"\"\"\n    profit = sale_amount - actual_cost\n    if profit > 0:\n        return profit\n    else:\n        return None\n\n# Test case\nassert profit_amount(1500, 1200) is None  # No profit, should return None\nassert profit_amount(1500, 1800) == 300   # Profit of 300, should return 300\nassert profit_amount(1000, 1000) is None  # No profit, should return None\nassert profit_amount(2000, 2500) == 500    # Profit of 500, should return 500\n\nprint(\"All test cases passed!\")", "result": "failed: invalid non-printable character U+00A0 (<string>, line 35)", "passed": false}
{"task_id": "MBPP/173", "completion": "import re\n\ndef remove_splchar(text):\n    \"\"\"\n    Remove everything except alphanumeric characters from a string.\n\n    Parameters:\n    text (str): The input string from which to remove special characters.\n\n    Returns:\n    str: A string containing only alphanumeric characters.\n    \"\"\"\n    # Use regular expression to substitute non-alphanumeric characters with an empty string\n    cleaned_text = re.sub(r'[^a-zA-Z0-9]', '', text)\n    return cleaned_text\n\n# Test case to validate the function\nassert remove_splchar('python \u00c2\u00a0@#&^%$*program123') == 'pythonprogram123'\n\n# Additional test cases\nassert remove_splchar('Hello, World!') == 'HelloWorld'\nassert remove_splchar('1234!@#$') == '1234'\nassert remove_splchar('') == ''\nassert remove_splchar('NoSpecialChars') == 'NoSpecialChars'\n\nprint(\"All test cases passed!\")", "result": "failed: invalid non-printable character U+00A0 (<string>, line 34)", "passed": false}
{"task_id": "MBPP/865", "completion": "def ntimes_list(nums, n):\n    \"\"\"\n    Multiplies each element in the list 'nums' by 'n' using the map function.\n    \n    Parameters:\n    nums (list): A list of numbers to be multiplied.\n    n (int): The multiplier.\n    \n    Returns:\n    list: A new list with each element multiplied by 'n'.\n    \n    Example:\n    >>> ntimes_list([1, 2, 3, 4, 5, 6, 7], 3)\n    [3, 6, 9, 12, 15, 18, 21]\n    \"\"\"\n    return list(map(lambda x: x * n, nums))\n\n# Test case\nassert ntimes_list([1, 2, 3, 4, 5, 6, 7], 3) == [3, 6, 9, 12, 15, 18, 21]", "result": "failed: invalid non-printable character U+00A0 (<string>, line 27)", "passed": false}
{"task_id": "MBPP/495", "completion": "import re\n\ndef remove_lowercase(str1):\n    \"\"\"\n    Remove all lowercase substrings from the given string using regex.\n\n    Parameters:\n    str1 (str): The input string from which lowercase letters will be removed.\n\n    Returns:\n    str: A new string with all lowercase letters removed.\n    \"\"\"\n    # Use regex to substitute all lowercase letters with an empty string\n    result = re.sub(r'[a-z]', '', str1)\n    return result\n\n# Test case\nassert remove_lowercase('KDeoALOklOOHserfLoAJSIskdsf') == 'KDALOOOHLAJSI'\n\n# Additional test cases\nassert remove_lowercase('HelloWorld') == 'HW'\nassert remove_lowercase('Python3.8') == 'P3.'\nassert remove_lowercase('123abcXYZ') == '123XYZ'\nassert remove_lowercase('') == ''  # Edge case: empty string\nassert remove_lowercase('ALLUPPERCASE') == 'ALLUPPERCASE'  # No lowercase letters\n\nprint(\"All test cases passed!\")", "result": "failed: invalid non-printable character U+00A0 (<string>, line 35)", "passed": false}
{"task_id": "MBPP/929", "completion": "def count_tuplex(tuplex, value):\n    \"\"\"\n    Count the occurrences of a specified value in a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple in which to count occurrences.\n    value: The value to count in the tuple.\n\n    Returns:\n    int: The number of times the value appears in the tuple.\n\n    Example:\n    >>> count_tuplex((2, 4, 5, 6, 2, 3, 4, 4, 7), 4)\n    3\n    \"\"\"\n    return tuplex.count(value)\n\n# Test case\nassert count_tuplex((2, 4, 5, 6, 2, 3, 4, 4, 7), 4) == 3", "result": "failed: invalid non-printable character U+00A0 (<string>, line 1)", "passed": false}
{"task_id": "MBPP/801", "completion": "def test_three_equal(x, y, z):\n    \"\"\"\n    Count the number of equal numbers from three given integers.\n\n    Parameters:\n    x (int): First integer\n    y (int): Second integer\n    z (int): Third integer\n\n    Returns:\n    int: The count of equal integers among x, y, and z\n    \"\"\"\n    # Initialize a count variable\n    count = 0\n    \n    # Check for equality and increment the count accordingly\n    if x == y:\n        count += 1\n    if y == z:\n        count += 1\n    if x == z:\n        count += 1\n    \n    # If all three are equal, we should return 3\n    if count == 3:\n        return 3\n    \n    # If two are equal, we should return 2\n    if count == 1:\n        return 2\n    \n    # If none are equal, we return 0\n    return 0\n\n# Test cases\nassert test_three_equal(1, 1, 1) == 3, \"Test case 1 failed\"\nassert test_three_equal(1, 1, 2) == 2, \"Test case 2 failed\"\nassert test_three_equal(1, 2, 2) == 2, \"Test case 3 failed\"\nassert test_three_equal(1, 2, 3) == 0, \"Test case 4 failed\"\nassert test_three_equal(2, 2, 2) == 3, \"Test case 5 failed\"\n\nprint(\"All test cases passed!\")", "result": "failed: invalid non-printable character U+00A0 (<string>, line 50)", "passed": false}
{"task_id": "MBPP/460", "completion": "def Extract(lst):\n    \"\"\"\n    Extract the first element of each sublist in the given list of lists.\n\n    Parameters:\n    lst (list of list): A list containing sublists from which to extract the first elements.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n\n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    # Using list comprehension to extract the first element of each sublist\n    return [sublist[0] for sublist in lst if sublist]  # Check if sublist is not empty\n\n# Test cases to validate the function\nif __name__ == \"__main__\":\n    # Test case 1: Standard case\n    assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n    \n    # Test case 2: Empty sublists\n    assert Extract([[1, 2], [], [6, 7, 8, 9]]) == [1, 6]  # Should skip the empty sublist\n    \n    # Test case 3: All sublists are empty\n    assert Extract([[], [], []]) == []  # Should return an empty list\n    \n    # Test case 4: Single element sublists\n    assert Extract([[1], [2], [3]]) == [1, 2, 3]  # Should return the single elements\n    \n    # Test case 5: Mixed types\n    assert Extract([[1, 2], ['a', 'b'], [3.5, 4.5]]) == [1, 'a', 3.5]  # Should handle mixed types\n\n    print(\"All test cases passed!\")", "result": "failed: invalid non-printable character U+00A0 (<string>, line 43)", "passed": false}
{"task_id": "MBPP/131", "completion": "def reverse_vowels(str1):\n    \"\"\"\n    Reverse only the vowels in the given string.\n    \n    Parameters:\n    str1 (str): The input string to process.\n    \n    Returns:\n    str: A new string with the vowels reversed.\n    \n    Example:\n    >>> reverse_vowels(\"Python\")\n    'Python'\n    >>> reverse_vowels(\"hello\")\n    'holle'\n    >>> reverse_vowels(\"leetcode\")\n    'leotcede'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"  # Define the vowels\n    str_list = list(str1)   # Convert the string to a list for mutability\n    left, right = 0, len(str_list) - 1  # Initialize two pointers\n\n    # Use two pointers to find and swap vowels\n    while left < right:\n        # Move the left pointer to the next vowel\n        while left < right and str_list[left] not in vowels:\n            left += 1\n        # Move the right pointer to the previous vowel\n        while left < right and str_list[right] not in vowels:\n            right -= 1\n        \n        # Swap the vowels\n        if left < right:\n            str_list[left], str_list[right] = str_list[right], str_list[left]\n            left += 1\n            right -= 1\n\n    return ''.join(str_list)  # Convert the list back to a string\n\n# Test cases\nassert reverse_vowels(\"Python\") == \"Python\"\nassert reverse_vowels(\"hello\") == \"holle\"\nassert reverse_vowels(\"leetcode\") == \"leotcede\"\nassert reverse_vowels(\"aA\") == \"Aa\"\nassert reverse_vowels(\"racecar\") == \"racecar\"\nassert reverse_vowels(\"\") == \"\"  # Edge case: empty string\nassert reverse_vowels(\"bcd\") == \"bcd\"  # Edge case: no vowels\n\nprint(\"All test cases passed!\")", "result": "failed: invalid non-printable character U+00A0 (<string>, line 57)", "passed": false}
{"task_id": "MBPP/645", "completion": "def find_k_product(test_list, K):\n    \"\"\"\n    Find the product of the elements at the K-th index in the given list of tuples.\n\n    Parameters:\n    test_list (list of tuples): A list containing tuples from which to extract elements.\n    K (int): The index of the elements to be multiplied.\n\n    Returns:\n    int: The product of the elements at the K-th index.\n\n    Example:\n    >>> find_k_product([(5, 6, 7), (1, 3, 5), (8, 9, 19)], 2)\n    665\n    \"\"\"\n    # Initialize the product to 1 (multiplicative identity)\n    product = 1\n    \n    # Iterate through each tuple in the list\n    for tup in test_list:\n        # Check if the K-th index exists in the tuple\n        if K < len(tup):\n            product *= tup[K]\n        else:\n            raise IndexError(f\"Index {K} is out of range for tuple {tup}\")\n\n    return product\n\n# Test cases to validate the function\nif __name__ == \"__main__\":\n    # Test case 1: Standard case\n    assert find_k_product([(5, 6, 7), (1, 3, 5), (8, 9, 19)], 2) == 665, \"Test case 1 failed\"\n    \n    # Test case 2: All tuples have the same value at index 1\n    assert find_k_product([(2, 3, 4), (5, 3, 6), (7, 3, 8)], 1) == 3 * 3 * 3, \"Test case 2 failed\"\n    \n    # Test case 3: Single tuple\n    assert find_k_product([(10, 20, 30)], 1) == 20, \"Test case 3 failed\"\n    \n    # Test case 4: K is out of range\n    try:\n        find_k_product([(1, 2), (3, 4)], 2)\n    except IndexError as e:\n        assert str(e) == \"Index 2 is out of range for tuple (1, 2)\", \"Test case 4 failed\"\n    \n    # Test case 5: Empty list\n    assert find_k_product([], 0) == 1, \"Test case 5 failed\"  # Product of an empty list is conventionally 1\n\n    print(\"All test cases passed!\")", "result": "failed: invalid non-printable character U+00A0 (<string>, line 57)", "passed": false}
{"task_id": "MBPP/4_1", "completion": "def fibonacci(n):\n    \"\"\"\n    Return the n-th Fibonacci number.\n    \n    The Fibonacci sequence is defined as:\n    F(0) = 0\n    F(1) = 1\n    F(n) = F(n-1) + F(n-2) for n > 1\n    \n    Parameters:\n    n (int): The index of the Fibonacci number to return.\n    \n    Returns:\n    int: The n-th Fibonacci number.\n    \n    Raises:\n    ValueError: If n is a negative integer.\n    \n    Example:\n    >>> fibonacci(5)\n    5\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\n# Test cases\nif __name__ == \"__main__\":\n    assert fibonacci(0) == 0\n    assert fibonacci(1) == 1\n    assert fibonacci(2) == 1\n    assert fibonacci(3) == 2\n    assert fibonacci(4) == 3\n    assert fibonacci(5) == 5\n    assert fibonacci(10) == 55\n    assert fibonacci(20) == 6765\n    print(\"All test cases passed!\")", "result": "failed: invalid syntax (<string>, line 5)", "passed": false}
{"task_id": "MBPP/4_4", "completion": "def rotate_matrix(matrix):\n    \"\"\"\n    Rotate a given matrix by 90 degrees clockwise.\n\n    Args:\n    matrix (list of list of int): A 2D list representing the matrix to be rotated.\n\n    Returns:\n    list of list of int: The rotated matrix.\n\n    Example:\n    >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return matrix  # Return the original matrix if it's empty\n\n    # Transpose the matrix\n    transposed = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n    \n    # Reverse each row to get the rotated matrix\n    rotated = [row[::-1] for row in transposed]\n    \n    return rotated\n\n# Test case\nassert rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]", "result": "failed: invalid syntax (<string>, line 5)", "passed": false}
{"task_id": "MBPP/4_6", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string among an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the initial prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:  # If prefix is empty, return immediately\n                return \"\"\n    \n    return prefix\n\n# Test case\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'", "result": "failed: invalid syntax (<string>, line 6)", "passed": false}
{"task_id": "MBPP/4_3", "completion": "def gcd(a, b):\n    \"\"\"\n    Calculate the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.\n\n    Parameters:\n    a (int): First number.\n    b (int): Second number.\n\n    Returns:\n    int: The GCD of the two numbers.\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b  # Update a and b\n    return a  # When b is 0, a is the GCD\n\n# Test the function with the provided example\nassert gcd(48, 18) == 6, \"Test case failed: gcd(48, 18) should be 6\"\n\n# Additional test cases\nassert gcd(56, 98) == 14, \"Test case failed: gcd(56, 98) should be 14\"\nassert gcd(101, 10) == 1, \"Test case failed: gcd(101, 10) should be 1\"\nassert gcd(0, 5) == 5, \"Test case failed: gcd(0, 5) should be 5\"\nassert gcd(5, 0) == 5, \"Test case failed: gcd(5, 0) should be 5\"\nassert gcd(0, 0) == 0, \"Test case failed: gcd(0, 0) is undefined, but we return 0\"\n\nprint(\"All test cases passed!\")", "result": "failed: invalid syntax (<string>, line 5)", "passed": false}
{"task_id": "MBPP/402", "completion": "def factorial_mod(n, p):\n    \"\"\"Compute factorial % p for all values from 0 to n.\"\"\"\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = (fact[i - 1] * i) % p\n    return fact\n\ndef mod_inverse(a, p):\n    \"\"\"Compute the modular inverse of a under modulo p using Fermat's Little Theorem.\"\"\"\n    return pow(a, p - 2, p)\n\ndef ncr_modp(n, r, p):\n    \"\"\"\n    Compute nCr % p using the formula nCr = n! / (r! * (n - r)!)\n    and modular arithmetic.\n    \n    Parameters:\n    n (int): The total number of items.\n    r (int): The number of items to choose.\n    p (int): The modulus.\n    \n    Returns:\n    int: The value of nCr % p.\n    \"\"\"\n    if r > n:\n        return 0  # nCr is 0 if r > n\n\n    # Precompute all factorials % p\n    fact = factorial_mod(n, p)\n\n    # Calculate nCr % p\n    numerator = fact[n]\n    denominator = (fact[r] * fact[n - r]) % p\n\n    # Use modular inverse to compute the result\n    result = (numerator * mod_inverse(denominator, p)) % p\n    return result\n\n# Test case\nassert ncr_modp(10, 2, 13) == 6", "result": "failed: invalid non-printable character U+00A0 (<string>, line 48)", "passed": false}
{"task_id": "MBPP/4_7", "completion": "def max_value(arr):\n    \"\"\"\n    Find the maximum value in a list of integers.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The maximum integer in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not arr:  # Check if the list is empty\n        raise ValueError(\"The list cannot be empty.\")\n    \n    max_val = arr[0]  # Initialize max_val with the first element\n    for num in arr:  # Iterate through the list\n        if num > max_val:  # Update max_val if a larger number is found\n            max_val = num\n            \n    return max_val  # Return the maximum value found\n\n# Test cases\nassert max_value([1, 2, 3, 4, 5]) == 5  # Regular case\nassert max_value([-1, -2, -3, -4, -5]) == -1  # All negative numbers\nassert max_value([5]) == 5  # Single element\nassert max_value([1, 3, 2, 5, 4]) == 5  # Unordered list\nassert max_value([0, 0, 0]) == 0  # All zeros\n\nprint(\"All test cases passed!\")", "result": "failed: invalid syntax (<string>, line 5)", "passed": false}
{"task_id": "MBPP/4_9", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    \n    :param strs: List of strings to find the common prefix from\n    :return: The longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the initial prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:  # If prefix is empty, return immediately\n                return \"\"\n    \n    return prefix\n\n# Test case\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'", "result": "failed: invalid syntax (<string>, line 5)", "passed": false}
{"task_id": "MBPP/4_8", "completion": "def longest_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    \n    :param strs: List of strings to evaluate\n    :return: The longest common prefix string, or an empty string if none exists\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the initial prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:  # If prefix is empty, return immediately\n                return \"\"\n    \n    return prefix\n\n# Test cases to validate the function\nassert longest_prefix(['flower', 'flow', 'flight']) == 'fl'\nassert longest_prefix(['dog', 'racecar', 'car']) == ''\nassert longest_prefix(['interspecies', 'interstellar', 'interstate']) == 'inter'\nassert longest_prefix(['a']) == 'a'\nassert longest_prefix([]) == ''\nassert longest_prefix(['']) == ''\nassert longest_prefix(['abc', 'ab', 'a']) == 'a'\n\nprint(\"All test cases passed!\")", "result": "failed: invalid syntax (<string>, line 6)", "passed": false}
{"task_id": "MBPP/4_2", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the initial prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:  # If prefix is empty, return immediately\n                return \"\"\n    \n    return prefix\n\n# Test case\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'", "result": "failed: invalid syntax (<string>, line 6)", "passed": false}
{"task_id": "MBPP/4_5", "completion": "def longest_common_substring(s1, s2):\n    \"\"\"\n    Find the length of the longest common substring between two strings.\n\n    Parameters:\n    s1 (str): The first string.\n    s2 (str): The second string.\n\n    Returns:\n    int: The length of the longest common substring.\n    \"\"\"\n    # Get the lengths of both strings\n    len1, len2 = len(s1), len(s2)\n    \n    # Create a 2D array to store lengths of longest common suffixes\n    # Initialize with zeros\n    dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]\n    \n    longest_length = 0  # Variable to keep track of the longest length found\n\n    # Build the dp array\n    for i in range(1, len1 + 1):\n        for j in range(1, len2 + 1):\n            if s1[i - 1] == s2[j - 1]:  # Characters match\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                longest_length = max(longest_length, dp[i][j])  # Update longest length\n            else:\n                dp[i][j] = 0  # No common substring ends here\n\n    return longest_length\n\n# Test cases\nassert longest_common_substring('abcdef', 'zcdemf') == 2  # 'cd' is the longest common substring\nassert longest_common_substring('hello', 'yell') == 2    # 'ell' is the longest common substring\nassert longest_common_substring('abc', 'def') == 0       # No common substring\nassert longest_common_substring('abcde', 'abfce') == 2    # 'ab' is the longest common substring\nassert longest_common_substring('', 'abc') == 0           # One string is empty\nassert longest_common_substring('abc', '') == 0           # One string is empty\nassert longest_common_substring('', '') == 0              # Both strings are empty\n\nprint(\"All test cases passed!\")", "result": "failed: invalid syntax (<string>, line 5)", "passed": false}
{"task_id": "MBPP/4_10", "completion": "def longest_common_subsequence(s1, s2):\n    \"\"\"\n    Find the length of the longest common subsequence of two strings.\n\n    Parameters:\n    s1 (str): The first string.\n    s2 (str): The second string.\n\n    Returns:\n    int: The length of the longest common subsequence.\n    \"\"\"\n    # Create a 2D array to store lengths of longest common subsequence.\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Build the dp array from the bottom up\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1  # Characters match\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])  # Take the max from left or above\n\n    return dp[m][n]  # The length of the longest common subsequence\n\n# Test cases to validate the function\nassert longest_common_subsequence('abcde', 'ace') == 3  # 'ace' is the LCS\nassert longest_common_subsequence('abc', 'abc') == 3    # 'abc' is the LCS\nassert longest_common_subsequence('abc', 'def') == 0     # No common subsequence\nassert longest_common_subsequence('abcde', 'abc') == 3   # 'abc' is the LCS\nassert longest_common_subsequence('', 'abc') == 0         # Empty string case\nassert longest_common_subsequence('abc', '') == 0         # Empty string case\nassert longest_common_subsequence('', '') == 0            # Both strings empty", "result": "failed: invalid syntax (<string>, line 5)", "passed": false}
