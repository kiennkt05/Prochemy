{"task_id": "auto/6", "completion": "from typing import List\n\ndef count_unique_elements(lst: List[int]) -> int:\n    \"\"\" Returns the count of unique elements in the provided list.\n    \n    >>> count_unique_elements([1, 2, 2, 3, 4])\n    4\n    >>> count_unique_elements([1, 1, 1, 1])\n    1\n    >>> count_unique_elements([])\n    0\n    >>> count_unique_elements([1, 2, 3, 4, 5])\n    5\n    >>> count_unique_elements([1, 2, 2, 3, 3, 3, 4, 4, 4, 4])\n    4\n    >>> count_unique_elements([-1, -1, 0, 1, 1])\n    3\n    >>> count_unique_elements([1, 2, 3, 4, 5, 5, 5, 5])\n    5\n    \"\"\"\n    return len(set(lst))\n\n# Running the test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "result": "passed", "passed": true}
{"task_id": "auto/0", "completion": "from typing import List\n\ndef product_of_elements(numbers: List[int]) -> int:\n    \"\"\" Calculate the product of all elements in the list.\n    \n    Args:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    int: The product of all integers in the list.\n\n    >>> product_of_elements([1, 2, 3, 4])\n    24\n    >>> product_of_elements([-1, -2, -3])\n    -6\n    >>> product_of_elements([])  # Edge case: empty list\n    1\n    >>> product_of_elements([0, 1, 2])  # Edge case: includes zero\n    0\n    >>> product_of_elements([5])  # Edge case: single element\n    5\n    >>> product_of_elements([-1, 1, -1, 1])  # Edge case: mixed signs\n    1\n    \"\"\"\n    product = 1\n    for number in numbers:\n        product *= number\n    return product\n\n# Test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "result": "passed", "passed": true}
{"task_id": "auto/4", "completion": "from typing import List\n\ndef find_duplicates(items: List[int]) -> List[int]:\n    \"\"\" Given a list of integers, return a list of duplicates (elements that appear more than once).\n    The duplicates should be returned in the order of their first occurrence in the input list.\n    \n    >>> find_duplicates([1, 2, 3, 1, 2, 4])\n    [1, 2]\n    >>> find_duplicates([5, 5, 5, 6, 7])\n    [5]\n    >>> find_duplicates([1, 2, 3, 4])\n    []\n    >>> find_duplicates([1, 1, 2, 2, 3, 3])\n    [1, 2, 3]\n    >>> find_duplicates([])\n    []\n    >>> find_duplicates([1, 2, 3, 4, 5, 6])\n    []\n    >>> find_duplicates([1, 2, 2, 1, 3, 4, 4])\n    [2, 1, 4]\n    \"\"\"\n    seen = set()\n    duplicates = []\n    \n    for item in items:\n        if item in seen:\n            if item not in duplicates:\n                duplicates.append(item)\n        else:\n            seen.add(item)\n    \n    return duplicates\n\n# Test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "result": "failed: ", "passed": false}
{"task_id": "auto/3", "completion": "from typing import Optional, List\n\ndef find_repeat(numbers: List[int]) -> Optional[int]:\n    \"\"\" Given a list of integers, return the first number that is repeated. If there are no repeats, return None.\n    \n    >>> find_repeat([1, 2, 3, 4, 5, 2])\n    2\n    >>> find_repeat([1, 2, 3, 4])\n    None\n    >>> find_repeat([1, 1, 2, 3])\n    1\n    >>> find_repeat([5, 3, 5, 2, 1])\n    5\n    >>> find_repeat([])\n    None\n    >>> find_repeat([1, 2, 3, 4, 5, 1, 2, 3])\n    1\n    >>> find_repeat([2, 2, 2, 2])\n    2\n    \"\"\"\n    seen = set()\n    for number in numbers:\n        if number in seen:\n            return number\n        seen.add(number)\n    return None\n\n# Test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "result": "passed", "passed": true}
{"task_id": "auto/5", "completion": "from typing import List\n\ndef count_occurrences(elements: List[int], target: int) -> int:\n    \"\"\" Count how many times a target integer appears in a given list of integers.\n    \n    Args:\n        elements (List[int]): A list of integers to search through.\n        target (int): The integer to count occurrences of.\n    \n    Returns:\n        int: The count of occurrences of the target integer in the list.\n    \n    Examples:\n    >>> count_occurrences([1, 2, 3, 3, 4], 3)\n    2\n    >>> count_occurrences([1, 2, 2, 2, 3, 4], 5)\n    0\n    \"\"\"\n    return elements.count(target)\n\n# Test cases\nif __name__ == \"__main__\":\n    # Basic test cases\n    assert count_occurrences([1, 2, 3, 3, 4], 3) == 2\n    assert count_occurrences([1, 2, 2, 2, 3, 4], 5) == 0\n    \n    # Additional test cases\n    assert count_occurrences([], 1) == 0  # Empty list\n    assert count_occurrences([1, 1, 1, 1], 1) == 4  # All elements are the target\n    assert count_occurrences([1, 2, 3, 4, 5], 0) == 0  # Target not in list\n    assert count_occurrences([1, 2, 3, 2, 2, 4], 2) == 3  # Multiple occurrences\n    assert count_occurrences([1, 2, 3, 4, 5], 5) == 1  # Target is the last element\n    assert count_occurrences([5, 5, 5, 5, 5], 5) == 5  # Target is the only element\n    \n    print(\"All test cases passed!\")", "result": "passed", "passed": true}
{"task_id": "auto/7", "completion": "from typing import List\n\ndef sum_integers(integers: List[int]) -> int:\n    \"\"\" Return the sum of all integers in the given list.\n    \n    >>> sum_integers([1, 2, 3])\n    6\n    >>> sum_integers([-1, -2, 3])\n    0\n    >>> sum_integers([])  # Edge case: empty list\n    0\n    >>> sum_integers([0, 0, 0])  # Edge case: list of zeros\n    0\n    >>> sum_integers([1, -1, 1, -1])  # Edge case: positive and negative cancel out\n    0\n    >>> sum_integers([100, 200, 300])  # Larger numbers\n    600\n    >>> sum_integers([-10, -20, 30, 10])  # Mixed positive and negative\n    10\n    \"\"\"\n    return sum(integers)\n\n# Test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "result": "passed", "passed": true}
{"task_id": "auto/8", "completion": "from typing import List\n\ndef unique_elements(elements: List[int]) -> List[int]:\n    \"\"\" Return a list of unique elements from the input list while maintaining their order. \n    >>> unique_elements([1, 2, 2, 3, 4, 4])\n    [1, 2, 3, 4]\n    >>> unique_elements([5, 5, 5])\n    [5]\n    >>> unique_elements([1, 2, 3, 1, 2, 3])\n    [1, 2, 3]\n    >>> unique_elements([])\n    []\n    >>> unique_elements([1])\n    [1]\n    >>> unique_elements([1, 2, 3, 2, 1, 4, 5, 4])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    seen = set()\n    unique_list = []\n    for element in elements:\n        if element not in seen:\n            seen.add(element)\n            unique_list.append(element)\n    return unique_list\n\n# Test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    # Additional test cases\n    assert unique_elements([1, 2, 2, 3, 4, 4]) == [1, 2, 3, 4]\n    assert unique_elements([5, 5, 5]) == [5]\n    assert unique_elements([1, 2, 3, 1, 2, 3]) == [1, 2, 3]\n    assert unique_elements([]) == []\n    assert unique_elements([1]) == [1]\n    assert unique_elements([1, 2, 3, 2, 1, 4, 5, 4]) == [1, 2, 3, 4, 5]\n    assert unique_elements([1, 1, 1, 1]) == [1]\n    assert unique_elements([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert unique_elements([1, 2, 2, 3, 3, 3, 4]) == [1, 2, 3, 4]\n\n    print(\"All tests passed!\")", "result": "passed", "passed": true}
{"task_id": "auto/9", "completion": "from typing import List\n\ndef remove_duplicates(elements: List[int]) -> List[int]:\n    \"\"\" Given a list of integers, return a new list that contains only unique elements.\n    \n    >>> remove_duplicates([1, 2, 2, 3, 4])\n    [1, 2, 3, 4]\n    >>> remove_duplicates([1, 1, 1, 1, 1])\n    [1]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([5, 5, 5, 6, 7, 6, 8])\n    [5, 6, 7, 8]\n    >>> remove_duplicates([10, 20, 30, 10, 20])\n    [10, 20, 30]\n    >>> remove_duplicates([-1, -1, 0, 1, 1])\n    [-1, 0, 1]\n    \"\"\"\n    return list(set(elements))\n\n# Test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    # Additional test cases\n    print(remove_duplicates([1, 2, 2, 3, 4]))  # Expected: [1, 2, 3, 4]\n    print(remove_duplicates([1, 1, 1, 1, 1]))  # Expected: [1]\n    print(remove_duplicates([]))                # Expected: []\n    print(remove_duplicates([5, 5, 5, 6, 7, 6, 8]))  # Expected: [5, 6, 7, 8]\n    print(remove_duplicates([10, 20, 30, 10, 20]))  # Expected: [10, 20, 30]\n    print(remove_duplicates([-1, -1, 0, 1, 1]))  # Expected: [-1, 0, 1]", "result": "passed", "passed": true}
{"task_id": "auto/2", "completion": "from typing import List\n\ndef merge_overlapping_intervals(intervals: List[List[int]]) -> List[List[int]]:\n    \"\"\" Given a list of intervals, merge all overlapping intervals and return the result as a new list.\n    Each interval is represented as a list of two integers [start, end].\n    \n    >>> merge_overlapping_intervals([[1,3],[2,6],[8,10],[15,18]])\n    [[1,6],[8,10],[15,18]]\n    \"\"\"\n    if not intervals:\n        return []\n\n    # Sort the intervals based on the starting times\n    intervals.sort(key=lambda x: x[0])\n    \n    merged = [intervals[0]]  # Start with the first interval\n\n    for current in intervals[1:]:\n        last_merged = merged[-1]\n        \n        # Check if there is an overlap\n        if current[0] <= last_merged[1]:  # Overlapping intervals\n            last_merged[1] = max(last_merged[1], current[1])  # Merge\n        else:\n            merged.append(current)  # No overlap, add to merged list\n\n    return merged\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test case 1: standard case with overlapping intervals\n    assert merge_overlapping_intervals([[1,3],[2,6],[8,10],[15,18]]) == [[1,6],[8,10],[15,18]]\n    \n    # Test case 2: no overlapping intervals\n    assert merge_overlapping_intervals([[1,2],[3,4],[5,6]]) == [[1,2],[3,4],[5,6]]\n    \n    # Test case 3: all intervals overlap\n    assert merge_overlapping_intervals([[1,4],[2,3],[3,5]]) == [[1,5]]\n    \n    # Test case 4: single interval\n    assert merge_overlapping_intervals([[1,2]]) == [[1,2]]\n    \n    # Test case 5: empty list\n    assert merge_overlapping_intervals([]) == []\n    \n    # Test case 6: intervals that touch but do not overlap\n    assert merge_overlapping_intervals([[1,2],[2,3],[3,4]]) == [[1,4]]\n    \n    # Test case 7: complex overlapping intervals\n    assert merge_overlapping_intervals([[1,4],[0,4]]) == [[0,4]]\n    \n    print(\"All test cases passed!\")", "result": "passed", "passed": true}
{"task_id": "auto/1", "completion": "from typing import List\n\ndef find_max_difference(numbers: List[int]) -> int:\n    \"\"\" Find the maximum difference between any two elements in the list.\n    The difference is defined as the absolute value of the subtraction of one element from another.\n    \n    >>> find_max_difference([1, 2, 3, 4, 5])\n    4\n    >>> find_max_difference([10, 20, 30, 40])\n    30\n    >>> find_max_difference([-10, -20, -30, -40])\n    30\n    >>> find_max_difference([5])\n    0\n    >>> find_max_difference([1, 1, 1, 1])\n    0\n    >>> find_max_difference([])\n    0\n    \"\"\"\n    if not numbers:\n        return 0  # Return 0 for an empty list\n    \n    max_value = max(numbers)\n    min_value = min(numbers)\n    \n    return max_value - min_value\n\n# Test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n    \n    # Additional test cases\n    assert find_max_difference([1, 2, 3, 4, 5]) == 4\n    assert find_max_difference([10, 20, 30, 40]) == 30\n    assert find_max_difference([-10, -20, -30, -40]) == 30\n    assert find_max_difference([5]) == 0\n    assert find_max_difference([1, 1, 1, 1]) == 0\n    assert find_max_difference([]) == 0\n    assert find_max_difference([1, -1, 0]) == 2\n    assert find_max_difference([100, 200, 300, 400, 500]) == 400\n    assert find_max_difference([-1, 0, 1]) == 2\n\n    print(\"All tests passed!\")", "result": "passed", "passed": true}
{"task_id": "HumanEval/10", "completion": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \"\"\"\n    # Find the longest palindromic suffix\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            # If the suffix is a palindrome, take the prefix and reverse it\n            prefix = string[:i]\n            return string + prefix[::-1]\n    return string  # If the string is empty or already a palindrome\n\n# Test cases\ndef test_make_palindrome():\n    assert make_palindrome('') == ''\n    assert make_palindrome('cat') == 'catac'\n    assert make_palindrome('cata') == 'catac'\n    assert make_palindrome('race') == 'racecar'\n    assert make_palindrome('a') == 'a'\n    assert make_palindrome('ab') == 'aba'\n    assert make_palindrome('abc') == 'abcba'\n    assert make_palindrome('abcd') == 'abcba'\n    assert make_palindrome('level') == 'level'\n    assert make_palindrome('deified') == 'deified'\n    assert make_palindrome('noon') == 'noon'\n    assert make_palindrome('abcdeedcba') == 'abcdeedcba'\n    assert make_palindrome('abcde') == 'abcdeedcba'\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_make_palindrome()", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    Calculate the number of collisions between two sets of cars\n    moving in opposite directions.\n\n    Parameters:\n    n (int): The number of cars in each direction.\n\n    Returns:\n    int: The total number of collisions.\n    \"\"\"\n    return n * n\n\n# Test cases\ndef test_car_race_collision():\n    assert car_race_collision(0) == 0, \"Test case 0 failed\"\n    assert car_race_collision(1) == 1, \"Test case 1 failed\"\n    assert car_race_collision(2) == 4, \"Test case 2 failed\"\n    assert car_race_collision(3) == 9, \"Test case 3 failed\"\n    assert car_race_collision(10) == 100, \"Test case 10 failed\"\n    assert car_race_collision(100) == 10000, \"Test case 100 failed\"\n    \n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_car_race_collision()", "result": "passed", "passed": true}
{"task_id": "HumanEval/77", "completion": "def iscube(a):\n    '''\n    Returns True if the integer a is a perfect cube, otherwise False.\n    '''\n    if a < 0:\n        # For negative numbers, we take the cube root of the absolute value\n        x = round(-(-a) ** (1/3))\n    else:\n        # For non-negative numbers, we take the cube root directly\n        x = round(a ** (1/3))\n    \n    return x ** 3 == a\n\n# Test cases\ndef test_iscube():\n    assert iscube(1) == True, \"Test case 1 failed\"\n    assert iscube(2) == False, \"Test case 2 failed\"\n    assert iscube(-1) == True, \"Test case 3 failed\"\n    assert iscube(64) == True, \"Test case 4 failed\"\n    assert iscube(0) == True, \"Test case 5 failed\"\n    assert iscube(180) == False, \"Test case 6 failed\"\n    assert iscube(-8) == True, \"Test case 7 failed\"\n    assert iscube(27) == True, \"Test case 8 failed\"\n    assert iscube(-27) == True, \"Test case 9 failed\"\n    assert iscube(1000) == True, \"Test case 10 failed\"\n    assert iscube(-1000) == True, \"Test case 11 failed\"\n    \n    print(\"All test cases passed!\")\n\n# Run the tests\ntest_iscube()", "result": "passed", "passed": true}
{"task_id": "HumanEval/65", "completion": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    \n    >>> circular_shift(12, 1)\n    '21'\n    >>> circular_shift(12, 2)\n    '12'\n    >>> circular_shift(12345, 1)\n    '51234'\n    >>> circular_shift(12345, 2)\n    '45123'\n    >>> circular_shift(12345, 5)\n    '54321'\n    >>> circular_shift(12345, 6)\n    '54321'\n    >>> circular_shift(0, 1)\n    '0'\n    >>> circular_shift(7, 3)\n    '7'\n    \"\"\"\n    # Convert the integer to a string to manipulate the digits\n    str_x = str(x)\n    length = len(str_x)\n    \n    # If shift is greater than the number of digits, reverse the string\n    if shift >= length:\n        return str_x[::-1]\n    \n    # Perform the circular shift\n    shift = shift % length  # Handle cases where shift is larger than length\n    return str_x[-shift:] + str_x[:-shift]\n\n# Test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/32", "completion": "import math\nfrom scipy.optimize import fsolve\n\ndef poly(xs: list, x: float) -> float:\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum(coeff * math.pow(x, i) for i, coeff in enumerate(xs))\n\ndef find_zero(xs: list) -> float:\n    \"\"\" \n    Find x such that poly(x) = 0.\n    Returns only one zero point, even if there are many.\n    The input list xs must have an even number of coefficients.\n    \"\"\"\n    if len(xs) % 2 != 0:\n        raise ValueError(\"The list of coefficients must have an even number of elements.\")\n    \n    # Define a function that we want to find the root for\n    def func(x):\n        return poly(xs, x)\n    \n    # Use fsolve to find the root, starting from an initial guess\n    root = fsolve(func, 0)[0]  # Start searching from x = 0\n    return root\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test case 1: Simple linear polynomial\n    print(round(find_zero([1, 2]), 2))  # Expected output: -0.5\n\n    # Test case 2: Cubic polynomial with known roots\n    print(round(find_zero([-6, 11, -6, 1]), 2))  # Expected output: 1.0\n\n    # Test case 3: Quadratic polynomial with a double root\n    print(round(find_zero([1, -2, 1]), 2))  # Expected output: 1.0\n\n    # Test case 4: Higher degree polynomial\n    print(round(find_zero([1, 0, -4]), 2))  # Expected output: 2.0\n\n    # Test case 5: Polynomial with complex roots (should still find a real root)\n    print(round(find_zero([1, 0, 1]), 2))  # Expected output: 0.0 (since x^2 + 1 = 0 has no real roots, but we can find a root near 0)\n\n    # Test case 6: Edge case with a zero polynomial\n    try:\n        print(find_zero([0, 0, 0, 0]))  # Should raise an error or return 0\n    except Exception as e:\n        print(e)  # Expected to catch an error", "result": "failed: No module named 'scipy'", "passed": false}
{"task_id": "HumanEval/84", "completion": "def solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n    # Calculate the sum of the digits\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to binary and remove the '0b' prefix\n    binary_sum = bin(digit_sum)[2:]\n    \n    return binary_sum\n\n# Test cases to validate the functionality\ndef test_solve():\n    assert solve(1000) == \"1\", \"Test case 1 failed\"\n    assert solve(150) == \"110\", \"Test case 2 failed\"\n    assert solve(147) == \"1100\", \"Test case 3 failed\"\n    assert solve(0) == \"0\", \"Test case 4 failed\"  # Edge case: sum of digits is 0\n    assert solve(9999) == \"36\", \"Test case 5 failed\"  # 9+9+9+9 = 36, binary is 100100\n    assert solve(1234) == \"11\", \"Test case 6 failed\"  # 1+2+3+4 = 10, binary is 1010\n    assert solve(10000) == \"1\", \"Test case 7 failed\"  # 1+0+0+0+0 = 1, binary is 1\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_solve()", "result": "failed: Test case 5 failed", "passed": false}
{"task_id": "HumanEval/75", "completion": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef generate_primes(limit):\n    \"\"\"Generate a list of prime numbers less than the given limit.\"\"\"\n    return [num for num in range(2, limit) if is_prime(num)]\n\ndef is_multiply_prime(a):\n    \"\"\"Return True if the given number is the multiplication of 3 prime numbers, False otherwise.\"\"\"\n    if a < 1 or a >= 100:\n        return False\n    \n    primes = generate_primes(100)\n    \n    # Check all combinations of three primes\n    from itertools import combinations\n    for p1, p2, p3 in combinations(primes, 3):\n        if p1 * p2 * p3 == a:\n            return True\n            \n    return False\n\n# Test cases\ndef test_is_multiply_prime():\n    assert is_multiply_prime(30) == True  # 2 * 3 * 5\n    assert is_multiply_prime(60) == True  # 2 * 3 * 10 (10 is not prime, so False)\n    assert is_multiply_prime(42) == True  # 2 * 3 * 7\n    assert is_multiply_prime(70) == True  # 2 * 5 * 7\n    assert is_multiply_prime(1) == False   # No product of primes\n    assert is_multiply_prime(2) == False   # Only one prime\n    assert is_multiply_prime(3) == False   # Only one prime\n    assert is_multiply_prime(4) == False   # 2 * 2 (not three distinct primes)\n    assert is_multiply_prime(105) == False  # 3 * 5 * 7 (not less than 100)\n    assert is_multiply_prime(99) == False   # 3 * 3 * 11 (not distinct)\n    assert is_multiply_prime(77) == False   # 7 * 11 (not three primes)\n    \n    print(\"All test cases passed!\")\n\n# Run the tests\ntest_is_multiply_prime()", "result": "failed: ", "passed": false}
{"task_id": "HumanEval/93", "completion": "def encode(message):\n    \"\"\"\n    Encodes the message by swapping case of all letters and replacing\n    all vowels with the letter that appears 2 places ahead in the English alphabet.\n    \n    Args:\n    message (str): The input message to encode.\n    \n    Returns:\n    str: The encoded message.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    encoded_message = []\n    \n    for char in message:\n        if char.isalpha():  # Check if the character is a letter\n            # Swap case\n            if char in vowels:\n                # Replace vowel with the letter 2 places ahead\n                if char.islower():\n                    new_char = chr(((ord(char) - ord('a') + 2) % 26) + ord('a'))\n                else:\n                    new_char = chr(((ord(char) - ord('A') + 2) % 26) + ord('A'))\n            else:\n                new_char = char.swapcase()\n            encoded_message.append(new_char)\n        else:\n            encoded_message.append(char)  # Non-letter characters remain unchanged\n    \n    return ''.join(encoded_message)\n\n# Test cases\ndef test_encode():\n    assert encode('test') == 'TGST', \"Test case 1 failed\"\n    assert encode('This is a message') == 'tHKS KS C MGSSCGG', \"Test case 2 failed\"\n    assert encode('Hello World') == 'hEllO WOrLD', \"Test case 3 failed\"\n    assert encode('Python Programming') == 'pYTHOn prOGrAMMIng', \"Test case 4 failed\"\n    assert encode('aeiou') == 'cGQW', \"Test case 5 failed\"\n    assert encode('AEIOU') == 'cGQW', \"Test case 6 failed\"\n    assert encode('') == '', \"Test case 7 failed\"\n    assert encode('1234') == '1234', \"Test case 8 failed\"\n    assert encode('!@#$%^&*()') == '!@#$%^&*()', \"Test case 9 failed\"\n    \n    print(\"All test cases passed!\")\n\n# Run the tests\ntest_encode()", "result": "failed: Test case 1 failed", "passed": false}
{"task_id": "HumanEval/94", "completion": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sum_of_digits(n):\n    \"\"\"Return the sum of the digits of a number.\"\"\"\n    return sum(int(digit) for digit in str(n))\n\ndef skjkasdkd(lst):\n    \"\"\"Find the largest prime value in the list and return the sum of its digits.\"\"\"\n    largest_prime = -1\n    \n    for number in lst:\n        if is_prime(number) and number > largest_prime:\n            largest_prime = number\n            \n    if largest_prime == -1:\n        return 0  # Return 0 if no prime number is found\n    \n    return sum_of_digits(largest_prime)\n\n# Test cases\ndef test_skjkasdkd():\n    assert skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]) == 10\n    assert skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) == 25\n    assert skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]) == 13\n    assert skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) == 11\n    assert skjkasdkd([0, 81, 12, 3, 1, 21]) == 3\n    assert skjkasdkd([0, 8, 1, 2, 1, 7]) == 7\n    assert skjkasdkd([4, 6, 8, 10]) == 0  # No prime numbers\n    assert skjkasdkd([]) == 0  # Empty list\n\n# Run the tests\ntest_skjkasdkd()\nprint(\"All tests passed!\")", "result": "passed", "passed": true}
{"task_id": "HumanEval/83", "completion": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    if n < 1:\n        return 0  # No n-digit numbers if n is less than 1\n\n    count_starting_with_1 = 10**(n - 1)  # n-digit numbers starting with '1'\n    count_ending_with_1 = 9 * 10**(n - 2) if n > 1 else 1  # n-digit numbers ending with '1'\n    count_both_starting_and_ending_with_1 = 10**(n - 2) if n > 1 else 0  # n-digit numbers starting and ending with '1'\n\n    total_count = (count_starting_with_1 + count_ending_with_1 - count_both_starting_and_ending_with_1)\n    return total_count\n\n# Test cases\ndef test_starts_one_ends():\n    assert starts_one_ends(1) == 1  # Only the number '1'\n    assert starts_one_ends(2) == 18  # 10-19 (10) + 1, 21, ..., 91 (9)\n    assert starts_one_ends(3) == 180  # 100-199 (100) + 101, 111, ..., 191 (10) + 201, ..., 901 (90)\n    assert starts_one_ends(4) == 1800  # 1000-1999 (1000) + 1001, 1011, ..., 1991 (100) + 2001, ..., 9001 (900)\n    assert starts_one_ends(5) == 18000  # 10000-19999 (10000) + 10001, ..., 19991 (1000) + 20001, ..., 90001 (9000)\n    assert starts_one_ends(6) == 180000  # 100000-199999 (100000) + 100001, ..., 199991 (10000) + 200001, ..., 900001 (90000)\n\n    print(\"All test cases passed!\")\n\n# Run the tests\ntest_starts_one_ends()", "result": "failed: ", "passed": false}
