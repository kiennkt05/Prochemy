{"task_id": "auto/7", "completion": "from typing import List\n\ndef sum_integers(integers: List[int]) -> int:\n    \"\"\" Return the sum of all integers in the given list.\n    \n    Args:\n        integers (List[int]): A list of integers to be summed.\n        \n    Returns:\n        int: The sum of the integers in the list.\n    \n    Examples:\n        >>> sum_integers([1, 2, 3])\n        6\n        >>> sum_integers([-1, -2, 3])\n        0\n    \"\"\"\n    # Initialize a variable to hold the sum\n    total_sum = 0\n    \n    # Iterate through each integer in the list and add it to total_sum\n    for number in integers:\n        total_sum += number\n    \n    return total_sum\n\n# Example test cases\nif __name__ == \"__main__\":\n    print(sum_integers([1, 2, 3]))  # Output: 6\n    print(sum_integers([-1, -2, 3]))  # Output: 0"}
{"task_id": "auto/0", "completion": "from typing import List\n\ndef product_of_elements(numbers: List[int]) -> int:\n    \"\"\" Calculate the product of all elements in the list.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n        \n    Returns:\n        int: The product of all integers in the list.\n        \n    Examples:\n    >>> product_of_elements([1, 2, 3, 4])\n    24\n    >>> product_of_elements([-1, -2, -3])\n    -6\n    >>> product_of_elements([])  # Edge case: empty list\n    1\n    >>> product_of_elements([0, 1, 2])  # Edge case: includes zero\n    0\n    >>> product_of_elements([5])  # Edge case: single element\n    5\n    \"\"\"\n    # Initialize the product to 1 (multiplicative identity)\n    product = 1\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        product *= number  # Multiply the current product by the number\n    \n    return product  # Return the final product"}
{"task_id": "auto/6", "completion": "from typing import List\n\ndef count_unique_elements(lst: List[int]) -> int:\n    \"\"\" Returns the count of unique elements in the provided list.\n    \n    Args:\n        lst (List[int]): A list of integers.\n        \n    Returns:\n        int: The count of unique integers in the list.\n    \n    Examples:\n        >>> count_unique_elements([1, 2, 2, 3, 4])\n        4\n        >>> count_unique_elements([1, 1, 1, 1])\n        1\n    \"\"\"\n    # Convert the list to a set to filter out duplicate elements\n    unique_elements = set(lst)\n    \n    # Return the number of unique elements\n    return len(unique_elements)\n\n# Example test cases\nif __name__ == \"__main__\":\n    print(count_unique_elements([1, 2, 2, 3, 4]))  # Output: 4\n    print(count_unique_elements([1, 1, 1, 1]))      # Output: 1\n    print(count_unique_elements([]))                  # Output: 0 (edge case: empty list)\n    print(count_unique_elements([5, 5, 5, 5, 6, 7])) # Output: 3 (edge case: multiple duplicates)"}
{"task_id": "auto/9", "completion": "from typing import List\n\ndef remove_duplicates(elements: List[int]) -> List[int]:\n    \"\"\" Given a list of integers, return a new list that contains only unique elements.\n    \n    Args:\n        elements (List[int]): A list of integers which may contain duplicates.\n        \n    Returns:\n        List[int]: A new list containing only unique integers, in the order of their first appearance.\n    \n    Examples:\n        >>> remove_duplicates([1, 2, 2, 3, 4])\n        [1, 2, 3, 4]\n        >>> remove_duplicates([1, 1, 1, 1, 1])\n        [1]\n    \"\"\"\n    seen = set()  # A set to track seen elements\n    unique_elements = []  # A list to store unique elements\n\n    for element in elements:\n        if element not in seen:  # Check if the element has not been seen before\n            seen.add(element)  # Add the element to the seen set\n            unique_elements.append(element)  # Append the unique element to the result list\n\n    return unique_elements  # Return the list of unique elements"}
{"task_id": "auto/3", "completion": "from typing import Optional, List\n\ndef find_repeat(numbers: List[int]) -> Optional[int]:\n    \"\"\" Given a list of integers, return the first number that is repeated. If there are no repeats, return None.\n    \n    >>> find_repeat([1, 2, 3, 4, 5, 2])\n    2\n    >>> find_repeat([1, 2, 3, 4])\n    None\n    \"\"\"\n    seen = set()  # A set to keep track of seen numbers\n    for number in numbers:\n        if number in seen:\n            return number  # Return the first repeated number\n        seen.add(number)  # Add the number to the set if it's not seen yet\n    return None  # Return None if no repeats are found\n\n# Example usage\nif __name__ == \"__main__\":\n    print(find_repeat([1, 2, 3, 4, 5, 2]))  # Output: 2\n    print(find_repeat([1, 2, 3, 4]))         # Output: None"}
{"task_id": "auto/1", "completion": "from typing import List\n\ndef find_max_difference(numbers: List[int]) -> int:\n    \"\"\" Find the maximum difference between any two elements in the list.\n    The difference is defined as the absolute value of the subtraction of one element from another.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n        \n    Returns:\n        int: The maximum difference between any two elements in the list.\n        \n    Raises:\n        ValueError: If the list is empty.\n        \n    Examples:\n        >>> find_max_difference([1, 2, 3, 4, 5])\n        4\n        >>> find_max_difference([10, 20, 30, 40])\n        30\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list must not be empty.\")\n    \n    # Find the maximum and minimum values in the list\n    max_value = max(numbers)\n    min_value = min(numbers)\n    \n    # Calculate the maximum difference\n    max_difference = max_value - min_value\n    \n    return max_difference\n\n# Example usage\nif __name__ == \"__main__\":\n    print(find_max_difference([1, 2, 3, 4, 5]))  # Output: 4\n    print(find_max_difference([10, 20, 30, 40]))  # Output: 30"}
{"task_id": "auto/5", "completion": "from typing import List\n\ndef count_occurrences(elements: List[int], target: int) -> int:\n    \"\"\" Count how many times a target integer appears in a given list of integers.\n    \n    Args:\n        elements (List[int]): A list of integers to search through.\n        target (int): The integer to count occurrences of.\n    \n    Returns:\n        int: The number of times the target integer appears in the list.\n    \n    Examples:\n        >>> count_occurrences([1, 2, 3, 3, 4], 3)\n        2\n        >>> count_occurrences([1, 2, 2, 2, 3, 4], 5)\n        0\n    \"\"\"\n    # Use the list's count method to find the number of occurrences of target\n    return elements.count(target)\n\n# Example test cases\nif __name__ == \"__main__\":\n    print(count_occurrences([1, 2, 3, 3, 4], 3))  # Output: 2\n    print(count_occurrences([1, 2, 2, 2, 3, 4], 5))  # Output: 0"}
{"task_id": "auto/4", "completion": "from typing import List\n\ndef find_duplicates(items: List[int]) -> List[int]:\n    \"\"\" Given a list of integers, return a list of duplicates (elements that appear more than once).\n    The duplicates should be returned in the order of their first occurrence in the input list.\n    \n    >>> find_duplicates([1, 2, 3, 1, 2, 4])\n    [1, 2]\n    >>> find_duplicates([5, 5, 5, 6, 7])\n    [5]\n    >>> find_duplicates([1, 2, 3, 4])\n    []\n    >>> find_duplicates([])\n    []\n    \"\"\"\n    seen = set()          # Set to track seen items\n    duplicates = set()    # Set to track duplicates\n    result = []           # List to maintain the order of duplicates\n\n    for item in items:\n        if item in seen:\n            if item not in duplicates:\n                duplicates.add(item)  # Add to duplicates if it's the first time we see it again\n                result.append(item)    # Maintain the order of first occurrence\n        else:\n            seen.add(item)            # Add to seen if it's the first time we see it\n\n    return result\n\n# Example usage\nif __name__ == \"__main__\":\n    print(find_duplicates([1, 2, 3, 1, 2, 4]))  # Output: [1, 2]\n    print(find_duplicates([5, 5, 5, 6, 7]))      # Output: [5]\n    print(find_duplicates([1, 2, 3, 4]))          # Output: []\n    print(find_duplicates([]))                      # Output: []"}
{"task_id": "auto/8", "completion": "from typing import List\n\ndef unique_elements(elements: List[int]) -> List[int]:\n    \"\"\" Return a list of unique elements from the input list while maintaining their order.\n    \n    This function iterates through the input list and uses a set to track elements that have \n    already been added to the result list. If an element is encountered for the first time, \n    it is appended to the result list.\n    \n    Args:\n        elements (List[int]): A list of integers which may contain duplicates.\n        \n    Returns:\n        List[int]: A list of unique integers in the order they first appeared in the input list.\n    \n    Examples:\n    >>> unique_elements([1, 2, 2, 3, 4, 4])\n    [1, 2, 3, 4]\n    >>> unique_elements([5, 5, 5])\n    [5]\n    \"\"\"\n    seen = set()  # Set to track seen elements\n    unique_list = []  # List to store unique elements\n    \n    for element in elements:\n        if element not in seen:  # Check if the element has been seen\n            seen.add(element)  # Mark the element as seen\n            unique_list.append(element)  # Add to the unique list\n    \n    return unique_list  # Return the list of unique elements"}
{"task_id": "auto/2", "completion": "from typing import List\n\ndef merge_overlapping_intervals(intervals: List[List[int]]) -> List[List[int]]:\n    \"\"\" Given a list of intervals, merge all overlapping intervals and return the result as a new list.\n    Each interval is represented as a list of two integers [start, end].\n    \n    >>> merge_overlapping_intervals([[1,3],[2,6],[8,10],[15,18]])\n    [[1,6],[8,10],[15,18]]\n    \"\"\"\n    # If the input list is empty, return an empty list\n    if not intervals:\n        return []\n    \n    # Step 1: Sort the intervals based on the starting times\n    intervals.sort(key=lambda x: x[0])\n    \n    # Step 2: Initialize a list to hold the merged intervals\n    merged = []\n    \n    # Start with the first interval\n    current_interval = intervals[0]\n    \n    for i in range(1, len(intervals)):\n        # If the current interval overlaps with the next one\n        if intervals[i][0] <= current_interval[1]:\n            # Merge them by updating the end of the current interval\n            current_interval[1] = max(current_interval[1], intervals[i][1])\n        else:\n            # No overlap, add the current interval to the merged list\n            merged.append(current_interval)\n            # Move to the next interval\n            current_interval = intervals[i]\n    \n    # Add the last interval after the loop\n    merged.append(current_interval)\n    \n    return merged\n\n# Example usage\nif __name__ == \"__main__\":\n    print(merge_overlapping_intervals([[1,3],[2,6],[8,10],[15,18]]))  # Output: [[1, 6], [8, 10], [15, 18]]"}
