{"task_id": "auto/5", "completion": "from typing import List\n\ndef count_occurrences(elements: List[int], target: int) -> int:\n    \"\"\" Count how many times a target integer appears in a given list of integers.\n    \n    Args:\n        elements (List[int]): A list of integers to search through.\n        target (int): The integer to count occurrences of.\n        \n    Returns:\n        int: The count of occurrences of the target integer in the list.\n    \n    Examples:\n        >>> count_occurrences([1, 2, 3, 3, 4], 3)\n        2\n        >>> count_occurrences([1, 2, 2, 2, 3, 4], 5)\n        0\n    \"\"\"\n    count = 0  # Initialize a counter for occurrences\n    for element in elements:  # Iterate through each element in the list\n        if element == target:  # Check if the current element matches the target\n            count += 1  # Increment the counter if a match is found\n    return count  # Return the total count of occurrences", "result": "passed", "passed": true}
{"task_id": "auto/7", "completion": "from typing import List\n\ndef sum_integers(integers: List[int]) -> int:\n    \"\"\" Return the sum of all integers in the given list.\n    \n    Args:\n        integers (List[int]): A list of integers to be summed.\n        \n    Returns:\n        int: The sum of the integers in the list.\n    \n    Examples:\n        >>> sum_integers([1, 2, 3])\n        6\n        >>> sum_integers([-1, -2, 3])\n        0\n    \"\"\"\n    # Initialize a variable to hold the sum\n    total_sum = 0\n    \n    # Iterate through each integer in the list and add it to total_sum\n    for number in integers:\n        total_sum += number\n    \n    return total_sum\n\n# If you want to run the examples as tests, you can uncomment the following lines:\n# if __name__ == \"__main__\":\n#     import doctest\n#     doctest.testmod()", "result": "passed", "passed": true}
{"task_id": "auto/1", "completion": "from typing import List\n\ndef find_max_difference(numbers: List[int]) -> int:\n    \"\"\" Find the maximum difference between any two elements in the list.\n    The difference is defined as the absolute value of the subtraction of one element from another.\n    \n    This function calculates the maximum difference by finding the maximum and minimum values in the list.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n        \n    Returns:\n        int: The maximum difference between any two elements in the list.\n        \n    Examples:\n        >>> find_max_difference([1, 2, 3, 4, 5])\n        4\n        >>> find_max_difference([10, 20, 30, 40])\n        30\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        raise ValueError(\"The list must contain at least one element.\")\n    \n    max_value = max(numbers)  # Find the maximum value in the list\n    min_value = min(numbers)  # Find the minimum value in the list\n    \n    return max_value - min_value  # Return the difference\n\n# Example test cases\nif __name__ == \"__main__\":\n    print(find_max_difference([1, 2, 3, 4, 5]))  # Output: 4\n    print(find_max_difference([10, 20, 30, 40]))  # Output: 30", "result": "failed: The list must contain at least one element.", "passed": false}
{"task_id": "auto/2", "completion": "from typing import List\n\ndef merge_overlapping_intervals(intervals: List[List[int]]) -> List[List[int]]:\n    \"\"\" Given a list of intervals, merge all overlapping intervals and return the result as a new list.\n    Each interval is represented as a list of two integers [start, end].\n    \n    >>> merge_overlapping_intervals([[1,3],[2,6],[8,10],[15,18]])\n    [[1,6],[8,10],[15,18]]\n    \"\"\"\n    if not intervals:\n        return []\n\n    # Step 1: Sort the intervals based on the starting values\n    intervals.sort(key=lambda x: x[0])\n    \n    merged = [intervals[0]]  # Start with the first interval\n\n    # Step 2: Iterate through the sorted intervals\n    for current in intervals[1:]:\n        last_merged = merged[-1]\n        \n        # Check if there is an overlap\n        if current[0] <= last_merged[1]:  # Overlapping intervals\n            # Merge the current interval with the last merged interval\n            last_merged[1] = max(last_merged[1], current[1])\n        else:\n            # No overlap, add the current interval to merged\n            merged.append(current)\n\n    return merged\n\n# Example usage\nif __name__ == \"__main__\":\n    print(merge_overlapping_intervals([[1,3],[2,6],[8,10],[15,18]]))  # Output: [[1, 6], [8, 10], [15, 18]]", "result": "passed", "passed": true}
{"task_id": "auto/6", "completion": "from typing import List\n\ndef count_unique_elements(lst: List[int]) -> int:\n    \"\"\" Returns the count of unique elements in the provided list.\n    \n    Args:\n        lst (List[int]): A list of integers.\n        \n    Returns:\n        int: The count of unique elements in the list.\n    \n    Examples:\n        >>> count_unique_elements([1, 2, 2, 3, 4])\n        4\n        >>> count_unique_elements([1, 1, 1, 1])\n        1\n    \"\"\"\n    # Convert the list to a set to filter out duplicate elements\n    unique_elements = set(lst)\n    \n    # Return the number of unique elements\n    return len(unique_elements)\n\n# Test cases to validate the function\nif __name__ == \"__main__\":\n    print(count_unique_elements([1, 2, 2, 3, 4]))  # Output: 4\n    print(count_unique_elements([1, 1, 1, 1]))      # Output: 1\n    print(count_unique_elements([]))                  # Output: 0\n    print(count_unique_elements([5, 5, 5, 5, 6, 7])) # Output: 3", "result": "passed", "passed": true}
{"task_id": "auto/9", "completion": "from typing import List\n\ndef remove_duplicates(elements: List[int]) -> List[int]:\n    \"\"\" Given a list of integers, return a new list that contains only unique elements.\n    \n    Args:\n        elements (List[int]): A list of integers which may contain duplicates.\n        \n    Returns:\n        List[int]: A new list containing only unique integers in the order of their first appearance.\n    \n    Examples:\n    >>> remove_duplicates([1, 2, 2, 3, 4])\n    [1, 2, 3, 4]\n    >>> remove_duplicates([1, 1, 1, 1, 1])\n    [1]\n    >>> remove_duplicates([5, 3, 5, 2, 3, 1])\n    [5, 3, 2, 1]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([10, 20, 10, 30, 20, 40])\n    [10, 20, 30, 40]\n    \"\"\"\n    seen = set()  # Set to track seen elements\n    unique_elements = []  # List to store unique elements\n\n    for element in elements:\n        if element not in seen:  # Check if the element is already seen\n            seen.add(element)  # Add to seen set\n            unique_elements.append(element)  # Append to the unique list\n\n    return unique_elements  # Return the list of unique elements", "result": "failed: ", "passed": false}
{"task_id": "auto/3", "completion": "from typing import Optional, List\n\ndef find_repeat(numbers: List[int]) -> Optional[int]:\n    \"\"\" Given a list of integers, return the first number that is repeated.\n    If there are no repeats, return None.\n    \n    >>> find_repeat([1, 2, 3, 4, 5, 2])\n    2\n    >>> find_repeat([1, 2, 3, 4])\n    None\n    \"\"\"\n    seen = set()  # A set to keep track of seen numbers\n    for number in numbers:\n        if number in seen:\n            return number  # Return the first repeated number\n        seen.add(number)  # Add the number to the set if not seen\n    return None  # Return None if no repeats are found", "result": "passed", "passed": true}
{"task_id": "auto/0", "completion": "from typing import List\n\ndef product_of_elements(numbers: List[int]) -> int:\n    \"\"\" Calculate the product of all elements in the list.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n        \n    Returns:\n        int: The product of all integers in the list.\n        \n    Examples:\n    >>> product_of_elements([1, 2, 3, 4])\n    24\n    >>> product_of_elements([-1, -2, -3])\n    -6\n    >>> product_of_elements([])  # Edge case: empty list\n    1\n    >>> product_of_elements([0, 1, 2])  # Edge case: includes zero\n    0\n    >>> product_of_elements([5])  # Edge case: single element\n    5\n    \"\"\"\n    # Initialize the product to 1 (multiplicative identity)\n    product = 1\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        product *= number  # Multiply the current product by the number\n    \n    return product  # Return the final product", "result": "passed", "passed": true}
{"task_id": "auto/4", "completion": "from typing import List\n\ndef find_duplicates(items: List[int]) -> List[int]:\n    \"\"\" Given a list of integers, return a list of duplicates (elements that appear more than once).\n    The duplicates should be returned in the order of their first occurrence in the input list.\n    \n    >>> find_duplicates([1, 2, 3, 1, 2, 4])\n    [1, 2]\n    >>> find_duplicates([5, 5, 5, 6, 7])\n    [5]\n    >>> find_duplicates([1, 2, 3, 4])\n    []\n    >>> find_duplicates([1, 2, 2, 3, 3, 3, 4])\n    [2, 3]\n    \"\"\"\n    seen = set()  # To track seen items\n    duplicates = []  # To store duplicates in order of first occurrence\n    \n    for item in items:\n        if item in seen:\n            if item not in duplicates:\n                duplicates.append(item)  # Add to duplicates if not already present\n        else:\n            seen.add(item)  # Mark the item as seen\n    \n    return duplicates", "result": "failed: ", "passed": false}
{"task_id": "auto/8", "completion": "from typing import List\n\ndef unique_elements(elements: List[int]) -> List[int]:\n    \"\"\" Return a list of unique elements from the input list while maintaining their order.\n    \n    Args:\n        elements (List[int]): A list of integers which may contain duplicates.\n    \n    Returns:\n        List[int]: A list of unique integers in the order they first appeared in the input list.\n    \n    Examples:\n        >>> unique_elements([1, 2, 2, 3, 4, 4])\n        [1, 2, 3, 4]\n        >>> unique_elements([5, 5, 5])\n        [5]\n        >>> unique_elements([1, 2, 3, 1, 2, 3])\n        [1, 2, 3]\n    \"\"\"\n    seen = set()  # A set to track seen elements\n    unique_list = []  # A list to store unique elements\n\n    for element in elements:\n        if element not in seen:  # Check if the element has not been seen\n            seen.add(element)  # Add the element to the seen set\n            unique_list.append(element)  # Append the unique element to the result list\n\n    return unique_list  # Return the list of unique elements\n\n# Test cases\nif __name__ == \"__main__\":\n    print(unique_elements([1, 2, 2, 3, 4, 4]))  # Output: [1, 2, 3, 4]\n    print(unique_elements([5, 5, 5]))            # Output: [5]\n    print(unique_elements([1, 2, 3, 1, 2, 3]))  # Output: [1, 2, 3]\n    print(unique_elements([]))                    # Output: []\n    print(unique_elements([1, 2, 3, 4, 5]))      # Output: [1, 2, 3, 4, 5]", "result": "passed", "passed": true}
