{"task_id": "auto/0", "completion": "from typing import List\n\ndef product_of_elements(numbers: List[int]) -> int:\n    \"\"\" Calculate the product of all elements in the list.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n    \n    Returns:\n        int: The product of all integers in the list.\n    \n    Examples:\n    >>> product_of_elements([1, 2, 3, 4])\n    24\n    >>> product_of_elements([-1, -2, -3])\n    -6\n    >>> product_of_elements([0, 1, 2, 3])\n    0\n    >>> product_of_elements([1, 2, 0, 4])\n    0\n    >>> product_of_elements([])\n    1  # Product of an empty list is defined as 1\n    \"\"\"\n    # Initialize product to 1\n    product = 1\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        product *= number  # Multiply the current number to the product\n    \n    return product  # Return the final product\n\n# Test cases to validate the function\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "auto/5", "completion": "from typing import List\n\ndef count_occurrences(elements: List[int], target: int) -> int:\n    \"\"\" Count how many times a target integer appears in a given list of integers.\n    \n    Args:\n        elements (List[int]): A list of integers to search through.\n        target (int): The integer to count occurrences of.\n    \n    Returns:\n        int: The count of occurrences of the target integer in the list.\n    \n    Examples:\n    >>> count_occurrences([1, 2, 3, 3, 4], 3)\n    2\n    >>> count_occurrences([1, 2, 2, 2, 3, 4], 5)\n    0\n    >>> count_occurrences([], 1)\n    0\n    >>> count_occurrences([1, 1, 1, 1], 1)\n    4\n    >>> count_occurrences([1, 2, 3, 4, 5], 6)\n    0\n    \"\"\"\n    count = 0  # Initialize a counter for occurrences\n    for element in elements:  # Iterate through each element in the list\n        if element == target:  # Check if the current element matches the target\n            count += 1  # Increment the count if a match is found\n    return count  # Return the total count of occurrences\n\n# Test cases to validate the function\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()  # Run the embedded tests in the docstring"}
{"task_id": "auto/9", "completion": "from typing import List\n\ndef remove_duplicates(elements: List[int]) -> List[int]:\n    \"\"\" Given a list of integers, return a new list that contains only unique elements.\n    \n    This function preserves the order of the first occurrence of each unique element.\n    \n    Args:\n        elements (List[int]): A list of integers which may contain duplicates.\n        \n    Returns:\n        List[int]: A new list containing only unique integers from the input list.\n    \n    Examples:\n    >>> remove_duplicates([1, 2, 2, 3, 4])\n    [1, 2, 3, 4]\n    >>> remove_duplicates([1, 1, 1, 1, 1])\n    [1]\n    >>> remove_duplicates([5, 3, 5, 2, 3, 1])\n    [5, 3, 2, 1]\n    >>> remove_duplicates([])\n    []\n    \"\"\"\n    unique_elements = []\n    seen = set()\n    \n    for element in elements:\n        if element not in seen:\n            seen.add(element)  # Add to the set of seen elements\n            unique_elements.append(element)  # Append to the result list\n    \n    return unique_elements\n\n# Test cases to validate the function\nif __name__ == \"__main__\":\n    # Running the provided test cases\n    assert remove_duplicates([1, 2, 2, 3, 4]) == [1, 2, 3, 4]\n    assert remove_duplicates([1, 1, 1, 1, 1]) == [1]\n    assert remove_duplicates([5, 3, 5, 2, 3, 1]) == [5, 3, 2, 1]\n    assert remove_duplicates([]) == []\n    \n    print(\"All test cases passed!\")"}
{"task_id": "auto/7", "completion": "from typing import List\n\ndef sum_integers(integers: List[int]) -> int:\n    \"\"\" Return the sum of all integers in the given list.\n    \n    Args:\n        integers (List[int]): A list of integers to sum up.\n    \n    Returns:\n        int: The sum of the integers in the list.\n    \n    Examples:\n    >>> sum_integers([1, 2, 3])\n    6\n    >>> sum_integers([-1, -2, 3])\n    0\n    \"\"\"\n    total = 0  # Initialize a variable to hold the sum\n    for number in integers:  # Iterate through each integer in the list\n        total += number  # Add the current integer to the total\n    return total  # Return the final sum\n\n# Test cases to validate the function\nif __name__ == \"__main__\":\n    # Running the test cases\n    assert sum_integers([1, 2, 3]) == 6, \"Test case 1 failed\"\n    assert sum_integers([-1, -2, 3]) == 0, \"Test case 2 failed\"\n    assert sum_integers([]) == 0, \"Test case 3 failed\"  # Edge case: empty list\n    assert sum_integers([10, -10, 5]) == 5, \"Test case 4 failed\"  # Mixed positive and negative\n    assert sum_integers([100, 200, 300]) == 600, \"Test case 5 failed\"  # All positive\n\n    print(\"All test cases passed!\")"}
{"task_id": "auto/6", "completion": "from typing import List\n\ndef count_unique_elements(lst: List[int]) -> int:\n    \"\"\" Returns the count of unique elements in the provided list.\n    \n    Args:\n        lst (List[int]): A list of integers.\n        \n    Returns:\n        int: The count of unique integers in the list.\n    \n    Examples:\n    >>> count_unique_elements([1, 2, 2, 3, 4])\n    4\n    >>> count_unique_elements([1, 1, 1, 1])\n    1\n    >>> count_unique_elements([])  # Edge case: empty list\n    0\n    >>> count_unique_elements([5, 5, 5, 5, 5])  # All elements are the same\n    1\n    >>> count_unique_elements([1, 2, 3, 4, 5])  # All unique elements\n    5\n    \"\"\"\n    # Convert the list to a set to filter out duplicate elements\n    unique_elements = set(lst)\n    \n    # Return the number of unique elements\n    return len(unique_elements)\n\n# Test cases to validate the function\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "auto/1", "completion": "from typing import List\n\ndef find_max_difference(numbers: List[int]) -> int:\n    \"\"\" Find the maximum difference between any two elements in the list.\n    The difference is defined as the absolute value of the subtraction of one element from another.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n        \n    Returns:\n        int: The maximum difference between any two elements in the list.\n        \n    Raises:\n        ValueError: If the list is empty.\n        \n    Examples:\n    >>> find_max_difference([1, 2, 3, 4, 5])\n    4\n    >>> find_max_difference([10, 20, 30, 40])\n    30\n    >>> find_max_difference([-10, -20, -30, -40])\n    30\n    >>> find_max_difference([5])\n    0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list must not be empty.\")\n    \n    # Find the maximum and minimum values in the list\n    max_value = max(numbers)\n    min_value = min(numbers)\n    \n    # Calculate the maximum difference\n    max_difference = max_value - min_value\n    \n    return max_difference\n\n# Test cases to validate the function\nif __name__ == \"__main__\":\n    # Test case 1\n    assert find_max_difference([1, 2, 3, 4, 5]) == 4\n    # Test case 2\n    assert find_max_difference([10, 20, 30, 40]) == 30\n    # Test case 3\n    assert find_max_difference([-10, -20, -30, -40]) == 30\n    # Test case 4\n    assert find_max_difference([5]) == 0\n    # Test case 5\n    assert find_max_difference([1, -1, 0]) == 2\n    # Test case 6\n    assert find_max_difference([100, 200, 300, 400, 500]) == 400\n    \n    print(\"All test cases passed!\")"}
{"task_id": "auto/4", "completion": "from typing import List\n\ndef find_duplicates(items: List[int]) -> List[int]:\n    \"\"\" \n    Given a list of integers, return a list of duplicates (elements that appear more than once).\n    The duplicates should be returned in the order of their first occurrence in the input list.\n    \n    >>> find_duplicates([1, 2, 3, 1, 2, 4])\n    [1, 2]\n    >>> find_duplicates([5, 5, 5, 6, 7])\n    [5]\n    \"\"\"\n    seen = set()  # Set to track seen items\n    duplicates = []  # List to store duplicates\n\n    for item in items:\n        if item in seen:\n            # If the item is already seen and not in duplicates, add it\n            if item not in duplicates:\n                duplicates.append(item)\n        else:\n            # If the item is not seen, add it to the seen set\n            seen.add(item)\n\n    return duplicates\n\n# Test cases to validate the function\nif __name__ == \"__main__\":\n    # Running the provided test cases\n    print(find_duplicates([1, 2, 3, 1, 2, 4]))  # Expected output: [1, 2]\n    print(find_duplicates([5, 5, 5, 6, 7]))     # Expected output: [5]\n    \n    # Additional test cases\n    print(find_duplicates([1, 2, 3]))            # Expected output: []\n    print(find_duplicates([1, 1, 1, 1]))         # Expected output: [1]\n    print(find_duplicates([1, 2, 3, 4, 5, 1, 2])) # Expected output: [1, 2]\n    print(find_duplicates([]))                    # Expected output: []"}
{"task_id": "auto/8", "completion": "from typing import List\n\ndef unique_elements(elements: List[int]) -> List[int]:\n    \"\"\" Return a list of unique elements from the input list while maintaining their order.\n    \n    This function iterates through the input list and uses a set to track elements that have \n    already been added to the result list. If an element is encountered for the first time, \n    it is appended to the result list.\n    \n    Args:\n        elements (List[int]): A list of integers which may contain duplicates.\n        \n    Returns:\n        List[int]: A list of unique integers in the order of their first appearance.\n    \n    Examples:\n    >>> unique_elements([1, 2, 2, 3, 4, 4])\n    [1, 2, 3, 4]\n    >>> unique_elements([5, 5, 5])\n    [5]\n    >>> unique_elements([1, 2, 3, 1, 2, 3])\n    [1, 2, 3]\n    >>> unique_elements([])\n    []\n    >>> unique_elements([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    seen = set()  # Set to track seen elements\n    unique_list = []  # List to store unique elements\n    \n    for element in elements:\n        if element not in seen:\n            seen.add(element)  # Mark the element as seen\n            unique_list.append(element)  # Add to the unique list\n    \n    return unique_list  # Return the list of unique elements\n\n# Test cases to validate the function\nif __name__ == \"__main__\":\n    # Running the provided test cases\n    print(unique_elements([1, 2, 2, 3, 4, 4]))  # Expected: [1, 2, 3, 4]\n    print(unique_elements([5, 5, 5]))            # Expected: [5]\n    print(unique_elements([1, 2, 3, 1, 2, 3]))  # Expected: [1, 2, 3]\n    print(unique_elements([]))                    # Expected: []\n    print(unique_elements([1, 2, 3, 4, 5]))      # Expected: [1, 2, 3, 4, 5]"}
{"task_id": "auto/3", "completion": "from typing import Optional, List\n\ndef find_repeat(numbers: List[int]) -> Optional[int]:\n    \"\"\" Given a list of integers, return the first number that is repeated.\n        If there are no repeats, return None.\n        \n        >>> find_repeat([1, 2, 3, 4, 5, 2])\n        2\n        >>> find_repeat([1, 2, 3, 4])\n        None\n    \"\"\"\n    seen = set()  # A set to keep track of seen numbers\n    for number in numbers:\n        if number in seen:\n            return number  # Return the first repeated number\n        seen.add(number)  # Add the number to the set if not seen\n    return None  # Return None if no repeats are found\n\n# Test cases to validate the function\nif __name__ == \"__main__\":\n    # Test case 1: A list with a repeat\n    assert find_repeat([1, 2, 3, 4, 5, 2]) == 2, \"Test case 1 failed\"\n    \n    # Test case 2: A list with no repeats\n    assert find_repeat([1, 2, 3, 4]) is None, \"Test case 2 failed\"\n    \n    # Test case 3: A list with multiple repeats\n    assert find_repeat([5, 1, 2, 3, 5, 4]) == 5, \"Test case 3 failed\"\n    \n    # Test case 4: A list with all elements the same\n    assert find_repeat([7, 7, 7, 7]) == 7, \"Test case 4 failed\"\n    \n    # Test case 5: An empty list\n    assert find_repeat([]) is None, \"Test case 5 failed\"\n    \n    # Test case 6: A list with negative numbers\n    assert find_repeat([-1, -2, -3, -1]) == -1, \"Test case 6 failed\"\n    \n    print(\"All test cases passed!\")"}
{"task_id": "auto/2", "completion": "from typing import List\n\ndef merge_overlapping_intervals(intervals: List[List[int]]) -> List[List[int]]:\n    \"\"\" \n    Given a list of intervals, merge all overlapping intervals and return the result as a new list.\n    Each interval is represented as a list of two integers [start, end].\n    \n    Args:\n    intervals (List[List[int]]): A list of intervals to be merged.\n    \n    Returns:\n    List[List[int]]: A list of merged intervals.\n    \n    Example:\n    >>> merge_overlapping_intervals([[1,3],[2,6],[8,10],[15,18]])\n    [[1, 6], [8, 10], [15, 18]]\n    \"\"\"\n    \n    # If the input list is empty, return an empty list\n    if not intervals:\n        return []\n    \n    # Step 1: Sort the intervals based on the starting values\n    intervals.sort(key=lambda x: x[0])\n    \n    # Step 2: Initialize a list to hold the merged intervals\n    merged = []\n    \n    # Start with the first interval\n    current_start, current_end = intervals[0]\n    \n    for i in range(1, len(intervals)):\n        start, end = intervals[i]\n        \n        # Step 3: Check if the current interval overlaps with the merged interval\n        if start <= current_end:\n            # There is an overlap, so we merge the intervals\n            current_end = max(current_end, end)\n        else:\n            # No overlap, add the current merged interval to the list\n            merged.append([current_start, current_end])\n            # Update to the current interval\n            current_start, current_end = start, end\n    \n    # Don't forget to add the last merged interval\n    merged.append([current_start, current_end])\n    \n    return merged\n\n# Test cases to validate the function\nif __name__ == \"__main__\":\n    # Test case 1: Basic overlapping intervals\n    assert merge_overlapping_intervals([[1,3],[2,6],[8,10],[15,18]]) == [[1, 6], [8, 10], [15, 18]]\n    \n    # Test case 2: No overlapping intervals\n    assert merge_overlapping_intervals([[1,2],[3,4],[5,6]]) == [[1, 2], [3, 4], [5, 6]]\n    \n    # Test case 3: All intervals overlap\n    assert merge_overlapping_intervals([[1,4],[2,3],[3,5]]) == [[1, 5]]\n    \n    # Test case 4: Single interval\n    assert merge_overlapping_intervals([[1, 4]]) == [[1, 4]]\n    \n    # Test case 5: Empty list\n    assert merge_overlapping_intervals([]) == []\n    \n    print(\"All test cases passed!\")"}
