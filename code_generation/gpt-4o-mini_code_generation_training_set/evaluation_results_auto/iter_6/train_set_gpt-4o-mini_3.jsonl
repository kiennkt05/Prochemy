{"task_id": "auto/7", "response": "The task is to complete the `calculate_mean` function, which takes a list of floating-point numbers as input and returns their mean (average). Below is the completed function along with comments explaining its functionality, error handling for edge cases, and an example of how to use it.\n\n```python\nfrom typing import List\n\ndef calculate_mean(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the mean (average) of a list of numbers.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n    float: The mean of the numbers in the list.\n\n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    # Check if the list is empty\n    if not numbers:\n        raise ValueError(\"The list of numbers must not be empty.\")\n    \n    # Calculate the sum of the numbers\n    total_sum = sum(numbers)\n    \n    # Calculate the mean by dividing the total sum by the number of elements\n    mean = total_sum / len(numbers)\n    \n    return mean\n\n# Example usage\nif __name__ == \"__main__\":\n    try:\n        numbers = [10.0, 20.0, 30.0, 40.0, 50.0]\n        mean_value = calculate_mean(numbers)\n        print(f\"The mean of {numbers} is {mean_value:.2f}\")\n    except ValueError as e:\n        print(e)\n```\n\n### Explanation:\n1. **Function Definition**: The function `calculate_mean` is defined to take a list of floats as input.\n2. **Error Handling**: It checks if the input list is empty and raises a `ValueError` if it is, ensuring that the function does not attempt to calculate a mean for an empty list.\n3. **Mean Calculation**: It calculates the total sum of the numbers and divides it by the length of the list to find the mean.\n4. **Example Usage**: The `if __name__ == \"__main__\":` block demonstrates how to use the function and handles potential errors gracefully.\n\n### Testing:\nYou can test the function with different lists of numbers to ensure it behaves as expected. For example, you can try it with an empty list to see the error handling in action.", "completion": "from typing import List\n\ndef calculate_mean(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the mean (average) of a list of numbers.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n    float: The mean of the numbers in the list.\n\n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    # Check if the list is empty\n    if not numbers:\n        raise ValueError(\"The list of numbers must not be empty.\")\n    \n    # Calculate the sum of the numbers\n    total_sum = sum(numbers)\n    \n    # Calculate the mean by dividing the total sum by the number of elements\n    mean = total_sum / len(numbers)\n    \n    return mean\n\n# Example usage\nif __name__ == \"__main__\":\n    try:\n        numbers = [10.0, 20.0, 30.0, 40.0, 50.0]\n        mean_value = calculate_mean(numbers)\n        print(f\"The mean of {numbers} is {mean_value:.2f}\")\n    except ValueError as e:\n        print(e)"}
{"task_id": "auto/1", "response": "The task is to implement a function that counts the maximum number of consecutive zeros in a list of integers. Below is the complete implementation of the `count_consecutive_zeros` function, along with comments explaining the logic, error handling, and an example of how to use the function.\n\n```python\nfrom typing import List\n\ndef count_consecutive_zeros(nums: List[int]) -> int:\n    \"\"\"\n    Count the maximum number of consecutive zeros in a list of integers.\n\n    Parameters:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The maximum count of consecutive zeros.\n    \"\"\"\n    max_count = 0  # Variable to keep track of the maximum count of consecutive zeros\n    current_count = 0  # Variable to count the current streak of zeros\n\n    for num in nums:\n        if num == 0:\n            current_count += 1  # Increment the count if the current number is zero\n        else:\n            max_count = max(max_count, current_count)  # Update max_count if current_count is greater\n            current_count = 0  # Reset current_count if the number is not zero\n\n    # Final check to update max_count in case the list ends with zeros\n    max_count = max(max_count, current_count)\n\n    return max_count\n\n# Example usage:\nif __name__ == \"__main__\":\n    example_list = [1, 0, 0, 2, 0, 0, 0, 3, 0]\n    result = count_consecutive_zeros(example_list)\n    print(f\"The maximum number of consecutive zeros is: {result}\")  # Output: 3\n```\n\n### Explanation:\n1. **Function Definition**: The function `count_consecutive_zeros` takes a list of integers as input.\n2. **Variables**: \n   - `max_count` keeps track of the maximum number of consecutive zeros found.\n   - `current_count` counts the current streak of zeros as we iterate through the list.\n3. **Loop Through List**: The function iterates through each number in the list:\n   - If the number is zero, it increments `current_count`.\n   - If the number is not zero, it compares `current_count` with `max_count` and resets `current_count`.\n4. **Final Check**: After the loop, it checks one last time to ensure that if the list ends with zeros, the count is updated.\n5. **Return Value**: The function returns the maximum count of consecutive zeros found.\n\n### Edge Cases:\n- The function handles cases where the list is empty or contains no zeros by returning `0`.\n- It also correctly counts zeros at the beginning or end of the list.\n\nThis implementation is efficient and follows best practices for readability and maintainability.", "completion": "from typing import List\n\ndef count_consecutive_zeros(nums: List[int]) -> int:\n    \"\"\"\n    Count the maximum number of consecutive zeros in a list of integers.\n\n    Parameters:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The maximum count of consecutive zeros.\n    \"\"\"\n    max_count = 0  # Variable to keep track of the maximum count of consecutive zeros\n    current_count = 0  # Variable to count the current streak of zeros\n\n    for num in nums:\n        if num == 0:\n            current_count += 1  # Increment the count if the current number is zero\n        else:\n            max_count = max(max_count, current_count)  # Update max_count if current_count is greater\n            current_count = 0  # Reset current_count if the number is not zero\n\n    # Final check to update max_count in case the list ends with zeros\n    max_count = max(max_count, current_count)\n\n    return max_count\n\n# Example usage:\nif __name__ == \"__main__\":\n    example_list = [1, 0, 0, 2, 0, 0, 0, 3, 0]\n    result = count_consecutive_zeros(example_list)\n    print(f\"The maximum number of consecutive zeros is: {result}\")  # Output: 3"}
{"task_id": "auto/5", "response": "The task is to implement a function `reverse_sublists` that takes a list of integers and reverses the order of the elements in the list. However, the description does not specify whether the entire list should be reversed or if it should be divided into sublists of a certain size before reversing each sublist. \n\nTo clarify, I will assume the requirement is to reverse the entire list. If you meant to reverse sublists of a specific size, please provide that detail.\n\nHere\u2019s how the function can be implemented to reverse the entire list:\n\n```python\nfrom typing import List\n\ndef reverse_sublists(data: List[int]) -> List[int]:\n    \"\"\"\n    Reverses the order of elements in the given list of integers.\n\n    Parameters:\n    data (List[int]): A list of integers to be reversed.\n\n    Returns:\n    List[int]: A new list containing the elements of the input list in reverse order.\n    \"\"\"\n    # Check if the input list is empty\n    if not data:\n        return []\n\n    # Reverse the list using slicing\n    reversed_data = data[::-1]\n    \n    return reversed_data\n\n# Example usage\nif __name__ == \"__main__\":\n    # Test the function with an example input\n    example_input = [1, 2, 3, 4, 5]\n    result = reverse_sublists(example_input)\n    print(\"Reversed List:\", result)  # Output should be [5, 4, 3, 2, 1]\n```\n\n### Explanation:\n1. **Function Definition**: The function `reverse_sublists` takes a list of integers as input.\n2. **Input Validation**: It checks if the input list is empty and returns an empty list if so.\n3. **Reversing the List**: The list is reversed using Python's slicing feature `data[::-1]`, which is an efficient way to reverse a list.\n4. **Return Value**: The reversed list is returned.\n5. **Example Usage**: An example is provided to demonstrate how to use the function, along with a print statement to show the output.\n\n### Edge Cases:\n- The function handles an empty list gracefully by returning an empty list.\n- It works with lists containing any integers, including negative numbers and zeros.\n\nIf you meant to reverse sublists of a specific size instead, please provide that detail, and I can adjust the implementation accordingly.", "completion": "from typing import List\n\ndef reverse_sublists(data: List[int]) -> List[int]:\n    \"\"\"\n    Reverses the order of elements in the given list of integers.\n\n    Parameters:\n    data (List[int]): A list of integers to be reversed.\n\n    Returns:\n    List[int]: A new list containing the elements of the input list in reverse order.\n    \"\"\"\n    # Check if the input list is empty\n    if not data:\n        return []\n\n    # Reverse the list using slicing\n    reversed_data = data[::-1]\n    \n    return reversed_data\n\n# Example usage\nif __name__ == \"__main__\":\n    # Test the function with an example input\n    example_input = [1, 2, 3, 4, 5]\n    result = reverse_sublists(example_input)\n    print(\"Reversed List:\", result)  # Output should be [5, 4, 3, 2, 1]"}
{"task_id": "auto/2", "response": "The task is to implement a function that calculates the sum of all negative numbers in a given list of integers. Below is the complete implementation of the `sum_negative_numbers` function, along with comments explaining its functionality, error handling, and an example of how to use it.\n\n```python\nfrom typing import List\n\ndef sum_negative_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all negative numbers in a list.\n\n    Parameters:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    int: The sum of negative integers in the list. If there are no negative numbers, returns 0.\n    \"\"\"\n    # Initialize a variable to hold the sum of negative numbers\n    negative_sum = 0\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        # Check if the number is negative\n        if number < 0:\n            negative_sum += number  # Add to the sum if it's negative\n    \n    return negative_sum  # Return the final sum of negative numbers\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test cases\n    test_list_1 = [1, -2, 3, -4, 5]\n    test_list_2 = [0, 2, 4, 6]\n    test_list_3 = [-1, -2, -3, -4]\n    test_list_4 = []  # Edge case: empty list\n\n    # Print results\n    print(f\"Sum of negative numbers in {test_list_1}: {sum_negative_numbers(test_list_1)}\")  # Output: -6\n    print(f\"Sum of negative numbers in {test_list_2}: {sum_negative_numbers(test_list_2)}\")  # Output: 0\n    print(f\"Sum of negative numbers in {test_list_3}: {sum_negative_numbers(test_list_3)}\")  # Output: -10\n    print(f\"Sum of negative numbers in {test_list_4}: {sum_negative_numbers(test_list_4)}\")  # Output: 0\n```\n\n### Explanation:\n1. **Function Definition**: The function `sum_negative_numbers` takes a list of integers as input and returns an integer representing the sum of all negative numbers in that list.\n\n2. **Initialization**: A variable `negative_sum` is initialized to zero to accumulate the sum of negative numbers.\n\n3. **Iteration**: The function iterates through each number in the input list. If a number is negative, it is added to `negative_sum`.\n\n4. **Return Value**: After processing all numbers, the function returns the total sum of negative numbers.\n\n5. **Example Usage**: The `if __name__ == \"__main__\":` block demonstrates how to use the function with various test cases, including an edge case of an empty list.\n\nThis implementation is efficient, clear, and follows best practices for Python programming.", "completion": "from typing import List\n\ndef sum_negative_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Calculate the sum of all negative numbers in a list.\n\n    Parameters:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    int: The sum of negative integers in the list. If there are no negative numbers, returns 0.\n    \"\"\"\n    # Initialize a variable to hold the sum of negative numbers\n    negative_sum = 0\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        # Check if the number is negative\n        if number < 0:\n            negative_sum += number  # Add to the sum if it's negative\n    \n    return negative_sum  # Return the final sum of negative numbers\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test cases\n    test_list_1 = [1, -2, 3, -4, 5]\n    test_list_2 = [0, 2, 4, 6]\n    test_list_3 = [-1, -2, -3, -4]\n    test_list_4 = []  # Edge case: empty list\n\n    # Print results\n    print(f\"Sum of negative numbers in {test_list_1}: {sum_negative_numbers(test_list_1)}\")  # Output: -6\n    print(f\"Sum of negative numbers in {test_list_2}: {sum_negative_numbers(test_list_2)}\")  # Output: 0\n    print(f\"Sum of negative numbers in {test_list_3}: {sum_negative_numbers(test_list_3)}\")  # Output: -10\n    print(f\"Sum of negative numbers in {test_list_4}: {sum_negative_numbers(test_list_4)}\")  # Output: 0"}
{"task_id": "auto/6", "response": "The provided code snippet defines a function `count_elements` that takes a list of integers (`numbers`) and an integer (`target`). However, the function is incomplete, and it seems the goal is to count how many times the `target` integer appears in the `numbers` list.\n\nHere\u2019s how we can complete this function, ensuring it adheres to best practices, includes error handling, and is well-documented:\n\n```python\nfrom typing import List\n\ndef count_elements(numbers: List[int], target: int) -> int:\n    \"\"\"\n    Count the occurrences of a target integer in a list of integers.\n\n    Parameters:\n    numbers (List[int]): A list of integers to search through.\n    target (int): The integer to count in the list.\n\n    Returns:\n    int: The count of occurrences of the target integer in the list.\n    \n    Raises:\n    ValueError: If the input list is not of type List[int].\n    \"\"\"\n    # Validate input\n    if not isinstance(numbers, list):\n        raise ValueError(\"The 'numbers' parameter must be a list.\")\n    if not all(isinstance(num, int) for num in numbers):\n        raise ValueError(\"All elements in 'numbers' must be integers.\")\n    \n    # Count occurrences of the target\n    count = 0\n    for num in numbers:\n        if num == target:\n            count += 1\n            \n    return count\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    # Test cases\n    print(count_elements([1, 2, 3, 4, 2, 2], 2))  # Output: 3\n    print(count_elements([1, 1, 1, 1, 1], 1))     # Output: 5\n    print(count_elements([1, 2, 3, 4, 5], 6))     # Output: 0\n    print(count_elements([], 1))                   # Output: 0\n```\n\n### Explanation:\n1. **Function Definition**: The function `count_elements` is defined to take a list of integers and a target integer.\n2. **Input Validation**: The function checks if the `numbers` parameter is a list and if all its elements are integers. If not, it raises a `ValueError`.\n3. **Counting Logic**: A simple loop iterates through the list, incrementing a counter whenever the current number matches the target.\n4. **Return Value**: The function returns the count of occurrences of the target integer.\n5. **Example Usage**: The `if __name__ == \"__main__\":` block provides example test cases to demonstrate the function's usage and expected outputs.\n\nThis implementation is efficient, clear, and robust, making it suitable for various scenarios while also being educational for users learning Python.", "completion": "from typing import List\n\ndef count_elements(numbers: List[int], target: int) -> int:\n    \"\"\"\n    Count the occurrences of a target integer in a list of integers.\n\n    Parameters:\n    numbers (List[int]): A list of integers to search through.\n    target (int): The integer to count in the list.\n\n    Returns:\n    int: The count of occurrences of the target integer in the list.\n    \n    Raises:\n    ValueError: If the input list is not of type List[int].\n    \"\"\"\n    # Validate input\n    if not isinstance(numbers, list):\n        raise ValueError(\"The 'numbers' parameter must be a list.\")\n    if not all(isinstance(num, int) for num in numbers):\n        raise ValueError(\"All elements in 'numbers' must be integers.\")\n    \n    # Count occurrences of the target\n    count = 0\n    for num in numbers:\n        if num == target:\n            count += 1\n            \n    return count\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    # Test cases\n    print(count_elements([1, 2, 3, 4, 2, 2], 2))  # Output: 3\n    print(count_elements([1, 1, 1, 1, 1], 1))     # Output: 5\n    print(count_elements([1, 2, 3, 4, 5], 6))     # Output: 0\n    print(count_elements([], 1))                   # Output: 0"}
{"task_id": "auto/3", "response": "The task is to implement a function that finds the missing number in a list of integers. The list is expected to contain numbers from 0 to n, where one number is missing. The function should return the missing number.\n\n### Requirements:\n1. The input is a list of integers (`nums`) that contains unique numbers from 0 to n, with one number missing.\n2. The function should return the missing number as an integer.\n3. The solution should be efficient, ideally with a time complexity of O(n) and a space complexity of O(1).\n\n### Approach:\nA common approach to solve this problem is to use the formula for the sum of the first n natural numbers. The sum of numbers from 0 to n is given by the formula:\n\\[ \\text{Sum} = \\frac{n(n + 1)}{2} \\]\nWe can calculate the expected sum and subtract the actual sum of the numbers in the list to find the missing number.\n\n### Implementation:\nHere is the complete implementation of the `find_missing_number` function, along with comments explaining each step:\n\n```python\nfrom typing import List\n\ndef find_missing_number(nums: List[int]) -> int:\n    \"\"\"\n    Find the missing number in a list of integers from 0 to n.\n    \n    Args:\n    nums (List[int]): A list of unique integers from 0 to n with one number missing.\n    \n    Returns:\n    int: The missing number.\n    \"\"\"\n    n = len(nums)  # The length of the list gives us the maximum number (n)\n    \n    # Calculate the expected sum of numbers from 0 to n\n    expected_sum = n * (n + 1) // 2\n    \n    # Calculate the actual sum of the numbers in the list\n    actual_sum = sum(nums)\n    \n    # The missing number is the difference between the expected and actual sums\n    missing_number = expected_sum - actual_sum\n    \n    return missing_number\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test case: The list contains numbers from 0 to 5, but 3 is missing\n    nums = [0, 1, 2, 4, 5]\n    print(f\"The missing number is: {find_missing_number(nums)}\")  # Output: 3\n```\n\n### Explanation:\n1. **Input Handling**: The function takes a list of integers as input.\n2. **Expected Sum Calculation**: It calculates the expected sum of numbers from 0 to n using the formula.\n3. **Actual Sum Calculation**: It computes the sum of the numbers present in the list.\n4. **Finding the Missing Number**: The missing number is found by subtracting the actual sum from the expected sum.\n5. **Example Usage**: An example is provided to demonstrate how to use the function.\n\n### Edge Cases:\n- If the input list is empty, the function will return 0, as the missing number in that case is 0.\n- The function assumes that there is exactly one missing number and that the input list contains unique integers.\n\nThis implementation is efficient and adheres to best practices in Python programming.", "completion": "from typing import List\n\ndef find_missing_number(nums: List[int]) -> int:\n    \"\"\"\n    Find the missing number in a list of integers from 0 to n.\n    \n    Args:\n    nums (List[int]): A list of unique integers from 0 to n with one number missing.\n    \n    Returns:\n    int: The missing number.\n    \"\"\"\n    n = len(nums)  # The length of the list gives us the maximum number (n)\n    \n    # Calculate the expected sum of numbers from 0 to n\n    expected_sum = n * (n + 1) // 2\n    \n    # Calculate the actual sum of the numbers in the list\n    actual_sum = sum(nums)\n    \n    # The missing number is the difference between the expected and actual sums\n    missing_number = expected_sum - actual_sum\n    \n    return missing_number\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Test case: The list contains numbers from 0 to 5, but 3 is missing\n    nums = [0, 1, 2, 4, 5]\n    print(f\"The missing number is: {find_missing_number(nums)}\")  # Output: 3"}
{"task_id": "auto/9", "response": "The task is to implement a function that counts the number of negative integers in a given list of integers. The function should be well-structured, efficient, and include appropriate documentation and test cases.\n\nHere\u2019s the complete implementation of the `count_negative_numbers` function, along with the necessary comments and example test cases:\n\n```python\nfrom typing import List\n\ndef count_negative_numbers(nums: List[int]) -> int:\n    \"\"\"Count the number of negative integers in a given list of integers.\n\n    Args:\n        nums (List[int]): A list of integers.\n\n    Returns:\n        int: The count of negative integers in the list.\n\n    Examples:\n        >>> count_negative_numbers([-1, 2, -3, 4, -5, 6])\n        3\n        >>> count_negative_numbers([1, 2, 3, 4, 5, 6])\n        0\n        >>> count_negative_numbers([])\n        0\n        >>> count_negative_numbers([-1, -2, -3])\n        3\n    \"\"\"\n    # Initialize a counter for negative numbers\n    negative_count = 0\n    \n    # Iterate through each number in the list\n    for num in nums:\n        # Check if the number is negative\n        if num < 0:\n            negative_count += 1  # Increment the counter if negative\n    \n    return negative_count  # Return the total count of negative numbers\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    # Test cases to validate the functionality\n    assert count_negative_numbers([-1, 2, -3, 4, -5, 6]) == 3\n    assert count_negative_numbers([1, 2, 3, 4, 5, 6]) == 0\n    assert count_negative_numbers([]) == 0\n    assert count_negative_numbers([-1, -2, -3]) == 3\n    print(\"All test cases passed!\")\n```\n\n### Explanation:\n1. **Function Definition**: The function `count_negative_numbers` takes a list of integers as input and returns the count of negative integers.\n2. **Docstring**: The docstring provides a clear description of the function's purpose, its parameters, return value, and includes example test cases.\n3. **Counter Initialization**: A counter `negative_count` is initialized to zero to keep track of the number of negative integers.\n4. **Iteration**: The function iterates through each integer in the input list, checking if it is negative.\n5. **Counting Negatives**: If a number is negative, the counter is incremented.\n6. **Return Value**: Finally, the function returns the total count of negative integers.\n7. **Test Cases**: The `if __name__ == \"__main__\":` block includes assertions to validate the function's correctness with various test cases.\n\nThis implementation is efficient, easy to understand, and follows best practices in Python programming.", "completion": "from typing import List\n\ndef count_negative_numbers(nums: List[int]) -> int:\n    \"\"\"Count the number of negative integers in a given list of integers.\n\n    Args:\n        nums (List[int]): A list of integers.\n\n    Returns:\n        int: The count of negative integers in the list.\n\n    Examples:\n        >>> count_negative_numbers([-1, 2, -3, 4, -5, 6])\n        3\n        >>> count_negative_numbers([1, 2, 3, 4, 5, 6])\n        0\n        >>> count_negative_numbers([])\n        0\n        >>> count_negative_numbers([-1, -2, -3])\n        3\n    \"\"\"\n    # Initialize a counter for negative numbers\n    negative_count = 0\n    \n    # Iterate through each number in the list\n    for num in nums:\n        # Check if the number is negative\n        if num < 0:\n            negative_count += 1  # Increment the counter if negative\n    \n    return negative_count  # Return the total count of negative numbers\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    # Test cases to validate the functionality\n    assert count_negative_numbers([-1, 2, -3, 4, -5, 6]) == 3\n    assert count_negative_numbers([1, 2, 3, 4, 5, 6]) == 0\n    assert count_negative_numbers([]) == 0\n    assert count_negative_numbers([-1, -2, -3]) == 3\n    print(\"All test cases passed!\")"}
{"task_id": "auto/4", "response": "The task is to implement a function `find_duplicates` that takes a list of floating-point numbers as input and returns a list of duplicate numbers found in that list. The output should contain each duplicate number only once, regardless of how many times it appears in the input list.\n\n### Requirements:\n1. The function should accept a list of floats.\n2. It should return a list of floats that are duplicates.\n3. The output list should contain each duplicate only once.\n4. The function should handle edge cases, such as an empty list or a list with no duplicates.\n\n### Implementation Steps:\n1. Use a set to track seen numbers and another set to track duplicates.\n2. Iterate through the input list and populate the sets accordingly.\n3. Convert the duplicates set to a list before returning it.\n\n### Code Implementation:\nHere is the complete implementation of the `find_duplicates` function:\n\n```python\nfrom typing import List\n\ndef find_duplicates(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Find and return a list of duplicate numbers from the input list.\n    \n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n    \n    Returns:\n    List[float]: A list of duplicate numbers found in the input list, \n                 with each duplicate appearing only once.\n    \"\"\"\n    seen = set()        # Set to track seen numbers\n    duplicates = set()  # Set to track duplicates\n\n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)  # Add to duplicates if already seen\n        else:\n            seen.add(number)        # Add to seen if not seen before\n\n    return list(duplicates)  # Convert duplicates set to a list and return\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    # Test cases\n    print(find_duplicates([1.0, 2.0, 3.0, 1.0, 2.0]))  # Output: [1.0, 2.0]\n    print(find_duplicates([1.5, 2.5, 3.5, 4.5]))       # Output: []\n    print(find_duplicates([]))                           # Output: []\n    print(find_duplicates([1.1, 1.1, 1.1, 2.2, 2.2]))  # Output: [1.1, 2.2]\n```\n\n### Explanation:\n- **Sets**: We use sets for `seen` and `duplicates` because they provide O(1) average time complexity for lookups and insertions, making the function efficient.\n- **Iteration**: We iterate through each number in the input list. If the number is already in the `seen` set, we add it to the `duplicates` set. If not, we add it to the `seen` set.\n- **Return Value**: Finally, we convert the `duplicates` set to a list and return it.\n\n### Edge Cases:\n- The function handles empty lists by returning an empty list.\n- It also correctly identifies duplicates regardless of how many times they appear in the input list.\n\nThis implementation is efficient, clear, and follows best practices in Python programming.", "completion": "from typing import List\n\ndef find_duplicates(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Find and return a list of duplicate numbers from the input list.\n    \n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n    \n    Returns:\n    List[float]: A list of duplicate numbers found in the input list, \n                 with each duplicate appearing only once.\n    \"\"\"\n    seen = set()        # Set to track seen numbers\n    duplicates = set()  # Set to track duplicates\n\n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)  # Add to duplicates if already seen\n        else:\n            seen.add(number)        # Add to seen if not seen before\n\n    return list(duplicates)  # Convert duplicates set to a list and return\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    # Test cases\n    print(find_duplicates([1.0, 2.0, 3.0, 1.0, 2.0]))  # Output: [1.0, 2.0]\n    print(find_duplicates([1.5, 2.5, 3.5, 4.5]))       # Output: []\n    print(find_duplicates([]))                           # Output: []\n    print(find_duplicates([1.1, 1.1, 1.1, 2.2, 2.2]))  # Output: [1.1, 2.2]"}
{"task_id": "auto/0", "response": "The task is to implement a function `find_duplicates` that takes a list of strings as input and returns a list of strings that are duplicates in the input list. \n\n### Requirements:\n1. The function should accept a list of strings.\n2. It should identify and return only the strings that appear more than once in the input list.\n3. The output list should contain each duplicate string only once, regardless of how many times it appears in the input list.\n4. The order of the duplicates in the output list should reflect their first appearance in the input list.\n\n### Implementation Steps:\n1. Use a dictionary to count occurrences of each string.\n2. Iterate through the input list to populate the dictionary.\n3. Create a list of strings that have a count greater than one.\n4. Return this list.\n\n### Edge Cases:\n- An empty input list should return an empty list.\n- If there are no duplicates, the function should return an empty list.\n\n### Code Implementation:\nHere is the complete implementation of the `find_duplicates` function:\n\n```python\nfrom typing import List\n\ndef find_duplicates(strings: List[str]) -> List[str]:\n    \"\"\"\n    Find and return a list of duplicate strings from the input list.\n    \n    Parameters:\n    strings (List[str]): A list of strings to check for duplicates.\n    \n    Returns:\n    List[str]: A list of duplicate strings, each appearing only once.\n    \"\"\"\n    # Dictionary to count occurrences of each string\n    count_dict = {}\n    \n    # Count occurrences of each string\n    for string in strings:\n        if string in count_dict:\n            count_dict[string] += 1\n        else:\n            count_dict[string] = 1\n    \n    # List to hold duplicates\n    duplicates = []\n    \n    # Collect strings that have more than one occurrence\n    for string, count in count_dict.items():\n        if count > 1:\n            duplicates.append(string)\n    \n    return duplicates\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    # Test case 1: Basic duplicates\n    input_list = [\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"kiwi\"]\n    print(find_duplicates(input_list))  # Output: ['apple', 'banana']\n    \n    # Test case 2: No duplicates\n    input_list = [\"apple\", \"banana\", \"orange\", \"kiwi\"]\n    print(find_duplicates(input_list))  # Output: []\n    \n    # Test case 3: Empty list\n    input_list = []\n    print(find_duplicates(input_list))  # Output: []\n    \n    # Test case 4: All duplicates\n    input_list = [\"apple\", \"apple\", \"apple\"]\n    print(find_duplicates(input_list))  # Output: ['apple']\n```\n\n### Explanation:\n- The function `find_duplicates` uses a dictionary to count how many times each string appears in the input list.\n- It then checks which strings have a count greater than one and adds them to the `duplicates` list.\n- Finally, it returns the list of duplicates, ensuring that each duplicate appears only once.\n\nThis implementation is efficient and handles various edge cases, making it robust and reliable.", "completion": "from typing import List\n\ndef find_duplicates(strings: List[str]) -> List[str]:\n    \"\"\"\n    Find and return a list of duplicate strings from the input list.\n    \n    Parameters:\n    strings (List[str]): A list of strings to check for duplicates.\n    \n    Returns:\n    List[str]: A list of duplicate strings, each appearing only once.\n    \"\"\"\n    # Dictionary to count occurrences of each string\n    count_dict = {}\n    \n    # Count occurrences of each string\n    for string in strings:\n        if string in count_dict:\n            count_dict[string] += 1\n        else:\n            count_dict[string] = 1\n    \n    # List to hold duplicates\n    duplicates = []\n    \n    # Collect strings that have more than one occurrence\n    for string, count in count_dict.items():\n        if count > 1:\n            duplicates.append(string)\n    \n    return duplicates\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    # Test case 1: Basic duplicates\n    input_list = [\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"kiwi\"]\n    print(find_duplicates(input_list))  # Output: ['apple', 'banana']\n    \n    # Test case 2: No duplicates\n    input_list = [\"apple\", \"banana\", \"orange\", \"kiwi\"]\n    print(find_duplicates(input_list))  # Output: []\n    \n    # Test case 3: Empty list\n    input_list = []\n    print(find_duplicates(input_list))  # Output: []\n    \n    # Test case 4: All duplicates\n    input_list = [\"apple\", \"apple\", \"apple\"]\n    print(find_duplicates(input_list))  # Output: ['apple']"}
{"task_id": "auto/8", "response": "The task is to implement a function that finds the maximum number of consecutive 1's in a binary array (a list of integers containing only 0s and 1s). The function should return an integer representing this maximum count.\n\n### Requirements:\n1. The function should take a list of integers (`nums`) as input.\n2. The list will only contain 0s and 1s.\n3. The function should return the maximum number of consecutive 1's found in the list.\n\n### Plan:\n- Initialize two variables: one to keep track of the current count of consecutive 1's and another to store the maximum count found.\n- Iterate through the list:\n  - If the current element is 1, increment the current count.\n  - If the current element is 0, compare the current count with the maximum count and reset the current count to zero.\n- After the loop, perform a final check to update the maximum count in case the list ends with 1's.\n- Return the maximum count.\n\n### Implementation:\nHere is the complete Python code for the function:\n\n```python\nfrom typing import List\n\ndef find_max_consecutive_ones(nums: List[int]) -> int:\n    \"\"\"\n    This function finds the maximum number of consecutive 1's in a binary array.\n\n    :param nums: List[int] - A list of integers (0s and 1s).\n    :return: int - The maximum count of consecutive 1's.\n    \"\"\"\n    max_count = 0  # To keep track of the maximum count of consecutive 1's\n    current_count = 0  # To count the current streak of 1's\n\n    for num in nums:\n        if num == 1:\n            current_count += 1  # Increment current count if the number is 1\n        else:\n            max_count = max(max_count, current_count)  # Update max count if current count is greater\n            current_count = 0  # Reset current count if the number is 0\n\n    # Final check in case the array ends with 1's\n    max_count = max(max_count, current_count)\n\n    return max_count\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    # Test cases\n    print(find_max_consecutive_ones([1, 1, 0, 1, 1, 1]))  # Output: 3\n    print(find_max_consecutive_ones([1, 0, 1, 1, 0, 1]))  # Output: 2\n    print(find_max_consecutive_ones([0, 0, 0]))            # Output: 0\n    print(find_max_consecutive_ones([1, 1, 1, 1, 1]))      # Output: 5\n```\n\n### Explanation:\n- The function `find_max_consecutive_ones` iterates through the input list `nums`.\n- It maintains a count of consecutive 1's and updates the maximum count whenever a 0 is encountered.\n- A final check ensures that if the list ends with 1's, the maximum count is updated accordingly.\n- The example usage demonstrates how to call the function and includes assertions for expected outputs. \n\nThis implementation is efficient with a time complexity of O(n), where n is the length of the input list, and it handles edge cases such as empty lists or lists with no 1's.", "completion": "from typing import List\n\ndef find_max_consecutive_ones(nums: List[int]) -> int:\n    \"\"\"\n    This function finds the maximum number of consecutive 1's in a binary array.\n\n    :param nums: List[int] - A list of integers (0s and 1s).\n    :return: int - The maximum count of consecutive 1's.\n    \"\"\"\n    max_count = 0  # To keep track of the maximum count of consecutive 1's\n    current_count = 0  # To count the current streak of 1's\n\n    for num in nums:\n        if num == 1:\n            current_count += 1  # Increment current count if the number is 1\n        else:\n            max_count = max(max_count, current_count)  # Update max count if current count is greater\n            current_count = 0  # Reset current count if the number is 0\n\n    # Final check in case the array ends with 1's\n    max_count = max(max_count, current_count)\n\n    return max_count\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    # Test cases\n    print(find_max_consecutive_ones([1, 1, 0, 1, 1, 1]))  # Output: 3\n    print(find_max_consecutive_ones([1, 0, 1, 1, 0, 1]))  # Output: 2\n    print(find_max_consecutive_ones([0, 0, 0]))            # Output: 0\n    print(find_max_consecutive_ones([1, 1, 1, 1, 1]))      # Output: 5"}
{"task_id": "HumanEval/41", "response": "To solve the problem of counting the number of collisions between two sets of cars moving in opposite directions, we can leverage the fact that each car from the left will collide with each car from the right. Since the cars are infinitely sturdy and continue moving as if they did not collide, the number of collisions is simply the product of the number of cars in each direction.\n\nHere's how we can implement the `car_race_collision` function in Python:\n\n```python\ndef car_race_collision(n: int) -> int:\n    \"\"\"\n    Calculate the number of collisions between two sets of cars moving in opposite directions.\n\n    Args:\n    n (int): The number of cars in each direction (left to right and right to left).\n\n    Returns:\n    int: The total number of collisions.\n    \n    Each car moving left to right will collide with each car moving right to left.\n    Therefore, the total number of collisions is n * n.\n    \"\"\"\n    # Validate input\n    if n < 0:\n        raise ValueError(\"The number of cars must be a non-negative integer.\")\n    \n    # Calculate the number of collisions\n    collisions = n * n\n    \n    return collisions\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    # Test cases\n    print(car_race_collision(0))  # Expected output: 0 (no cars, no collisions)\n    print(car_race_collision(1))  # Expected output: 1 (1 car in each direction)\n    print(car_race_collision(2))  # Expected output: 4 (2 cars in each direction)\n    print(car_race_collision(3))  # Expected output: 9 (3 cars in each direction)\n```\n\n### Explanation of the Code:\n1. **Function Definition**: The function `car_race_collision` takes an integer `n` as input, which represents the number of cars in each direction.\n2. **Input Validation**: We check if `n` is a non-negative integer. If not, we raise a `ValueError` to inform the user of invalid input.\n3. **Collision Calculation**: The total number of collisions is calculated as `n * n`, since each car from the left will collide with each car from the right.\n4. **Return Value**: The function returns the total number of collisions.\n5. **Example Usage**: The `if __name__ == \"__main__\":` block contains test cases to demonstrate the function's usage and validate its correctness.\n\nThis implementation is efficient, straightforward, and adheres to best practices in Python programming.", "completion": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    Calculate the number of collisions between two sets of cars moving in opposite directions.\n\n    Args:\n    n (int): The number of cars in each direction (left to right and right to left).\n\n    Returns:\n    int: The total number of collisions.\n    \n    Each car moving left to right will collide with each car moving right to left.\n    Therefore, the total number of collisions is n * n.\n    \"\"\"\n    # Validate input\n    if n < 0:\n        raise ValueError(\"The number of cars must be a non-negative integer.\")\n    \n    # Calculate the number of collisions\n    collisions = n * n\n    \n    return collisions\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    # Test cases\n    print(car_race_collision(0))  # Expected output: 0 (no cars, no collisions)\n    print(car_race_collision(1))  # Expected output: 1 (1 car in each direction)\n    print(car_race_collision(2))  # Expected output: 4 (2 cars in each direction)\n    print(car_race_collision(3))  # Expected output: 9 (3 cars in each direction)"}
{"task_id": "HumanEval/10", "response": "To implement the `make_palindrome` function as described, we will follow the outlined algorithm. The goal is to find the shortest palindrome that starts with the given string. We will identify the longest palindromic suffix and then append the necessary prefix (in reverse) to form the complete palindrome.\n\nHere's the complete implementation of the `make_palindrome` function along with the necessary helper function to check for palindromes:\n\n```python\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" \n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string the reverse of a string prefix that comes before the palindromic suffix.\n    \n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    # Edge case: if the input string is empty, return it as is\n    if not string:\n        return string\n    \n    # Find the longest palindromic suffix\n    for i in range(len(string)):\n        # Check if the substring from i to the end is a palindrome\n        if is_palindrome(string[i:]):\n            # If it is, we need to append the reverse of the prefix before this suffix\n            prefix = string[:i]\n            return string + prefix[::-1]\n    \n    # If no palindromic suffix is found, the entire string is non-palindromic\n    # In this case, we append the entire string reversed\n    return string + string[::-1]\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    print(make_palindrome(''))        # Output: ''\n    print(make_palindrome('cat'))     # Output: 'catac'\n    print(make_palindrome('cata'))    # Output: 'catac'\n    print(make_palindrome('race'))     # Output: 'racecar'\n    print(make_palindrome('a'))       # Output: 'a'\n    print(make_palindrome('ab'))      # Output: 'aba'\n```\n\n### Explanation of the Code:\n1. **is_palindrome Function**: This function checks if a given string is the same forwards and backwards. It uses Python's slicing feature to reverse the string and compare it to the original.\n\n2. **make_palindrome Function**:\n   - It first checks for an empty string and returns it immediately.\n   - It then iterates through the string to find the longest palindromic suffix. For each index `i`, it checks if the substring from `i` to the end is a palindrome.\n   - If a palindromic suffix is found, it takes the prefix (the part of the string before the palindromic suffix), reverses it, and appends it to the original string to form the palindrome.\n   - If no palindromic suffix is found, it appends the entire string reversed to itself.\n\n3. **Example Usage**: The code includes a main block that demonstrates how to use the `make_palindrome` function with various test cases.\n\nThis implementation is efficient and follows best practices, ensuring clarity and maintainability.", "completion": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" \n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string the reverse of a string prefix that comes before the palindromic suffix.\n    \n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    # Edge case: if the input string is empty, return it as is\n    if not string:\n        return string\n    \n    # Find the longest palindromic suffix\n    for i in range(len(string)):\n        # Check if the substring from i to the end is a palindrome\n        if is_palindrome(string[i:]):\n            # If it is, we need to append the reverse of the prefix before this suffix\n            prefix = string[:i]\n            return string + prefix[::-1]\n    \n    # If no palindromic suffix is found, the entire string is non-palindromic\n    # In this case, we append the entire string reversed\n    return string + string[::-1]\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    print(make_palindrome(''))        # Output: ''\n    print(make_palindrome('cat'))     # Output: 'catac'\n    print(make_palindrome('cata'))    # Output: 'catac'\n    print(make_palindrome('race'))     # Output: 'racecar'\n    print(make_palindrome('a'))       # Output: 'a'\n    print(make_palindrome('ab'))      # Output: 'aba'"}
{"task_id": "HumanEval/65", "response": "To implement the `circular_shift` function as described, we need to follow these steps:\n\n1. **Convert the integer to a string** to easily manipulate its digits.\n2. **Calculate the effective shift**. If the shift is greater than the number of digits, we will reverse the digits instead.\n3. **Perform the circular shift** by slicing the string based on the calculated shift.\n4. **Return the result** as a string.\n\nHere\u2019s the complete implementation of the `circular_shift` function, along with the provided docstring and example test cases:\n\n```python\ndef circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    \n    >>> circular_shift(12, 1)\n    '21'\n    >>> circular_shift(12, 2)\n    '12'\n    >>> circular_shift(12345, 1)\n    '51234'\n    >>> circular_shift(12345, 5)\n    '54321'\n    >>> circular_shift(12345, 6)\n    '54321'\n    \"\"\"\n    # Convert the integer to a string to manipulate its digits\n    str_x = str(x)\n    num_digits = len(str_x)\n    \n    # If shift is greater than the number of digits, reverse the string\n    if shift >= num_digits:\n        return str_x[::-1]\n    \n    # Calculate the effective shift\n    effective_shift = shift % num_digits\n    \n    # Perform the circular shift\n    shifted_str = str_x[-effective_shift:] + str_x[:-effective_shift]\n    \n    return shifted_str\n\n# Example usage and testing\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n```\n\n### Explanation of the Code:\n- **Conversion to String**: We convert the integer `x` to a string to easily access and manipulate its digits.\n- **Effective Shift Calculation**: We use the modulo operator to ensure that the shift wraps around if it exceeds the number of digits.\n- **Circular Shift Logic**: We slice the string to create the new arrangement of digits based on the calculated effective shift.\n- **Reversal Condition**: If the shift is greater than or equal to the number of digits, we simply reverse the string.\n\n### Testing:\nThe function includes a docstring with examples that can be tested using Python's `doctest` module. This allows for easy verification of the function's correctness. The additional test cases ensure that the function behaves as expected in various scenarios.", "completion": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    \n    >>> circular_shift(12, 1)\n    '21'\n    >>> circular_shift(12, 2)\n    '12'\n    >>> circular_shift(12345, 1)\n    '51234'\n    >>> circular_shift(12345, 5)\n    '54321'\n    >>> circular_shift(12345, 6)\n    '54321'\n    \"\"\"\n    # Convert the integer to a string to manipulate its digits\n    str_x = str(x)\n    num_digits = len(str_x)\n    \n    # If shift is greater than the number of digits, reverse the string\n    if shift >= num_digits:\n        return str_x[::-1]\n    \n    # Calculate the effective shift\n    effective_shift = shift % num_digits\n    \n    # Perform the circular shift\n    shifted_str = str_x[-effective_shift:] + str_x[:-effective_shift]\n    \n    return shifted_str\n\n# Example usage and testing\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "HumanEval/77", "response": "To implement the `iscube` function that checks if a given integer is a perfect cube of some integer, we can follow these steps:\n\n1. **Calculate the cube root** of the absolute value of the input integer.\n2. **Round the cube root** to the nearest integer.\n3. **Check if the cube of this rounded integer** equals the original integer (considering both positive and negative cases).\n\nHere's the complete implementation of the `iscube` function, along with comments explaining each part of the code:\n\n```python\ndef iscube(a):\n    '''\n    Check if the given integer a is a perfect cube of some integer.\n    \n    Parameters:\n    a (int): The integer to check.\n    \n    Returns:\n    bool: True if a is a perfect cube, False otherwise.\n    \n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n    # Calculate the cube root of the absolute value of a\n    cube_root = round(abs(a) ** (1/3))\n    \n    # Check if the cube of the rounded cube root equals the absolute value of a\n    return cube_root ** 3 == abs(a)\n\n# Example test cases to validate the functionality\nif __name__ == \"__main__\":\n    # Test cases\n    print(iscube(1))    # True\n    print(iscube(2))    # False\n    print(iscube(-1))   # True\n    print(iscube(64))   # True\n    print(iscube(0))    # True\n    print(iscube(180))  # False\n```\n\n### Explanation:\n- The function `iscube` takes an integer `a` as input.\n- It computes the cube root of the absolute value of `a` using `abs(a) ** (1/3)`, and then rounds it to the nearest integer using `round()`.\n- It checks if the cube of this rounded integer equals the absolute value of `a`. If it does, it means `a` is a perfect cube, and the function returns `True`. Otherwise, it returns `False`.\n- The example test cases at the bottom demonstrate how to use the function and validate its correctness.\n\nThis implementation is efficient and handles both positive and negative integers, as well as zero.", "completion": "def iscube(a):\n    '''\n    Check if the given integer a is a perfect cube of some integer.\n    \n    Parameters:\n    a (int): The integer to check.\n    \n    Returns:\n    bool: True if a is a perfect cube, False otherwise.\n    \n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n    # Calculate the cube root of the absolute value of a\n    cube_root = round(abs(a) ** (1/3))\n    \n    # Check if the cube of the rounded cube root equals the absolute value of a\n    return cube_root ** 3 == abs(a)\n\n# Example test cases to validate the functionality\nif __name__ == \"__main__\":\n    # Test cases\n    print(iscube(1))    # True\n    print(iscube(2))    # False\n    print(iscube(-1))   # True\n    print(iscube(64))   # True\n    print(iscube(0))    # True\n    print(iscube(180))  # False"}
{"task_id": "HumanEval/75", "response": "To implement the function `is_multiply_prime(a)`, we need to follow these steps:\n\n1. **Identify Prime Numbers**: We need a way to determine if a number is prime and to generate a list of prime numbers less than 100.\n\n2. **Check Multiplication of Three Primes**: We will check combinations of three prime numbers to see if their product equals the given number `a`.\n\n3. **Return the Result**: The function should return `True` if `a` can be expressed as the product of three prime numbers, and `False` otherwise.\n\nHere\u2019s the complete implementation of the function along with comments explaining each part:\n\n```python\ndef is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef generate_primes(limit):\n    \"\"\"Generate a list of prime numbers up to a given limit.\"\"\"\n    return [num for num in range(2, limit) if is_prime(num)]\n\ndef is_multiply_prime(a):\n    \"\"\"Return True if the given number is the multiplication of 3 prime numbers, False otherwise.\"\"\"\n    if a < 1 or a >= 100:\n        raise ValueError(\"Input must be less than 100 and greater than 0.\")\n    \n    primes = generate_primes(100)  # Generate all prime numbers less than 100\n    prime_count = len(primes)\n    \n    # Check all combinations of three primes\n    for i in range(prime_count):\n        for j in range(i, prime_count):\n            for k in range(j, prime_count):\n                product = primes[i] * primes[j] * primes[k]\n                if product == a:\n                    return True\n                if product > a:  # No need to check further if product exceeds a\n                    break\n    \n    return False\n\n# Example usage and test cases\nprint(is_multiply_prime(30))  # Expected output: True (2 * 3 * 5)\nprint(is_multiply_prime(60))  # Expected output: True (2 * 3 * 10, but 10 is not prime, so False)\nprint(is_multiply_prime(1))   # Expected output: False (1 cannot be expressed as a product of primes)\nprint(is_multiply_prime(97))  # Expected output: False (97 is prime itself)\n```\n\n### Explanation of the Code:\n1. **is_prime(n)**: This helper function checks if a number `n` is prime.\n2. **generate_primes(limit)**: This function generates a list of all prime numbers less than the specified limit (100 in this case).\n3. **is_multiply_prime(a)**: This is the main function that checks if `a` can be expressed as the product of three prime numbers. It raises a `ValueError` if `a` is not in the valid range (1 to 99).\n\n### Edge Cases Handled:\n- The function checks if `a` is less than 1 or greater than or equal to 100 and raises an error if so.\n- It efficiently breaks out of loops if the product exceeds `a`, avoiding unnecessary calculations.\n\n### Testing:\nThe example usage demonstrates how to call the function and includes expected outputs for clarity. You can further expand the test cases to validate the function against various inputs.", "completion": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef generate_primes(limit):\n    \"\"\"Generate a list of prime numbers up to a given limit.\"\"\"\n    return [num for num in range(2, limit) if is_prime(num)]\n\ndef is_multiply_prime(a):\n    \"\"\"Return True if the given number is the multiplication of 3 prime numbers, False otherwise.\"\"\"\n    if a < 1 or a >= 100:\n        raise ValueError(\"Input must be less than 100 and greater than 0.\")\n    \n    primes = generate_primes(100)  # Generate all prime numbers less than 100\n    prime_count = len(primes)\n    \n    # Check all combinations of three primes\n    for i in range(prime_count):\n        for j in range(i, prime_count):\n            for k in range(j, prime_count):\n                product = primes[i] * primes[j] * primes[k]\n                if product == a:\n                    return True\n                if product > a:  # No need to check further if product exceeds a\n                    break\n    \n    return False\n\n# Example usage and test cases\nprint(is_multiply_prime(30))  # Expected output: True (2 * 3 * 5)\nprint(is_multiply_prime(60))  # Expected output: True (2 * 3 * 10, but 10 is not prime, so False)\nprint(is_multiply_prime(1))   # Expected output: False (1 cannot be expressed as a product of primes)\nprint(is_multiply_prime(97))  # Expected output: False (97 is prime itself)"}
{"task_id": "HumanEval/84", "response": "To implement the `solve` function as described, we need to follow these steps:\n\n1. **Calculate the sum of the digits of the integer N**.\n2. **Convert the sum into its binary representation**.\n3. **Return the binary representation as a string**.\n\nHere's the complete implementation of the `solve` function, along with comments to explain each part of the code:\n\n```python\ndef solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n    \n    # Ensure N is within the specified constraints\n    if not (0 <= N <= 10000):\n        raise ValueError(\"N must be between 0 and 10000 inclusive.\")\n    \n    # Calculate the sum of the digits of N\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to binary and remove the '0b' prefix\n    binary_representation = bin(digit_sum)[2:]\n    \n    return binary_representation\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    # Test cases\n    print(solve(1000))  # Output: \"1\"\n    print(solve(150))   # Output: \"110\"\n    print(solve(147))   # Output: \"1100\"\n```\n\n### Explanation of the Code:\n1. **Input Validation**: The function checks if `N` is within the valid range (0 to 10000). If not, it raises a `ValueError`.\n2. **Sum of Digits**: It converts `N` to a string to iterate over each digit, converts each character back to an integer, and sums them up using a generator expression.\n3. **Binary Conversion**: The sum of the digits is converted to binary using the `bin()` function, which returns a string prefixed with '0b'. We slice the string to remove this prefix.\n4. **Return Value**: The function returns the binary representation of the sum as a string.\n\n### Example Outputs:\n- For `N = 1000`, the sum of digits is `1`, and its binary representation is `\"1\"`.\n- For `N = 150`, the sum of digits is `6`, and its binary representation is `\"110\"`.\n- For `N = 147`, the sum of digits is `12`, and its binary representation is `\"1100\"`.\n\nThis implementation is efficient, clear, and adheres to best practices in Python programming.", "completion": "def solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n    \n    # Ensure N is within the specified constraints\n    if not (0 <= N <= 10000):\n        raise ValueError(\"N must be between 0 and 10000 inclusive.\")\n    \n    # Calculate the sum of the digits of N\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to binary and remove the '0b' prefix\n    binary_representation = bin(digit_sum)[2:]\n    \n    return binary_representation\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    # Test cases\n    print(solve(1000))  # Output: \"1\"\n    print(solve(150))   # Output: \"110\"\n    print(solve(147))   # Output: \"1100\""}
{"task_id": "HumanEval/32", "response": "To complete the `find_zero` function, we need to implement a method to find the root of the polynomial defined by the coefficients in the list `xs`. Since the coefficients are guaranteed to represent a polynomial with an even number of coefficients and the largest non-zero coefficient ensures a solution, we can use numerical methods to find the root.\n\nA common approach for finding roots of polynomials is to use the Newton-Raphson method or the bisection method. For simplicity and robustness, we can use the `scipy.optimize` library, which provides a convenient function called `fsolve` to find roots of equations.\n\nHere's the complete implementation of the `find_zero` function along with the necessary imports and comments for clarity:\n\n```python\nimport math\nfrom scipy.optimize import fsolve\n\ndef poly(xs: list, x: float) -> float:\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    Returns the value of the polynomial at x.\n    \n    Parameters:\n    xs (list): Coefficients of the polynomial, where xs[i] is the coefficient for x^i.\n    x (float): The point at which to evaluate the polynomial.\n    \n    Returns:\n    float: The value of the polynomial at x.\n    \"\"\"\n    return sum(coeff * math.pow(x, i) for i, coeff in enumerate(xs))\n\ndef find_zero(xs: list) -> float:\n    \"\"\"\n    Finds a root of the polynomial defined by coefficients xs.\n    \n    Parameters:\n    xs (list): Coefficients of the polynomial, must have an even number of coefficients.\n    \n    Returns:\n    float: A root of the polynomial.\n    \n    Raises:\n    ValueError: If the number of coefficients is not even.\n    \n    Examples:\n    >>> round(find_zero([1, 2]), 2)  # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2)  # (x - 1)(x - 2)(x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n    if len(xs) % 2 != 0:\n        raise ValueError(\"The number of coefficients must be even.\")\n    \n    # Define a function that represents the polynomial equation\n    def equation(x):\n        return poly(xs, x)\n    \n    # Use fsolve to find a root, starting from an initial guess (e.g., x=0)\n    root = fsolve(equation, 0)[0]\n    \n    return root\n\n# Example usage\nif __name__ == \"__main__\":\n    print(round(find_zero([1, 2]), 2))  # Output: -0.5\n    print(round(find_zero([-6, 11, -6, 1]), 2))  # Output: 1.0\n```\n\n### Explanation:\n1. **Imports**: We import `math` for mathematical operations and `fsolve` from `scipy.optimize` for root-finding.\n2. **poly Function**: This function evaluates the polynomial at a given point `x` using the coefficients provided in `xs`.\n3. **find_zero Function**:\n   - It checks if the number of coefficients is even and raises a `ValueError` if not.\n   - It defines an inner function `equation` that represents the polynomial equation we want to solve.\n   - It uses `fsolve` to find a root of the polynomial, starting from an initial guess of `0`.\n4. **Example Usage**: The code includes a main block to demonstrate how to use the `find_zero` function with example polynomials.\n\nThis implementation is robust, handles errors, and is well-documented for clarity.", "completion": "import math\nfrom scipy.optimize import fsolve\n\ndef poly(xs: list, x: float) -> float:\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    Returns the value of the polynomial at x.\n    \n    Parameters:\n    xs (list): Coefficients of the polynomial, where xs[i] is the coefficient for x^i.\n    x (float): The point at which to evaluate the polynomial.\n    \n    Returns:\n    float: The value of the polynomial at x.\n    \"\"\"\n    return sum(coeff * math.pow(x, i) for i, coeff in enumerate(xs))\n\ndef find_zero(xs: list) -> float:\n    \"\"\"\n    Finds a root of the polynomial defined by coefficients xs.\n    \n    Parameters:\n    xs (list): Coefficients of the polynomial, must have an even number of coefficients.\n    \n    Returns:\n    float: A root of the polynomial.\n    \n    Raises:\n    ValueError: If the number of coefficients is not even.\n    \n    Examples:\n    >>> round(find_zero([1, 2]), 2)  # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2)  # (x - 1)(x - 2)(x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n    if len(xs) % 2 != 0:\n        raise ValueError(\"The number of coefficients must be even.\")\n    \n    # Define a function that represents the polynomial equation\n    def equation(x):\n        return poly(xs, x)\n    \n    # Use fsolve to find a root, starting from an initial guess (e.g., x=0)\n    root = fsolve(equation, 0)[0]\n    \n    return root\n\n# Example usage\nif __name__ == \"__main__\":\n    print(round(find_zero([1, 2]), 2))  # Output: -0.5\n    print(round(find_zero([-6, 11, -6, 1]), 2))  # Output: 1.0"}
{"task_id": "HumanEval/94", "response": "To solve the problem of finding the largest prime number in a list of integers and returning the sum of its digits, we can break down the task into several steps:\n\n1. **Identify Prime Numbers**: We need a function to check if a number is prime.\n2. **Find the Largest Prime**: Iterate through the list to find the largest prime number.\n3. **Sum the Digits**: Once we have the largest prime, we will calculate the sum of its digits.\n4. **Handle Edge Cases**: We should consider cases where there are no prime numbers in the list.\n\nHere\u2019s the complete Python code that implements the above logic:\n\n```python\ndef is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sum_of_digits(n):\n    \"\"\"Calculate the sum of the digits of a number.\"\"\"\n    return sum(int(digit) for digit in str(n))\n\ndef largest_prime_digit_sum(lst):\n    \"\"\"Find the largest prime in the list and return the sum of its digits.\"\"\"\n    largest_prime = None\n    \n    # Iterate through the list to find the largest prime\n    for number in lst:\n        if is_prime(number):\n            if largest_prime is None or number > largest_prime:\n                largest_prime = number\n    \n    # If no prime number was found, return 0 or an appropriate value\n    if largest_prime is None:\n        return 0\n    \n    # Calculate and return the sum of the digits of the largest prime\n    return sum_of_digits(largest_prime)\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    test_cases = [\n        ([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3], 10),\n        ([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1], 25),\n        ([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3], 13),\n        ([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6], 11),\n        ([0, 81, 12, 3, 1, 21], 3),\n        ([0, 8, 1, 2, 1, 7], 7),\n    ]\n    \n    for lst, expected in test_cases:\n        result = largest_prime_digit_sum(lst)\n        assert result == expected, f\"Test failed for {lst}: expected {expected}, got {result}\"\n    \n    print(\"All tests passed!\")\n```\n\n### Explanation of the Code:\n- **is_prime(n)**: This function checks if a number `n` is prime by testing divisibility from 2 up to the square root of `n`.\n- **sum_of_digits(n)**: This function calculates the sum of the digits of the number `n` by converting it to a string, iterating over each character, converting it back to an integer, and summing them up.\n- **largest_prime_digit_sum(lst)**: This function iterates through the list `lst`, finds the largest prime number, and returns the sum of its digits. If no prime is found, it returns 0.\n- **Test Cases**: The code includes a set of test cases to validate the functionality of the implementation.\n\nThis code is structured, efficient, and includes error handling for cases where no prime numbers are present.", "completion": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sum_of_digits(n):\n    \"\"\"Calculate the sum of the digits of a number.\"\"\"\n    return sum(int(digit) for digit in str(n))\n\ndef largest_prime_digit_sum(lst):\n    \"\"\"Find the largest prime in the list and return the sum of its digits.\"\"\"\n    largest_prime = None\n    \n    # Iterate through the list to find the largest prime\n    for number in lst:\n        if is_prime(number):\n            if largest_prime is None or number > largest_prime:\n                largest_prime = number\n    \n    # If no prime number was found, return 0 or an appropriate value\n    if largest_prime is None:\n        return 0\n    \n    # Calculate and return the sum of the digits of the largest prime\n    return sum_of_digits(largest_prime)\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    test_cases = [\n        ([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3], 10),\n        ([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1], 25),\n        ([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3], 13),\n        ([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6], 11),\n        ([0, 81, 12, 3, 1, 21], 3),\n        ([0, 8, 1, 2, 1, 7], 7),\n    ]\n    \n    for lst, expected in test_cases:\n        result = largest_prime_digit_sum(lst)\n        assert result == expected, f\"Test failed for {lst}: expected {expected}, got {result}\"\n    \n    print(\"All tests passed!\")"}
{"task_id": "HumanEval/93", "response": "To implement the `encode` function as described, we will follow these steps:\n\n1. **Swap the case** of each letter in the message.\n2. **Replace vowels** (a, e, i, o, u) with the letter that appears two places ahead in the English alphabet. For example:\n   - 'a' becomes 'c'\n   - 'e' becomes 'g'\n   - 'i' becomes 'k'\n   - 'o' becomes 'q'\n   - 'u' becomes 'w'\n3. **Return the modified message**.\n\nWe will also include error handling to ensure that the input is a string and add comments to explain the code. Here\u2019s the complete implementation:\n\n```python\ndef encode(message):\n    \"\"\"\n    Encodes a message by swapping the case of all letters and replacing\n    all vowels with the letter that appears two places ahead in the English alphabet.\n\n    Parameters:\n    message (str): The input message to encode.\n\n    Returns:\n    str: The encoded message.\n\n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n    # Define a mapping for vowels to their corresponding letters\n    vowel_replacement = {\n        'a': 'c', 'A': 'C',\n        'e': 'g', 'E': 'G',\n        'i': 'k', 'I': 'K',\n        'o': 'q', 'O': 'Q',\n        'u': 'w', 'U': 'W'\n    }\n    \n    # Initialize an empty list to build the encoded message\n    encoded_message = []\n    \n    # Iterate through each character in the message\n    for char in message:\n        if char.isalpha():  # Check if the character is a letter\n            # Swap case\n            swapped_case = char.swapcase()\n            # Replace vowel if it is one\n            if swapped_case in vowel_replacement:\n                encoded_message.append(vowel_replacement[swapped_case])\n            else:\n                encoded_message.append(swapped_case)\n        else:\n            # If it's not a letter, we can choose to keep it as is\n            encoded_message.append(char)\n    \n    # Join the list into a single string and return\n    return ''.join(encoded_message)\n\n# Example usage\nif __name__ == \"__main__\":\n    print(encode('test'))  # Output: 'TGST'\n    print(encode('This is a message'))  # Output: 'tHKS KS C MGSSCGG'\n```\n\n### Explanation:\n- We define a dictionary `vowel_replacement` to map each vowel to its corresponding letter that is two places ahead.\n- We iterate through each character in the input `message`. If the character is a letter, we swap its case and check if it is a vowel. If it is, we replace it using our mapping; otherwise, we just append the swapped case character.\n- Non-letter characters are appended to the result without modification.\n- Finally, we join the list of characters into a single string and return it.\n\n### Testing:\nYou can test the function using the provided examples to ensure it behaves as expected. The function is designed to handle any string input containing letters and spaces.", "completion": "def encode(message):\n    \"\"\"\n    Encodes a message by swapping the case of all letters and replacing\n    all vowels with the letter that appears two places ahead in the English alphabet.\n\n    Parameters:\n    message (str): The input message to encode.\n\n    Returns:\n    str: The encoded message.\n\n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n    # Define a mapping for vowels to their corresponding letters\n    vowel_replacement = {\n        'a': 'c', 'A': 'C',\n        'e': 'g', 'E': 'G',\n        'i': 'k', 'I': 'K',\n        'o': 'q', 'O': 'Q',\n        'u': 'w', 'U': 'W'\n    }\n    \n    # Initialize an empty list to build the encoded message\n    encoded_message = []\n    \n    # Iterate through each character in the message\n    for char in message:\n        if char.isalpha():  # Check if the character is a letter\n            # Swap case\n            swapped_case = char.swapcase()\n            # Replace vowel if it is one\n            if swapped_case in vowel_replacement:\n                encoded_message.append(vowel_replacement[swapped_case])\n            else:\n                encoded_message.append(swapped_case)\n        else:\n            # If it's not a letter, we can choose to keep it as is\n            encoded_message.append(char)\n    \n    # Join the list into a single string and return\n    return ''.join(encoded_message)\n\n# Example usage\nif __name__ == \"__main__\":\n    print(encode('test'))  # Output: 'TGST'\n    print(encode('This is a message'))  # Output: 'tHKS KS C MGSSCGG'"}
{"task_id": "HumanEval/83", "response": "To implement the function `starts_one_ends(n)`, we need to count the n-digit positive integers that either start with the digit '1' or end with the digit '1'. \n\n### Requirements:\n1. **n-digit Positive Integers**: The range of n-digit integers is from \\(10^{(n-1)}\\) to \\(10^n - 1\\).\n2. **Starting with '1'**: The n-digit integers that start with '1' are from \\(10^{(n-1)}\\) to \\(2 \\times 10^{(n-1)} - 1\\).\n3. **Ending with '1'**: The n-digit integers that end with '1' can be calculated by considering all n-digit integers and counting those that end with '1'.\n\n### Steps to Calculate:\n- Count the n-digit integers that start with '1'.\n- Count the n-digit integers that end with '1'.\n- Use the principle of inclusion-exclusion to avoid double counting those integers that both start and end with '1'.\n\n### Implementation:\nHere\u2019s how we can implement this in Python:\n\n```python\ndef starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \n    Parameters:\n    n (int): The number of digits in the positive integers to consider.\n    \n    Returns:\n    int: The count of n-digit integers that start or end with 1.\n    \"\"\"\n    \n    if n < 1:\n        raise ValueError(\"n must be a positive integer.\")\n    \n    # Count of n-digit integers that start with '1'\n    start_with_1_count = 10 ** (n - 1)  # From 10^(n-1) to 2*10^(n-1) - 1\n    \n    # Count of n-digit integers that end with '1'\n    end_with_1_count = 10 ** (n - 1)  # There are 10^(n-1) choices for the first (n-1) digits\n    \n    # Count of n-digit integers that start and end with '1'\n    start_and_end_with_1_count = 10 ** (n - 2) if n > 1 else 0  # Only valid if n > 1\n    \n    # Using inclusion-exclusion principle\n    total_count = start_with_1_count + end_with_1_count - start_and_end_with_1_count\n    \n    return total_count\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    # Test cases\n    print(starts_one_ends(1))  # Should return 1 (only the number 1)\n    print(starts_one_ends(2))  # Should return 19 (10-19 and 11, 21)\n    print(starts_one_ends(3))  # Should return 190 (100-199 and 101, 111, ..., 191)\n```\n\n### Explanation:\n- The function first checks if `n` is a positive integer.\n- It calculates the count of n-digit integers that start with '1' and those that end with '1'.\n- It also calculates the count of integers that both start and end with '1' to avoid double counting.\n- Finally, it returns the total count using the inclusion-exclusion principle.\n\n### Edge Cases:\n- The function raises a `ValueError` if `n` is less than 1, ensuring robustness.\n- The logic for counting integers that start and end with '1' is adjusted based on the value of `n`.\n\nThis implementation is efficient and follows best practices for clarity and maintainability.", "completion": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \n    Parameters:\n    n (int): The number of digits in the positive integers to consider.\n    \n    Returns:\n    int: The count of n-digit integers that start or end with 1.\n    \"\"\"\n    \n    if n < 1:\n        raise ValueError(\"n must be a positive integer.\")\n    \n    # Count of n-digit integers that start with '1'\n    start_with_1_count = 10 ** (n - 1)  # From 10^(n-1) to 2*10^(n-1) - 1\n    \n    # Count of n-digit integers that end with '1'\n    end_with_1_count = 10 ** (n - 1)  # There are 10^(n-1) choices for the first (n-1) digits\n    \n    # Count of n-digit integers that start and end with '1'\n    start_and_end_with_1_count = 10 ** (n - 2) if n > 1 else 0  # Only valid if n > 1\n    \n    # Using inclusion-exclusion principle\n    total_count = start_with_1_count + end_with_1_count - start_and_end_with_1_count\n    \n    return total_count\n\n# Example usage and test cases\nif __name__ == \"__main__\":\n    # Test cases\n    print(starts_one_ends(1))  # Should return 1 (only the number 1)\n    print(starts_one_ends(2))  # Should return 19 (10-19 and 11, 21)\n    print(starts_one_ends(3))  # Should return 190 (100-199 and 101, 111, ..., 191)"}
