{"task_id": "auto/7", "completion": "from typing import List\n\ndef calculate_mean(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the mean (average) of a list of numbers.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n    float: The mean of the numbers in the list. If the list is empty, returns 0.0.\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        return 0.0  # Return 0.0 for an empty list to avoid division by zero\n\n    total_sum = sum(numbers)  # Calculate the sum of the numbers\n    count = len(numbers)  # Get the count of numbers\n    mean = total_sum / count  # Calculate the mean\n    return mean  # Return the calculated mean\n\n# Test cases to validate the functionality of the calculate_mean function\nif __name__ == \"__main__\":\n    # Test case 1: Normal case with positive numbers\n    assert calculate_mean([1.0, 2.0, 3.0, 4.0, 5.0]) == 3.0, \"Test case 1 failed\"\n\n    # Test case 2: Normal case with negative numbers\n    assert calculate_mean([-1.0, -2.0, -3.0]) == -2.0, \"Test case 2 failed\"\n\n    # Test case 3: Mixed positive and negative numbers\n    assert calculate_mean([-1.0, 0.0, 1.0]) == 0.0, \"Test case 3 failed\"\n\n    # Test case 4: Single number\n    assert calculate_mean([5.0]) == 5.0, \"Test case 4 failed\"\n\n    # Test case 5: Empty list\n    assert calculate_mean([]) == 0.0, \"Test case 5 failed\"\n\n    # Test case 6: Large numbers\n    assert calculate_mean([1e6, 2e6, 3e6]) == 2e6, \"Test case 6 failed\"\n\n    print(\"All test cases passed!\")"}
{"task_id": "auto/9", "completion": "from typing import List\n\ndef count_negative_numbers(nums: List[int]) -> int:\n    \"\"\"Count the number of negative integers in a given list of integers.\n    \n    Args:\n        nums (List[int]): A list of integers.\n        \n    Returns:\n        int: The count of negative integers in the list.\n    \n    Examples:\n    >>> count_negative_numbers([-1, 2, -3, 4, -5, 6])\n    3\n    >>> count_negative_numbers([1, 2, 3, 4, 5, 6])\n    0\n    >>> count_negative_numbers([-10, -20, 0, 10, 20])\n    2\n    >>> count_negative_numbers([])\n    0\n    \"\"\"\n    return sum(1 for num in nums if num < 0)\n\n# Test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "auto/1", "completion": "from typing import List\n\ndef count_consecutive_zeros(nums: List[int]) -> int:\n    \"\"\"\n    Count the maximum number of consecutive zeros in a list of integers.\n\n    Args:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The maximum count of consecutive zeros.\n    \"\"\"\n    max_count = 0  # To keep track of the maximum count of consecutive zeros\n    current_count = 0  # To count the current streak of zeros\n\n    for num in nums:\n        if num == 0:\n            current_count += 1  # Increment the count for consecutive zeros\n        else:\n            max_count = max(max_count, current_count)  # Update max_count if needed\n            current_count = 0  # Reset current_count for the next sequence\n\n    # Final check in case the list ends with zeros\n    max_count = max(max_count, current_count)\n\n    return max_count\n\n# Test cases to validate the functionality of the count_consecutive_zeros function\nif __name__ == \"__main__\":\n    # Test case 1: No zeros\n    print(count_consecutive_zeros([1, 2, 3, 4]))  # Expected output: 0\n\n    # Test case 2: Zeros at the beginning\n    print(count_consecutive_zeros([0, 0, 1, 2, 0]))  # Expected output: 2\n\n    # Test case 3: Zeros at the end\n    print(count_consecutive_zeros([1, 2, 0, 0, 0]))  # Expected output: 3\n\n    # Test case 4: Zeros in the middle\n    print(count_consecutive_zeros([1, 0, 0, 2, 0, 0, 0, 3]))  # Expected output: 3\n\n    # Test case 5: All zeros\n    print(count_consecutive_zeros([0, 0, 0, 0]))  # Expected output: 4\n\n    # Test case 6: Mixed numbers with no consecutive zeros\n    print(count_consecutive_zeros([1, 2, 3, 4, 5]))  # Expected output: 0\n\n    # Test case 7: Single zero\n    print(count_consecutive_zeros([0]))  # Expected output: 1\n\n    # Test case 8: Multiple groups of zeros\n    print(count_consecutive_zeros([0, 1, 0, 0, 2, 0, 0, 0, 3]))  # Expected output: 3"}
{"task_id": "auto/5", "completion": "from typing import List\n\ndef reverse_sublists(data: List[int], chunk_size: int) -> List[int]:\n    \"\"\"\n    Reverses the elements of the input list in chunks of specified size.\n\n    Parameters:\n    data (List[int]): The list of integers to be processed.\n    chunk_size (int): The size of each chunk to reverse.\n\n    Returns:\n    List[int]: A new list with the elements reversed in chunks.\n    \"\"\"\n    if chunk_size <= 0:\n        raise ValueError(\"chunk_size must be a positive integer\")\n    \n    reversed_list = []\n    \n    # Process the list in chunks\n    for i in range(0, len(data), chunk_size):\n        # Get the current chunk\n        chunk = data[i:i + chunk_size]\n        # Reverse the current chunk and add to the result\n        reversed_list.extend(reversed(chunk))\n    \n    return reversed_list\n\n# Example usage\nif __name__ == \"__main__\":\n    data = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    chunk_size = 3\n    result = reverse_sublists(data, chunk_size)\n    print(result)  # Output: [3, 2, 1, 6, 5, 4, 9, 8, 7]"}
{"task_id": "auto/2", "completion": "from typing import List\n\ndef sum_negative_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Sums all negative numbers in the provided list of integers.\n\n    Parameters:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    int: The sum of all negative integers in the list. If there are no negative integers, returns 0.\n    \"\"\"\n    # Initialize a variable to hold the sum of negative numbers\n    negative_sum = 0\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        # Check if the number is negative\n        if number < 0:\n            # Add the negative number to the sum\n            negative_sum += number\n            \n    return negative_sum\n\n# Test cases to validate the functionality of the sum_negative_numbers function\nif __name__ == \"__main__\":\n    # Test case 1: A mix of positive and negative numbers\n    print(sum_negative_numbers([1, -2, 3, -4, 5]))  # Expected output: -6\n\n    # Test case 2: All positive numbers\n    print(sum_negative_numbers([1, 2, 3, 4, 5]))    # Expected output: 0\n\n    # Test case 3: All negative numbers\n    print(sum_negative_numbers([-1, -2, -3, -4, -5]))  # Expected output: -15\n\n    # Test case 4: No numbers\n    print(sum_negative_numbers([]))                    # Expected output: 0\n\n    # Test case 5: Mixed with zero\n    print(sum_negative_numbers([-1, 0, 1, -2, 2]))    # Expected output: -3"}
{"task_id": "auto/8", "completion": "from typing import List\n\ndef find_max_consecutive_ones(nums: List[int]) -> int:\n    \"\"\"\n    This function finds the maximum number of consecutive 1's in a binary list.\n\n    :param nums: List[int] - A list of integers (0's and 1's)\n    :return: int - The maximum count of consecutive 1's\n    \"\"\"\n    max_count = 0  # To keep track of the maximum count of consecutive 1's\n    current_count = 0  # To count the current streak of 1's\n\n    for num in nums:\n        if num == 1:\n            current_count += 1  # Increment the count for consecutive 1's\n        else:\n            max_count = max(max_count, current_count)  # Update max_count if needed\n            current_count = 0  # Reset current count for 0's\n\n    # Final check to update max_count in case the list ends with 1's\n    max_count = max(max_count, current_count)\n\n    return max_count\n\n# Test cases to validate the functionality of the function\nif __name__ == \"__main__\":\n    # Test case 1: Basic test with mixed 0's and 1's\n    print(find_max_consecutive_ones([1, 1, 0, 1, 1, 1]))  # Expected output: 3\n\n    # Test case 2: All 1's\n    print(find_max_consecutive_ones([1, 1, 1, 1]))  # Expected output: 4\n\n    # Test case 3: All 0's\n    print(find_max_consecutive_ones([0, 0, 0, 0]))  # Expected output: 0\n\n    # Test case 4: No consecutive 1's\n    print(find_max_consecutive_ones([1, 0, 1, 0, 1]))  # Expected output: 1\n\n    # Test case 5: Mixed with varying lengths of 1's\n    print(find_max_consecutive_ones([1, 1, 0, 1, 1, 1, 0, 1, 1]))  # Expected output: 3"}
{"task_id": "auto/6", "completion": "from typing import List\n\ndef count_elements(numbers: List[int], target: int) -> int:\n    \"\"\"\n    Count the occurrences of a target integer in a list of integers.\n\n    Parameters:\n    numbers (List[int]): A list of integers to search through.\n    target (int): The integer to count in the list.\n\n    Returns:\n    int: The count of occurrences of the target integer in the list.\n    \"\"\"\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        # If the current number matches the target, increment the counter\n        if number == target:\n            count += 1\n            \n    return count\n\n# Test cases to validate the functionality of the count_elements function\nif __name__ == \"__main__\":\n    # Test case 1: Basic test with multiple occurrences\n    assert count_elements([1, 2, 3, 4, 2, 2], 2) == 3, \"Test case 1 failed\"\n    \n    # Test case 2: Target not in the list\n    assert count_elements([1, 2, 3, 4], 5) == 0, \"Test case 2 failed\"\n    \n    # Test case 3: Target is the only element in the list\n    assert count_elements([5], 5) == 1, \"Test case 3 failed\"\n    \n    # Test case 4: Empty list\n    assert count_elements([], 1) == 0, \"Test case 4 failed\"\n    \n    # Test case 5: All elements are the target\n    assert count_elements([7, 7, 7, 7], 7) == 4, \"Test case 5 failed\"\n    \n    # Test case 6: Negative numbers\n    assert count_elements([-1, -2, -3, -1, -1], -1) == 3, \"Test case 6 failed\"\n    \n    print(\"All test cases passed!\")"}
{"task_id": "auto/3", "completion": "from typing import List\n\ndef find_missing_number(nums: List[int]) -> int:\n    \"\"\"\n    Find the missing number in a list of integers from 0 to n.\n    \n    Args:\n    nums (List[int]): A list of integers containing n distinct numbers in the range [0, n].\n    \n    Returns:\n    int: The missing number.\n    \"\"\"\n    n = len(nums)  # The length of the list is n, meaning numbers should be from 0 to n\n    expected_sum = n * (n + 1) // 2  # Sum of first n natural numbers\n    actual_sum = sum(nums)  # Sum of the numbers present in the list\n    \n    # The missing number is the difference between expected and actual sums\n    missing_number = expected_sum - actual_sum\n    return missing_number\n\n# Test cases to validate the functionality of the function\nif __name__ == \"__main__\":\n    # Test case 1: Missing number is 2\n    assert find_missing_number([0, 1, 3]) == 2\n    # Test case 2: Missing number is 0\n    assert find_missing_number([1, 2, 3]) == 0\n    # Test case 3: Missing number is 4\n    assert find_missing_number([0, 1, 2, 3]) == 4\n    # Test case 4: Missing number is 1\n    assert find_missing_number([0]) == 1\n    # Test case 5: Missing number is 3\n    assert find_missing_number([0, 1, 2, 4]) == 3\n    \n    print(\"All test cases passed!\")"}
{"task_id": "auto/4", "completion": "from typing import List\n\ndef find_duplicates(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Find and return a list of duplicate numbers from the input list.\n    \n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n    \n    Returns:\n    List[float]: A list of duplicate numbers found in the input list.\n    \"\"\"\n    seen = set()        # Set to track seen numbers\n    duplicates = set()  # Set to track duplicates\n\n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)  # Add to duplicates if already seen\n        else:\n            seen.add(number)        # Add to seen if not seen before\n\n    return list(duplicates)  # Convert duplicates set to a list and return\n\n# Test cases to validate the functionality of the find_duplicates function\nif __name__ == \"__main__\":\n    # Test case 1: Basic duplicates\n    print(find_duplicates([1.0, 2.0, 3.0, 2.0, 1.0]))  # Expected output: [1.0, 2.0]\n\n    # Test case 2: No duplicates\n    print(find_duplicates([1.0, 2.0, 3.0]))  # Expected output: []\n\n    # Test case 3: All duplicates\n    print(find_duplicates([1.0, 1.0, 1.0, 1.0]))  # Expected output: [1.0]\n\n    # Test case 4: Mixed types of duplicates\n    print(find_duplicates([1.0, 2.0, 3.0, 1.0, 2.0, 4.0]))  # Expected output: [1.0, 2.0]\n\n    # Test case 5: Empty list\n    print(find_duplicates([]))  # Expected output: []"}
{"task_id": "auto/0", "completion": "from typing import List\n\ndef find_duplicates(strings: List[str]) -> List[str]:\n    \"\"\"\n    This function takes a list of strings and returns a list of duplicate strings.\n    \n    Parameters:\n    strings (List[str]): A list of strings to check for duplicates.\n    \n    Returns:\n    List[str]: A list containing the duplicate strings found in the input list.\n    \"\"\"\n    seen = set()  # Set to track seen strings\n    duplicates = []  # List to store duplicates\n\n    for string in strings:\n        if string in seen:\n            # If the string is already in seen, it's a duplicate\n            if string not in duplicates:\n                duplicates.append(string)  # Add to duplicates if not already added\n        else:\n            seen.add(string)  # Add the string to seen set\n\n    return duplicates\n\n# Test cases to validate the functionality of the find_duplicates function\nif __name__ == \"__main__\":\n    # Test case 1: Basic duplicates\n    print(find_duplicates([\"apple\", \"banana\", \"apple\", \"orange\", \"banana\"]))  # Expected: ['apple', 'banana']\n    \n    # Test case 2: No duplicates\n    print(find_duplicates([\"cat\", \"dog\", \"fish\"]))  # Expected: []\n    \n    # Test case 3: All duplicates\n    print(find_duplicates([\"a\", \"a\", \"a\", \"a\"]))  # Expected: ['a']\n    \n    # Test case 4: Mixed case duplicates\n    print(find_duplicates([\"Hello\", \"hello\", \"HELLO\", \"hello\"]))  # Expected: ['hello']\n    \n    # Test case 5: Empty list\n    print(find_duplicates([]))  # Expected: []\n    \n    # Test case 6: Large input with duplicates\n    large_input = [\"item\" + str(i) for i in range(1000)] + [\"item\" + str(i) for i in range(500)]\n    print(find_duplicates(large_input))  # Expected: ['item0', 'item1', ..., 'item499']"}
{"task_id": "HumanEval/65", "completion": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    \n    >>> circular_shift(12, 1)\n    '21'\n    >>> circular_shift(12, 2)\n    '12'\n    >>> circular_shift(12345, 1)\n    '51234'\n    >>> circular_shift(12345, 5)\n    '54321'\n    >>> circular_shift(12345, 6)\n    '54321'\n    \"\"\"\n    # Convert the integer to a string to manipulate digits\n    str_x = str(x)\n    length = len(str_x)\n    \n    # Calculate effective shift\n    effective_shift = shift % length\n    \n    # If effective shift is 0, return the original string\n    if effective_shift == 0:\n        return str_x\n    \n    # Perform the circular shift\n    shifted = str_x[-effective_shift:] + str_x[:-effective_shift]\n    \n    return shifted\n\n# Test cases\nif __name__ == \"__main__\":\n    print(circular_shift(12, 1))  # Expected: '21'\n    print(circular_shift(12, 2))  # Expected: '12'\n    print(circular_shift(12345, 1))  # Expected: '51234'\n    print(circular_shift(12345, 5))  # Expected: '54321'\n    print(circular_shift(12345, 6))  # Expected: '54321'"}
{"task_id": "HumanEval/77", "completion": "def iscube(a):\n    '''\n    Check if the given integer a is a perfect cube.\n    \n    Parameters:\n    a (int): The integer to check.\n    \n    Returns:\n    bool: True if a is a perfect cube, False otherwise.\n    \n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n    # Calculate the cube root of the absolute value of a\n    cube_root = round(abs(a) ** (1/3))\n    \n    # Check if the cube of the rounded cube root equals the absolute value of a\n    return cube_root ** 3 == abs(a)\n\n# Test cases to validate the functionality of the iscube function\ndef test_iscube():\n    assert iscube(1) == True, \"Test case 1 failed\"\n    assert iscube(2) == False, \"Test case 2 failed\"\n    assert iscube(-1) == True, \"Test case 3 failed\"\n    assert iscube(64) == True, \"Test case 4 failed\"\n    assert iscube(0) == True, \"Test case 5 failed\"\n    assert iscube(180) == False, \"Test case 6 failed\"\n    assert iscube(-27) == True, \"Test case 7 failed\"\n    assert iscube(729) == True, \"Test case 8 failed\"\n    assert iscube(-1000) == True, \"Test case 9 failed\"\n    assert iscube(1001) == False, \"Test case 10 failed\"\n    \n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_iscube()"}
{"task_id": "HumanEval/32", "completion": "import math\nfrom scipy.optimize import bisect\n\ndef poly(xs: list, x: float) -> float:\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    \n    Args:\n        xs (list): Coefficients of the polynomial, where xs[i] is the coefficient for x^i.\n        x (float): The point at which to evaluate the polynomial.\n    \n    Returns:\n        float: The value of the polynomial at x.\n    \"\"\"\n    return sum(coeff * math.pow(x, i) for i, coeff in enumerate(xs))\n\ndef find_zero(xs: list) -> float:\n    \"\"\"\n    Finds a root of the polynomial defined by coefficients xs.\n    \n    Args:\n        xs (list): Coefficients of the polynomial, must have an even number of coefficients.\n    \n    Returns:\n        float: A root of the polynomial.\n    \n    Raises:\n        ValueError: If the number of coefficients is not even or if no root is found.\n    \n    Examples:\n        >>> round(find_zero([1, 2]), 2)  # f(x) = 1 + 2x\n        -0.5\n        >>> round(find_zero([-6, 11, -6, 1]), 2)  # (x - 1) * (x - 2) * (x - 3)\n        1.0\n    \"\"\"\n    if len(xs) % 2 != 0:\n        raise ValueError(\"The number of coefficients must be even.\")\n    \n    # Define a function for the root-finding algorithm\n    def f(x):\n        return poly(xs, x)\n    \n    # Use the bisection method to find a root\n    # We need to find an interval where the function changes sign\n    # We can start with a reasonable interval, e.g., [-100, 100]\n    root = bisect(f, -100, 100)\n    return root\n\n# Test cases\nif __name__ == \"__main__\":\n    print(round(find_zero([1, 2]), 2))  # Expected output: -0.5\n    print(round(find_zero([-6, 11, -6, 1]), 2))  # Expected output: 1.0"}
{"task_id": "HumanEval/84", "completion": "def solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n    # Step 1: Convert N to string to iterate over each digit\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Step 2: Convert the sum to binary and remove the '0b' prefix\n    binary_sum = bin(digit_sum)[2:]\n    \n    return binary_sum\n\n# Test cases to validate the functionality of the solve function\nif __name__ == \"__main__\":\n    print(solve(1000))  # Expected output: \"1\"\n    print(solve(150))   # Expected output: \"110\"\n    print(solve(147))   # Expected output: \"1100\"\n    print(solve(0))     # Expected output: \"0\" (sum of digits is 0)\n    print(solve(9999))  # Expected output: \"100\" (sum of digits is 36, which is 100100 in binary)"}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    Calculate the number of collisions between two sets of cars\n    moving in opposite directions on a straight road.\n\n    Parameters:\n    n (int): The number of cars in each direction.\n\n    Returns:\n    int: The total number of collisions.\n    \"\"\"\n    # Each car moving left to right will collide with each car moving right to left\n    total_collisions = n * n\n    return total_collisions\n\n# Test cases to validate the functionality of the car_race_collision function\nif __name__ == \"__main__\":\n    # Test case 1: 1 car in each direction\n    assert car_race_collision(1) == 1, \"Test case 1 failed\"\n    \n    # Test case 2: 2 cars in each direction\n    assert car_race_collision(2) == 4, \"Test case 2 failed\"\n    \n    # Test case 3: 3 cars in each direction\n    assert car_race_collision(3) == 9, \"Test case 3 failed\"\n    \n    # Test case 4: 0 cars in each direction (no collisions)\n    assert car_race_collision(0) == 0, \"Test case 4 failed\"\n    \n    # Test case 5: 10 cars in each direction\n    assert car_race_collision(10) == 100, \"Test case 5 failed\"\n    \n    print(\"All test cases passed!\")"}
{"task_id": "HumanEval/10", "completion": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    # If the input string is empty, return it as is\n    if not string:\n        return string\n    \n    # Find the longest palindromic suffix\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            # The prefix that needs to be reversed and appended\n            prefix_to_append = string[:i]\n            # Create the palindrome by appending the reverse of the prefix\n            return string + prefix_to_append[::-1]\n    \n    # If no palindromic suffix is found, the whole string is the prefix\n    return string + string[:-1][::-1]  # This case handles single character strings\n\n# Test cases to validate the functionality\nif __name__ == \"__main__\":\n    print(make_palindrome(''))        # Output: ''\n    print(make_palindrome('cat'))     # Output: 'catac'\n    print(make_palindrome('cata'))    # Output: 'catac'\n    print(make_palindrome('race'))     # Output: 'racecar'\n    print(make_palindrome('a'))       # Output: 'a'\n    print(make_palindrome('ab'))      # Output: 'aba'"}
{"task_id": "HumanEval/83", "completion": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \n    Parameters:\n    n (int): The number of digits in the positive integers.\n    \n    Returns:\n    int: The count of n-digit positive integers that start or end with 1.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer.\")\n    \n    if n == 1:\n        return 1  # The only 1-digit number is '1'\n    \n    # Count of n-digit numbers starting with '1'\n    start_with_1 = 10 ** (n - 1)\n    \n    # Count of n-digit numbers ending with '1'\n    end_with_1 = 9 * (10 ** (n - 2))\n    \n    # Count of n-digit numbers starting and ending with '1'\n    start_and_end_with_1 = 10 ** (n - 2)\n    \n    # Total count\n    total_count = start_with_1 + end_with_1 - start_and_end_with_1\n    \n    return total_count\n\n# Test cases\nprint(starts_one_ends(1))  # Output: 1\nprint(starts_one_ends(2))  # Output: 18\nprint(starts_one_ends(3))  # Output: 271\nprint(starts_one_ends(4))  # Output: 3881"}
{"task_id": "HumanEval/75", "completion": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef generate_primes(limit):\n    \"\"\"Generate a list of prime numbers up to a given limit.\"\"\"\n    return [num for num in range(2, limit) if is_prime(num)]\n\ndef is_multiply_prime(a):\n    \"\"\"Return True if the given number is the multiplication of 3 prime numbers, False otherwise.\n    \n    Args:\n        a (int): The number to check, must be less than 100.\n    \n    Returns:\n        bool: True if a is the product of 3 prime numbers, False otherwise.\n    \"\"\"\n    if a >= 100:\n        raise ValueError(\"Input must be less than 100.\")\n    \n    primes = generate_primes(100)\n    \n    # Check all combinations of three primes\n    for i in range(len(primes)):\n        for j in range(i, len(primes)):\n            for k in range(j, len(primes)):\n                product = primes[i] * primes[j] * primes[k]\n                if product == a:\n                    return True\n                if product > a:  # No need to check further if product exceeds a\n                    break\n    return False\n\n# Test cases\nprint(is_multiply_prime(30))  # True, because 2 * 3 * 5 = 30\nprint(is_multiply_prime(60))  # True, because 2 * 3 * 10 = 60 (10 is not prime, so False)\nprint(is_multiply_prime(42))  # True, because 2 * 3 * 7 = 42\nprint(is_multiply_prime(1))   # False, no product of three primes can be 1\nprint(is_multiply_prime(97))  # False, 97 is prime but not a product of three primes\nprint(is_multiply_prime(70))  # False, no combination of three primes gives 70"}
{"task_id": "HumanEval/94", "completion": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sum_of_digits(n):\n    \"\"\"Return the sum of the digits of a number.\"\"\"\n    return sum(int(digit) for digit in str(n))\n\ndef skjkasdkd(lst):\n    \"\"\"Find the largest prime value in the list and return the sum of its digits.\"\"\"\n    largest_prime = None\n    \n    for number in lst:\n        if is_prime(number):\n            if largest_prime is None or number > largest_prime:\n                largest_prime = number\n    \n    if largest_prime is not None:\n        return sum_of_digits(largest_prime)\n    else:\n        return 0  # Return 0 if no prime number is found\n\n# Test cases\nprint(skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))  # Output: 10\nprint(skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))  # Output: 25\nprint(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]))  # Output: 13\nprint(skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]))  # Output: 11\nprint(skjkasdkd([0, 81, 12, 3, 1, 21]))  # Output: 3\nprint(skjkasdkd([0, 8, 1, 2, 1, 7]))  # Output: 7"}
{"task_id": "HumanEval/93", "completion": "def encode(message):\n    \"\"\"\n    Encodes a message by swapping the case of all letters and replacing\n    all vowels with the letter that appears two places ahead in the English alphabet.\n    \n    Vowels are defined as 'a', 'e', 'i', 'o', 'u' (and their uppercase counterparts).\n    \n    Parameters:\n    message (str): The input message to encode.\n    \n    Returns:\n    str: The encoded message.\n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n    # Define a mapping for vowels to their replacements\n    vowel_replacement = {\n        'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w',\n        'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'\n    }\n    \n    encoded_message = []\n    \n    for char in message:\n        if char.isalpha():  # Check if the character is a letter\n            # Swap case\n            swapped_char = char.swapcase()\n            # Replace vowel if it is one\n            if swapped_char in vowel_replacement:\n                swapped_char = vowel_replacement[swapped_char]\n            encoded_message.append(swapped_char)\n        else:\n            # If it's not a letter, keep it as is\n            encoded_message.append(char)\n    \n    return ''.join(encoded_message)\n\n# Test cases\nif __name__ == \"__main__\":\n    print(encode('test'))  # Expected output: 'TGST'\n    print(encode('This is a message'))  # Expected output: 'tHKS KS C MGSSCGG'\n    print(encode('Hello World'))  # Expected output: 'hGNNM YQTN'\n    print(encode('Python Programming'))  # Expected output: 'pKTHON PRKJQMMING'\n    print(encode('AEIOU'))  # Expected output: 'cGIKQW'"}
