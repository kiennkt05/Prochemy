{"task_id": "auto/9", "completion": "from typing import List\n\ndef count_negative_numbers(nums: List[int]) -> int:\n    \"\"\"Count the number of negative integers in a given list of integers.\n\n    Args:\n        nums (List[int]): A list of integers.\n\n    Returns:\n        int: The count of negative integers in the list.\n\n    Examples:\n        >>> count_negative_numbers([-1, 2, -3, 4, -5, 6])\n        3\n        >>> count_negative_numbers([1, 2, 3, 4, 5, 6])\n        0\n    \"\"\"\n    # Initialize a counter for negative numbers\n    negative_count = 0\n    \n    # Iterate through each number in the list\n    for num in nums:\n        # Check if the number is negative\n        if num < 0:\n            negative_count += 1  # Increment the counter if negative\n    \n    return negative_count  # Return the total count of negative numbers\n\n# Unit tests to verify the function works as intended\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "auto/0", "completion": "from typing import List\n\ndef find_duplicates(strings: List[str]) -> List[str]:\n    \"\"\"\n    This function takes a list of strings and returns a list of duplicate strings.\n    \n    Parameters:\n    strings (List[str]): A list of strings to check for duplicates.\n    \n    Returns:\n    List[str]: A list of duplicate strings found in the input list.\n    \"\"\"\n    # Create a dictionary to count occurrences of each string\n    string_count = {}\n    \n    # Count each string's occurrences\n    for string in strings:\n        if string in string_count:\n            string_count[string] += 1\n        else:\n            string_count[string] = 1\n    \n    # Extract strings that have more than one occurrence\n    duplicates = [string for string, count in string_count.items() if count > 1]\n    \n    return duplicates\n\n# Example usage\nif __name__ == \"__main__\":\n    example_strings = [\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"kiwi\"]\n    print(find_duplicates(example_strings))  # Output: ['apple', 'banana']"}
{"task_id": "auto/3", "completion": "from typing import List\n\ndef find_missing_number(nums: List[int]) -> int:\n    \"\"\"\n    Find the missing number in a list of integers from 0 to n.\n\n    Args:\n    nums (List[int]): A list of integers containing n distinct numbers\n                      taken from 0, 1, 2, ..., n.\n\n    Returns:\n    int: The missing number in the list.\n    \"\"\"\n    n = len(nums)  # The length of the list is n\n    expected_sum = n * (n + 1) // 2  # Sum of the first n natural numbers\n    actual_sum = sum(nums)  # Sum of the numbers in the list\n    missing_number = expected_sum - actual_sum  # The missing number is the difference\n    return missing_number\n\n# Example usage:\nif __name__ == \"__main__\":\n    nums = [0, 1, 2, 4]  # Example list with a missing number 3\n    print(f\"The missing number is: {find_missing_number(nums)}\")  # Output: 3"}
{"task_id": "auto/2", "completion": "from typing import List\n\ndef sum_negative_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Sums all negative numbers in the provided list of integers.\n\n    Parameters:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    int: The sum of all negative integers in the list.\n    \"\"\"\n    # Initialize a variable to hold the sum of negative numbers\n    negative_sum = 0\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        # Check if the number is negative\n        if number < 0:\n            # Add the negative number to the sum\n            negative_sum += number\n            \n    return negative_sum\n\n# Example usage\nif __name__ == \"__main__\":\n    example_numbers = [1, -2, 3, -4, 5, -6]\n    result = sum_negative_numbers(example_numbers)\n    print(f\"The sum of negative numbers is: {result}\")  # Output: -12"}
{"task_id": "auto/6", "completion": "from typing import List\n\ndef count_elements(numbers: List[int], target: int) -> int:\n    \"\"\"\n    Count the occurrences of a target number in a list of integers.\n\n    Parameters:\n    numbers (List[int]): A list of integers to search through.\n    target (int): The integer to count in the list.\n\n    Returns:\n    int: The count of occurrences of the target in the list.\n    \"\"\"\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        # If the current number matches the target, increment the counter\n        if number == target:\n            count += 1\n            \n    # Return the final count\n    return count\n\n# Example usage:\nif __name__ == \"__main__\":\n    sample_numbers = [1, 2, 3, 4, 2, 2, 5]\n    target_number = 2\n    print(f\"The number {target_number} appears {count_elements(sample_numbers, target_number)} times.\")"}
{"task_id": "auto/7", "completion": "from typing import List\n\ndef calculate_mean(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the mean (average) of a list of numbers.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n    float: The mean of the numbers in the list. Returns 0.0 if the list is empty.\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        return 0.0  # Return 0.0 for an empty list to avoid division by zero\n    \n    total = sum(numbers)  # Calculate the sum of the numbers\n    count = len(numbers)  # Get the count of numbers\n    mean = total / count  # Calculate the mean\n    return mean  # Return the calculated mean\n\n# Example usage:\nif __name__ == \"__main__\":\n    sample_numbers = [1.5, 2.5, 3.5, 4.5]\n    print(f\"The mean of {sample_numbers} is {calculate_mean(sample_numbers)}\")"}
{"task_id": "auto/8", "completion": "from typing import List\n\ndef find_max_consecutive_ones(nums: List[int]) -> int:\n    \"\"\"\n    This function takes a list of binary digits (0s and 1s) and returns the maximum number of consecutive 1s.\n    \n    :param nums: List[int] - A list containing binary digits (0s and 1s).\n    :return: int - The maximum count of consecutive 1s in the list.\n    \"\"\"\n    max_count = 0  # Variable to keep track of the maximum count of consecutive 1s\n    current_count = 0  # Variable to count the current streak of 1s\n\n    for num in nums:\n        if num == 1:\n            current_count += 1  # Increment the count if the current number is 1\n            max_count = max(max_count, current_count)  # Update max_count if current_count is greater\n        else:\n            current_count = 0  # Reset current_count if the current number is 0\n\n    return max_count  # Return the maximum count of consecutive 1s\n\n# Example usage:\nif __name__ == \"__main__\":\n    print(find_max_consecutive_ones([1, 1, 0, 1, 1, 1]))  # Output: 3"}
{"task_id": "auto/4", "completion": "from typing import List\n\ndef find_duplicates(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Find and return a list of duplicate numbers from the input list.\n    \n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n    \n    Returns:\n    List[float]: A list of duplicate numbers found in the input list.\n    \"\"\"\n    # Create a set to track seen numbers and another set for duplicates\n    seen = set()\n    duplicates = set()\n    \n    # Iterate through each number in the input list\n    for number in numbers:\n        # If the number has been seen before, add it to duplicates\n        if number in seen:\n            duplicates.add(number)\n        else:\n            # Otherwise, add it to the seen set\n            seen.add(number)\n    \n    # Convert the set of duplicates back to a list and return it\n    return list(duplicates)\n\n# Example usage:\nif __name__ == \"__main__\":\n    sample_numbers = [1.0, 2.5, 3.0, 2.5, 1.0, 4.0, 5.5, 3.0]\n    print(find_duplicates(sample_numbers))  # Output: [1.0, 2.5, 3.0]"}
{"task_id": "auto/1", "completion": "from typing import List\n\ndef count_consecutive_zeros(nums: List[int]) -> int:\n    \"\"\"\n    Count the longest consecutive sequence of zeros in a list of integers.\n\n    Args:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The length of the longest consecutive sequence of zeros.\n    \"\"\"\n    max_count = 0  # To keep track of the maximum length of consecutive zeros\n    current_count = 0  # To count the current sequence of zeros\n\n    for num in nums:\n        if num == 0:\n            current_count += 1  # Increment the count for consecutive zeros\n        else:\n            max_count = max(max_count, current_count)  # Update max_count if needed\n            current_count = 0  # Reset current count for non-zero number\n\n    # Final check in case the longest sequence ends at the last element\n    max_count = max(max_count, current_count)\n\n    return max_count\n\n# Example usage:\nif __name__ == \"__main__\":\n    print(count_consecutive_zeros([1, 0, 0, 2, 0, 0, 0, 3]))  # Output: 3\n    print(count_consecutive_zeros([0, 0, 0, 0]))  # Output: 4\n    print(count_consecutive_zeros([1, 2, 3]))  # Output: 0"}
{"task_id": "auto/5", "completion": "from typing import List\n\ndef reverse_sublists(data: List[int]) -> List[int]:\n    if not data:  # Check if the input list is empty\n        return []\n\n    result = []  # This will hold the final result\n    current_sublist = []  # This will hold the current sublist of identical integers\n\n    for i in range(len(data)):\n        # If the current element is the same as the last one, add it to the current sublist\n        if i > 0 and data[i] == data[i - 1]:\n            current_sublist.append(data[i])\n        else:\n            # If we encounter a new number and current_sublist is not empty, reverse it and add to result\n            if current_sublist:\n                result.extend(reversed(current_sublist))\n            # Start a new sublist with the current number\n            current_sublist = [data[i]]\n\n    # Don't forget to add the last sublist after the loop\n    if current_sublist:\n        result.extend(reversed(current_sublist))\n\n    return result\n\n# Example usage\nif __name__ == \"__main__\":\n    example_data = [1, 1, 2, 3, 3, 3, 4, 4, 5]\n    print(reverse_sublists(example_data))  # Output: [1, 1, 3, 3, 3, 4, 4, 5]"}
{"task_id": "HumanEval/10", "completion": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" \n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    # If the input string is empty, return it as is\n    if not string:\n        return string\n    \n    # Find the length of the string\n    n = len(string)\n    \n    # Check for the longest palindromic suffix\n    for i in range(n):\n        # Check if the substring from i to the end is a palindrome\n        if is_palindrome(string[i:]):\n            # If it is, we take the prefix before this suffix\n            prefix = string[:i]\n            # Reverse the prefix and append it to the original string\n            return string + prefix[::-1]\n    \n    # If no palindromic suffix is found, the whole string is non-palindromic\n    return string + string[::-1]\n\n# Unit tests to verify the correctness of the function\nif __name__ == \"__main__\":\n    assert make_palindrome('') == ''\n    assert make_palindrome('cat') == 'catac'\n    assert make_palindrome('cata') == 'catac'\n    assert make_palindrome('race') == 'racecar'\n    assert make_palindrome('a') == 'a'\n    assert make_palindrome('ab') == 'aba'\n    assert make_palindrome('abc') == 'abcba'\n    \n    print(\"All tests passed!\")"}
{"task_id": "HumanEval/77", "completion": "def iscube(a):\n    '''\n    Check if the given integer a is a perfect cube.\n    \n    Parameters:\n    a (int): The integer to check.\n    \n    Returns:\n    bool: True if a is a perfect cube, False otherwise.\n    \n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n    # Calculate the cube root of the absolute value of a\n    cube_root = round(abs(a) ** (1/3))\n    \n    # Check if the cube of the calculated root equals the absolute value of a\n    return cube_root ** 3 == abs(a)\n\n# Test cases to validate the function\nif __name__ == \"__main__\":\n    test_cases = [1, 2, -1, 64, 0, 180]\n    results = [iscube(tc) for tc in test_cases]\n    print(results)  # Expected output: [True, False, True, True, True, False]"}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    Calculate the number of collisions between two sets of cars moving towards each other.\n\n    Parameters:\n    n (int): The number of cars in each direction.\n\n    Returns:\n    int: The total number of collisions.\n    \"\"\"\n    # Each car moving left to right will collide with each car moving right to left\n    # Therefore, the total number of collisions is n * n\n    return n * n\n\n# Example usage:\nif __name__ == \"__main__\":\n    print(car_race_collision(3))  # Output: 9\n    print(car_race_collision(5))  # Output: 25"}
{"task_id": "HumanEval/65", "completion": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    \n    >>> circular_shift(12, 1)\n    '21'\n    >>> circular_shift(12, 2)\n    '12'\n    >>> circular_shift(12345, 1)\n    '51234'\n    >>> circular_shift(12345, 5)\n    '54321'\n    >>> circular_shift(12345, 6)\n    '54321'\n    \"\"\"\n    # Convert the integer to a string to manipulate the digits\n    str_x = str(x)\n    num_digits = len(str_x)\n    \n    # If shift is greater than the number of digits, reverse the string\n    if shift >= num_digits:\n        return str_x[::-1]\n    \n    # Calculate the effective shift\n    effective_shift = shift % num_digits\n    \n    # Perform the circular shift\n    shifted_str = str_x[-effective_shift:] + str_x[:-effective_shift]\n    \n    return shifted_str\n\n# Example usage\nif __name__ == \"__main__\":\n    print(circular_shift(12, 1))  # Output: '21'\n    print(circular_shift(12, 2))  # Output: '12'\n    print(circular_shift(12345, 1))  # Output: '51234'\n    print(circular_shift(12345, 5))  # Output: '54321'\n    print(circular_shift(12345, 6))  # Output: '54321'"}
{"task_id": "HumanEval/75", "completion": "from itertools import combinations\nfrom sympy import primerange\n\ndef is_multiply_prime(a):\n    \"\"\"Check if the given number is the multiplication of 3 prime numbers.\n    \n    Args:\n        a (int): The number to check (must be less than 100).\n        \n    Returns:\n        bool: True if a is the product of 3 prime numbers, False otherwise.\n    \"\"\"\n    if a >= 100:\n        raise ValueError(\"Input must be less than 100.\")\n    \n    # Generate a list of prime numbers less than 100\n    primes = list(primerange(1, 100))\n    \n    # Check all combinations of three primes\n    for combo in combinations(primes, 3):\n        if combo[0] * combo[1] * combo[2] == a:\n            return True\n            \n    return False\n\n# Example usage\nprint(is_multiply_prime(30))  # Output: True\nprint(is_multiply_prime(28))  # Output: False"}
{"task_id": "HumanEval/84", "completion": "def solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n    # Step 1: Convert N to string to iterate over each digit\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Step 2: Convert the sum to binary and remove the '0b' prefix\n    binary_sum = bin(digit_sum)[2:]\n    \n    return binary_sum\n\n# Example test cases\nprint(solve(1000))  # Output: \"1\"\nprint(solve(150))   # Output: \"110\"\nprint(solve(147))   # Output: \"1100\""}
{"task_id": "HumanEval/32", "completion": "import math\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    Returns the value of the polynomial at x.\n    \"\"\"\n    return sum(coeff * math.pow(x, i) for i, coeff in enumerate(xs))\n\ndef derivative(xs: list):\n    \"\"\"\n    Computes the derivative of the polynomial defined by coefficients xs.\n    Returns the coefficients of the derivative polynomial.\n    \"\"\"\n    return [i * coeff for i, coeff in enumerate(xs) if i > 0]\n\ndef find_zero(xs: list):\n    \"\"\"\n    Finds a root of the polynomial defined by coefficients xs.\n    Returns only one root, even if there are many.\n    The input list xs must have an even number of coefficients,\n    and the largest non-zero coefficient guarantees a solution.\n    \n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n    # Initial guess for the root\n    x0 = 0.0\n    tolerance = 1e-7\n    max_iterations = 1000\n    \n    for _ in range(max_iterations):\n        f_x0 = poly(xs, x0)  # Evaluate the polynomial at x0\n        f_prime_x0 = poly(derivative(xs), x0)  # Evaluate the derivative at x0\n        \n        if abs(f_prime_x0) < tolerance:  # Avoid division by zero\n            raise ValueError(\"Derivative is too small; no convergence.\")\n        \n        # Newton-Raphson update\n        x1 = x0 - f_x0 / f_prime_x0\n        \n        if abs(x1 - x0) < tolerance:  # Check for convergence\n            return x1\n        \n        x0 = x1  # Update x0 for the next iteration\n    \n    raise ValueError(\"Maximum iterations reached; no convergence.\")\n\n# Example usage\nif __name__ == \"__main__\":\n    print(round(find_zero([1, 2]), 2))  # Should print -0.5\n    print(round(find_zero([-6, 11, -6, 1]), 2))  # Should print 1.0"}
{"task_id": "HumanEval/83", "completion": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer.\")\n    \n    # Total n-digit integers\n    total_n_digit_integers = 10**n - 10**(n-1)  # This is 9 * 10^(n-1)\n\n    # Count of n-digit integers that start with 1\n    start_with_1_count = 10**(n-1)  # 1 followed by (n-1) digits (0-9)\n\n    # Count of n-digit integers that end with 1\n    end_with_1_count = 10**(n-1)  # (n-1) digits (0-9) followed by 1\n\n    # Count of n-digit integers that start and end with 1\n    start_and_end_with_1_count = 10**(n-2) if n > 1 else 0  # 1 followed by (n-2) digits (0-9) followed by 1\n\n    # Total count using inclusion-exclusion principle\n    total_count = start_with_1_count + end_with_1_count - start_and_end_with_1_count\n\n    return total_count\n\n# Example usage:\nprint(starts_one_ends(2))  # Should return 18\nprint(starts_one_ends(3))  # Should return 180"}
{"task_id": "HumanEval/93", "completion": "def encode(message):\n    \"\"\"\n    Encodes a message by swapping the case of all letters and replacing\n    all vowels with the letter that appears two places ahead in the English alphabet.\n\n    Parameters:\n    message (str): The input message to encode.\n\n    Returns:\n    str: The encoded message.\n\n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n    # Define a mapping for vowels to their replacements\n    vowel_replacement = {\n        'a': 'c', 'A': 'C',\n        'e': 'g', 'E': 'G',\n        'i': 'k', 'I': 'K',\n        'o': 'q', 'O': 'Q',\n        'u': 'w', 'U': 'W'\n    }\n    \n    # Initialize an empty list to build the encoded message\n    encoded_message = []\n    \n    # Iterate through each character in the message\n    for char in message:\n        if char in vowel_replacement:\n            # Replace vowel and swap case\n            encoded_message.append(vowel_replacement[char])\n        elif char.isalpha():\n            # Swap case for consonants\n            if char.islower():\n                encoded_message.append(char.upper())\n            else:\n                encoded_message.append(char.lower())\n        else:\n            # Keep non-alphabetic characters unchanged\n            encoded_message.append(char)\n    \n    # Join the list into a single string and return\n    return ''.join(encoded_message)\n\n# Example usage\nif __name__ == \"__main__\":\n    print(encode('test'))  # Output: 'TGST'\n    print(encode('This is a message'))  # Output: 'tHKS KS C MGSSCGG'"}
{"task_id": "HumanEval/94", "completion": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sum_of_digits(n):\n    \"\"\"Return the sum of the digits of a number.\"\"\"\n    return sum(int(digit) for digit in str(n))\n\ndef skjkasdkd(lst):\n    \"\"\"Find the largest prime value in the list and return the sum of its digits.\"\"\"\n    largest_prime = None\n    \n    # Iterate through the list to find the largest prime\n    for number in lst:\n        if is_prime(number):\n            if largest_prime is None or number > largest_prime:\n                largest_prime = number\n    \n    # If no prime number is found, return 0\n    if largest_prime is None:\n        return 0\n    \n    # Return the sum of the digits of the largest prime\n    return sum_of_digits(largest_prime)\n\n# Example test cases\nprint(skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))  # Output: 10\nprint(skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))  # Output: 25\nprint(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]))  # Output: 13\nprint(skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]))  # Output: 11\nprint(skjkasdkd([0, 81, 12, 3, 1, 21]))  # Output: 3\nprint(skjkasdkd([0, 8, 1, 2, 1, 7]))  # Output: 7"}
