{"task_id": "auto/3", "completion": "from typing import List\n\ndef find_missing_number(nums: List[int]) -> int:\n    n = len(nums)  # Length of the list\n    expected_sum = n * (n + 1) // 2  # Sum of first n natural numbers\n    actual_sum = sum(nums)  # Sum of the numbers in the list\n    \n    # The missing number is the difference between expected and actual sums\n    missing_number = expected_sum - actual_sum\n    return missing_number\n\n# Test cases to validate the functionality\nif __name__ == \"__main__\":\n    # Test case 1: Missing number is 2\n    print(find_missing_number([0, 1, 3]))  # Output: 2\n    \n    # Test case 2: Missing number is 0\n    print(find_missing_number([1, 2, 3]))  # Output: 0\n    \n    # Test case 3: Missing number is 4\n    print(find_missing_number([0, 1, 2, 3]))  # Output: 4\n    \n    # Test case 4: Missing number is 1\n    print(find_missing_number([0]))  # Output: 1\n    \n    # Test case 5: Missing number is 3\n    print(find_missing_number([0, 1, 2, 4, 5]))  # Output: 3"}
{"task_id": "auto/7", "completion": "from typing import List\n\ndef calculate_mean(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the mean (average) of a list of numbers.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n    float: The mean of the numbers. Returns 0.0 if the list is empty.\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        return 0.0  # Return 0.0 for an empty list to avoid division by zero\n    \n    total_sum = sum(numbers)  # Calculate the sum of the numbers\n    count = len(numbers)  # Get the count of numbers\n    mean = total_sum / count  # Calculate the mean\n    return mean  # Return the calculated mean\n\n# Test cases to validate the functionality of the calculate_mean function\nif __name__ == \"__main__\":\n    print(calculate_mean([1.0, 2.0, 3.0]))  # Expected output: 2.0\n    print(calculate_mean([10.5, 20.5, 30.5]))  # Expected output: 20.5\n    print(calculate_mean([]))  # Expected output: 0.0\n    print(calculate_mean([-1.0, 0.0, 1.0]))  # Expected output: 0.0\n    print(calculate_mean([5.0]))  # Expected output: 5.0"}
{"task_id": "auto/9", "completion": "from typing import List\n\ndef count_negative_numbers(nums: List[int]) -> int:\n    \"\"\"Count the number of negative integers in a given list of integers.\n    \n    Args:\n        nums (List[int]): A list of integers.\n        \n    Returns:\n        int: The count of negative integers in the list.\n    \n    Examples:\n    >>> count_negative_numbers([-1, 2, -3, 4, -5, 6])\n    3\n    >>> count_negative_numbers([1, 2, 3, 4, 5, 6])\n    0\n    >>> count_negative_numbers([])  # Edge case: empty list\n    0\n    >>> count_negative_numbers([-1, -2, -3])  # All negative numbers\n    3\n    >>> count_negative_numbers([0, 1, 2])  # No negative numbers\n    0\n    \"\"\"\n    # Initialize a counter for negative numbers\n    negative_count = 0\n    \n    # Iterate through each number in the list\n    for num in nums:\n        # Check if the number is negative\n        if num < 0:\n            negative_count += 1  # Increment the counter if negative\n    \n    return negative_count  # Return the total count of negative numbers\n\n# Test cases to validate the functionality\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "auto/6", "completion": "from typing import List\n\ndef count_elements(numbers: List[int], target: int) -> int:\n    \"\"\"\n    Count the occurrences of a target integer in a list of integers.\n\n    Parameters:\n    numbers (List[int]): A list of integers to search through.\n    target (int): The integer to count in the list.\n\n    Returns:\n    int: The count of occurrences of the target integer in the list.\n    \"\"\"\n    count = 0  # Initialize a counter for occurrences\n    for number in numbers:  # Iterate through each number in the list\n        if number == target:  # Check if the current number is equal to the target\n            count += 1  # Increment the counter if it matches\n    return count  # Return the total count\n\n# Test cases to validate the functionality of the count_elements function\nif __name__ == \"__main__\":\n    # Test case 1: Target is present multiple times\n    print(count_elements([1, 2, 3, 4, 2, 2], 2))  # Output: 3\n\n    # Test case 2: Target is not present\n    print(count_elements([1, 2, 3, 4], 5))  # Output: 0\n\n    # Test case 3: Target is present once\n    print(count_elements([1, 2, 3, 4], 3))  # Output: 1\n\n    # Test case 4: Empty list\n    print(count_elements([], 1))  # Output: 0\n\n    # Test case 5: Target is negative\n    print(count_elements([-1, -2, -3, -1, -1], -1))  # Output: 3"}
{"task_id": "auto/2", "completion": "from typing import List\n\ndef sum_negative_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    This function takes a list of integers and returns the sum of all negative numbers in the list.\n    \n    :param numbers: List[int] - A list of integers\n    :return: int - The sum of negative integers in the list\n    \"\"\"\n    total = 0  # Initialize the sum of negative numbers\n    for number in numbers:\n        if number < 0:  # Check if the number is negative\n            total += number  # Add the negative number to the total\n    return total  # Return the final sum of negative numbers\n\n# Test cases to validate the functionality of the function\nif __name__ == \"__main__\":\n    # Test case 1: Mixed numbers\n    print(sum_negative_numbers([1, -2, 3, -4, 5]))  # Expected output: -6 (-2 + -4)\n    \n    # Test case 2: All positive numbers\n    print(sum_negative_numbers([1, 2, 3, 4, 5]))  # Expected output: 0 (no negative numbers)\n    \n    # Test case 3: All negative numbers\n    print(sum_negative_numbers([-1, -2, -3, -4, -5]))  # Expected output: -15 (-1 + -2 + -3 + -4 + -5)\n    \n    # Test case 4: Empty list\n    print(sum_negative_numbers([]))  # Expected output: 0 (no numbers to sum)\n    \n    # Test case 5: No negative numbers\n    print(sum_negative_numbers([0, 1, 2, 3]))  # Expected output: 0 (no negative numbers)"}
{"task_id": "auto/0", "completion": "from typing import List\n\ndef find_duplicates(strings: List[str]) -> List[str]:\n    # Dictionary to hold the count of each string\n    count_dict = {}\n    \n    # Count occurrences of each string\n    for string in strings:\n        if string in count_dict:\n            count_dict[string] += 1\n        else:\n            count_dict[string] = 1\n    \n    # Extract strings that have a count greater than 1\n    duplicates = [string for string, count in count_dict.items() if count > 1]\n    \n    return duplicates\n\n# Test cases to validate the functionality of the find_duplicates function\nif __name__ == \"__main__\":\n    # Test case 1: Basic duplicates\n    print(find_duplicates([\"apple\", \"banana\", \"apple\", \"orange\", \"banana\"]))  # Expected: ['apple', 'banana']\n    \n    # Test case 2: No duplicates\n    print(find_duplicates([\"cat\", \"dog\", \"fish\"]))  # Expected: []\n    \n    # Test case 3: All duplicates\n    print(find_duplicates([\"a\", \"a\", \"a\", \"a\"]))  # Expected: ['a']\n    \n    # Test case 4: Mixed case sensitivity\n    print(find_duplicates([\"Hello\", \"hello\", \"HELLO\", \"hello\"]))  # Expected: ['hello']\n    \n    # Test case 5: Empty list\n    print(find_duplicates([]))  # Expected: []"}
{"task_id": "auto/4", "completion": "from typing import List\n\ndef find_duplicates(numbers: List[float]) -> List[float]:\n    seen = set()        # Set to track seen numbers\n    duplicates = set()  # Set to track duplicates\n\n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)  # Add to duplicates if already seen\n        else:\n            seen.add(number)        # Add to seen if not seen before\n\n    return list(duplicates)  # Convert the set of duplicates to a list\n\n# Test cases to validate the functionality\nif __name__ == \"__main__\":\n    # Test case 1: Basic duplicates\n    print(find_duplicates([1.0, 2.0, 3.0, 2.0, 1.0]))  # Expected output: [1.0, 2.0]\n\n    # Test case 2: No duplicates\n    print(find_duplicates([1.0, 2.0, 3.0]))  # Expected output: []\n\n    # Test case 3: All duplicates\n    print(find_duplicates([1.0, 1.0, 1.0, 1.0]))  # Expected output: [1.0]\n\n    # Test case 4: Mixed types of duplicates\n    print(find_duplicates([1.0, 2.0, 3.0, 1.0, 2.0, 4.0]))  # Expected output: [1.0, 2.0]\n\n    # Test case 5: Empty list\n    print(find_duplicates([]))  # Expected output: []"}
{"task_id": "auto/1", "completion": "from typing import List\n\ndef count_consecutive_zeros(nums: List[int]) -> int:\n    max_count = 0  # To keep track of the maximum consecutive zeros\n    current_count = 0  # To count the current streak of zeros\n\n    for num in nums:\n        if num == 0:\n            current_count += 1  # Increment count for consecutive zeros\n        else:\n            # Update max_count if current_count is greater\n            if current_count > max_count:\n                max_count = current_count\n            current_count = 0  # Reset current count for non-zero number\n\n    # Final check in case the list ends with zeros\n    if current_count > max_count:\n        max_count = current_count\n\n    return max_count\n\n# Test cases to validate the functionality\nif __name__ == \"__main__\":\n    print(count_consecutive_zeros([1, 0, 0, 2, 0, 0, 0, 3]))  # Output: 3\n    print(count_consecutive_zeros([0, 0, 0, 0]))              # Output: 4\n    print(count_consecutive_zeros([1, 2, 3, 4]))              # Output: 0\n    print(count_consecutive_zeros([0, 1, 0, 0, 0, 2, 0]))     # Output: 3\n    print(count_consecutive_zeros([]))                         # Output: 0"}
{"task_id": "auto/8", "completion": "from typing import List\n\ndef find_max_consecutive_ones(nums: List[int]) -> int:\n    max_count = 0  # To keep track of the maximum number of consecutive 1s\n    current_count = 0  # To count the current streak of consecutive 1s\n\n    for num in nums:\n        if num == 1:\n            current_count += 1  # Increment current count if we see a 1\n        else:\n            max_count = max(max_count, current_count)  # Update max count if current is greater\n            current_count = 0  # Reset current count if we see a 0\n\n    # Final check to update max_count in case the array ends with 1s\n    max_count = max(max_count, current_count)\n\n    return max_count\n\n# Test cases to validate the functionality of the code\nif __name__ == \"__main__\":\n    print(find_max_consecutive_ones([1, 1, 0, 1, 1, 1]))  # Output: 3\n    print(find_max_consecutive_ones([1, 0, 1, 1, 0, 1]))  # Output: 2\n    print(find_max_consecutive_ones([0, 0, 0, 0]))        # Output: 0\n    print(find_max_consecutive_ones([1, 1, 1, 1, 1]))     # Output: 5\n    print(find_max_consecutive_ones([]))                   # Output: 0"}
{"task_id": "auto/5", "completion": "from typing import List\n\ndef reverse_sublists(data: List[int], sublist_size: int = 2) -> List[int]:\n    \"\"\"\n    Reverses the order of elements in sublists of the given list.\n    \n    Parameters:\n    data (List[int]): The list of integers to be processed.\n    sublist_size (int): The size of each sublist to be reversed. Default is 2.\n    \n    Returns:\n    List[int]: A new list with the sublists reversed.\n    \"\"\"\n    # Initialize an empty list to hold the result\n    result = []\n    \n    # Process the list in chunks of sublist_size\n    for i in range(0, len(data), sublist_size):\n        # Get the current sublist\n        sublist = data[i:i + sublist_size]\n        # Reverse the current sublist and extend the result list\n        result.extend(reversed(sublist))\n    \n    return result\n\n# Test cases to validate the functionality\nif __name__ == \"__main__\":\n    # Test case 1: Normal case with even number of elements\n    print(reverse_sublists([1, 2, 3, 4, 5, 6]))  # Expected output: [2, 1, 4, 3, 6, 5]\n    \n    # Test case 2: Normal case with odd number of elements\n    print(reverse_sublists([1, 2, 3, 4, 5]))     # Expected output: [2, 1, 4, 3, 5]\n    \n    # Test case 3: Single element\n    print(reverse_sublists([1]))                  # Expected output: [1]\n    \n    # Test case 4: Empty list\n    print(reverse_sublists([]))                   # Expected output: []\n    \n    # Test case 5: Custom sublist size\n    print(reverse_sublists([1, 2, 3, 4, 5, 6, 7], sublist_size=3))  # Expected output: [3, 2, 1, 6, 5, 4, 7]"}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    Calculate the number of collisions between two sets of cars\n    moving in opposite directions on a straight road.\n\n    Parameters:\n    n (int): The number of cars in each direction.\n\n    Returns:\n    int: The total number of collisions.\n    \"\"\"\n    # Each car moving left to right collides with each car moving right to left\n    collisions = n * n\n    return collisions\n\n# Test cases to validate the functionality of the code\nif __name__ == \"__main__\":\n    # Test case 1: 1 car in each direction\n    print(car_race_collision(1))  # Expected output: 1\n\n    # Test case 2: 2 cars in each direction\n    print(car_race_collision(2))  # Expected output: 4\n\n    # Test case 3: 3 cars in each direction\n    print(car_race_collision(3))  # Expected output: 9\n\n    # Test case 4: 0 cars in each direction\n    print(car_race_collision(0))  # Expected output: 0\n\n    # Test case 5: 10 cars in each direction\n    print(car_race_collision(10))  # Expected output: 100"}
{"task_id": "HumanEval/10", "completion": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    \n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    # If the input string is empty, return it as is\n    if not string:\n        return string\n    \n    # Find the longest palindromic suffix\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            # The longest palindromic suffix starts at index i\n            suffix = string[i:]\n            prefix = string[:i]\n            # Reverse the prefix and append it to the original string\n            return string + prefix[::-1]\n    \n    # If no palindromic suffix is found, the entire string is non-palindromic\n    return string + string[::-1]  # This case is theoretically unreachable due to the loop\n\n# Test cases to validate the functionality\nif __name__ == \"__main__\":\n    print(make_palindrome(''))        # Expected: ''\n    print(make_palindrome('cat'))     # Expected: 'catac'\n    print(make_palindrome('cata'))    # Expected: 'catac'\n    print(make_palindrome('race'))     # Expected: 'racecar'\n    print(make_palindrome('a'))       # Expected: 'a'\n    print(make_palindrome('ab'))      # Expected: 'aba'"}
{"task_id": "HumanEval/65", "completion": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    \n    >>> circular_shift(12, 1)\n    '21'\n    >>> circular_shift(12, 2)\n    '12'\n    >>> circular_shift(12345, 1)\n    '51234'\n    >>> circular_shift(12345, 5)\n    '54321'\n    >>> circular_shift(12345, 6)\n    '54321'\n    \"\"\"\n    # Convert the integer to a string to manipulate its digits\n    str_x = str(x)\n    length = len(str_x)\n    \n    # If shift is greater than the number of digits, reverse the string\n    if shift >= length:\n        return str_x[::-1]\n    \n    # Calculate the effective shift\n    effective_shift = shift % length\n    \n    # Perform the circular shift\n    shifted = str_x[-effective_shift:] + str_x[:-effective_shift]\n    \n    return shifted\n\n# Test cases to validate the functionality\nif __name__ == \"__main__\":\n    print(circular_shift(12, 1))  # Expected output: '21'\n    print(circular_shift(12, 2))  # Expected output: '12'\n    print(circular_shift(12345, 1))  # Expected output: '51234'\n    print(circular_shift(12345, 5))  # Expected output: '54321'\n    print(circular_shift(12345, 6))  # Expected output: '54321'"}
{"task_id": "HumanEval/32", "completion": "import math\nfrom scipy.optimize import bisect\n\ndef poly(xs: list, x: float) -> float:\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    Returns the value of the polynomial at x.\n    \n    :param xs: List of coefficients [a0, a1, a2, ..., an] for the polynomial\n    :param x: The point at which to evaluate the polynomial\n    :return: The value of the polynomial at x\n    \"\"\"\n    return sum(coeff * math.pow(x, i) for i, coeff in enumerate(xs))\n\ndef find_zero(xs: list) -> float:\n    \"\"\"\n    Finds a root of the polynomial defined by coefficients xs.\n    The function returns only one root, even if there are multiple.\n    The input list xs must have an even number of coefficients and\n    the largest non-zero coefficient guarantees a solution.\n    \n    :param xs: List of coefficients of the polynomial\n    :return: A root of the polynomial\n    \"\"\"\n    # Define a function that we want to find the root for\n    def f(x):\n        return poly(xs, x)\n    \n    # Use the bisection method to find a root\n    # We need to find an interval where the function changes sign\n    # We can start with a reasonable interval, e.g., [-10, 10]\n    root = bisect(f, -10, 10)\n    return root\n\n# Test cases to validate the functionality of the find_zero function\nif __name__ == \"__main__\":\n    print(round(find_zero([1, 2]), 2))  # f(x) = 1 + 2x, expected output: -0.5\n    print(round(find_zero([-6, 11, -6, 1]), 2))  # f(x) = -6 + 11x - 6x^2 + x^3, expected output: 1.0\n    print(round(find_zero([1, 0, -4]), 2))  # f(x) = 1 - 4x^2, expected output: 0.5"}
{"task_id": "HumanEval/75", "completion": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef generate_primes(limit):\n    \"\"\"Generate a list of prime numbers up to a given limit.\"\"\"\n    return [num for num in range(2, limit) if is_prime(num)]\n\ndef is_multiply_prime(a):\n    \"\"\"Return True if the given number is the multiplication of 3 prime numbers, False otherwise.\"\"\"\n    if a < 1 or a >= 100:\n        return False  # Constraint: a must be less than 100\n\n    primes = generate_primes(100)\n    \n    # Check all combinations of three primes\n    for i in range(len(primes)):\n        for j in range(i, len(primes)):\n            for k in range(j, len(primes)):\n                product = primes[i] * primes[j] * primes[k]\n                if product == a:\n                    return True\n                if product > a:\n                    break  # No need to check further if product exceeds a\n\n    return False\n\n# Test cases to validate the functionality\nprint(is_multiply_prime(30))  # True, because 2 * 3 * 5 = 30\nprint(is_multiply_prime(60))  # True, because 2 * 3 * 10 = 60 (but 10 is not prime, so False)\nprint(is_multiply_prime(42))  # True, because 2 * 3 * 7 = 42\nprint(is_multiply_prime(1))   # False, as 1 cannot be expressed as a product of primes\nprint(is_multiply_prime(97))  # False, as 97 is prime and cannot be expressed as a product of three primes"}
{"task_id": "HumanEval/84", "completion": "def solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n    # Step 1: Convert N to string to iterate over each digit\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Step 2: Convert the sum to binary and return as a string\n    return bin(digit_sum)[2:]  # [2:] to remove the '0b' prefix\n\n# Test cases to validate the functionality\nif __name__ == \"__main__\":\n    print(solve(1000))  # Output: \"1\"\n    print(solve(150))   # Output: \"110\"\n    print(solve(147))   # Output: \"1100\"\n    print(solve(0))     # Output: \"0\" (edge case)\n    print(solve(9999))  # Output: \"10010\" (9+9+9+9=36, which is 100100 in binary)"}
{"task_id": "HumanEval/77", "completion": "def iscube(a):\n    '''\n    Check if the given integer a is a perfect cube.\n    \n    Parameters:\n    a (int): The integer to check.\n    \n    Returns:\n    bool: True if a is a perfect cube, False otherwise.\n    \n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n    # Calculate the cube root of the absolute value of a\n    cube_root = round(abs(a) ** (1/3))\n    \n    # Check if the cube of the rounded cube root equals the absolute value of a\n    return cube_root ** 3 == abs(a)\n\n# Test cases to validate the functionality of the iscube function\nprint(iscube(1))    # True, because 1 is 1^3\nprint(iscube(2))    # False, because 2 is not a perfect cube\nprint(iscube(-1))   # True, because -1 is (-1)^3\nprint(iscube(64))   # True, because 64 is 4^3\nprint(iscube(0))    # True, because 0 is 0^3\nprint(iscube(180))  # False, because 180 is not a perfect cube"}
{"task_id": "HumanEval/93", "completion": "def encode(message):\n    \"\"\"\n    Encodes the message by swapping case of all letters and replacing\n    all vowels with the letter that appears 2 places ahead in the English alphabet.\n    \n    Parameters:\n    message (str): The input message to encode.\n    \n    Returns:\n    str: The encoded message.\n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n    \n    # Define a mapping for vowels to their replacements\n    vowel_replacement = {\n        'a': 'c', 'A': 'C',\n        'e': 'g', 'E': 'G',\n        'i': 'k', 'I': 'K',\n        'o': 'q', 'O': 'Q',\n        'u': 'w', 'U': 'W'\n    }\n    \n    encoded_message = []\n    \n    for char in message:\n        if char.isalpha():  # Check if the character is a letter\n            # Swap case\n            swapped_char = char.swapcase()\n            # Replace vowel if it's in the mapping\n            if swapped_char in vowel_replacement:\n                encoded_message.append(vowel_replacement[swapped_char])\n            else:\n                encoded_message.append(swapped_char)\n        else:\n            # If it's not a letter, we can just append it as is (e.g., spaces)\n            encoded_message.append(char)\n    \n    return ''.join(encoded_message)\n\n# Test cases\nprint(encode('test'))  # Expected output: 'TGST'\nprint(encode('This is a message'))  # Expected output: 'tHKS KS C MGSSCGG'\nprint(encode('Hello World'))  # Expected output: 'hGNNQ WQTKD'\nprint(encode('Python Programming'))  # Expected output: 'pYTHON PRgRAmMING'"}
{"task_id": "HumanEval/94", "completion": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sum_of_digits(n):\n    \"\"\"Return the sum of the digits of a number.\"\"\"\n    return sum(int(digit) for digit in str(n))\n\ndef skjkasdkd(lst):\n    \"\"\"Find the largest prime value in the list and return the sum of its digits.\"\"\"\n    largest_prime = None\n    \n    # Iterate through the list to find the largest prime\n    for number in lst:\n        if is_prime(number):\n            if largest_prime is None or number > largest_prime:\n                largest_prime = number\n    \n    # If no prime number is found, return 0 (or handle as needed)\n    if largest_prime is None:\n        return 0\n    \n    # Return the sum of the digits of the largest prime\n    return sum_of_digits(largest_prime)\n\n# Test cases to validate the functionality\nprint(skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]))  # Output: 10\nprint(skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]))  # Output: 25\nprint(skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]))  # Output: 13\nprint(skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]))  # Output: 11\nprint(skjkasdkd([0, 81, 12, 3, 1, 21]))  # Output: 3\nprint(skjkasdkd([0, 8, 1, 2, 1, 7]))  # Output: 7"}
{"task_id": "HumanEval/83", "completion": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    if n < 1:\n        return 0  # No n-digit numbers for n < 1\n\n    # Count of n-digit numbers starting with '1'\n    count_starting_with_1 = 10 ** (n - 1)\n\n    # Count of n-digit numbers ending with '1'\n    if n == 1:\n        count_ending_with_1 = 1  # Only the number '1'\n    else:\n        count_ending_with_1 = 9 * (10 ** (n - 2))\n\n    # Count of n-digit numbers starting and ending with '1'\n    if n == 1:\n        count_both = 1  # Only the number '1'\n    else:\n        count_both = 10 ** (n - 2)\n\n    # Total count\n    total_count = count_starting_with_1 + count_ending_with_1 - count_both\n    return total_count\n\n# Test cases\nprint(starts_one_ends(1))  # Expected output: 1 (only the number '1')\nprint(starts_one_ends(2))  # Expected output: 18 (10-19 and 11, 21, ..., 91)\nprint(starts_one_ends(3))  # Expected output: 271 (100-199, 101, 111, ..., 191, 201, ..., 901)\nprint(starts_one_ends(4))  # Expected output: 3700"}
