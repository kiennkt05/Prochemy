{"task_id": "auto/9", "completion": "from typing import List\n\ndef count_negative_numbers(nums: List[int]) -> int:\n    \"\"\"Count the number of negative integers in a given list of integers.\n    \n    Args:\n        nums (List[int]): A list of integers.\n        \n    Returns:\n        int: The count of negative integers in the list.\n    \n    Examples:\n        >>> count_negative_numbers([-1, 2, -3, 4, -5, 6])\n        3\n        >>> count_negative_numbers([1, 2, 3, 4, 5, 6])\n        0\n    \"\"\"\n    return sum(1 for num in nums if num < 0)\n\ndef main():\n    # Test cases to validate the functionality of count_negative_numbers\n    test_cases = [\n        ([-1, 2, -3, 4, -5, 6], 3),\n        ([1, 2, 3, 4, 5, 6], 0),\n        ([0, -1, -2, -3], 3),\n        ([], 0),\n        ([5, 4, 3, 2, 1], 0),\n        ([-10, -20, 30, 40], 2),\n        ([1, -1, 1, -1, 1], 2)\n    ]\n    \n    for i, (input_data, expected) in enumerate(test_cases):\n        result = count_negative_numbers(input_data)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i+1} passed: {input_data} -> {result}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "auto/1", "completion": "from typing import List\n\ndef count_consecutive_zeros(nums: List[int]) -> int:\n    \"\"\"\n    Counts the maximum number of consecutive zeros in a list of integers.\n\n    Args:\n    nums (List[int]): A list of integers.\n\n    Returns:\n    int: The maximum count of consecutive zeros.\n    \"\"\"\n    max_count = 0  # To keep track of the maximum count of consecutive zeros\n    current_count = 0  # To count the current streak of zeros\n\n    for num in nums:\n        if num == 0:\n            current_count += 1  # Increment the count for consecutive zeros\n        else:\n            max_count = max(max_count, current_count)  # Update max_count if needed\n            current_count = 0  # Reset current count for non-zero number\n\n    # Final check in case the list ends with zeros\n    max_count = max(max_count, current_count)\n\n    return max_count\n\n# Test cases to validate the functionality of the function\ndef test_count_consecutive_zeros():\n    assert count_consecutive_zeros([0, 0, 1, 0, 0, 0, 2, 0]) == 3, \"Test case 1 failed\"\n    assert count_consecutive_zeros([1, 2, 3]) == 0, \"Test case 2 failed\"\n    assert count_consecutive_zeros([0, 0, 0, 0]) == 4, \"Test case 3 failed\"\n    assert count_consecutive_zeros([]) == 0, \"Test case 4 failed\"\n    assert count_consecutive_zeros([1, 0, 0, 0, 1, 0, 0]) == 3, \"Test case 5 failed\"\n    assert count_consecutive_zeros([0, 1, 0, 0, 0, 0]) == 4, \"Test case 6 failed\"\n    assert count_consecutive_zeros([0]) == 1, \"Test case 7 failed\"\n    assert count_consecutive_zeros([1, 2, 3, 4]) == 0, \"Test case 8 failed\"\n    \n    print(\"All test cases passed!\")\n\n# Run the test cases\nif __name__ == \"__main__\":\n    test_count_consecutive_zeros()"}
{"task_id": "auto/2", "completion": "from typing import List\n\ndef sum_negative_numbers(numbers: List[int]) -> int:\n    \"\"\"\n    Sums all negative numbers in the provided list of integers.\n\n    Parameters:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    int: The sum of all negative integers in the list. If there are no negative integers, returns 0.\n    \"\"\"\n    # Initialize the sum variable\n    total = 0\n    \n    # Iterate through the list and sum negative numbers\n    for number in numbers:\n        if number < 0:\n            total += number\n            \n    return total\n\n# Testing the function\ndef test_sum_negative_numbers():\n    \"\"\"\n    Tests the sum_negative_numbers function with various test cases.\n    \"\"\"\n    # Test cases\n    test_cases = [\n        ([1, -2, 3, -4, 5], -6),  # Normal case with negative numbers\n        ([0, 1, 2, 3], 0),         # No negative numbers\n        ([-1, -2, -3], -6),        # All negative numbers\n        ([], 0),                   # Empty list\n        ([5, 10, 15], 0),          # All positive numbers\n        ([-5, 5, -10, 10], -15)    # Mixed positive and negative\n    ]\n    \n    for i, (input_data, expected) in enumerate(test_cases):\n        result = sum_negative_numbers(input_data)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n    \n    print(\"All test cases passed!\")\n\n# Run the tests\nif __name__ == \"__main__\":\n    test_sum_negative_numbers()"}
{"task_id": "auto/6", "completion": "from typing import List\n\ndef count_elements(numbers: List[int], target: int) -> int:\n    \"\"\"\n    Count the occurrences of a target integer in a list of integers.\n\n    Parameters:\n    numbers (List[int]): A list of integers to search through.\n    target (int): The integer to count in the list.\n\n    Returns:\n    int: The count of occurrences of the target integer in the list.\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise ValueError(\"The 'numbers' parameter must be a list.\")\n    if not all(isinstance(num, int) for num in numbers):\n        raise ValueError(\"All elements in 'numbers' must be integers.\")\n    if not isinstance(target, int):\n        raise ValueError(\"The 'target' parameter must be an integer.\")\n\n    count = 0\n    for number in numbers:\n        if number == target:\n            count += 1\n    return count\n\n# Test cases\ndef test_count_elements():\n    assert count_elements([1, 2, 3, 4, 2, 2], 2) == 3, \"Test case 1 failed\"\n    assert count_elements([1, 1, 1, 1, 1], 1) == 5, \"Test case 2 failed\"\n    assert count_elements([1, 2, 3, 4, 5], 6) == 0, \"Test case 3 failed\"\n    assert count_elements([], 1) == 0, \"Test case 4 failed\"\n    assert count_elements([0, 0, 0], 0) == 3, \"Test case 5 failed\"\n    print(\"All test cases passed!\")\n\nif __name__ == \"__main__\":\n    # Example usage\n    numbers = [1, 2, 3, 2, 4, 2]\n    target = 2\n    result = count_elements(numbers, target)\n    print(f\"The number {target} appears {result} times in the list.\")\n\n    # Run tests\n    test_count_elements()"}
{"task_id": "auto/3", "completion": "from typing import List\n\ndef find_missing_number(nums: List[int]) -> int:\n    \"\"\"\n    Find the missing number in a list of integers from 0 to n.\n    \n    Args:\n    nums (List[int]): A list of integers containing n distinct numbers in the range from 0 to n.\n    \n    Returns:\n    int: The missing number.\n    \"\"\"\n    n = len(nums)  # The length of the list is n, meaning numbers should be from 0 to n\n    expected_sum = n * (n + 1) // 2  # Sum of first n natural numbers\n    actual_sum = sum(nums)  # Sum of the numbers present in the list\n    \n    missing_number = expected_sum - actual_sum  # The missing number\n    return missing_number\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test case 1: Missing number is 2\n    print(find_missing_number([0, 1, 3]))  # Output: 2\n    \n    # Test case 2: Missing number is 0\n    print(find_missing_number([1, 2, 3]))  # Output: 0\n    \n    # Test case 3: Missing number is 4\n    print(find_missing_number([0, 1, 2, 3]))  # Output: 4\n    \n    # Test case 4: Missing number is 1\n    print(find_missing_number([0]))  # Output: 1\n    \n    # Test case 5: Missing number is 3\n    print(find_missing_number([0, 1, 2, 4, 5]))  # Output: 3"}
{"task_id": "auto/5", "completion": "from typing import List\n\ndef reverse_sublists(data: List[int], sublist_length: int) -> List[int]:\n    \"\"\"\n    Reverses the order of elements in sublists of a specified length within the given list.\n\n    Parameters:\n    data (List[int]): The list of integers to process.\n    sublist_length (int): The length of each sublist to reverse.\n\n    Returns:\n    List[int]: A new list with the specified sublists reversed.\n    \"\"\"\n    if sublist_length <= 0:\n        raise ValueError(\"Sublist length must be a positive integer.\")\n    \n    result = []\n    for i in range(0, len(data), sublist_length):\n        # Get the current sublist\n        sublist = data[i:i + sublist_length]\n        # Reverse the sublist and extend the result\n        result.extend(reversed(sublist))\n    \n    return result\n\n# Example usage\nif __name__ == \"__main__\":\n    data = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    sublist_length = 3\n    reversed_data = reverse_sublists(data, sublist_length)\n    print(reversed_data)  # Output: [3, 2, 1, 6, 5, 4, 9, 8, 7]"}
{"task_id": "auto/4", "completion": "from typing import List\n\ndef find_duplicates(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Find and return a list of duplicate numbers from the input list.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n    List[float]: A list of duplicate numbers found in the input list.\n    \"\"\"\n    if not isinstance(numbers, list):\n        raise ValueError(\"Input must be a list.\")\n    \n    duplicates = []\n    seen = set()\n    for number in numbers:\n        if not isinstance(number, (float, int)):\n            raise ValueError(\"All elements in the list must be numbers.\")\n        if number in seen:\n            if number not in duplicates:\n                duplicates.append(number)\n        else:\n            seen.add(number)\n    \n    return duplicates\n\n# Testing the function\ndef test_find_duplicates():\n    # Test cases\n    assert find_duplicates([1.0, 2.0, 3.0, 1.0, 2.0]) == [1.0, 2.0], \"Test Case 1 Failed\"\n    assert find_duplicates([1.5, 2.5, 3.5, 4.5]) == [], \"Test Case 2 Failed\"\n    assert find_duplicates([1.0, 1.0, 1.0, 1.0]) == [1.0], \"Test Case 3 Failed\"\n    assert find_duplicates([]) == [], \"Test Case 4 Failed\"\n    assert find_duplicates([1.0, 2.0, 3.0, 2.0, 1.0]) == [1.0, 2.0], \"Test Case 5 Failed\"\n    \n    print(\"All test cases passed!\")\n\n# Run tests\nif __name__ == \"__main__\":\n    test_find_duplicates()"}
{"task_id": "HumanEval/10", "completion": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" \n    Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string the reverse of a string prefix that comes before the palindromic suffix.\n    \n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    >>> make_palindrome('race')\n    'racecar'\n    >>> make_palindrome('a')\n    'a'\n    \"\"\"\n    if not isinstance(string, str):\n        raise ValueError(\"Input must be a string.\")\n    \n    n = len(string)\n    if n == 0:\n        return string\n    \n    # Find the longest palindromic suffix\n    for i in range(n):\n        if is_palindrome(string[i:]):\n            # If the suffix is a palindrome, we need to add the reverse of the prefix\n            prefix = string[:i]\n            return string + prefix[::-1]\n    \n    # If no palindromic suffix is found, the whole string is non-palindromic\n    return string + string[::-1]\n\n\n# Test cases to validate the functionality\nif __name__ == \"__main__\":\n    test_cases = [\n        ('', ''), \n        ('cat', 'catac'), \n        ('cata', 'catac'), \n        ('race', 'racecar'), \n        ('a', 'a'), \n        ('ab', 'abba'), \n        ('abc', 'abcba')\n    ]\n    \n    for input_string, expected_output in test_cases:\n        result = make_palindrome(input_string)\n        assert result == expected_output, f\"Test failed for input '{input_string}': expected '{expected_output}', got '{result}'\"\n    \n    print(\"All tests passed!\")"}
{"task_id": "auto/0", "completion": "from typing import List\n\ndef find_duplicates(strings: List[str]) -> List[str]:\n    \"\"\"\n    Find and return a list of duplicate strings from the input list.\n\n    Parameters:\n    strings (List[str]): A list of strings to check for duplicates.\n\n    Returns:\n    List[str]: A list of duplicate strings found in the input list.\n    \"\"\"\n    if not isinstance(strings, list):\n        raise ValueError(\"Input must be a list of strings.\")\n    \n    # Use a dictionary to count occurrences of each string\n    string_count = {}\n    duplicates = []\n\n    for string in strings:\n        if not isinstance(string, str):\n            raise ValueError(\"All elements in the list must be strings.\")\n        \n        # Count occurrences\n        if string in string_count:\n            string_count[string] += 1\n        else:\n            string_count[string] = 1\n\n    # Collect strings that appear more than once\n    for string, count in string_count.items():\n        if count > 1:\n            duplicates.append(string)\n\n    return duplicates\n\n# Testing the function\ndef test_find_duplicates():\n    \"\"\"\n    Test cases for the find_duplicates function.\n    \"\"\"\n    # Test case 1: Basic duplicates\n    assert find_duplicates([\"apple\", \"banana\", \"apple\", \"orange\", \"banana\"]) == [\"apple\", \"banana\"]\n    \n    # Test case 2: No duplicates\n    assert find_duplicates([\"apple\", \"banana\", \"orange\"]) == []\n    \n    # Test case 3: All duplicates\n    assert find_duplicates([\"apple\", \"apple\", \"apple\"]) == [\"apple\"]\n    \n    # Test case 4: Mixed case duplicates\n    assert find_duplicates([\"Apple\", \"apple\", \"Banana\", \"banana\"]) == []\n    \n    # Test case 5: Empty list\n    assert find_duplicates([]) == []\n    \n    # Test case 6: Non-string input\n    try:\n        find_duplicates([\"apple\", 1, \"banana\"])\n    except ValueError as e:\n        assert str(e) == \"All elements in the list must be strings.\"\n    \n    print(\"All tests passed!\")\n\n# Run tests\nif __name__ == \"__main__\":\n    test_find_duplicates()"}
{"task_id": "auto/7", "completion": "from typing import List\n\ndef calculate_mean(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the mean (average) of a list of numbers.\n\n    Parameters:\n    numbers (List[float]): A list of floating-point numbers.\n\n    Returns:\n    float: The mean of the numbers. Returns 0.0 if the list is empty.\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        print(\"Warning: The list is empty. Returning 0.0 as mean.\")\n        return 0.0\n    \n    total = sum(numbers)  # Sum of all numbers\n    count = len(numbers)  # Count of numbers\n    mean = total / count  # Calculate mean\n    return mean\n\ndef main():\n    # Example usage of calculate_mean\n    numbers = [10.0, 20.0, 30.0, 40.0, 50.0]\n    mean_value = calculate_mean(numbers)\n    print(f\"The mean of {numbers} is {mean_value}\")\n\n    # Test with an empty list\n    empty_list = []\n    mean_empty = calculate_mean(empty_list)\n    print(f\"The mean of an empty list is {mean_empty}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "HumanEval/41", "completion": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    Calculate the number of collisions between two sets of cars.\n    \n    Args:\n    n (int): The number of cars in each direction (left to right and right to left).\n    \n    Returns:\n    int: The total number of collisions.\n    \n    A collision occurs when a car moving left to right hits a car moving right to left.\n    Since all cars are infinitely sturdy and continue moving, the number of collisions\n    is simply the product of the number of cars in each direction.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"The number of cars cannot be negative.\")\n    \n    # The number of collisions is n (left to right) * n (right to left)\n    return n * n\n\n# Test cases to validate the functionality\ndef test_car_race_collision():\n    assert car_race_collision(0) == 0, \"Test case 1 failed\"\n    assert car_race_collision(1) == 1, \"Test case 2 failed\"\n    assert car_race_collision(2) == 4, \"Test case 3 failed\"\n    assert car_race_collision(3) == 9, \"Test case 4 failed\"\n    assert car_race_collision(10) == 100, \"Test case 5 failed\"\n    \n    try:\n        car_race_collision(-1)\n    except ValueError as e:\n        assert str(e) == \"The number of cars cannot be negative.\", \"Test case 6 failed\"\n    \n    print(\"All test cases passed!\")\n\n# Execute the test cases\nif __name__ == \"__main__\":\n    test_car_race_collision()"}
{"task_id": "HumanEval/65", "completion": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    \n    >>> circular_shift(12, 1)\n    '21'\n    >>> circular_shift(12, 2)\n    '12'\n    >>> circular_shift(12345, 1)\n    '51234'\n    >>> circular_shift(12345, 5)\n    '54321'\n    >>> circular_shift(12345, 6)\n    '54321'\n    >>> circular_shift(0, 1)\n    '0'\n    >>> circular_shift(7, 0)\n    '7'\n    \"\"\"\n    # Convert the integer to a string to manipulate its digits\n    str_x = str(x)\n    num_digits = len(str_x)\n    \n    # If shift is greater than the number of digits, reverse the string\n    if shift >= num_digits:\n        return str_x[::-1]\n    \n    # Perform the circular shift\n    shift = shift % num_digits  # Handle shifts larger than the number of digits\n    return str_x[-shift:] + str_x[:-shift]\n\n# Testing the function with provided examples and additional cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"}
{"task_id": "auto/8", "completion": "from typing import List\n\ndef find_max_consecutive_ones(nums: List[int]) -> int:\n    \"\"\"\n    This function takes a list of integers (0s and 1s) and returns the maximum number of consecutive 1's.\n    \n    :param nums: List[int] - A list containing binary values (0s and 1s).\n    :return: int - The maximum count of consecutive 1's in the list.\n    \"\"\"\n    max_count = 0  # To keep track of the maximum count of consecutive 1's\n    current_count = 0  # To count the current streak of 1's\n\n    for num in nums:\n        if num == 1:\n            current_count += 1  # Increment the count if the number is 1\n            max_count = max(max_count, current_count)  # Update max_count if current_count is greater\n        else:\n            current_count = 0  # Reset current_count if the number is 0\n\n    return max_count\n\n# Test cases to validate the functionality of the function\ndef test_find_max_consecutive_ones():\n    assert find_max_consecutive_ones([1, 1, 0, 1, 1, 1]) == 3, \"Test case 1 failed\"\n    assert find_max_consecutive_ones([1, 0, 1, 1, 0, 1]) == 2, \"Test case 2 failed\"\n    assert find_max_consecutive_ones([0, 0, 0, 0]) == 0, \"Test case 3 failed\"\n    assert find_max_consecutive_ones([1, 1, 1, 1]) == 4, \"Test case 4 failed\"\n    assert find_max_consecutive_ones([]) == 0, \"Test case 5 failed\"\n    assert find_max_consecutive_ones([0, 1, 1, 0, 1, 1, 1, 0, 1]) == 3, \"Test case 6 failed\"\n    \n    print(\"All test cases passed!\")\n\n# Run the test cases\nif __name__ == \"__main__\":\n    test_find_max_consecutive_ones()"}
{"task_id": "HumanEval/77", "completion": "def iscube(a):\n    '''\n    Check if the given integer a is a perfect cube of some integer.\n\n    Parameters:\n    a (int): The integer to check.\n\n    Returns:\n    bool: True if a is a perfect cube, False otherwise.\n\n    Examples:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n    # Calculate the cube root of the absolute value of a\n    cube_root = round(abs(a) ** (1/3))\n    \n    # Check if the cube of the rounded cube root equals the absolute value of a\n    return cube_root ** 3 == abs(a)\n\n# Testing the function with provided examples\nif __name__ == \"__main__\":\n    test_cases = [1, 2, -1, 64, 0, 180]\n    for case in test_cases:\n        result = iscube(case)\n        print(f\"iscube({case}) ==> {result}\")"}
{"task_id": "HumanEval/32", "completion": "import math\n\ndef poly(xs: list, x: float) -> float:\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    Returns the value of the polynomial.\n    \n    :param xs: List of coefficients [a0, a1, a2, ..., an] for the polynomial a0 + a1*x + a2*x^2 + ... + an*x^n\n    :param x: The point at which to evaluate the polynomial\n    :return: The value of the polynomial at x\n    \"\"\"\n    return sum(coeff * math.pow(x, i) for i, coeff in enumerate(xs))\n\ndef derivative(xs: list) -> list:\n    \"\"\"\n    Computes the derivative of the polynomial defined by coefficients xs.\n    \n    :param xs: List of coefficients [a0, a1, a2, ..., an]\n    :return: List of coefficients of the derivative polynomial\n    \"\"\"\n    return [i * coeff for i, coeff in enumerate(xs) if i > 0]\n\ndef find_zero(xs: list, initial_guess: float = 0.0, tolerance: float = 1e-7, max_iterations: int = 1000) -> float:\n    \"\"\"\n    Finds a root of the polynomial defined by coefficients xs using the Newton-Raphson method.\n    \n    :param xs: List of coefficients of the polynomial\n    :param initial_guess: Initial guess for the root\n    :param tolerance: Tolerance for convergence\n    :param max_iterations: Maximum number of iterations to prevent infinite loops\n    :return: A root of the polynomial\n    :raises ValueError: If the input list does not have an even number of coefficients\n    \"\"\"\n    if len(xs) % 2 != 0:\n        raise ValueError(\"The list of coefficients must have an even number of elements.\")\n    \n    current_guess = initial_guess\n    for _ in range(max_iterations):\n        f_value = poly(xs, current_guess)\n        f_derivative = poly(derivative(xs), current_guess)\n        \n        if abs(f_derivative) < tolerance:  # Avoid division by zero\n            raise ValueError(\"Derivative is too small; no solution found.\")\n        \n        next_guess = current_guess - f_value / f_derivative\n        \n        if abs(next_guess - current_guess) < tolerance:\n            return next_guess\n        \n        current_guess = next_guess\n    \n    raise ValueError(\"Maximum iterations reached; no solution found.\")\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test the polynomial evaluation\n    print(round(poly([1, 2], -0.5), 2))  # Should print -0.5\n    print(round(poly([-6, 11, -6, 1], 1), 2))  # Should print 0.0 (f(1) = 0)\n\n    # Test the find_zero function\n    print(round(find_zero([1, 2]), 2))  # Should print -0.5\n    print(round(find_zero([-6, 11, -6, 1]), 2))  # Should print 1.0"}
{"task_id": "HumanEval/75", "completion": "from itertools import combinations\nfrom math import prod\n\ndef is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef generate_primes(limit):\n    \"\"\"Generate a list of prime numbers less than the given limit.\"\"\"\n    return [num for num in range(2, limit) if is_prime(num)]\n\ndef is_multiply_prime(a):\n    \"\"\"Return True if the given number is the multiplication of 3 prime numbers, False otherwise.\"\"\"\n    if a < 1 or a >= 100:\n        raise ValueError(\"Input must be a number less than 100 and greater than 0.\")\n    \n    primes = generate_primes(100)\n    \n    # Check all combinations of 3 primes\n    for combo in combinations(primes, 3):\n        if prod(combo) == a:\n            return True\n    return False\n\n# Test cases\ndef test_is_multiply_prime():\n    assert is_multiply_prime(30) == True  # 2 * 3 * 5\n    assert is_multiply_prime(60) == True  # 2 * 3 * 10 (not valid, but 2 * 5 * 3 = 30)\n    assert is_multiply_prime(42) == True  # 2 * 3 * 7\n    assert is_multiply_prime(70) == True  # 2 * 5 * 7\n    assert is_multiply_prime(1) == False   # No product of primes\n    assert is_multiply_prime(2) == False   # Only one prime\n    assert is_multiply_prime(100) == False  # Out of bounds\n    assert is_multiply_prime(99) == False   # No combination of 3 primes gives 99\n\n    print(\"All tests passed!\")\n\n# Run tests\ntest_is_multiply_prime()"}
{"task_id": "HumanEval/93", "completion": "def encode(message):\n    \"\"\"\n    Encodes the given message by swapping the case of all letters\n    and replacing all vowels with the letter that appears two places\n    ahead in the English alphabet.\n\n    Parameters:\n    message (str): The input message to encode.\n\n    Returns:\n    str: The encoded message.\n\n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n    # Define vowels and their replacements\n    vowels = 'aeiouAEIOU'\n    encoded_message = []\n\n    for char in message:\n        if char in vowels:\n            # Replace vowel with the letter two places ahead\n            if char.islower():\n                new_char = chr(ord(char) + 2)\n            else:\n                new_char = chr(ord(char) + 2).upper()\n            encoded_message.append(new_char)\n        elif char.isalpha():\n            # Swap case for consonants\n            encoded_message.append(char.swapcase())\n        else:\n            # Keep non-alphabetic characters unchanged\n            encoded_message.append(char)\n\n    return ''.join(encoded_message)\n\n# Test cases to validate the functionality\nif __name__ == \"__main__\":\n    print(encode('test'))  # Expected output: 'TGST'\n    print(encode('This is a message'))  # Expected output: 'tHKS KS C MGSSCGG'\n    print(encode('Hello World!'))  # Expected output: 'hNQQT YQTN!'\n    print(encode('Python Programming'))  # Expected output: 'pYTHON PRQJRAMMING'"}
{"task_id": "HumanEval/84", "completion": "def solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n    if N < 0 or N > 10000:\n        raise ValueError(\"N must be between 0 and 10000 inclusive.\")\n    \n    # Calculate the sum of the digits of N\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to binary and return it as a string\n    return bin(digit_sum)[2:]  # [2:] to remove the '0b' prefix\n\n# Example usage\nif __name__ == \"__main__\":\n    print(solve(1000))  # Output: \"1\"\n    print(solve(150))   # Output: \"110\"\n    print(solve(147))   # Output: \"1100\""}
{"task_id": "HumanEval/94", "completion": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sum_of_digits(n):\n    \"\"\"Calculate the sum of the digits of a number.\"\"\"\n    return sum(int(digit) for digit in str(n))\n\ndef largest_prime_digit_sum(lst):\n    \"\"\"Find the largest prime in the list and return the sum of its digits.\"\"\"\n    largest_prime = None\n    \n    for number in lst:\n        if is_prime(number):\n            if largest_prime is None or number > largest_prime:\n                largest_prime = number\n    \n    if largest_prime is not None:\n        return sum_of_digits(largest_prime)\n    else:\n        return 0  # Return 0 if no prime number is found\n\n# Test cases\nif __name__ == \"__main__\":\n    test_cases = [\n        ([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3], 10),\n        ([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1], 25),\n        ([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3], 13),\n        ([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6], 11),\n        ([0, 81, 12, 3, 1, 21], 3),\n        ([0, 8, 1, 2, 1, 7], 7),\n        ([4, 6, 8, 10], 0)  # No prime numbers\n    ]\n    \n    for i, (lst, expected) in enumerate(test_cases):\n        result = largest_prime_digit_sum(lst)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n    \n    print(\"All test cases passed!\")"}
{"task_id": "HumanEval/83", "completion": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \n    Parameters:\n    n (int): The number of digits in the positive integers.\n    \n    Returns:\n    int: The count of n-digit integers that start or end with 1.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer.\")\n    \n    if n == 1:\n        # For 1-digit numbers, only '1' is valid\n        return 1\n    \n    # Count of n-digit numbers that start with '1'\n    start_with_1 = 10**(n - 1)  # 1 followed by (n-1) digits (0-9)\n    \n    # Count of n-digit numbers that end with '1'\n    end_with_1 = 9 * 10**(n - 2)  # (1-9) for the first digit, (0-9) for (n-2) digits, and '1' at the end\n    \n    # Total count of n-digit numbers that start or end with '1'\n    total_count = start_with_1 + end_with_1\n    \n    # Since numbers that start and end with '1' are counted twice, we need to subtract them\n    if n > 1:\n        both_start_and_end_with_1 = 10**(n - 2)  # 1 for the first digit, (0-9) for (n-2) digits, 1 for the last digit\n        total_count -= both_start_and_end_with_1\n    \n    return total_count\n\n# Example usage\nif __name__ == \"__main__\":\n    n = 3\n    print(f\"The count of {n}-digit integers that start or end with 1 is: {starts_one_ends(n)}\")"}
