{"date": "2025-09-15 04:01", "hash": "ee43ecabebf20deef4bb776a405ac5b1", "eval": {"Mbpp/2": [{"task_id": "Mbpp/2", "solution": "def similar_elements(list1, list2):\n    \"\"\"\n    This function takes two lists as input and returns a list of shared elements.\n    \"\"\"\n    # Convert both lists to sets to find the intersection\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Find the intersection of both sets\n    shared_elements = set1.intersection(set2)\n    \n    # Return the result as a list\n    return list(shared_elements)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/3": [{"task_id": "Mbpp/3", "solution": "def is_not_prime(n):\n    \"\"\"\n    Function to determine if a number is not prime.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/6": [{"task_id": "Mbpp/6", "solution": "def differ_At_One_Bit_Pos(num1, num2):\n    \"\"\"\n    Check if two numbers differ at exactly one bit position.\n\n    Parameters:\n    num1 (int): The first number.\n    num2 (int): The second number.\n\n    Returns:\n    bool: True if the numbers differ at exactly one bit position, False otherwise.\n    \"\"\"\n    # XOR the two numbers. The result will have bits set to 1 where num1 and num2 differ.\n    xor_result = num1 ^ num2\n    \n    # Check if xor_result is a power of two, which means it has exactly one bit set.\n    # A number is a power of two if it is greater than 0 and its binary representation has only one '1'.\n    return xor_result != 0 and (xor_result & (xor_result - 1)) == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/4": [{"task_id": "Mbpp/4", "solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    # Use heapq.nlargest to find the n largest numbers\n    largest_numbers = heapq.nlargest(n, numbers)\n    return largest_numbers", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/8": [{"task_id": "Mbpp/8", "solution": "def square_nums(nums):\n    \"\"\"\n    This function takes a list of numbers and returns a new list with the squares of each number.\n\n    :param nums: List of integers\n    :return: List of integers where each element is the square of the corresponding element in the input list\n    \"\"\"\n    return [x ** 2 for x in nums]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/7": [{"task_id": "Mbpp/7", "solution": "def find_char_long(s):\n    # Split the string into words\n    words = s.split()\n    # Filter words that are at least 4 characters long\n    long_words = [word for word in words if len(word) >= 4]\n    return long_words", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["This is a very long string with no words that are at least 4 characters long."]]}], "Mbpp/11": [{"task_id": "Mbpp/11", "solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of the given character from the string.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to remove.\n\n    Returns:\n    str: The modified string with the first and last occurrence of the character removed.\n    \"\"\"\n    # Find the first occurrence of the character\n    first_occurrence = s.find(char)\n    # Find the last occurrence of the character\n    last_occurrence = s.rfind(char)\n\n    # If the character is not found or only found once, return the original string\n    if first_occurrence == -1 or first_occurrence == last_occurrence:\n        return s\n\n    # Remove the first occurrence\n    s = s[:first_occurrence] + s[first_occurrence + 1:]\n    # Adjust the last occurrence index since the string has been modified\n    last_occurrence -= 1\n    # Remove the last occurrence\n    s = s[:last_occurrence] + s[last_occurrence + 1:]\n\n    return s", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["a", "a"]]}], "Mbpp/9": [{"task_id": "Mbpp/9", "solution": "def find_Rotations(s):\n    \"\"\"\n    This function finds the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Parameters:\n    s (str): The input string to be rotated.\n    \n    Returns:\n    int: The minimum number of rotations required to get the same string.\n    \"\"\"\n    n = len(s)\n    # Concatenate the string with itself\n    doubled_s = s + s\n    \n    # Iterate over possible rotation lengths\n    for i in range(1, n + 1):\n        # Check if the substring of length n starting from i is equal to the original string\n        if doubled_s[i:i + n] == s:\n            return i\n    \n    # If no rotation is found, return the length of the string\n    return n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/12": [{"task_id": "Mbpp/12", "solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Parameters:\n    matrix (list of list of int): A 2D list where each sublist represents a row of the matrix.\n\n    Returns:\n    list of list of int: The matrix sorted by the sum of its rows.\n    \"\"\"\n    # Sort the matrix using the sum of each row as the key\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/14": [{"task_id": "Mbpp/14", "solution": "def find_Volume(base_length, height_of_triangle, length_of_prism):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    base_length (float): The base length of the triangular face.\n    height_of_triangle (float): The height of the triangular face.\n    length_of_prism (float): The length of the prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    # Calculate the area of the triangular base\n    area_of_triangle = 0.5 * base_length * height_of_triangle\n    \n    # Calculate the volume of the prism\n    volume = area_of_triangle * length_of_prism\n    \n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/16": [{"task_id": "Mbpp/16", "solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters joined with an underscore,\n    and False otherwise.\n    \"\"\"\n    # Use regular expression to match the pattern\n    pattern = r'^[a-z]+(_[a-z]+)+$'\n    return bool(re.match(pattern, s))", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["a"]]}], "Mbpp/17": [{"task_id": "Mbpp/17", "solution": "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square given its side length.\n\n    Parameters:\n    side_length (float): The length of one side of the square.\n\n    Returns:\n    float: The perimeter of the square.\n    \"\"\"\n    return 4 * side_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/19": [{"task_id": "Mbpp/19", "solution": "def test_duplicate(arr):\n    \"\"\"\n    This function checks if there are any duplicate elements in the given array of integers.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates and compare lengths\n    return len(arr) != len(set(arr))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/18": [{"task_id": "Mbpp/18", "solution": "def remove_dirty_chars(first_string, second_string):\n    # Create a set of characters from the second string for quick lookup\n    chars_to_remove = set(second_string)\n    \n    # Use a list comprehension to filter out characters present in the second string\n    result = [char for char in first_string if char not in chars_to_remove]\n    \n    # Join the list back into a string and return\n    return ''.join(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/20": [{"task_id": "Mbpp/20", "solution": "def is_woodall(n):\n    \"\"\"\n    A Woodall number is a number of the form W_n = n * 2^n - 1.\n    This function checks if the given number is a Woodall number.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if n is a Woodall number, False otherwise.\n    \"\"\"\n    if n < 1:\n        return False\n    \n    k = 1\n    while True:\n        woodall_number = k * (2 ** k) - 1\n        if woodall_number == n:\n            return True\n        if woodall_number > n:\n            return False\n        k += 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/56": [{"task_id": "Mbpp/56", "solution": "def check(number):\n    \"\"\"\n    Check if a given number is one less than twice its reverse.\n\n    Parameters:\n    number (int): The number to check.\n\n    Returns:\n    bool: True if the number is one less than twice its reverse, False otherwise.\n    \"\"\"\n    # Convert the number to a string to reverse it\n    reverse_number = int(str(number)[::-1])\n    \n    # Check if the number is one less than twice its reverse\n    return number == 2 * reverse_number - 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/58": [{"task_id": "Mbpp/58", "solution": "def opposite_Signs(a, b):\n    \"\"\"\n    This function checks if two integers have opposite signs.\n    \n    Parameters:\n    a (int): First integer\n    b (int): Second integer\n    \n    Returns:\n    bool: True if the integers have opposite signs, False otherwise\n    \"\"\"\n    # XOR operation between a and b will have its sign bit set if a and b have opposite signs\n    return (a ^ b) < 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/57": [{"task_id": "Mbpp/57", "solution": "def find_Max_Num(digits):\n    # Convert each digit to a string\n    str_digits = map(str, digits)\n    # Sort the digits in descending order\n    sorted_digits = sorted(str_digits, reverse=True)\n    # Join the sorted digits to form the largest number\n    max_num_str = ''.join(sorted_digits)\n    # Convert the result back to an integer\n    return int(max_num_str)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/59": [{"task_id": "Mbpp/59", "solution": "def is_octagonal(n):\n    \"\"\"\n    Calculate the nth octagonal number.\n\n    The formula for the nth octagonal number is:\n    O_n = n * (3n - 2)\n\n    Parameters:\n    n (int): The position of the octagonal number to find.\n\n    Returns:\n    int: The nth octagonal number.\n    \"\"\"\n    return n * (3 * n - 2)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/62": [{"task_id": "Mbpp/62", "solution": "def smallest_num(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns the smallest number in the list.\n    \n    :param numbers: List of numbers\n    :return: The smallest number in the list\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    \n    # Initialize the smallest number with the first element of the list\n    smallest = numbers[0]\n    \n    # Iterate through the list to find the smallest number\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    \n    return smallest", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/63": [{"task_id": "Mbpp/63", "solution": "def max_difference(tuple_list):\n    \"\"\"\n    This function takes a list of tuples and returns the maximum difference\n    between the elements of the tuples.\n    \n    :param tuple_list: List of tuples, where each tuple contains two integers\n    :return: The maximum difference between the elements of the tuples\n    \"\"\"\n    max_diff = 0\n    for a, b in tuple_list:\n        diff = abs(a - b)\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/64": [{"task_id": "Mbpp/64", "solution": "def subject_marks(marks):\n    \"\"\"\n    Sorts a list of tuples based on the second value of each tuple.\n\n    Parameters:\n    marks (list of tuples): A list where each tuple contains a subject and its corresponding mark.\n\n    Returns:\n    list of tuples: The list sorted by the second value of each tuple.\n    \"\"\"\n    # Sort the list of tuples using the second element of each tuple\n    return sorted(marks, key=lambda x: x[1])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/65": [{"task_id": "Mbpp/65", "solution": "def recursive_list_sum(lst):\n    \"\"\"\n    This function takes a nested list and returns the sum of all its elements.\n    It flattens the list recursively and sums up the elements.\n    \"\"\"\n    total = 0\n    for element in lst:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/66": [{"task_id": "Mbpp/66", "solution": "def pos_count(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns the count of positive numbers in the list.\n\n    :param numbers: List of integers\n    :return: Integer count of positive numbers\n    \"\"\"\n    count = 0\n    for number in numbers:\n        if number > 0:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/67": [{"task_id": "Mbpp/67", "solution": "def bell_number(n):\n    # Create a 2D array to store Bell numbers\n    bell = [[0 for i in range(n+1)] for j in range(n+1)]\n    \n    # Base case: Bell(0) is 1\n    bell[0][0] = 1\n    \n    # Fill the Bell triangle\n    for i in range(1, n+1):\n        # Explicitly put the last value of the previous row as the first value of this row\n        bell[i][0] = bell[i-1][i-1]\n        \n        # Fill the rest of the entries in the current row\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    # The Bell number for n is the first entry in the nth row\n    return bell[n][0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/68": [{"task_id": "Mbpp/68", "solution": "def is_Monotonic(array):\n    \"\"\"\n    Function to check if the given array is monotonic.\n    An array is monotonic if it is either entirely non-increasing or non-decreasing.\n\n    Parameters:\n    array (list): A list of integers.\n\n    Returns:\n    bool: True if the array is monotonic, False otherwise.\n    \"\"\"\n    if not array:\n        return True\n\n    increasing = decreasing = True\n\n    for i in range(1, len(array)):\n        if array[i] > array[i - 1]:\n            decreasing = False\n        if array[i] < array[i - 1]:\n            increasing = False\n\n    return increasing or decreasing", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/69": [{"task_id": "Mbpp/69", "solution": "def is_sublist(main_list, sub_list):\n    \"\"\"\n    Check if sub_list is a sublist of main_list.\n\n    Parameters:\n    main_list (list): The list to be searched.\n    sub_list (list): The list to search for.\n\n    Returns:\n    bool: True if sub_list is a sublist of main_list, False otherwise.\n    \"\"\"\n    # Get the lengths of the main list and the sublist\n    len_main = len(main_list)\n    len_sub = len(sub_list)\n\n    # If the sublist is longer than the main list, it cannot be a sublist\n    if len_sub > len_main:\n        return False\n\n    # Iterate over the main list to find the sublist\n    for i in range(len_main - len_sub + 1):\n        # Check if the slice of main_list matches the sub_list\n        if main_list[i:i + len_sub] == sub_list:\n            return True\n\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/70": [{"task_id": "Mbpp/70", "solution": "def get_equal(tuples_list):\n    \"\"\"\n    This function checks if all tuples in the given list have the same length.\n\n    :param tuples_list: List of tuples\n    :return: True if all tuples have the same length, False otherwise\n    \"\"\"\n    if not tuples_list:\n        return True  # If the list is empty, we consider all tuples to have equal length\n\n    # Get the length of the first tuple\n    first_length = len(tuples_list[0])\n\n    # Check if all other tuples have the same length\n    for t in tuples_list:\n        if len(t) != first_length:\n            return False\n\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/71": [{"task_id": "Mbpp/71", "solution": "def comb_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the comb sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    def get_next_gap(gap):\n        # Shrink gap by the shrink factor\n        gap = (gap * 10) // 13\n        if gap < 1:\n            return 1\n        return gap\n\n    n = len(arr)\n    gap = n\n    swapped = True\n\n    while gap != 1 or swapped:\n        # Find the next gap\n        gap = get_next_gap(gap)\n        swapped = False\n\n        # Compare all elements with current gap\n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                # Swap arr[i] and arr[i + gap]\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                swapped = True\n\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/72": [{"task_id": "Mbpp/72", "solution": "def dif_Square(n):\n    \"\"\"\n    Check if a number can be represented as the difference of two squares.\n    \n    A number n can be expressed as the difference of two squares if and only if n is not of the form 4k + 2.\n    This is because:\n    n = a^2 - b^2 = (a-b)(a+b)\n    If n = 4k + 2, then (a-b) and (a+b) must both be even, but their product cannot be 4k + 2.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if n can be represented as the difference of two squares, False otherwise.\n    \"\"\"\n    # Check if n is of the form 4k + 2\n    return n % 4 != 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/61": [{"task_id": "Mbpp/61", "solution": "def count_Substrings(s):\n    def sum_of_digits(sub):\n        return sum(int(char) for char in sub)\n\n    count = 0\n    n = len(s)\n    \n    # Iterate over all possible substrings\n    for start in range(n):\n        for end in range(start + 1, n + 1):\n            substring = s[start:end]\n            if sum_of_digits(substring) == len(substring):\n                count += 1\n\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/74": [{"task_id": "Mbpp/74", "solution": "def is_samepatterns(strings, patterns):\n    if len(strings) != len(patterns):\n        return False\n\n    # Create two dictionaries to map strings to patterns and vice versa\n    str_to_pat = {}\n    pat_to_str = {}\n\n    for s, p in zip(strings, patterns):\n        if s in str_to_pat:\n            if str_to_pat[s] != p:\n                return False\n        else:\n            str_to_pat[s] = p\n\n        if p in pat_to_str:\n            if pat_to_str[p] != s:\n                return False\n        else:\n            pat_to_str[p] = s\n\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["red", "red", "red", "red", "red", "red"], ["a", "b", "c", "a", "b", "c"]]]}], "Mbpp/75": [{"task_id": "Mbpp/75", "solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    This function takes a list of tuples and an integer k, and returns a list of tuples\n    where all elements in each tuple are divisible by k.\n\n    :param tuples_list: List of tuples containing integers\n    :param k: Integer by which divisibility is checked\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over each tuple in the list\n    for t in tuples_list:\n        # Check if all elements in the tuple are divisible by k\n        if all(element % k == 0 for element in t):\n            # If true, append the tuple to the result list\n            result.append(t)\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/77": [{"task_id": "Mbpp/77", "solution": "def is_Diff(number):\n    \"\"\"\n    This function checks if a given number is divisible by 11.\n    \n    Parameters:\n    number (int): The number to check for divisibility by 11.\n    \n    Returns:\n    bool: True if the number is divisible by 11, False otherwise.\n    \"\"\"\n    # Calculate the alternating sum of the digits\n    str_num = str(number)\n    alternating_sum = 0\n    for i, digit in enumerate(str_num):\n        if i % 2 == 0:\n            alternating_sum += int(digit)\n        else:\n            alternating_sum -= int(digit)\n    \n    # Check if the alternating sum is divisible by 11\n    return alternating_sum % 11 == 0", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-1212]]}], "Mbpp/79": [{"task_id": "Mbpp/79", "solution": "def word_len(word):\n    \"\"\"\n    Check whether the length of the word is odd or not.\n\n    Parameters:\n    word (str): The word to check.\n\n    Returns:\n    bool: True if the length of the word is odd, False otherwise.\n    \"\"\"\n    return len(word) % 2 != 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/80": [{"task_id": "Mbpp/80", "solution": "def tetrahedral_number(n):\n    \"\"\"\n    Calculate the nth tetrahedral number.\n\n    A tetrahedral number, T_n, is a figurate number that represents a pyramid with a triangular base and three sides (a tetrahedron).\n    The nth tetrahedral number is the sum of the first n triangular numbers.\n\n    The formula for the nth tetrahedral number is:\n    T_n = n * (n + 1) * (n + 2) / 6\n\n    :param n: The term of the tetrahedral number sequence to calculate.\n    :return: The nth tetrahedral number.\n    \"\"\"\n    return n * (n + 1) * (n + 2) // 6", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/82": [{"task_id": "Mbpp/82", "solution": "import math\ndef volume_sphere(radius):\n    \"\"\"\n    Calculate the volume of a sphere given its radius.\n\n    Parameters:\n    radius (float): The radius of the sphere.\n\n    Returns:\n    float: The volume of the sphere.\n    \"\"\"\n    # Volume of a sphere formula: V = (4/3) * \u03c0 * r^3\n    volume = (4/3) * math.pi * radius**3\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/84": [{"task_id": "Mbpp/84", "solution": "def newman_conway_sequence(n):\n    \"\"\"\n    Calculate the nth number in the Newman-Conway sequence.\n\n    The Newman-Conway sequence is defined as follows:\n    P(1) = 1\n    P(2) = 1\n    For all n > 2, P(n) = P(P(n - 1)) + P(n - P(n - 1))\n\n    :param n: The position in the sequence to calculate.\n    :return: The nth number in the Newman-Conway sequence.\n    \"\"\"\n    if n == 1 or n == 2:\n        return 1\n\n    # Initialize the sequence with the first two known values\n    sequence = [0, 1, 1]  # sequence[0] is a placeholder for convenience\n\n    # Calculate the sequence up to the nth number\n    for i in range(3, n + 1):\n        next_value = sequence[sequence[i - 1]] + sequence[i - sequence[i - 1]]\n        sequence.append(next_value)\n\n    return sequence[n]\n\n# Test the function with the provided assertion\nassert newman_conway_sequence(10) == 6\n\n# Example usage\nif __name__ == \"__main__\":\n    n = 10\n    result = newman_conway_sequence(n)\n    print(f\"The {n}th number in the Newman-Conway sequence is {result}.\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/85": [{"task_id": "Mbpp/85", "solution": "import math\ndef surfacearea_sphere(radius):\n    \"\"\"\n    Calculate the surface area of a sphere given its radius.\n\n    Parameters:\n    radius (float): The radius of the sphere.\n\n    Returns:\n    float: The surface area of the sphere.\n    \"\"\"\n    # Surface area of a sphere formula: 4 * \u03c0 * r^2\n    return 4 * math.pi * radius ** 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/86": [{"task_id": "Mbpp/86", "solution": "def centered_hexagonal_number(n):\n    \"\"\"\n    Calculate the nth centered hexagonal number.\n\n    A centered hexagonal number is a centered figurate number that represents a hexagon with a dot in the center\n    and all other dots surrounding the center dot in a hexagonal lattice.\n\n    The formula for the nth centered hexagonal number is:\n    C_n = 3n(n - 1) + 1\n\n    :param n: The term of the centered hexagonal number to calculate.\n    :return: The nth centered hexagonal number.\n    \"\"\"\n    return 3 * n * (n - 1) + 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/87": [{"task_id": "Mbpp/87", "solution": "def merge_dictionaries_three(dict1, dict2, dict3):\n    \"\"\"\n    Merges three dictionaries into a single dictionary.\n    If there are duplicate keys, the value from the last dictionary is used.\n    \"\"\"\n    # Start with an empty dictionary\n    merged_dict = {}\n    \n    # Update the merged dictionary with each of the input dictionaries\n    merged_dict.update(dict1)\n    merged_dict.update(dict2)\n    merged_dict.update(dict3)\n    \n    return merged_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/88": [{"task_id": "Mbpp/88", "solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n\n    Parameters:\n    lst (list): A list of elements.\n\n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/89": [{"task_id": "Mbpp/89", "solution": "def closest_num(n):\n    \"\"\"\n    This function returns the closest smaller number than the given number n.\n    \"\"\"\n    # Since we need the closest smaller number, we simply subtract 1 from n\n    return n - 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/91": [{"task_id": "Mbpp/91", "solution": "def find_substring(string_list, substring):\n    \"\"\"\n    Check if a substring is present in any of the strings in the given list.\n\n    Parameters:\n    string_list (list of str): The list of strings to search within.\n    substring (str): The substring to search for.\n\n    Returns:\n    bool: True if the substring is found in any of the strings, False otherwise.\n    \"\"\"\n    for string in string_list:\n        if substring in string:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/90": [{"task_id": "Mbpp/90", "solution": "def len_log(words):\n    \"\"\"\n    This function takes a list of words and returns the length of the longest word.\n    \n    :param words: List of words (strings)\n    :return: Length of the longest word\n    \"\"\"\n    if not words:\n        return 0\n    \n    # Find the longest word by length\n    longest_word = max(words, key=len)\n    \n    # Return the length of the longest word\n    return len(longest_word)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/92": [{"task_id": "Mbpp/92", "solution": "def is_undulating(number):\n    \"\"\"\n    Check if a number is undulating. An undulating number is a number that has at least three digits\n    and consists of two different digits that alternate. For example, 1212121 is undulating.\n    \n    :param number: Integer, the number to check\n    :return: Boolean, True if the number is undulating, False otherwise\n    \"\"\"\n    # Convert the number to a string to easily access each digit\n    num_str = str(number)\n    \n    # An undulating number must have at least three digits\n    if len(num_str) < 3:\n        return False\n    \n    # Extract the first two digits\n    first_digit = num_str[0]\n    second_digit = num_str[1]\n    \n    # The first two digits must be different\n    if first_digit == second_digit:\n        return False\n    \n    # Check the alternating pattern\n    for i in range(2, len(num_str)):\n        if i % 2 == 0:\n            # Even index should match the first digit\n            if num_str[i] != first_digit:\n                return False\n        else:\n            # Odd index should match the second digit\n            if num_str[i] != second_digit:\n                return False\n    \n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[82]]}], "Mbpp/93": [{"task_id": "Mbpp/93", "solution": "def power(a, b):\n    \"\"\"\n    Calculate the value of 'a' to the power 'b'.\n\n    Parameters:\n    a (int or float): The base number.\n    b (int): The exponent.\n\n    Returns:\n    int or float: The result of a raised to the power of b.\n    \"\"\"\n    return a ** b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/95": [{"task_id": "Mbpp/95", "solution": "def Find_Min_Length(list_of_lists):\n    \"\"\"\n    This function takes a list of lists as input and returns the length of the smallest list.\n    \n    Parameters:\n    list_of_lists (list): A list containing lists of varying lengths.\n    \n    Returns:\n    int: The length of the smallest list.\n    \"\"\"\n    if not list_of_lists:\n        return 0  # Return 0 if the input list is empty\n    \n    # Use min with a generator expression to find the minimum length\n    min_length = min(len(lst) for lst in list_of_lists)\n    return min_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/94": [{"task_id": "Mbpp/94", "solution": "def index_minimum(tuples_list):\n    \"\"\"\n    This function takes a list of tuples and returns the first value of the tuple with the smallest second value.\n    \n    :param tuples_list: List of tuples, where each tuple contains a string and an integer.\n    :return: The first value of the tuple with the smallest second value.\n    \"\"\"\n    # Check if the list is empty\n    if not tuples_list:\n        return None\n    \n    # Initialize the minimum tuple with the first element\n    min_tuple = tuples_list[0]\n    \n    # Iterate over the list to find the tuple with the smallest second value\n    for current_tuple in tuples_list:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/97": [{"task_id": "Mbpp/97", "solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Count the frequency of each element in the flattened list\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/96": [{"task_id": "Mbpp/96", "solution": "def divisor(n):\n    \"\"\"\n    This function returns the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"The input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/99": [{"task_id": "Mbpp/99", "solution": "def decimal_to_binary(n):\n    # Handle the special case where the number is 0\n    if n == 0:\n        return '0'\n    \n    binary_str = ''\n    while n > 0:\n        # Get the remainder when n is divided by 2 (either 0 or 1)\n        remainder = n % 2\n        # Prepend the remainder to the binary string\n        binary_str = str(remainder) + binary_str\n        # Update n to be the quotient of n divided by 2\n        n = n // 2\n    \n    return binary_str", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-5]]}], "Mbpp/98": [{"task_id": "Mbpp/98", "solution": "import math\nfrom functools import reduce\ndef multiply_num(numbers):\n    # Multiply all numbers in the list\n    product = reduce(lambda x, y: x * y, numbers)\n    # Divide the product by the length of the list\n    result = product / len(numbers)\n    return result\nnumbers = (8, 2, 3, -1, 7)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/101": [{"task_id": "Mbpp/101", "solution": "def kth_element(arr, k):\n    \"\"\"\n    Returns the k-th element of the array using 1-based indexing.\n    \n    Parameters:\n    arr (list): The list of elements.\n    k (int): The 1-based index of the element to retrieve.\n    \n    Returns:\n    The k-th element of the array.\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    index = k - 1\n    \n    # Return the element at the 0-based index\n    return arr[index]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/100": [{"task_id": "Mbpp/100", "solution": "def next_smallest_palindrome(n):\n    \"\"\"\n    Find the next smallest palindrome greater than the specified integer n.\n    \n    Parameters:\n    n (int): The integer to find the next smallest palindrome for.\n    \n    Returns:\n    int: The next smallest palindrome greater than n.\n    \"\"\"\n    def is_palindrome(num):\n        \"\"\"Check if a number is a palindrome.\"\"\"\n        return str(num) == str(num)[::-1]\n    \n    # Start checking from the next number\n    n += 1\n    while not is_palindrome(n):\n        n += 1\n    return n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/102": [{"task_id": "Mbpp/102", "solution": "def snake_to_camel(snake_str):\n    # Split the snake case string by underscores\n    components = snake_str.split('_')\n    # Capitalize the first letter of each component and join them\n    camel_case_str = ''.join(x.capitalize() for x in components)\n    return camel_case_str", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["___python_program"]]}], "Mbpp/103": [{"task_id": "Mbpp/103", "solution": "def eulerian_num(n, m):\n    \"\"\"\n    Calculate the Eulerian number a(n, m).\n    \n    Eulerian numbers are defined by the recurrence relation:\n    a(n, m) = (n - m) * a(n - 1, m - 1) + (m + 1) * a(n - 1, m)\n    with initial conditions:\n    a(0, 0) = 1\n    a(n, m) = 0 if m >= n or m < 0\n    \"\"\"\n    # Create a table to store results of subproblems\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    \n    # Base case\n    dp[0][0] = 1\n    \n    # Fill the table according to the recurrence relation\n    for i in range(1, n + 1):\n        for j in range(0, min(i, m + 1)):\n            if j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    \n    return dp[n][m]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0, 0]]}], "Mbpp/105": [{"task_id": "Mbpp/105", "solution": "def count_true_booleans(boolean_list):\n    \"\"\"\n    Count the number of True values in the given list of booleans.\n\n    Parameters:\n    boolean_list (list): A list containing boolean values.\n\n    Returns:\n    int: The count of True values in the list.\n    \"\"\"\n    return sum(1 for item in boolean_list if item is True)\n\n# Test the function with the provided assertion\nassert count_true_booleans([True, False, True]) == 2\n\n# Additional test cases\nprint(count_true_booleans([True, True, True]))  # Output: 3\nprint(count_true_booleans([False, False, False]))  # Output: 0\nprint(count_true_booleans([True, False, False, True, True]))  # Output: 3\nprint(count_true_booleans([]))  # Output: 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/104": [{"task_id": "Mbpp/104", "solution": "def sort_sublists(list_of_lists):\n    \"\"\"\n    Sort each sublist of strings in a given list of lists.\n\n    Parameters:\n    list_of_lists (list of list of str): A list containing sublists of strings.\n\n    Returns:\n    list of list of str: A list with each sublist sorted.\n    \"\"\"\n    # Iterate over each sublist and sort it\n    sorted_list_of_lists = [sorted(sublist) for sublist in list_of_lists]\n    return sorted_list_of_lists", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/106": [{"task_id": "Mbpp/106", "solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the elements of the list appended to the tuple.\n    \"\"\"\n    # Convert the list to a tuple and concatenate it with the original tuple\n    return tpl + tuple(lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/108": [{"task_id": "Mbpp/108", "solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    combined_list.sort()\n    return combined_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/109": [{"task_id": "Mbpp/109", "solution": "def odd_Equivalent(binary_string, rotations):\n    \"\"\"\n    This function takes a binary string and a number of rotations, and returns the number of times\n    the binary string, when rotated, represents an odd number.\n    \n    Parameters:\n    binary_string (str): The binary string to be rotated.\n    rotations (int): The number of rotations to perform.\n    \n    Returns:\n    int: The number of rotations that result in an odd number.\n    \"\"\"\n    count_odd = 0\n    length = len(binary_string)\n    \n    # Perform the rotations\n    for i in range(rotations):\n        # Rotate the string\n        rotated_string = binary_string[i % length:] + binary_string[:i % length]\n        \n        # Check if the rotated binary string represents an odd number\n        if rotated_string[-1] == '1':  # Check the last bit\n            count_odd += 1\n    \n    return count_odd", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["10000100110011", 5]]}], "Mbpp/111": [{"task_id": "Mbpp/111", "solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    This function takes a list of lists and returns a list of elements that are common to all the nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Start with the first list's elements as the initial set of common elements\n    common_elements = set(nested_lists[0])\n\n    # Intersect with each subsequent list\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/113": [{"task_id": "Mbpp/113", "solution": "def check_integer(s):\n    \"\"\"\n    This function checks if the given string represents an integer.\n\n    Parameters:\n    s (str): The string to check.\n\n    Returns:\n    bool: True if the string represents an integer, False otherwise.\n    \"\"\"\n    # Strip any leading or trailing whitespace\n    s = s.strip()\n    \n    # Check if the string is empty after stripping\n    if not s:\n        return False\n    \n    # Check if the string is a valid integer\n    if s[0] in ('-', '+'):  # Allow for a leading sign\n        return s[1:].isdigit()\n    return s.isdigit()", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/116": [{"task_id": "Mbpp/116", "solution": "def tuple_to_int(tup):\n    \"\"\"\n    Convert a tuple of positive integers into a single integer.\n\n    Parameters:\n    tup (tuple): A tuple of positive integers.\n\n    Returns:\n    int: A single integer formed by concatenating the elements of the tuple.\n    \"\"\"\n    # Convert each integer in the tuple to a string and join them\n    # Then convert the resulting string back to an integer\n    return int(''.join(map(str, tup)))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/118": [{"task_id": "Mbpp/118", "solution": "def string_to_list(input_string):\n    \"\"\"\n    Convert a string to a list of strings split on the space character.\n\n    Parameters:\n    input_string (str): The string to be split.\n\n    Returns:\n    list: A list of strings split on the space character.\n    \"\"\"\n    return input_string.split()", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/119": [{"task_id": "Mbpp/119", "solution": "def search(arr):\n    \"\"\"\n    This function finds the element that appears only once in a sorted array.\n    :param arr: List[int] - A sorted list of integers where every element appears twice except for one.\n    :return: int - The element that appears only once.\n    \"\"\"\n    # Initialize the result variable\n    result = 0\n    \n    # Iterate over each element in the array\n    for num in arr:\n        # XOR the result with the current number\n        result ^= num\n    \n    # Return the result which is the single element\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/120": [{"task_id": "Mbpp/120", "solution": "def max_product_tuple(tuples_list):\n    \"\"\"\n    This function takes a list of tuples, where each tuple contains two numbers.\n    It returns the maximum absolute product of the numbers in any tuple.\n    \"\"\"\n    max_product = float('-inf')  # Initialize with the smallest possible number\n\n    for a, b in tuples_list:\n        product = abs(a * b)  # Calculate the absolute product of the tuple\n        if product > max_product:\n            max_product = product  # Update max_product if the current product is greater\n\n    return max_product", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/124": [{"task_id": "Mbpp/124", "solution": "import math\ndef angle_complex(z):\n    \"\"\"\n    Calculate the angle (or argument) of a complex number.\n\n    Parameters:\n    z (complex): A complex number.\n\n    Returns:\n    float: The angle of the complex number in radians.\n    \"\"\"\n    return math.atan2(z.imag, z.real)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["0.0", "1j"]], "plus_fail_tests": [["0.0", "0j"]]}], "Mbpp/125": [{"task_id": "Mbpp/125", "solution": "def find_length(binary_string):\n    # Initialize variables to track the maximum difference and current difference\n    max_diff = 0\n    current_diff = 0\n\n    # Iterate over each character in the binary string\n    for char in binary_string:\n        # If the character is '0', increase the current difference\n        if char == '0':\n            current_diff += 1\n        # If the character is '1', decrease the current difference\n        else:\n            current_diff -= 1\n\n        # If the current difference is greater than the maximum difference, update max_diff\n        if current_diff > max_diff:\n            max_diff = current_diff\n\n        # If the current difference becomes negative, reset it to 0\n        if current_diff < 0:\n            current_diff = 0\n\n    return max_diff", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/126": [{"task_id": "Mbpp/126", "solution": "def sum_of_common_divisors(a, b):\n    \"\"\"\n    This function returns the sum of all common divisors of two given numbers a and b.\n    \"\"\"\n    def gcd(x, y):\n        # Function to compute the greatest common divisor using Euclid's algorithm\n        while y:\n            x, y = y, x % y\n        return x\n\n    def divisors(n):\n        # Function to find all divisors of a number n\n        divs = set()\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divs.add(i)\n                divs.add(n // i)\n        return divs\n\n    # Find the greatest common divisor of a and b\n    greatest_common_divisor = gcd(a, b)\n    \n    # Find all divisors of the greatest common divisor\n    common_divisors = divisors(greatest_common_divisor)\n    \n    # Return the sum of all common divisors\n    return sum(common_divisors)\n\n# Test the function with the given assertion\nassert sum_of_common_divisors(10, 15) == 6\n\n# Example usage\nprint(sum_of_common_divisors(10, 15))  # Output: 6\nprint(sum_of_common_divisors(12, 18))  # Output: 12 (common divisors are 1, 2, 3, 6)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/127": [{"task_id": "Mbpp/127", "solution": "def multiply_int(a, b):\n    \"\"\"\n    Multiplies two integers and returns the result.\n\n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n\n    Returns:\n    int: The product of the two integers.\n    \"\"\"\n    return a * b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/128": [{"task_id": "Mbpp/128", "solution": "def long_words(n, sentence):\n    \"\"\"\n    This function takes an integer n and a sentence (string) as input.\n    It returns a list of words from the sentence that are longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/129": [{"task_id": "Mbpp/129", "solution": "def magic_square_test(matrix):\n    # Check if the matrix is empty or not square\n    if not matrix or any(len(row) != len(matrix) for row in matrix):\n        return False\n\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the magic sum\n    magic_sum = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/130": [{"task_id": "Mbpp/130", "solution": "def max_occurrences(lst):\n    # Create a dictionary to count the frequency of each element\n    frequency = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # Increment the count for the item in the frequency dictionary\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    for item, count in frequency.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/131": [{"task_id": "Mbpp/131", "solution": "def reverse_vowels(s: str) -> str:\n    # Define a set of vowels\n    vowels = set(\"aeiouAEIOU\")\n    \n    # Convert the string to a list to allow modification\n    s_list = list(s)\n    \n    # Initialize two pointers\n    left, right = 0, len(s) - 1\n    \n    # Use two pointers to find vowels from both ends\n    while left < right:\n        # Move the left pointer until a vowel is found\n        while left < right and s_list[left] not in vowels:\n            left += 1\n        # Move the right pointer until a vowel is found\n        while left < right and s_list[right] not in vowels:\n            right -= 1\n        \n        # Swap the vowels\n        s_list[left], s_list[right] = s_list[right], s_list[left]\n        \n        # Move both pointers towards the center\n        left += 1\n        right -= 1\n    \n    # Convert the list back to a string\n    return ''.join(s_list)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/132": [{"task_id": "Mbpp/132", "solution": "def tup_string(tup):\n    \"\"\"\n    Convert a tuple of characters to a string.\n\n    Parameters:\n    tup (tuple): A tuple containing characters.\n\n    Returns:\n    str: A string formed by concatenating the characters in the tuple.\n    \"\"\"\n    return ''.join(tup)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/133": [{"task_id": "Mbpp/133", "solution": "def sum_negativenum(numbers):\n    \"\"\"\n    Calculate the sum of the negative numbers in a given list of numbers.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The sum of the negative numbers in the list.\n    \"\"\"\n    # Initialize sum to 0\n    negative_sum = 0\n    \n    # Iterate through each number in the list\n    for num in numbers:\n        # Check if the number is negative\n        if num < 0:\n            # Add the negative number to the sum\n            negative_sum += num\n    \n    return negative_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/135": [{"task_id": "Mbpp/135", "solution": "def hexagonal_num(n):\n    \"\"\"\n    Calculate the nth hexagonal number.\n\n    A hexagonal number is a figurate number that represents a hexagon with n dots on a side.\n    The formula to find the nth hexagonal number is: H(n) = n * (2n - 1)\n\n    Parameters:\n    n (int): The position of the hexagonal number to find.\n\n    Returns:\n    int: The nth hexagonal number.\n    \"\"\"\n    return n * (2 * n - 1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/137": [{"task_id": "Mbpp/137", "solution": "import math\ndef zero_count(arr):\n    if not arr:  # Check if the array is empty\n        return 0.0\n    \n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    \n    if non_zeroes == 0:  # Avoid division by zero\n        return float('inf')  # or return 0.0 if you prefer\n    \n    return zeroes / non_zeroes", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/123": [{"task_id": "Mbpp/123", "solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    total = 1  # 1 is a proper divisor of every number\n    sqrt_n = int(n**0.5)\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef is_amicable(a):\n    \"\"\"Check if a number is amicable.\"\"\"\n    b = sum_of_divisors(a)\n    return a != b and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers up to a specified limit.\"\"\"\n    amicable_sum = 0\n    for number in range(2, limit + 1):\n        if is_amicable(number):\n            amicable_sum += number\n    return amicable_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/138": [{"task_id": "Mbpp/138", "solution": "def is_Sum_Of_Powers_Of_Two(n):\n    \"\"\"\n    Check if a given number can be represented as a sum of non-zero powers of 2.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number can be represented as a sum of non-zero powers of 2, False otherwise.\n    \"\"\"\n    # A number can be represented as a sum of non-zero powers of 2 if it is a positive integer\n    # and can be expressed in binary form with only 1s (e.g., 10 = 1010 in binary).\n    # This is equivalent to checking if the number is greater than 0.\n    return n > 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[7]], "plus_fail_tests": [[123456789]]}], "Mbpp/139": [{"task_id": "Mbpp/139", "solution": "import math\ndef circle_circumference(radius):\n    \"\"\"\n    Calculate the circumference of a circle given its radius.\n\n    Parameters:\n    radius (float): The radius of the circle.\n\n    Returns:\n    float: The circumference of the circle.\n    \"\"\"\n    return 2 * math.pi * radius", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/140": [{"task_id": "Mbpp/140", "solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Parameters:\n    list_of_lists (list of lists/tuples): A list containing lists or tuples of numbers.\n\n    Returns:\n    set: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    result_set = set()\n    \n    # Iterate over each sublist/tuple in the list_of_lists\n    for sublist in list_of_lists:\n        # Update the result_set with elements from the current sublist/tuple\n        result_set.update(sublist)\n    \n    return result_set", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/142": [{"task_id": "Mbpp/142", "solution": "def count_samepair(list1, list2, list3):\n    # Initialize a counter for identical items\n    count = 0\n    \n    # Iterate over the lists using zip to pair elements at the same position\n    for item1, item2, item3 in zip(list1, list2, list3):\n        # Check if all three items are identical\n        if item1 == item2 == item3:\n            count += 1\n    \n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/141": [{"task_id": "Mbpp/141", "solution": "def pancake_sort(arr):\n    def flip(sublist, k):\n        \"\"\"Helper function to reverse the order of the first k elements of the sublist.\"\"\"\n        sublist[:k] = sublist[:k][::-1]\n\n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0:size]\n        max_index = max(range(size), key=arr.__getitem__)\n        \n        # Move the maximum element to the end of the current sublist\n        if max_index != size - 1:\n            # Flip the maximum element to the front if it's not already there\n            if max_index != 0:\n                flip(arr, max_index + 1)\n            # Flip it to the end of the current sublist\n            flip(arr, size)\n    \n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/160": [{"task_id": "Mbpp/160", "solution": "def find_solution(a, b, n):\n    \"\"\"\n    Find integers x and y such that ax + by = n.\n    \n    Parameters:\n    a (int): Coefficient of x.\n    b (int): Coefficient of y.\n    n (int): The target value.\n    \n    Returns:\n    tuple: A tuple (x, y) if a solution exists, otherwise None.\n    \"\"\"\n    def gcd_extended(a, b):\n        \"\"\"\n        Extended Euclidean Algorithm to find gcd of a and b.\n        It also finds x and y such that ax + by = gcd(a, b)\n        \n        Returns:\n        gcd, x, y\n        \"\"\"\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = gcd_extended(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n\n    gcd, x, y = gcd_extended(a, b)\n    \n    # Check if n is a multiple of gcd(a, b)\n    if n % gcd != 0:\n        return None\n    \n    # Scale the solution of ax + by = gcd(a, b) to ax + by = n\n    x *= n // gcd\n    y *= n // gcd\n    \n    return (x, y)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2, 3, 7]], "plus_fail_tests": [[25, 10, 500]]}], "Mbpp/145": [{"task_id": "Mbpp/145", "solution": "def max_Abs_Diff(arr):\n    \"\"\"\n    This function takes a tuple of integers and returns the maximum difference\n    between any two elements in the array.\n    \"\"\"\n    if not arr or len(arr) < 2:\n        return 0  # If the array is empty or has less than 2 elements, return 0\n\n    # Find the minimum and maximum elements in the array\n    min_element = min(arr)\n    max_element = max(arr)\n\n    # The maximum difference will be between the maximum and minimum elements\n    max_difference = max_element - min_element\n\n    return max_difference", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/161": [{"task_id": "Mbpp/161", "solution": "def remove_elements(original_list, elements_to_remove):\n    \"\"\"\n    Remove all elements from original_list that are present in elements_to_remove.\n\n    :param original_list: List of elements from which some elements need to be removed.\n    :param elements_to_remove: List of elements that need to be removed from original_list.\n    :return: A new list with the elements removed.\n    \"\"\"\n    # Convert elements_to_remove to a set for faster lookup\n    elements_to_remove_set = set(elements_to_remove)\n    \n    # Use list comprehension to filter out elements\n    result_list = [element for element in original_list if element not in elements_to_remove_set]\n    \n    return result_list", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, "apple", [1, 2], [3, 4], {"name": "John"}, 5.5], [2, "apple", [3, 4], {"name": "John"}, 5.5]]]}], "Mbpp/165": [{"task_id": "Mbpp/165", "solution": "def count_char_position(s):\n    # Convert the string to lowercase to make the function case insensitive\n    s = s.lower()\n    count = 0\n    \n    # Iterate over the string and check if the character matches its position in the alphabet\n    for i, char in enumerate(s):\n        # Calculate the position in the alphabet (1-based index)\n        alphabet_position = ord(char) - ord('a') + 1\n        # Check if the position matches the index (1-based)\n        if alphabet_position == i + 1:\n            count += 1\n    \n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/166": [{"task_id": "Mbpp/166", "solution": "def find_even_pair(nums):\n    \"\"\"\n    This function counts the number of pairs of integers in a list that XOR to an even number.\n    \n    Args:\n    nums (list): A list of integers.\n    \n    Returns:\n    int: The number of pairs that XOR to an even number.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    # Count the number of even and odd numbers in the list\n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # A pair (a, b) XORs to an even number if both are even or both are odd\n    # So, we count pairs of even numbers and pairs of odd numbers\n    even_pairs = (even_count * (even_count - 1)) // 2\n    odd_pairs = (odd_count * (odd_count - 1)) // 2\n    \n    return even_pairs + odd_pairs", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/167": [{"task_id": "Mbpp/167", "solution": "def next_power_of_2(n):\n    \"\"\"\n    Find the smallest power of 2 greater than or equal to n.\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The smallest power of 2 greater than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 1\n    power = 1\n    while power < n:\n        power *= 2\n    return power", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/168": [{"task_id": "Mbpp/168", "solution": "def frequency(lst, number):\n    \"\"\"\n    Count the number of occurrences of 'number' in the list 'lst'.\n\n    Parameters:\n    lst (list): The list in which to count occurrences.\n    number (int): The number to count in the list.\n\n    Returns:\n    int: The count of occurrences of 'number' in 'lst'.\n    \"\"\"\n    return lst.count(number)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/170": [{"task_id": "Mbpp/170", "solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    :param numbers: List of integers.\n    :param start_index: Starting index of the range (inclusive).\n    :param end_index: Ending index of the range (inclusive).\n    :return: Sum of the numbers within the specified range.\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0 or end_index >= len(numbers) or start_index > end_index:\n        raise ValueError(\"Invalid indices: start_index and end_index must be within the list bounds and start_index <= end_index.\")\n    \n    # Calculate the sum of the numbers within the specified range\n    return sum(numbers[start_index:end_index + 1])", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 7, 5]]}], "Mbpp/171": [{"task_id": "Mbpp/171", "solution": "def perimeter_pentagon(side_length):\n    \"\"\"\n    Calculate the perimeter of a regular pentagon given the length of its side.\n\n    Parameters:\n    side_length (float): The length of one side of the pentagon.\n\n    Returns:\n    float: The perimeter of the pentagon.\n    \"\"\"\n    # A regular pentagon has 5 equal sides\n    num_sides = 5\n    perimeter = num_sides * side_length\n    return perimeter", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/172": [{"task_id": "Mbpp/172", "solution": "def count_occurance(s):\n    \"\"\"\n    Count the number of occurrences of the substring 'std' in the given string s.\n\n    Parameters:\n    s (str): The string in which to count occurrences of 'std'.\n\n    Returns:\n    int: The number of times 'std' occurs in the string.\n    \"\"\"\n    return s.count('std')", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/222": [{"task_id": "Mbpp/222", "solution": "def check_type(tup):\n    \"\"\"\n    This function checks if all elements in the tuple have the same data type.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if all elements have the same data type, False otherwise.\n    \"\"\"\n    if not tup:  # If the tuple is empty, return True\n        return True\n\n    # Get the type of the first element\n    first_type = type(tup[0])\n\n    # Check if all elements have the same type as the first element\n    for element in tup:\n        if type(element) != first_type:\n            return False\n\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/162": [{"task_id": "Mbpp/162", "solution": "def sum_series(n):\n    \"\"\"\n    Calculate the sum of the series (n - 2*i) from i=0 to n // 2.\n    \n    Parameters:\n    n (int): The starting integer of the series.\n    \n    Returns:\n    int: The sum of the series.\n    \"\"\"\n    total_sum = 0\n    i = 0\n    while n - 2 * i >= 0:\n        total_sum += n - 2 * i\n        i += 1\n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/223": [{"task_id": "Mbpp/223", "solution": "def is_majority(arr, n, element):\n    \"\"\"\n    Determines if the given element is the majority element in the sorted array.\n    \n    Parameters:\n    arr (list): A sorted list of elements.\n    n (int): The length of the list.\n    element: The element to check for majority.\n    \n    Returns:\n    bool: True if the element is the majority element, False otherwise.\n    \"\"\"\n    # A majority element must appear at least n//2 + 1 times\n    majority_count = n // 2 + 1\n    \n    # Find the first occurrence of the element using binary search\n    def binary_search_first_occurrence(arr, n, element):\n        low, high = 0, n - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == element:\n                if mid == 0 or arr[mid - 1] != element:\n                    return mid\n                else:\n                    high = mid - 1\n            elif arr[mid] < element:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return -1\n    \n    # Find the first occurrence of the element\n    first_occurrence = binary_search_first_occurrence(arr, n, element)\n    \n    # If the element is not found, it cannot be the majority element\n    if first_occurrence == -1:\n        return False\n    \n    # Check if the element appears at least majority_count times\n    if first_occurrence + majority_count - 1 < n and arr[first_occurrence + majority_count - 1] == element:\n        return True\n    \n    return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 1, 0]]}], "Mbpp/224": [{"task_id": "Mbpp/224", "solution": "def count_set_bits(n):\n    \"\"\"\n    Count the number of set bits (1s) in the binary representation of a given number.\n\n    Parameters:\n    n (int): The number to count set bits in.\n\n    Returns:\n    int: The count of set bits in the binary representation of n.\n    \"\"\"\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\n\n# Test the function with the provided assertion\nassert count_set_bits(2) == 1\n\n# Additional test cases\nassert count_set_bits(0) == 0  # No set bits in 0\nassert count_set_bits(1) == 1  # One set bit in 1\nassert count_set_bits(3) == 2  # Binary 11 has two set bits\nassert count_set_bits(4) == 1  # Binary 100 has one set bit\nassert count_set_bits(15) == 4 # Binary 1111 has four set bits\n\nprint(\"All tests passed.\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/226": [{"task_id": "Mbpp/226", "solution": "def odd_values_string(s):\n    \"\"\"\n    This function removes characters which have odd index values from the given string.\n    \n    Parameters:\n    s (str): The input string from which characters with odd index values will be removed.\n    \n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    # Use list comprehension to filter out characters at odd indices\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 0])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/227": [{"task_id": "Mbpp/227", "solution": "def min_of_three(a, b, c):\n    \"\"\"\n    Returns the minimum of three numbers.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n    c (int or float): The third number.\n\n    Returns:\n    int or float: The minimum of the three numbers.\n    \"\"\"\n    return min(a, b, c)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/230": [{"task_id": "Mbpp/230", "solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replaces blank spaces in the input_string with the specified character.\n\n    Parameters:\n    input_string (str): The string in which to replace spaces.\n    char (str): The character to replace spaces with.\n\n    Returns:\n    str: The modified string with spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', char)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/232": [{"task_id": "Mbpp/232", "solution": "def larg_nnum(lst, n):\n    \"\"\"\n    Returns a list containing the n largest items from the input list.\n\n    Parameters:\n    lst (list): The list from which to find the largest items.\n    n (int): The number of largest items to return.\n\n    Returns:\n    list: A list containing the n largest items from the input list.\n    \"\"\"\n    # Sort the list in descending order and take the first n elements\n    return sorted(lst, reverse=True)[:n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/233": [{"task_id": "Mbpp/233", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/234": [{"task_id": "Mbpp/234", "solution": "def volume_cube(side_length):\n    \"\"\"\n    Calculate the volume of a cube given its side length.\n\n    Parameters:\n    side_length (float): The length of a side of the cube.\n\n    Returns:\n    float: The volume of the cube.\n    \"\"\"\n    return side_length ** 3", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/235": [{"task_id": "Mbpp/235", "solution": "def even_bit_set_number(n):\n    \"\"\"\n    This function sets all even bits of a given number.\n    An even bit is defined as a bit at an even position (0-indexed).\n    \"\"\"\n    # Initialize a mask with all even bits set\n    mask = 0\n    bit_position = 0\n    \n    # Create a mask with all even bits set\n    while (1 << bit_position) <= n:\n        if bit_position % 2 == 0:\n            mask |= (1 << bit_position)\n        bit_position += 1\n    \n    # Set all even bits of n using the mask\n    return n | mask", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[999999999]]}], "Mbpp/237": [{"task_id": "Mbpp/237", "solution": "def check_occurences(tuples_list):\n    # Create a dictionary to store the occurrences of each tuple\n    occurrences = {}\n    \n    for t in tuples_list:\n        # Sort the tuple to ensure (a, b) and (b, a) are considered the same\n        sorted_tuple = tuple(sorted(t))\n        \n        # Increment the count of the sorted tuple in the dictionary\n        if sorted_tuple in occurrences:\n            occurrences[sorted_tuple] += 1\n        else:\n            occurrences[sorted_tuple] = 1\n    \n    return occurrences", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/238": [{"task_id": "Mbpp/238", "solution": "def number_of_substrings(s: str) -> int:\n    \"\"\"\n    Calculate the number of non-empty substrings of a given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The number of non-empty substrings.\n    \"\"\"\n    # The number of non-empty substrings of a string of length n is given by the formula n * (n + 1) / 2\n    n = len(s)\n    return n * (n + 1) // 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/240": [{"task_id": "Mbpp/240", "solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Parameters:\n    list1 (list): The first list.\n    list2 (list): The second list whose elements will replace the last element of list1.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    # Remove the last element of list1 and extend it with list2\n    return list1[:-1] + list2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/242": [{"task_id": "Mbpp/242", "solution": "def count_charac(s):\n    \"\"\"\n    This function takes a string as input and returns the total number of characters in the string.\n    \n    Parameters:\n    s (str): The input string whose characters are to be counted.\n    \n    Returns:\n    int: The total number of characters in the input string.\n    \"\"\"\n    return len(s)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/244": [{"task_id": "Mbpp/244", "solution": "import math\ndef next_Perfect_Square(n):\n    \"\"\"\n    This function finds the next perfect square greater than a given number n.\n    \n    Parameters:\n    n (int): The number to find the next perfect square for.\n    \n    Returns:\n    int: The next perfect square greater than n.\n    \"\"\"\n    # Find the square root of the given number\n    root = math.sqrt(n)\n    \n    # Find the next whole number greater than the square root\n    next_root = math.ceil(root)\n    \n    # Calculate the next perfect square\n    next_perfect_square = next_root ** 2\n    \n    return next_perfect_square", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[9]], "plus_fail_tests": [[-5]]}], "Mbpp/245": [{"task_id": "Mbpp/245", "solution": "def max_sum_bitonic_subsequence(arr):\n    n = len(arr)\n    \n    # Initialize the increasing and decreasing subsequence sums\n    inc = [0] * n\n    dec = [0] * n\n    \n    # Fill the increasing subsequence sums\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n    \n    # Fill the decreasing subsequence sums\n    for i in range(n-1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(n-1, i, -1):\n            if arr[j] < arr[i] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n    \n    # Find the maximum sum of bitonic subsequence\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n    \n    return max_sum\n\n# Test the function with the provided test case\nassert max_sum_bitonic_subsequence([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/247": [{"task_id": "Mbpp/247", "solution": "def lps(s: str) -> int:\n    \"\"\"\n    Function to find the length of the longest palindromic subsequence in the given string.\n    \"\"\"\n    n = len(s)\n    \n    # Create a 2D array to store the length of the longest palindromic subsequence\n    dp = [[0] * n for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Build the table. The outer loop is for substrings of increasing length\n    for cl in range(2, n + 1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if s[i] == s[j] and cl == 2:\n                dp[i][j] = 2\n            elif s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n    \n    # The length of the longest palindromic subseq is in dp[0][n-1]\n    return dp[0][n - 1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/250": [{"task_id": "Mbpp/250", "solution": "def count_X(tup, element):\n    \"\"\"\n    Counts the occurrences of the specified element in the given tuple.\n\n    Parameters:\n    tup (tuple): The tuple in which to count occurrences.\n    element: The element to count in the tuple.\n\n    Returns:\n    int: The number of times the element occurs in the tuple.\n    \"\"\"\n    return tup.count(element)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/251": [{"task_id": "Mbpp/251", "solution": "def insert_element(lst, element):\n    # Create a new list to store the result\n    result = []\n    # Iterate over each item in the original list\n    for item in lst:\n        # Append the element before each item\n        result.append(element)\n        result.append(item)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/252": [{"task_id": "Mbpp/252", "solution": "import cmath\ndef convert(complex_number):\n    \"\"\"\n    Convert a complex number to its polar coordinates representation.\n\n    Parameters:\n    complex_number (complex): A complex number.\n\n    Returns:\n    tuple: A tuple containing the magnitude and phase angle (in radians) of the complex number.\n    \"\"\"\n    # Use cmath.polar to convert the complex number to polar coordinates\n    magnitude, angle = cmath.polar(complex_number)\n    return (magnitude, angle)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/253": [{"task_id": "Mbpp/253", "solution": "def count_integer(lst):\n    \"\"\"\n    This function takes a list as input and returns the number of integer elements in the list.\n\n    Parameters:\n    lst (list): The list to be checked for integer elements.\n\n    Returns:\n    int: The count of integer elements in the list.\n    \"\"\"\n    return sum(1 for item in lst if isinstance(item, int))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/239": [{"task_id": "Mbpp/239", "solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a memoization table where dp[i][j] represents the number of sequences\n    # of length j that end with the number i.\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Base case: There is one sequence of length 1 for each number from 1 to m\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n\n    # Fill the dp table\n    for length in range(2, n + 1):  # For each sequence length from 2 to n\n        for current in range(1, m + 1):  # For each possible current number\n            # Calculate the number of sequences of length `length` ending with `current`\n            for previous in range(1, current // 2 + 1):  # Previous must be at least half of current\n                dp[current][length] += dp[previous][length - 1]\n\n    # Sum up all sequences of length n\n    total_sequences = sum(dp[i][n] for i in range(1, m + 1))\n    return total_sequences", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/256": [{"task_id": "Mbpp/256", "solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    # Initialize a list to track prime status of numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n\n    # Implement the Sieve of Eratosthenes\n    for start in range(2, int(n**0.5) + 1):\n        if is_prime[start]:\n            for multiple in range(start*start, n, start):\n                is_prime[multiple] = False\n\n    # Count the number of primes\n    return sum(is_prime)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/257": [{"task_id": "Mbpp/257", "solution": "def swap_numbers(a, b):\n    \"\"\"\n    This function takes two numbers and returns a tuple with the second number first and the first number second.\n    \n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n    \n    Returns:\n    tuple: A tuple with the second number first and the first number second.\n    \"\"\"\n    return (b, a)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/259": [{"task_id": "Mbpp/259", "solution": "def maximize_elements(tuple1, tuple2):\n    \"\"\"\n    This function takes two tuples of tuples and returns a new tuple of tuples\n    where each element is the maximum of the corresponding elements from the input tuples.\n    \"\"\"\n    # Ensure both tuples have the same length\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Both tuples must have the same length\")\n\n    # Create a new tuple with maximized elements\n    maximized_tuple = tuple(\n        (max(a[0], b[0]), max(a[1], b[1])) for a, b in zip(tuple1, tuple2)\n    )\n\n    return maximized_tuple", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/255": [{"task_id": "Mbpp/255", "solution": "from itertools import product\ndef combinations_colors(elements, n):\n    \"\"\"\n    Generate all combinations with repetition of the elements of the list.\n\n    :param elements: List of elements to combine\n    :param n: Length of each combination\n    :return: List of tuples, each representing a combination\n    \"\"\"\n    return list(product(elements, repeat=n))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Red", "Green", "Blue"], 2]], "plus_fail_tests": [[["A", "B", "C", "D"], 4]]}], "Mbpp/260": [{"task_id": "Mbpp/260", "solution": "def newman_prime(n):\n    \"\"\"\n    Function to find the nth Newman\u2013Shanks\u2013Williams prime number.\n    The sequence is defined as:\n    NS(n) = 1 if n == 0 or n == 1\n    NS(n) = 2 * NS(n-1) + NS(n-2) for n > 1\n    A number in this sequence is a prime number if it is only divisible by 1 and itself.\n    \"\"\"\n    def is_prime(num):\n        \"\"\"Helper function to check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    # Generate NS(n) sequence and find the nth prime\n    ns_sequence = [1, 1]  # Starting values for NS(0) and NS(1)\n    prime_count = 0\n    current_index = 2\n\n    while prime_count < n:\n        # Calculate the next NS number\n        next_ns = 2 * ns_sequence[current_index - 1] + ns_sequence[current_index - 2]\n        ns_sequence.append(next_ns)\n\n        # Check if the current NS number is prime\n        if is_prime(next_ns):\n            prime_count += 1\n            if prime_count == n:\n                return next_ns\n\n        current_index += 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[100]]}], "Mbpp/261": [{"task_id": "Mbpp/261", "solution": "def division_elements(tuple1, tuple2):\n    \"\"\"\n    Perform element-wise division of two tuples.\n\n    Args:\n    tuple1 (tuple): The first tuple containing dividend elements.\n    tuple2 (tuple): The second tuple containing divisor elements.\n\n    Returns:\n    tuple: A tuple containing the result of element-wise division.\n    \"\"\"\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Both tuples must have the same length.\")\n    \n    result = tuple(a // b for a, b in zip(tuple1, tuple2))\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[5, 2, 3, 3], [5, 2, 3, 4]]]}], "Mbpp/262": [{"task_id": "Mbpp/262", "solution": "def split_two_parts(lst, L):\n    \"\"\"\n    Splits the given list into two parts where the length of the first part is L.\n\n    Parameters:\n    lst (list): The list to be split.\n    L (int): The length of the first part of the list.\n\n    Returns:\n    tuple: A tuple containing the two parts of the list.\n    \"\"\"\n    # Ensure L is not greater than the length of the list\n    if L > len(lst):\n        raise ValueError(\"L cannot be greater than the length of the list\")\n\n    # Split the list into two parts\n    first_part = lst[:L]\n    second_part = lst[L:]\n\n    return (first_part, second_part)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/264": [{"task_id": "Mbpp/264", "solution": "def dog_age(human_years):\n    \"\"\"\n    Calculate a dog's age in dog's years.\n\n    The first two years of a dog's life count as 10.5 dog years each.\n    Each year following equates to 4 dog years.\n\n    Parameters:\n    human_years (int): The age of the dog in human years.\n\n    Returns:\n    int: The age of the dog in dog years.\n    \"\"\"\n    if human_years <= 0:\n        return 0\n    elif human_years == 1:\n        return 10.5\n    elif human_years == 2:\n        return 21\n    else:\n        return 21 + (human_years - 2) * 4", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/265": [{"task_id": "Mbpp/265", "solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n lists, where each list contains every nth element from the original list.\n    \n    Parameters:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, where each sublist contains every nth element from the original list.\n    \"\"\"\n    # Initialize a list of empty lists to hold the result\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list and distribute elements into the result lists\n    for index, element in enumerate(lst):\n        result[index % n].append(element)\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/266": [{"task_id": "Mbpp/266", "solution": "def lateralsurface_cube(side_length):\n    \"\"\"\n    Calculate the lateral surface area of a cube.\n\n    Parameters:\n    side_length (float): The length of a side of the cube.\n\n    Returns:\n    float: The lateral surface area of the cube.\n    \"\"\"\n    # The lateral surface area of a cube is the sum of the areas of the four vertical faces.\n    # Each face is a square with area equal to side_length^2.\n    # Therefore, the lateral surface area is 4 times the area of one face.\n    lateral_surface_area = 4 * (side_length ** 2)\n    return lateral_surface_area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/267": [{"task_id": "Mbpp/267", "solution": "def square_Sum(n):\n    \"\"\"\n    This function takes an integer n and returns the sum of the squares of the first n odd natural numbers.\n    \"\"\"\n    sum_of_squares = 0\n    odd_number = 1\n    for _ in range(n):\n        sum_of_squares += odd_number ** 2\n        odd_number += 2  # Move to the next odd number\n    return sum_of_squares", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000000.0]]}], "Mbpp/268": [{"task_id": "Mbpp/268", "solution": "def find_star_num(n):\n    \"\"\"\n    Calculate the nth star number.\n\n    A star number is a centered figurate number that represents a centered hexagram (six-pointed star),\n    such as the Star of David, or the Chinese Star. The nth star number is given by the formula:\n    \n    Star(n) = 6 * n * (n - 1) + 1\n\n    Parameters:\n    n (int): The position of the star number to find.\n\n    Returns:\n    int: The nth star number.\n    \"\"\"\n    return 6 * n * (n - 1) + 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/270": [{"task_id": "Mbpp/270", "solution": "def sum_even_and_even_index(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns the sum of even numbers\n    that are located at even indices in the list.\n    \n    :param numbers: List of integers\n    :return: Sum of even numbers at even indices\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index in range(0, len(numbers), 2):  # Only consider even indices\n        if numbers[index] % 2 == 0:  # Check if the number at the even index is even\n            total_sum += numbers[index]\n    \n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/269": [{"task_id": "Mbpp/269", "solution": "def ascii_value(char):\n    \"\"\"\n    This function takes a single character as input and returns its ASCII value.\n    \n    :param char: A single character string\n    :return: ASCII value of the character\n    \"\"\"\n    return ord(char)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/272": [{"task_id": "Mbpp/272", "solution": "def rear_extract(tuples_list):\n    \"\"\"\n    This function takes a list of tuples and returns a list containing the rear element of each tuple.\n\n    :param tuples_list: List of tuples\n    :return: List of rear elements from each tuple\n    \"\"\"\n    # Use list comprehension to extract the last element from each tuple\n    return [t[-1] for t in tuples_list]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/273": [{"task_id": "Mbpp/273", "solution": "def subtract_elements(tuple1, tuple2):\n    \"\"\"\n    Subtracts elements of the first tuple by the elements of the second tuple with the same index.\n\n    Parameters:\n    tuple1 (tuple): The first tuple of numbers.\n    tuple2 (tuple): The second tuple of numbers.\n\n    Returns:\n    tuple: A tuple containing the result of the subtraction.\n    \"\"\"\n    # Ensure both tuples are of the same length\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Both tuples must be of the same length\")\n\n    # Subtract elements of tuple2 from tuple1\n    result = tuple(a - b for a, b in zip(tuple1, tuple2))\n    return result\n\n# Test the function with the provided example\nassert subtract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)\n\n# Additional test cases\nassert subtract_elements((1, 2, 3), (1, 1, 1)) == (0, 1, 2)\nassert subtract_elements((0, 0, 0), (0, 0, 0)) == (0, 0, 0)\nassert subtract_elements((5, 10, 15), (5, 10, 15)) == (0, 0, 0)\nassert subtract_elements((100, 200, 300), (50, 100, 150)) == (50, 100, 150)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/274": [{"task_id": "Mbpp/274", "solution": "def even_binomial_Coeff_Sum(n):\n    \"\"\"\n    This function calculates the sum of binomial coefficients at even indices for a given positive integer n.\n    \"\"\"\n    # Initialize the sum\n    sum_even_indices = 0\n    \n    # Calculate the binomial coefficients for even indices\n    for k in range(0, n + 1, 2):\n        sum_even_indices += binomial_coefficient(n, k)\n    \n    return sum_even_indices\ndef binomial_coefficient(n, k):\n    \"\"\"\n    Helper function to calculate the binomial coefficient C(n, k) = n! / (k! * (n-k)!)\n    \"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    # Calculate factorials\n    return factorial(n) // (factorial(k) * factorial(n - k))\ndef factorial(num):\n    \"\"\"\n    Helper function to calculate the factorial of a number\n    \"\"\"\n    if num == 0 or num == 1:\n        return 1\n    result = 1\n    for i in range(2, num + 1):\n        result *= i\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/276": [{"task_id": "Mbpp/276", "solution": "import math\ndef volume_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder given its radius and height.\n\n    Parameters:\n    radius (float): The radius of the cylinder.\n    height (float): The height of the cylinder.\n\n    Returns:\n    float: The volume of the cylinder.\n    \"\"\"\n    # Volume of a cylinder formula: V = \u03c0r\u00b2h\n    volume = math.pi * (radius ** 2) * height\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/277": [{"task_id": "Mbpp/277", "solution": "def dict_filter(input_dict, n):\n    \"\"\"\n    Filters the input dictionary to only include entries with values greater than or equal to n.\n\n    Parameters:\n    input_dict (dict): The dictionary to filter.\n    n (int): The threshold value.\n\n    Returns:\n    dict: A new dictionary with filtered entries.\n    \"\"\"\n    return {key: value for key, value in input_dict.items() if value >= n}", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/278": [{"task_id": "Mbpp/278", "solution": "def count_first_elements(tup):\n    \"\"\"\n    This function takes a tuple as input and returns the number of elements\n    that occur before the first tuple element in the given tuple.\n    \n    :param tup: A tuple containing various elements, including at least one tuple.\n    :return: An integer representing the number of elements before the first tuple element.\n    \"\"\"\n    count = 0\n    for element in tup:\n        if isinstance(element, tuple):\n            break\n        count += 1\n    return count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6]]]}], "Mbpp/279": [{"task_id": "Mbpp/279", "solution": "def is_num_decagonal(n):\n    \"\"\"\n    Calculate the nth decagonal number.\n\n    A decagonal number is a figurate number that extends the concept of\n    triangular and square numbers to the decagon (a ten-sided polygon).\n    The nth decagonal number is given by the formula:\n    \n    D_n = n * (4n - 3)\n\n    Parameters:\n    n (int): The position of the decagonal number to find.\n\n    Returns:\n    int: The nth decagonal number.\n    \"\"\"\n    return n * (4 * n - 3)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/280": [{"task_id": "Mbpp/280", "solution": "def sequential_search(arr, element):\n    \"\"\"\n    This function takes an array and an element as input and returns a tuple.\n    The tuple contains a boolean indicating if the element is in the array and\n    the index position of the element (or -1 if the element is not found).\n    \"\"\"\n    for index, value in enumerate(arr):\n        if value == element:\n            return (True, index)\n    return (False, -1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/281": [{"task_id": "Mbpp/281", "solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    # Convert the list to a set, which removes duplicates\n    unique_elements = set(lst)\n    # Compare the length of the set with the original list\n    return len(unique_elements) == len(lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/282": [{"task_id": "Mbpp/282", "solution": "def sub_list(list1, list2):\n    \"\"\"\n    Subtracts elements of list2 from list1 element-wise.\n    \n    Parameters:\n    list1 (list of int/float): The first list of numbers.\n    list2 (list of int/float): The second list of numbers.\n    \n    Returns:\n    list of int/float: A new list containing the result of element-wise subtraction.\n    \n    Raises:\n    ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Both lists must have the same length.\")\n    \n    return [a - b for a, b in zip(list1, list2)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/283": [{"task_id": "Mbpp/283", "solution": "def validate(number):\n    # Convert the number to a string to iterate over each digit\n    num_str = str(number)\n    \n    # Create a dictionary to count the frequency of each digit\n    frequency = {}\n    \n    # Count the frequency of each digit in the number\n    for digit in num_str:\n        if digit in frequency:\n            frequency[digit] += 1\n        else:\n            frequency[digit] = 1\n    \n    # Check if the frequency of each digit is less than or equal to the digit itself\n    for digit, count in frequency.items():\n        if count > int(digit):\n            return False\n    \n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/284": [{"task_id": "Mbpp/284", "solution": "def check_element(lst, element):\n    \"\"\"\n    This function checks whether all items in the list are equal to the given element.\n\n    Parameters:\n    lst (list): The list of elements to check.\n    element: The element to compare against each item in the list.\n\n    Returns:\n    bool: True if all items in the list are equal to the given element, False otherwise.\n    \"\"\"\n    for item in lst:\n        if item != element:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/285": [{"task_id": "Mbpp/285", "solution": "import re\ndef text_match_two_three(text):\n    \"\"\"\n    This function checks whether the input string contains the character 'a' \n    followed by two or three 'b' characters.\n\n    Parameters:\n    text (str): The input string to check.\n\n    Returns:\n    bool: True if the pattern 'a' followed by two or three 'b's is found, False otherwise.\n    \"\"\"\n    # Define the regex pattern for 'a' followed by two or three 'b's\n    pattern = r'ab{2,3}'\n    \n    # Use re.search to find the pattern in the text\n    if re.search(pattern, text):\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/286": [{"task_id": "Mbpp/286", "solution": "def max_sub_array_sum_repeated(arr, n, k):\n    \"\"\"\n    Function to find the largest sum of a contiguous subarray in the modified array\n    which is formed by repeating the given array k times.\n    \n    :param arr: List[int] - The original array\n    :param n: int - The length of the original array\n    :param k: int - The number of times the array is repeated\n    :return: int - The largest sum of a contiguous subarray\n    \"\"\"\n    def kadane(arr):\n        \"\"\"Helper function to find the maximum subarray sum using Kadane's algorithm.\"\"\"\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    # Calculate the sum of the original array\n    total_sum = sum(arr)\n\n    # Use Kadane's algorithm to find the maximum subarray sum in one array\n    max_kadane = kadane(arr)\n\n    if k == 1:\n        return max_kadane\n\n    # Find the maximum prefix sum\n    max_prefix_sum = float('-inf')\n    current_prefix_sum = 0\n    for i in range(n):\n        current_prefix_sum += arr[i]\n        max_prefix_sum = max(max_prefix_sum, current_prefix_sum)\n\n    # Find the maximum suffix sum\n    max_suffix_sum = float('-inf')\n    current_suffix_sum = 0\n    for i in range(n-1, -1, -1):\n        current_suffix_sum += arr[i]\n        max_suffix_sum = max(max_suffix_sum, current_suffix_sum)\n\n    # If the total sum is positive, consider the contribution of the middle arrays\n    if total_sum > 0:\n        return max(max_kadane, max_prefix_sum + max_suffix_sum + (k-2) * total_sum)\n    else:\n        return max(max_kadane, max_prefix_sum + max_suffix_sum)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/287": [{"task_id": "Mbpp/287", "solution": "def square_Sum(n):\n    \"\"\"\n    This function takes an integer n and returns the sum of squares of the first n even natural numbers.\n    \"\"\"\n    sum_of_squares = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        sum_of_squares += even_number ** 2\n    return sum_of_squares", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000000]]}], "Mbpp/290": [{"task_id": "Mbpp/290", "solution": "def max_length(list_of_lists):\n    \"\"\"\n    This function takes a list of lists and returns a tuple containing the maximum length\n    of the lists and one of the lists with that maximum length.\n    \n    :param list_of_lists: List[List[Any]]\n    :return: Tuple[int, List[Any]]\n    \"\"\"\n    if not list_of_lists:\n        return (0, [])\n    \n    max_len = 0\n    max_list = []\n    \n    for lst in list_of_lists:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = lst\n    \n    return (max_len, max_list)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/292": [{"task_id": "Mbpp/292", "solution": "def find(dividend, divisor):\n    \"\"\"\n    This function takes two numbers, dividend and divisor, and returns the quotient\n    rounded down to the nearest integer.\n    \n    :param dividend: The number to be divided.\n    :param divisor: The number by which to divide.\n    :return: The quotient rounded down to the nearest integer.\n    \"\"\"\n    if divisor == 0:\n        raise ValueError(\"Divisor cannot be zero.\")\n    \n    # Use floor division to get the quotient rounded down to the nearest integer\n    quotient = dividend // divisor\n    return quotient", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/293": [{"task_id": "Mbpp/293", "solution": "import math\ndef otherside_rightangle(a, b):\n    \"\"\"\n    Calculate the length of the third side of a right-angled triangle\n    given the lengths of the other two sides.\n\n    Parameters:\n    a (float): Length of one side of the triangle.\n    b (float): Length of the other side of the triangle.\n\n    Returns:\n    float: Length of the third side of the triangle.\n    \"\"\"\n    # Use the Pythagorean theorem: c^2 = a^2 + b^2\n    c = math.sqrt(a**2 + b**2)\n    return c", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/294": [{"task_id": "Mbpp/294", "solution": "def max_val(heterogeneous_list):\n    # Filter out non-numeric values from the list\n    numeric_values = [item for item in heterogeneous_list if isinstance(item, (int, float))]\n    \n    # Return the maximum value from the numeric values\n    return max(numeric_values)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["3.14", false, 7.5]]]}], "Mbpp/296": [{"task_id": "Mbpp/296", "solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count inversions in an array.\n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i = left    # Starting index for left subarray\n        j = mid + 1 # Starting index for right subarray\n        k = left    # Starting index to be sorted\n        inv_count = 0\n\n        # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                # There are mid - i inversions, because all the remaining elements in the left subarray\n                # (arr[i...mid]) are greater than arr[j]\n                temp_arr[k] = arr[j]\n                inv_count += (mid-i + 1)\n                j += 1\n            k += 1\n\n        # Copy the remaining elements of left subarray, if any\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        # Copy the remaining elements of right subarray, if any\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        # Copy the sorted subarray into Original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n            \n        return inv_count\n\n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right)//2\n\n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n        return inv_count\n\n    # Create a temporary array\n    temp_arr = [0]*len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/271": [{"task_id": "Mbpp/271", "solution": "def even_Power_Sum(n):\n    \"\"\"\n    This function calculates the sum of the first n even natural numbers raised to the fifth power.\n    \n    Parameters:\n    n (int): The number of even natural numbers to consider.\n    \n    Returns:\n    int: The sum of the first n even natural numbers raised to the fifth power.\n    \"\"\"\n    sum_even_powers = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        sum_even_powers += even_number ** 5\n    return sum_even_powers", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/297": [{"task_id": "Mbpp/297", "solution": "def flatten_list(nested_list):\n    \"\"\"\n    Flattens a nested list structure into a single list of elements.\n\n    :param nested_list: List of elements, where elements can be either integers or lists of integers\n    :return: A single flattened list containing all the integers from the nested list\n    \"\"\"\n    flat_list = []\n    for item in nested_list:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))\n        else:\n            flat_list.append(item)\n    return flat_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/299": [{"task_id": "Mbpp/299", "solution": "def max_aggregate(scores):\n    # Create a dictionary to store the aggregate scores for each person\n    aggregate_scores = {}\n    \n    # Iterate over each tuple in the list\n    for name, score in scores:\n        # If the name is already in the dictionary, add the score to the existing score\n        if name in aggregate_scores:\n            aggregate_scores[name] += score\n        else:\n            # If the name is not in the dictionary, add it with the current score\n            aggregate_scores[name] = score\n    \n    # Find the name with the maximum aggregate score\n    max_name = max(aggregate_scores, key=aggregate_scores.get)\n    max_score = aggregate_scores[max_name]\n    \n    return (max_name, max_score)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/301": [{"task_id": "Mbpp/301", "solution": "def dict_depth(d):\n    \"\"\"\n    This function calculates the depth of a dictionary.\n    The depth is defined as the maximum number of nested dictionaries.\n\n    :param d: The dictionary whose depth is to be calculated\n    :return: An integer representing the depth of the dictionary\n    \"\"\"\n    if not isinstance(d, dict) or not d:\n        return 0\n    else:\n        return 1 + max(dict_depth(v) for v in d.values())", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"a": 1, "b": {"c": {"d": {}}}}]], "plus_fail_tests": [[{}]]}], "Mbpp/300": [{"task_id": "Mbpp/300", "solution": "import math\ndef count_binary_seq(n):\n    \"\"\"\n    Function to count all binary sequences of length 2n such that the sum of the first n bits\n    is the same as the sum of the last n bits.\n    \"\"\"\n    from math import comb\n\n    # The problem is equivalent to finding the number of ways to choose k bits from n bits\n    # such that the sum of the first n bits equals the sum of the last n bits.\n    # This is equivalent to finding the number of ways to choose k bits from n bits\n    # and then choosing k bits from the remaining n bits.\n\n    # Initialize the count\n    count = 0\n\n    # Iterate over all possible sums of the first n bits\n    for k in range(n + 1):\n        # The number of ways to choose k bits from n bits for the first half\n        first_half_ways = comb(n, k)\n        # The number of ways to choose k bits from n bits for the second half\n        second_half_ways = comb(n, k)\n        # Multiply the ways for both halves\n        count += first_half_ways * second_half_ways\n\n    return count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[50]]}], "Mbpp/305": [{"task_id": "Mbpp/305", "solution": "def start_withp(word_list):\n    # Initialize an empty list to store words starting with 'p'\n    p_words = []\n    \n    # Iterate over each string in the list\n    for words in word_list:\n        # Split the string into individual words\n        for word in words.split():\n            # Check if the word starts with 'p' or 'P'\n            if word.lower().startswith('p'):\n                # Add the word to the list of p_words\n                p_words.append(word)\n            # If we have found two words, we can stop searching\n            if len(p_words) == 2:\n                return tuple(p_words)\n    \n    # If less than two words are found, return the found words\n    return tuple(p_words)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[]]]}], "Mbpp/306": [{"task_id": "Mbpp/306", "solution": "def max_sum_increasing_subseq(arr, n, i, k):\n    \"\"\"\n    Function to find the maximum sum of increasing subsequence from prefix until ith index\n    and also including a given kth element which is after i, i.e., k > i.\n\n    :param arr: List of integers\n    :param n: Length of the array\n    :param i: Index until which the prefix is considered\n    :param k: Index of the element that must be included in the subsequence\n    :return: Maximum sum of the increasing subsequence\n    \"\"\"\n    # Initialize a list to store the maximum sum of increasing subsequence ending at each index\n    max_sum = [0] * n\n\n    # Calculate the maximum sum of increasing subsequence for the prefix until index i\n    for j in range(i + 1):\n        max_sum[j] = arr[j]\n        for m in range(j):\n            if arr[m] < arr[j]:\n                max_sum[j] = max(max_sum[j], max_sum[m] + arr[j])\n\n    # Find the maximum sum of increasing subsequence that includes the kth element\n    max_sum_with_k = 0\n    for j in range(i + 1):\n        if arr[j] < arr[k]:\n            max_sum_with_k = max(max_sum_with_k, max_sum[j] + arr[k])\n\n    return max_sum_with_k", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[5, 2, 4, 1, 3, 6], 6, 1, 3]]}], "Mbpp/308": [{"task_id": "Mbpp/308", "solution": "def large_product(list1, list2, n):\n    # Create a list to store all possible products\n    products = []\n    \n    # Calculate the product of each pair (one element from each list)\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first n largest products\n    return products[:n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/310": [{"task_id": "Mbpp/310", "solution": "def string_to_tuple(s):\n    \"\"\"\n    Convert a given string to a tuple of characters.\n\n    Parameters:\n    s (str): The string to be converted.\n\n    Returns:\n    tuple: A tuple containing each character of the string as an element.\n    \"\"\"\n    return tuple(s)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["python 3.0"]], "plus_fail_tests": [["hello   world"]]}], "Mbpp/309": [{"task_id": "Mbpp/309", "solution": "def maximum(a, b):\n    \"\"\"\n    Returns the maximum of two numbers a and b.\n    \n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n    \n    Returns:\n    int or float: The maximum of the two numbers.\n    \"\"\"\n    return a if a > b else b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/311": [{"task_id": "Mbpp/311", "solution": "def set_left_most_unset_bit(n):\n    \"\"\"\n    This function sets the left-most unset bit of a given integer n.\n    \"\"\"\n    # Convert the number to binary and find the first unset bit from the left\n    binary_representation = bin(n)[2:]  # Get binary representation without '0b' prefix\n    length = len(binary_representation)\n    \n    # Find the left-most unset bit\n    for i in range(length):\n        if binary_representation[i] == '0':\n            # Set the left-most unset bit\n            n |= (1 << (length - i - 1))\n            break\n    else:\n        # If no unset bit is found, it means all bits are set\n        # In this case, add a new bit at the left\n        n |= (1 << length)\n    \n    return n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[15]], "plus_fail_tests": [[255]]}], "Mbpp/388": [{"task_id": "Mbpp/388", "solution": "def highest_Power_of_2(n):\n    \"\"\"\n    This function returns the highest power of 2 that is less than or equal to n.\n    \n    Parameters:\n    n (int): The number to compare against powers of 2.\n    \n    Returns:\n    int: The highest power of 2 less than or equal to n.\n    \"\"\"\n    # Start with the highest power of 2 as 1 (2^0)\n    power = 1\n    \n    # Double the power until it exceeds n\n    while power * 2 <= n:\n        power *= 2\n    \n    return power", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/312": [{"task_id": "Mbpp/312", "solution": "import math\ndef volume_cone(radius, height):\n    \"\"\"\n    Calculate the volume of a cone given its radius and height.\n\n    Parameters:\n    radius (float): The radius of the base of the cone.\n    height (float): The height of the cone.\n\n    Returns:\n    float: The volume of the cone.\n    \"\"\"\n    # Volume of a cone formula: (1/3) * \u03c0 * r^2 * h\n    volume = (1/3) * math.pi * radius**2 * height\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/389": [{"task_id": "Mbpp/389", "solution": "def find_lucas(n):\n    \"\"\"\n    Function to find the n-th Lucas number.\n    \n    The Lucas numbers are a sequence similar to the Fibonacci numbers, \n    except that they start with 2 and 1. The sequence is defined as:\n    L(0) = 2\n    L(1) = 1\n    L(n) = L(n-1) + L(n-2) for n > 1\n    \"\"\"\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # Initialize the first two Lucas numbers\n    lucas_0 = 2\n    lucas_1 = 1\n    \n    # Calculate the n-th Lucas number iteratively\n    for i in range(2, n + 1):\n        lucas_n = lucas_0 + lucas_1\n        lucas_0 = lucas_1\n        lucas_1 = lucas_n\n    \n    return lucas_n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/391": [{"task_id": "Mbpp/391", "solution": "def convert_list_dictionary(ids, names, scores):\n    \"\"\"\n    Convert three lists into a list of nested dictionaries.\n\n    Parameters:\n    ids (list): A list of unique identifiers.\n    names (list): A list of names corresponding to the identifiers.\n    scores (list): A list of scores corresponding to the identifiers and names.\n\n    Returns:\n    list: A list of dictionaries where each dictionary has the structure:\n          {id: {name: score}}\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(ids) == len(names) == len(scores)):\n        raise ValueError(\"All input lists must have the same length.\")\n    \n    # Create the list of nested dictionaries\n    result = [{id_: {name: score}} for id_, name, score in zip(ids, names, scores)]\n    \n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["S001", "S002", "S003", "S004"], ["Adina Park", "Leyton Marsh", "Duncan Boyle", "Saim Richards"], [[1, 2, 3], [4, 5, 6], {"a": "x", "b": "y", "c": "z"}]]]}], "Mbpp/390": [{"task_id": "Mbpp/390", "solution": "def add_string(lst, format_str):\n    \"\"\"\n    This function takes a list of elements and a format string, and applies the format string\n    to each element in the list, returning a new list with the formatted strings.\n\n    :param lst: List of elements to be formatted\n    :param format_str: A format string that includes a placeholder for the element\n    :return: A list of formatted strings\n    \"\"\"\n    return [format_str.format(item) for item in lst]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/392": [{"task_id": "Mbpp/392", "solution": "def get_max_sum(n, memo=None):\n    if memo is None:\n        memo = {}\n    \n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        return 0\n    \n    # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n    sum_parts = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    \n    # The maximum sum is the maximum of the calculated sum and n itself\n    result = max(sum_parts, n)\n    \n    # Store the result in the memoization dictionary\n    memo[n] = result\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/394": [{"task_id": "Mbpp/394", "solution": "def check_distinct(input_tuple):\n    \"\"\"\n    This function checks if the given tuple contains no duplicates.\n    \n    Parameters:\n    input_tuple (tuple): The tuple to check for duplicates.\n    \n    Returns:\n    bool: True if the tuple contains no duplicates, False otherwise.\n    \"\"\"\n    # Convert the tuple to a set, which removes duplicates\n    unique_elements = set(input_tuple)\n    \n    # Compare the length of the set with the original tuple\n    return len(unique_elements) == len(input_tuple)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/395": [{"task_id": "Mbpp/395", "solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/398": [{"task_id": "Mbpp/398", "solution": "def sum_of_digits(numbers):\n    \"\"\"\n    Compute the sum of digits of each number in the given list.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The sum of all digits of each number in the list.\n    \"\"\"\n    total_sum = 0\n    for number in numbers:\n        # Convert the number to a string to iterate over each digit\n        for digit in str(number):\n            # Convert the digit back to an integer and add to the total sum\n            total_sum += int(digit)\n    return total_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[10, 20, 4, 5, "b", 70, "a"]]]], "plus_fail_tests": [[[-10, 15, 0, -5, 2]]]}], "Mbpp/397": [{"task_id": "Mbpp/397", "solution": "def median_numbers(a, b, c):\n    \"\"\"\n    This function takes three numbers as input and returns the median of the three numbers.\n    The median is the middle value when the numbers are sorted in order.\n    \"\"\"\n    # Create a list of the numbers\n    numbers = [a, b, c]\n    \n    # Sort the list\n    numbers.sort()\n    \n    # Return the middle element\n    return numbers[1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/404": [{"task_id": "Mbpp/404", "solution": "def minimum(a, b):\n    \"\"\"\n    This function returns the minimum of two numbers a and b.\n    \n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n    \n    Returns:\n    int or float: The minimum of the two numbers.\n    \"\"\"\n    return a if a < b else b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/406": [{"task_id": "Mbpp/406", "solution": "def find_Parity(number):\n    \"\"\"\n    This function checks if the parity of a given number is odd.\n    Parity is odd if the number of 1-bits in the binary representation of the number is odd.\n    \n    :param number: Integer, the number to check the parity of\n    :return: Boolean, True if the parity is odd, False otherwise\n    \"\"\"\n    # Count the number of 1s in the binary representation of the number\n    count_of_ones = bin(number).count('1')\n    \n    # Check if the count of 1s is odd\n    return count_of_ones % 2 != 0", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[2]]}], "Mbpp/405": [{"task_id": "Mbpp/405", "solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    element (any): The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/409": [{"task_id": "Mbpp/409", "solution": "def min_product_tuple(tuples_list):\n    \"\"\"\n    This function takes a list of tuples, where each tuple contains two integers.\n    It returns the minimum product of the pairs of integers from the tuples.\n    \"\"\"\n    # Initialize the minimum product to a large number\n    min_product = float('inf')\n    \n    # Iterate over each tuple in the list\n    for a, b in tuples_list:\n        # Calculate the product of the current tuple\n        product = a * b\n        # Update the minimum product if the current product is smaller\n        if product < min_product:\n            min_product = product\n    \n    return min_product", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/410": [{"task_id": "Mbpp/410", "solution": "def min_val(heterogeneous_list):\n    # Filter out non-numeric values\n    numeric_values = [item for item in heterogeneous_list if isinstance(item, (int, float))]\n    \n    # Return the minimum value from the numeric values\n    return min(numeric_values)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["Python", 10, 5, 2.5, 2.5, "version"]]]}], "Mbpp/412": [{"task_id": "Mbpp/412", "solution": "def remove_odd(numbers):\n    \"\"\"\n    This function takes a list of integers and returns a new list with all the odd numbers removed.\n\n    :param numbers: List of integers\n    :return: List of integers with odd numbers removed\n    \"\"\"\n    return [num for num in numbers if num % 2 == 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/414": [{"task_id": "Mbpp/414", "solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (iterable): First sequence to check.\n    seq2 (iterable): Second sequence to check against.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    # Convert the second sequence to a set for O(1) average time complexity lookups\n    set_seq2 = set(seq2)\n    \n    # Check if any element in seq1 is in the set of seq2\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/413": [{"task_id": "Mbpp/413", "solution": "def extract_nth_element(tuples_list, n):\n    \"\"\"\n    Extracts the nth element from each tuple in a list of tuples.\n\n    Parameters:\n    tuples_list (list of tuples): The list of tuples from which to extract elements.\n    n (int): The index of the element to extract from each tuple.\n\n    Returns:\n    list: A list containing the nth element from each tuple.\n    \"\"\"\n    return [t[n] for t in tuples_list]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/415": [{"task_id": "Mbpp/415", "solution": "def max_Product(arr):\n    \"\"\"\n    This function finds a pair of numbers in the given array that has the highest product.\n    \n    :param arr: List of integers\n    :return: A tuple containing the pair of integers with the highest product\n    \"\"\"\n    if len(arr) < 2:\n        raise ValueError(\"Array must contain at least two elements\")\n    \n    # Initialize variables to store the maximum and second maximum numbers\n    max1 = max2 = float('-inf')\n    # Initialize variables to store the minimum and second minimum numbers\n    min1 = min2 = float('inf')\n    \n    # Traverse the array to find the two largest and two smallest numbers\n    for num in arr:\n        # Update the two largest numbers\n        if num > max1:\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max2 = num\n        \n        # Update the two smallest numbers\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n    \n    # Calculate the product of the two largest numbers and the two smallest numbers\n    max_product = max1 * max2\n    min_product = min1 * min2\n    \n    # Return the pair with the highest product\n    if max_product > min_product:\n        return (max1, max2)\n    else:\n        return (min1, min2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 7, 0, 8, 4]]], "plus_fail_tests": [[[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]]}], "Mbpp/419": [{"task_id": "Mbpp/419", "solution": "def round_and_sum(numbers):\n    # Round each number in the list\n    rounded_numbers = [round(num) for num in numbers]\n    \n    # Calculate the sum of the rounded numbers\n    total_sum = sum(rounded_numbers)\n    \n    # Multiply the sum by the length of the list\n    result = total_sum * len(numbers)\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/418": [{"task_id": "Mbpp/418", "solution": "def Find_Max(list_of_lists):\n    \"\"\"\n    This function takes a list of lists and returns the sublist with the maximum length.\n    If there are multiple sublists with the same maximum length, it returns the first one encountered.\n    \n    :param list_of_lists: List of lists\n    :return: The sublist with the maximum length\n    \"\"\"\n    if not list_of_lists:\n        return None\n    \n    max_length = 0\n    max_list = None\n    \n    for sublist in list_of_lists:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n            max_list = sublist\n    \n    return max_list", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[], [], []]]]}], "Mbpp/420": [{"task_id": "Mbpp/420", "solution": "def cube_Sum(n):\n    \"\"\"\n    This function calculates the sum of cubes of the first n even natural numbers.\n    \n    Parameters:\n    n (int): The number of even natural numbers to consider.\n    \n    Returns:\n    int: The sum of cubes of the first n even natural numbers.\n    \"\"\"\n    # Generate the first n even natural numbers\n    even_numbers = [2 * i for i in range(1, n + 1)]\n    \n    # Calculate the sum of cubes of these even numbers\n    cube_sum = sum(x**3 for x in even_numbers)\n    \n    return cube_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/421": [{"task_id": "Mbpp/421", "solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple into a single string with the given delimiter.\n    \n    Parameters:\n    input_tuple (tuple): The tuple containing elements to concatenate.\n    delimiter (str): The delimiter to use between elements. Default is '-'.\n    \n    Returns:\n    str: A single string with all elements of the tuple concatenated with the delimiter.\n    \"\"\"\n    # Convert all elements to string and join them with the delimiter\n    return delimiter.join(map(str, input_tuple))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/422": [{"task_id": "Mbpp/422", "solution": "def find_Average_Of_Cube(n):\n    \"\"\"\n    This function calculates the average of the cubes of the first n natural numbers.\n\n    Parameters:\n    n (int): The number of natural numbers to consider.\n\n    Returns:\n    float: The average of the cubes of the first n natural numbers.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    # Calculate the sum of cubes of the first n natural numbers\n    sum_of_cubes = sum(i**3 for i in range(1, n + 1))\n    \n    # Calculate the average\n    average = sum_of_cubes / n\n    \n    return average", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/425": [{"task_id": "Mbpp/425", "solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    lst (list of lists): The list of sublists to search through.\n    element (any): The element to count in the sublists.\n\n    Returns:\n    int: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/424": [{"task_id": "Mbpp/424", "solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    strings_tuple (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list containing the last character of each string in the tuple.\n    \"\"\"\n    return [s[-1] for s in strings_tuple]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/426": [{"task_id": "Mbpp/426", "solution": "def filter_oddnumbers(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns a new list containing only the odd numbers from the original list.\n    \n    :param numbers: List of integers\n    :return: List of odd integers\n    \"\"\"\n    return [num for num in numbers if num % 2 != 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/428": [{"task_id": "Mbpp/428", "solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            # Save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n\n        # Reduce the gap for the next element\n        gap //= 2\n\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/427": [{"task_id": "Mbpp/427", "solution": "def change_date_format(date_str):\n    \"\"\"\n    Convert a date from yyyy-mm-dd format to dd-mm-yyyy format.\n\n    Parameters:\n    date_str (str): A date string in the format yyyy-mm-dd.\n\n    Returns:\n    str: The date string in the format dd-mm-yyyy.\n    \"\"\"\n    # Split the input date string by the '-' delimiter\n    year, month, day = date_str.split('-')\n    \n    # Reformat the date to dd-mm-yyyy\n    new_date_str = f\"{day}-{month}-{year}\"\n    \n    return new_date_str", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["2021-1-026"]]}], "Mbpp/429": [{"task_id": "Mbpp/429", "solution": "def and_tuples(tuple1, tuple2):\n    \"\"\"\n    This function takes two tuples of integers and returns a new tuple where each element is the result\n    of the bitwise AND operation between the corresponding elements of the input tuples.\n    \"\"\"\n    # Ensure both tuples are of the same length\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Both tuples must be of the same length.\")\n    \n    # Perform elementwise bitwise AND operation\n    result = tuple(a & b for a, b in zip(tuple1, tuple2))\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/432": [{"task_id": "Mbpp/432", "solution": "def median_trapezium(a, b, h):\n    \"\"\"\n    Calculate the median length of a trapezium.\n\n    Parameters:\n    a (float): Length of the first parallel side.\n    b (float): Length of the second parallel side.\n    h (float): Height of the trapezium (not used in median calculation).\n\n    Returns:\n    float: The median length of the trapezium.\n    \"\"\"\n    # The formula for the median length of a trapezium is (a + b) / 2\n    return (a + b) / 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/430": [{"task_id": "Mbpp/430", "solution": "def parabola_directrix(a, b, c):\n    \"\"\"\n    Calculate the y-coordinate of the directrix of a parabola\n    given by the equation y = ax^2 + bx + c.\n    \n    Parameters:\n    a (float): Coefficient of x^2\n    b (float): Coefficient of x\n    c (float): Constant term\n    \n    Returns:\n    float: y-coordinate of the directrix\n    \"\"\"\n    # Calculate the y-coordinate of the directrix\n    directrix_y = c - (b**2 - 1) / (4 * a)\n    return directrix_y", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5, 3, 2]], "plus_fail_tests": [[0, 0, 0]]}], "Mbpp/433": [{"task_id": "Mbpp/433", "solution": "def check_greater(arr, num):\n    \"\"\"\n    This function checks if the given number is greater than all elements in the array.\n    \n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to compare against the elements of the array.\n    \n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/436": [{"task_id": "Mbpp/436", "solution": "def neg_nos(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns a list containing only the negative numbers.\n\n    :param numbers: List of integers\n    :return: List of negative integers\n    \"\"\"\n    return [num for num in numbers if num < 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/435": [{"task_id": "Mbpp/435", "solution": "def last_Digit(number):\n    \"\"\"\n    This function returns the last digit of a given number.\n\n    Parameters:\n    number (int): The number from which to find the last digit.\n\n    Returns:\n    int: The last digit of the number.\n    \"\"\"\n    # Convert the number to a string, get the last character, and convert it back to an integer\n    return int(str(number)[-1])", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[true]]}], "Mbpp/437": [{"task_id": "Mbpp/437", "solution": "def remove_odd(s):\n    \"\"\"\n    This function removes characters at odd indices from the input string.\n\n    Parameters:\n    s (str): The input string from which odd indexed characters are to be removed.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    # Use string slicing to get characters at even indices\n    return s[::2]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["python"]], "plus_fail_tests": [["Hello, world!"]]}], "Mbpp/439": [{"task_id": "Mbpp/439", "solution": "def multiple_to_single(numbers):\n    \"\"\"\n    Joins a list of integers into a single integer.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: A single integer formed by concatenating the integers in the list.\n    \"\"\"\n    # Convert each integer to a string and join them\n    joined_string = ''.join(map(str, numbers))\n    # Convert the resulting string back to an integer\n    return int(joined_string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/440": [{"task_id": "Mbpp/440", "solution": "import re\ndef find_adverb_position(sentence):\n    # Regular expression to match adverbs ending with 'ly'\n    adverb_pattern = r'\\b\\w+ly\\b'\n    \n    # Search for the first adverb in the sentence\n    match = re.search(adverb_pattern, sentence)\n    \n    if match:\n        # Return the start position, end position, and the adverb itself\n        return (match.start(), match.end(), match.group())\n    else:\n        # Return None if no adverb is found\n        return None", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["awaquicklyy"]]}], "Mbpp/445": [{"task_id": "Mbpp/445", "solution": "def index_multiplication(tuple1, tuple2):\n    \"\"\"\n    Perform index-wise multiplication of tuple elements in the given two tuples.\n    \n    Args:\n    tuple1: A tuple of tuples containing integers.\n    tuple2: A tuple of tuples containing integers.\n    \n    Returns:\n    A tuple of tuples where each element is the result of index-wise multiplication of the input tuples.\n    \"\"\"\n    # Ensure both tuples have the same length\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Both tuples must have the same length.\")\n    \n    # Perform index-wise multiplication\n    result = tuple((a * c, b * d) for (a, b), (c, d) in zip(tuple1, tuple2))\n    \n    return result\ntuple1 = ((1, 3), (4, 5), (2, 9), (1, 10))\ntuple2 = ((6, 7), (3, 9), (1, 1), (7, 3))\nresult = index_multiplication(tuple1, tuple2)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[1, 2], [3, 4], [5, 6]], [[7, 8], [9, 10]]]]}], "Mbpp/441": [{"task_id": "Mbpp/441", "solution": "def surfacearea_cube(side_length):\n    \"\"\"\n    Calculate the surface area of a cube given the side length.\n\n    Parameters:\n    side_length (float): The length of one side of the cube.\n\n    Returns:\n    float: The surface area of the cube.\n    \"\"\"\n    # A cube has 6 faces, each of which is a square with area side_length^2\n    return 6 * (side_length ** 2)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/446": [{"task_id": "Mbpp/446", "solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of the list in the tuple.\n\n    Parameters:\n    tup (tuple): A tuple containing elements to be counted.\n    lst (list): A list of elements whose occurrences need to be counted in the tuple.\n\n    Returns:\n    int: The total count of occurrences of list elements in the tuple.\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/448": [{"task_id": "Mbpp/448", "solution": "def perrin_number(n):\n    \"\"\"\n    Calculate the nth Perrin number.\n    The Perrin sequence is defined as:\n    P(0) = 3, P(1) = 0, P(2) = 2\n    P(n) = P(n-2) + P(n-3) for n > 2\n    \"\"\"\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b, c = 3, 0, 2\n        for i in range(3, n + 1):\n            a, b, c = b, c, b + a\n        return c\ndef cal_sum(n):\n    \"\"\"\n    Calculate the sum of the first n Perrin numbers.\n    \"\"\"\n    return sum(perrin_number(i) for i in range(n))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[9]], "plus_fail_tests": [[-5]]}], "Mbpp/447": [{"task_id": "Mbpp/447", "solution": "def cube_nums(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns a new list with the cubes of the original numbers.\n    \n    :param numbers: List of integers\n    :return: List of integers where each element is the cube of the corresponding element in the input list\n    \"\"\"\n    return [x**3 for x in numbers]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/450": [{"task_id": "Mbpp/450", "solution": "def extract_string(strings, size):\n    \"\"\"\n    Extract strings of a specified size from a given list of string values.\n\n    Parameters:\n    strings (list): A list of string values.\n    size (int): The size of strings to extract.\n\n    Returns:\n    list: A list of strings that have the specified size.\n    \"\"\"\n    return [s for s in strings if len(s) == size]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/453": [{"task_id": "Mbpp/453", "solution": "def sum_of_even_factors(n):\n    \"\"\"\n    This function returns the sum of even factors of a given number n.\n    \n    Parameters:\n    n (int): The number for which to find the sum of even factors.\n    \n    Returns:\n    int: The sum of even factors of n.\n    \"\"\"\n    sum_even_factors = 0\n    for i in range(2, n + 1, 2):  # Start from 2 and increment by 2 to check only even numbers\n        if n % i == 0:\n            sum_even_factors += i\n    return sum_even_factors\n\n# Test the function with the given assertion\nassert sum_of_even_factors(18) == 26\n\n# Additional test cases\nprint(sum_of_even_factors(12))  # Output should be 18 (2 + 4 + 6 + 12)\nprint(sum_of_even_factors(30))  # Output should be 48 (2 + 6 + 10 + 30)\nprint(sum_of_even_factors(1))   # Output should be 0 (no even factors)\nprint(sum_of_even_factors(2))   # Output should be 2 (only even factor is 2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/451": [{"task_id": "Mbpp/451", "solution": "def remove_whitespaces(s: str) -> str:\n    \"\"\"\n    Remove all whitespaces from the given string.\n\n    Parameters:\n    s (str): The input string from which whitespaces need to be removed.\n\n    Returns:\n    str: A new string with all whitespaces removed.\n    \"\"\"\n    return ''.join(s.split())", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["\n\t"]]}], "Mbpp/454": [{"task_id": "Mbpp/454", "solution": "import re\ndef text_match_wordz(text):\n    \"\"\"\n    This function checks if the given text contains a word with the letter 'z'.\n    \n    Parameters:\n    text (str): The input string to be checked.\n    \n    Returns:\n    bool: True if there is a word containing 'z', False otherwise.\n    \"\"\"\n    # Use regular expression to find a word containing 'z'\n    pattern = r'\\b\\w*z\\w*\\b'\n    match = re.search(pattern, text)\n    return match is not None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/455": [{"task_id": "Mbpp/455", "solution": "def check_month_number(month):\n    \"\"\"\n    This function checks whether the given month number contains 31 days or not.\n    \n    Parameters:\n    month (int): The month number (1 for January, 2 for February, ..., 12 for December)\n    \n    Returns:\n    bool: True if the month has 31 days, False otherwise\n    \"\"\"\n    # List of months with 31 days\n    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]\n    \n    # Check if the given month is in the list of months with 31 days\n    return month in months_with_31_days\n\n# Test the function with the provided assertion\nassert check_month_number(5) == True\n\n# Additional test cases\nassert check_month_number(2) == False  # February\nassert check_month_number(4) == False  # April\nassert check_month_number(7) == True   # July\nassert check_month_number(11) == False # November\nassert check_month_number(12) == True  # December\n\nprint(\"All tests passed.\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/456": [{"task_id": "Mbpp/456", "solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Parameters:\n    strings (list of str): A list of strings to be reversed.\n\n    Returns:\n    list of str: A list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in strings]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/458": [{"task_id": "Mbpp/458", "solution": "def rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n\n    Returns:\n    float: The area of the rectangle.\n    \"\"\"\n    return length * width", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/457": [{"task_id": "Mbpp/457", "solution": "def Find_Min(sublists):\n    \"\"\"\n    This function takes a list of sublists and returns the sublist with the minimum length.\n    If there are multiple sublists with the same minimum length, it returns the first one encountered.\n    \n    :param sublists: List of sublists\n    :return: Sublist with the minimum length\n    \"\"\"\n    if not sublists:\n        return None  # Return None if the input list is empty\n\n    # Initialize the minimum sublist as the first sublist\n    min_sublist = sublists[0]\n    \n    # Iterate through the sublists to find the one with the minimum length\n    for sublist in sublists:\n        if len(sublist) < len(min_sublist):\n            min_sublist = sublist\n    \n    return min_sublist", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/459": [{"task_id": "Mbpp/459", "solution": "def remove_uppercase(s):\n    \"\"\"\n    This function removes uppercase substrings from the given string.\n    \n    Parameters:\n    s (str): The input string from which uppercase substrings need to be removed.\n    \n    Returns:\n    str: A new string with all uppercase substrings removed.\n    \"\"\"\n    result = []\n    i = 0\n    while i < len(s):\n        if s[i].isupper():\n            # Skip the entire uppercase substring\n            while i < len(s) and s[i].isupper():\n                i += 1\n        else:\n            # Add lowercase character to result\n            result.append(s[i])\n            i += 1\n    return ''.join(result)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["ThiS%^%!s&a(mY)TesTStR%i*ng"]]}], "Mbpp/462": [{"task_id": "Mbpp/462", "solution": "from itertools import combinations\ndef combinations_list(elements):\n    result = []\n    # Generate combinations of all possible lengths\n    for r in range(len(elements) + 1):\n        for combo in combinations(elements, r):\n            result.append(list(combo))\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["orange", "red", "green", "blue"]]], "plus_fail_tests": [[["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"]]]}], "Mbpp/460": [{"task_id": "Mbpp/460", "solution": "def Extract(list_of_lists):\n    \"\"\"\n    This function takes a list of lists and returns a list containing the first element of each sublist.\n    \n    :param list_of_lists: List of lists from which to extract the first element of each sublist\n    :return: List of first elements from each sublist\n    \"\"\"\n    # Use list comprehension to extract the first element from each sublist\n    return [sublist[0] for sublist in list_of_lists if sublist]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/463": [{"task_id": "Mbpp/463", "solution": "def max_subarray_product(nums):\n    if not nums:\n        return 0\n\n    # Initialize the maximum product, minimum product, and result with the first element\n    max_product = min_product = result = nums[0]\n\n    # Iterate through the array starting from the second element\n    for num in nums[1:]:\n        if num < 0:\n            # Swap max_product and min_product if the current number is negative\n            max_product, min_product = min_product, max_product\n\n        # Calculate the maximum and minimum product ending at the current position\n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n\n        # Update the result with the maximum product found so far\n        result = max(result, max_product)\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/468": [{"task_id": "Mbpp/468", "solution": "def max_product(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n\n    # Initialize a list to store the maximum product of increasing subsequences ending at each index\n    max_product_ending_at = [0] * n\n\n    # Initialize the maximum product found\n    max_product_found = 0\n\n    # Iterate over each element in the array\n    for i in range(n):\n        # Start with the current element as the minimum product\n        max_product_ending_at[i] = arr[i]\n\n        # Check all previous elements to find increasing subsequences\n        for j in range(i):\n            if arr[j] < arr[i]:\n                # Update the maximum product for the subsequence ending at i\n                max_product_ending_at[i] = max(max_product_ending_at[i], max_product_ending_at[j] * arr[i])\n\n        # Update the global maximum product found\n        max_product_found = max(max_product_found, max_product_ending_at[i])\n\n    return max_product_found", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 100, 4, 5, 150, 6]]], "plus_fail_tests": [[[2, 3, 3, 4, 5, 3, 6]]]}], "Mbpp/465": [{"task_id": "Mbpp/465", "solution": "def drop_empty(input_dict):\n    \"\"\"\n    This function takes a dictionary as input and returns a new dictionary\n    with all items that have a value of None removed.\n    \n    :param input_dict: Dictionary to process\n    :return: Dictionary with non-None values\n    \"\"\"\n    # Use dictionary comprehension to filter out items with None values\n    return {key: value for key, value in input_dict.items() if value is not None}", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/470": [{"task_id": "Mbpp/470", "solution": "def add_pairwise(input_tuple):\n    \"\"\"\n    This function takes a tuple of integers and returns a new tuple containing the pairwise addition\n    of neighboring elements from the input tuple.\n    \n    :param input_tuple: A tuple of integers\n    :return: A tuple containing the pairwise addition of neighboring elements\n    \"\"\"\n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate over the input tuple, stopping before the last element\n    for i in range(len(input_tuple) - 1):\n        # Add the current element and the next element\n        pair_sum = input_tuple[i] + input_tuple[i + 1]\n        # Append the result to the list\n        result.append(pair_sum)\n    \n    # Convert the list to a tuple and return it\n    return tuple(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/471": [{"task_id": "Mbpp/471", "solution": "def find_remainder(arr, n):\n    \"\"\"\n    This function takes an array of integers and a modulus n, and returns the product of the array elements modulo n.\n    \n    :param arr: List[int] - A list of integers\n    :param n: int - The modulus\n    :return: int - The product of the array elements modulo n\n    \"\"\"\n    product = 1\n    for num in arr:\n        product *= num\n        product %= n  # Take modulo at each step to prevent overflow and keep the number manageable\n    return product", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/472": [{"task_id": "Mbpp/472", "solution": "def check_Consecutive(lst):\n    \"\"\"\n    This function checks if the given list contains consecutive numbers.\n    \n    Parameters:\n    lst (list): A list of integers.\n    \n    Returns:\n    bool: True if the list contains consecutive numbers, False otherwise.\n    \"\"\"\n    if not lst:\n        return False\n    \n    # Sort the list\n    sorted_lst = sorted(lst)\n    \n    # Check if each element is consecutive\n    for i in range(len(sorted_lst) - 1):\n        if sorted_lst[i] + 1 != sorted_lst[i + 1]:\n            return False\n    \n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/474": [{"task_id": "Mbpp/474", "solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the string s.\n\n    Parameters:\n    s (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n\n    Returns:\n    str: The modified string with old_char replaced by new_char.\n    \"\"\"\n    return s.replace(old_char, new_char)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/473": [{"task_id": "Mbpp/473", "solution": "def tuple_intersection(list1, list2):\n    # Convert each tuple to a frozenset to ignore order\n    set1 = {frozenset(t) for t in list1}\n    set2 = {frozenset(t) for t in list2}\n    \n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n    \n    # Convert frozensets back to tuples with sorted elements\n    result = {tuple(sorted(t)) for t in intersection}\n    \n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[1, 2, 3], [4, 5, 6, 4], [7, 8, 9]], [[4, 5, 6], [1, 2, 3]]]]}], "Mbpp/475": [{"task_id": "Mbpp/475", "solution": "def sort_counter(d):\n    \"\"\"\n    Sorts a dictionary by its values in descending order and returns a list of tuples.\n\n    Parameters:\n    d (dict): The dictionary to be sorted.\n\n    Returns:\n    list: A list of tuples sorted by the dictionary's values in descending order.\n    \"\"\"\n    # Sort the dictionary by value in descending order and return as a list of tuples\n    return sorted(d.items(), key=lambda item: item[1], reverse=True)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/477": [{"task_id": "Mbpp/477", "solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    s (str): The string to be converted.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return s.lower()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/476": [{"task_id": "Mbpp/476", "solution": "def big_sum(arr):\n    \"\"\"\n    This function takes a list of numbers and returns the sum of the largest and smallest numbers in the list.\n    \n    :param arr: List of numbers\n    :return: Sum of the largest and smallest numbers in the list\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array should not be empty\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/478": [{"task_id": "Mbpp/478", "solution": "def remove_lowercase(s):\n    \"\"\"\n    This function removes all lowercase substrings from the given string.\n    A substring is considered lowercase if it consists entirely of lowercase letters.\n    \"\"\"\n    result = []\n    current_substring = []\n\n    for char in s:\n        if char.islower():\n            # If we encounter a lowercase character, we clear the current substring\n            current_substring = []\n        else:\n            # If it's an uppercase character, we add it to the current substring\n            current_substring.append(char)\n            # Add the current substring to the result\n            result.extend(current_substring)\n            # Clear the current substring\n            current_substring = []\n\n    return ''.join(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/554": [{"task_id": "Mbpp/554", "solution": "def Split(numbers):\n    \"\"\"\n    This function takes a list of integers and returns a list containing only the odd integers.\n\n    :param numbers: List of integers\n    :return: List of odd integers\n    \"\"\"\n    return [num for num in numbers if num % 2 != 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/479": [{"task_id": "Mbpp/479", "solution": "def first_Digit(number):\n    \"\"\"\n    This function returns the first digit of a given number.\n    \n    Parameters:\n    number (int): The number from which to find the first digit.\n    \n    Returns:\n    int: The first digit of the number.\n    \"\"\"\n    # Convert the number to a string to easily access the first character\n    number_str = str(abs(number))  # Use abs to handle negative numbers\n    # Return the first character converted back to an integer\n    return int(number_str[0])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/555": [{"task_id": "Mbpp/555", "solution": "def difference(n):\n    # Calculate the sum of the first n natural numbers\n    sum_of_natural_numbers = n * (n + 1) // 2\n    \n    # Calculate the sum of cubes of the first n natural numbers\n    sum_of_cubes = (n * (n + 1) // 2) ** 2\n    \n    # Return the difference\n    return sum_of_cubes - sum_of_natural_numbers", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/556": [{"task_id": "Mbpp/556", "solution": "def find_Odd_Pair(arr, n):\n    \"\"\"\n    Function to count the number of pairs whose XOR value is odd.\n    \n    Parameters:\n    arr (list): List of integers.\n    n (int): Number of elements in the list.\n    \n    Returns:\n    int: Number of pairs with odd XOR value.\n    \"\"\"\n    # Count of even and odd numbers in the array\n    even_count = 0\n    odd_count = 0\n    \n    # Iterate through the array to count even and odd numbers\n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # A pair (a, b) has an odd XOR if one is even and the other is odd\n    # So, the number of such pairs is even_count * odd_count\n    return even_count * odd_count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 2], 10]]}], "Mbpp/557": [{"task_id": "Mbpp/557", "solution": "def toggle_string(s):\n    \"\"\"\n    This function takes a string as input and returns a new string with the case of each character toggled.\n    \n    Parameters:\n    s (str): The input string whose characters' cases need to be toggled.\n    \n    Returns:\n    str: A new string with each character's case toggled.\n    \"\"\"\n    # Use a list comprehension to toggle the case of each character\n    toggled = [char.lower() if char.isupper() else char.upper() for char in s]\n    \n    # Join the list back into a string and return\n    return ''.join(toggled)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/559": [{"task_id": "Mbpp/559", "solution": "def max_sub_array_sum(arr, n):\n    \"\"\"\n    Function to find the sum of the largest contiguous sublist in the given list.\n    \n    Parameters:\n    arr (list): The input list of integers.\n    n (int): The number of elements in the list.\n    \n    Returns:\n    int: The sum of the largest contiguous sublist.\n    \"\"\"\n    # Initialize variables\n    max_so_far = float('-inf')  # This will store the maximum sum found so far\n    max_ending_here = 0  # This will store the maximum sum of the sublist ending at the current position\n\n    for i in range(n):\n        max_ending_here += arr[i]\n        \n        # Update max_so_far if max_ending_here is greater\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        \n        # If max_ending_here becomes negative, reset it to 0\n        if max_ending_here < 0:\n            max_ending_here = 0\n\n    return max_so_far", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 0]]}], "Mbpp/558": [{"task_id": "Mbpp/558", "solution": "def digit_distance_nums(num1, num2):\n    \"\"\"\n    Calculate the sum of the per-digit difference between two integers.\n\n    Parameters:\n    num1 (int): The first integer.\n    num2 (int): The second integer.\n\n    Returns:\n    int: The sum of the per-digit differences.\n    \"\"\"\n    # Convert both numbers to strings to compare digit by digit\n    str_num1 = str(num1)\n    str_num2 = str(num2)\n    \n    # Pad the shorter number with leading zeros\n    max_len = max(len(str_num1), len(str_num2))\n    str_num1 = str_num1.zfill(max_len)\n    str_num2 = str_num2.zfill(max_len)\n    \n    # Calculate the sum of per-digit differences\n    total_difference = 0\n    for digit1, digit2 in zip(str_num1, str_num2):\n        total_difference += abs(int(digit1) - int(digit2))\n    \n    return total_difference", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/560": [{"task_id": "Mbpp/560", "solution": "def union_elements(tuple1, tuple2):\n    # Convert tuples to sets to find the union\n    set1 = set(tuple1)\n    set2 = set(tuple2)\n    \n    # Find the union of the two sets\n    union_set = set1.union(set2)\n    \n    # Convert the union set back to a sorted tuple\n    sorted_union_tuple = tuple(sorted(union_set))\n    \n    return sorted_union_tuple", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/563": [{"task_id": "Mbpp/563", "solution": "def extract_values(s):\n    import re\n    # Use regular expression to find all substrings enclosed in double quotes\n    return re.findall(r'\"(.*?)\"', s)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/562": [{"task_id": "Mbpp/562", "solution": "def Find_Max_Length(list_of_lists):\n    \"\"\"\n    This function takes a list of lists as input and returns the length of the longest sublist.\n    \n    Parameters:\n    list_of_lists (list): A list containing sublists.\n    \n    Returns:\n    int: The length of the longest sublist.\n    \"\"\"\n    # Initialize a variable to keep track of the maximum length found\n    max_length = 0\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Update max_length if the current sublist is longer\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n    \n    return max_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/564": [{"task_id": "Mbpp/564", "solution": "def count_pairs(lst, n):\n    \"\"\"\n    Count the number of possible unordered pairs where both elements are unequal.\n\n    Parameters:\n    lst (list): A list of integers.\n    n (int): The number of elements in the list.\n\n    Returns:\n    int: The number of unordered pairs with unequal elements.\n    \"\"\"\n    # Initialize a counter for pairs\n    pair_count = 0\n\n    # Iterate over each pair of elements in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the elements are unequal\n            if lst[i] != lst[j]:\n                pair_count += 1\n\n    return pair_count\n\n# Test the function with the provided example\nassert count_pairs([1, 2, 1], 3) == 2\n\n# Additional test cases\nprint(count_pairs([1, 2, 3, 4], 4))  # Expected output: 6\nprint(count_pairs([1, 1, 1, 1], 4))  # Expected output: 0\nprint(count_pairs([1, 2, 3, 2], 4))  # Expected output: 5\nprint(count_pairs([1, 2], 2))        # Expected output: 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/566": [{"task_id": "Mbpp/566", "solution": "def sum_digits(n):\n    \"\"\"\n    Calculate the sum of the digits of a non-negative integer.\n\n    Parameters:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: The sum of the digits of the integer.\n    \"\"\"\n    # Convert the number to a string to iterate over each digit\n    return sum(int(digit) for digit in str(n))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/565": [{"task_id": "Mbpp/565", "solution": "def split(string):\n    \"\"\"\n    Splits a string into a list of its characters.\n\n    Parameters:\n    string (str): The string to be split.\n\n    Returns:\n    list: A list containing each character of the string.\n    \"\"\"\n    return list(string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/567": [{"task_id": "Mbpp/567", "solution": "def issort_list(lst):\n    \"\"\"\n    Check if the given list is sorted in non-decreasing order.\n\n    Parameters:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if the list is sorted, False otherwise.\n    \"\"\"\n    # Iterate through the list and check if each element is less than or equal to the next\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/569": [{"task_id": "Mbpp/569", "solution": "def sort_sublists(list_of_lists):\n    \"\"\"\n    Sort each sublist of strings in a given list of lists.\n\n    Parameters:\n    list_of_lists (list of list of str): A list containing sublists of strings.\n\n    Returns:\n    list of list of str: A list with each sublist sorted alphabetically.\n    \"\"\"\n    # Use list comprehension to sort each sublist\n    return [sorted(sublist) for sublist in list_of_lists]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/568": [{"task_id": "Mbpp/568", "solution": "def empty_list(n):\n    \"\"\"\n    Create a list of N empty dictionaries.\n\n    Parameters:\n    n (int): The number of empty dictionaries to create.\n\n    Returns:\n    list: A list containing N empty dictionaries.\n    \"\"\"\n    return [{} for _ in range(n)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/572": [{"task_id": "Mbpp/572", "solution": "def two_unique_nums(lst):\n    \"\"\"\n    This function takes a list of numbers and returns a new list containing only the numbers\n    that appear exactly once in the original list.\n    \n    :param lst: List of integers\n    :return: List of integers that appear exactly once in the input list\n    \"\"\"\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Count each number in the list\n    for num in lst:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Collect numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/573": [{"task_id": "Mbpp/573", "solution": "def unique_product(numbers):\n    # Convert the list to a set to get unique numbers\n    unique_numbers = set(numbers)\n    \n    # Initialize the product to 1 (multiplicative identity)\n    product = 1\n    \n    # Calculate the product of unique numbers\n    for number in unique_numbers:\n        product *= number\n    \n    return product", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/576": [{"task_id": "Mbpp/576", "solution": "def is_Sub_Array(main_list, sub_list):\n    \"\"\"\n    Check if sub_list is a sublist of main_list.\n\n    Parameters:\n    main_list (list): The list in which to search for the sublist.\n    sub_list (list): The list to check as a sublist.\n\n    Returns:\n    bool: True if sub_list is a sublist of main_list, False otherwise.\n    \"\"\"\n    # Get the lengths of both lists\n    len_main = len(main_list)\n    len_sub = len(sub_list)\n\n    # If the sub_list is longer than the main_list, it cannot be a sublist\n    if len_sub > len_main:\n        return False\n\n    # Iterate through the main_list to find the sub_list\n    for i in range(len_main - len_sub + 1):\n        # Check if the slice of main_list matches the sub_list\n        if main_list[i:i+len_sub] == sub_list:\n            return True\n\n    return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5], [1, 3, 5]]]}], "Mbpp/578": [{"task_id": "Mbpp/578", "solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \n    Parameters:\n    list1 (list): The first list.\n    list2 (list): The second list.\n    list3 (list): The third list.\n    \n    Returns:\n    list: A new list with elements interleaved from the three input lists.\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length\")\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list\nlist1 = [1, 2, 3]\nlist2 = [4, 5, 6]\nlist3 = [7, 8, 9]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/577": [{"task_id": "Mbpp/577", "solution": "def last_digit_factorial(n):\n    \"\"\"\n    This function returns the last digit of the factorial of a given number n.\n    \"\"\"\n    # If n is 0 or 1, the factorial is 1, and the last digit is also 1\n    if n == 0 or n == 1:\n        return 1\n    \n    # Initialize the factorial result\n    factorial = 1\n    \n    # Calculate the factorial of n\n    for i in range(2, n + 1):\n        factorial *= i\n    \n    # Return the last digit of the factorial\n    return factorial % 10\n\n# Test the function with the given assertion\nassert last_digit_factorial(4) == 4\n\n# Additional test cases\nprint(last_digit_factorial(0))  # Output: 1\nprint(last_digit_factorial(1))  # Output: 1\nprint(last_digit_factorial(5))  # Output: 0\nprint(last_digit_factorial(10)) # Output: 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/579": [{"task_id": "Mbpp/579", "solution": "def find_dissimilar(tuple1, tuple2):\n    \"\"\"\n    This function takes two tuples and returns a tuple containing elements\n    that are present in one tuple but not in the other.\n    \"\"\"\n    # Convert tuples to sets to find dissimilar elements\n    set1 = set(tuple1)\n    set2 = set(tuple2)\n    \n    # Find elements that are in set1 but not in set2 and vice versa\n    dissimilar_elements = set1.symmetric_difference(set2)\n    \n    # Convert the result back to a tuple\n    return tuple(dissimilar_elements)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/581": [{"task_id": "Mbpp/581", "solution": "import math\ndef surface_Area(base_edge, height):\n    \"\"\"\n    Calculate the surface area of a square pyramid.\n\n    Parameters:\n    base_edge (float): The length of the base edge of the square pyramid.\n    height (float): The height of the square pyramid from the base to the apex.\n\n    Returns:\n    float: The surface area of the square pyramid.\n    \"\"\"\n    # Calculate the base area (A_base)\n    A_base = base_edge ** 2\n    \n    # Calculate the slant height (l) using the Pythagorean theorem\n    slant_height = math.sqrt((base_edge / 2) ** 2 + height ** 2)\n    \n    # Calculate the lateral surface area (A_lateral)\n    A_lateral = 2 * base_edge * slant_height\n    \n    # Total surface area is the sum of the base area and the lateral surface area\n    total_surface_area = A_base + A_lateral\n    \n    return total_surface_area", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 4]], "plus_fail_tests": [[10, 20]]}], "Mbpp/580": [{"task_id": "Mbpp/580", "solution": "def extract_even(mixed_tuple):\n    def is_even(n):\n        return isinstance(n, int) and n % 2 == 0\n\n    def filter_even_elements(t):\n        result = []\n        for item in t:\n            if isinstance(item, tuple):\n                filtered_item = filter_even_elements(item)\n                if filtered_item:  # Only add non-empty tuples\n                    result.append(filtered_item)\n            elif is_even(item):\n                result.append(item)\n        return tuple(result)\n\n    return filter_even_elements(mixed_tuple)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/583": [{"task_id": "Mbpp/583", "solution": "def catalan_number(n):\n    \"\"\"\n    Function to calculate the nth Catalan number.\n    The nth Catalan number is given by the formula:\n    C(n) = (2n)! / ((n + 1)! * n!)\n    \"\"\"\n    if n == 0:\n        return 1\n\n    # Calculate factorials\n    factorial = [1] * (2 * n + 1)\n    for i in range(2, 2 * n + 1):\n        factorial[i] = factorial[i - 1] * i\n\n    # Calculate the nth Catalan number using the formula\n    catalan = factorial[2 * n] // (factorial[n + 1] * factorial[n])\n    return catalan", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/586": [{"task_id": "Mbpp/586", "solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list with the first part moved to the end.\n    \"\"\"\n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Concatenate the second part with the first part\n    result = second_part + first_part\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/585": [{"task_id": "Mbpp/585", "solution": "def expensive_items(items, n):\n    \"\"\"\n    This function takes a list of dictionaries (items) and an integer n, and returns a list of the n most expensive items.\n    Each item is represented as a dictionary with 'name' and 'price' keys.\n    \"\"\"\n    # Sort the items by price in descending order\n    sorted_items = sorted(items, key=lambda x: x['price'], reverse=True)\n    \n    # Return the top n items\n    return sorted_items[:n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/587": [{"task_id": "Mbpp/587", "solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    lst (list): The list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/588": [{"task_id": "Mbpp/588", "solution": "def big_diff(lst):\n    \"\"\"\n    This function takes a list of numbers and returns the difference between\n    the largest and smallest values in the list.\n    \n    :param lst: List of numbers\n    :return: Difference between the largest and smallest number\n    \"\"\"\n    if not lst:\n        raise ValueError(\"List must not be empty\")\n    \n    max_value = max(lst)\n    min_value = min(lst)\n    \n    return max_value - min_value", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/589": [{"task_id": "Mbpp/589", "solution": "import math\ndef perfect_squares(start, end):\n    \"\"\"\n    This function returns a list of perfect squares between two given numbers (inclusive).\n    \n    Parameters:\n    start (int): The starting number of the range.\n    end (int): The ending number of the range.\n    \n    Returns:\n    list: A list of perfect squares between start and end.\n    \"\"\"\n    # Initialize an empty list to store perfect squares\n    squares = []\n    \n    # Find the smallest integer greater than or equal to the square root of start\n    start_sqrt = math.ceil(math.sqrt(start))\n    \n    # Find the largest integer less than or equal to the square root of end\n    end_sqrt = math.floor(math.sqrt(end))\n    \n    # Iterate over the range of integers from start_sqrt to end_sqrt\n    for i in range(start_sqrt, end_sqrt + 1):\n        # Append the square of the current integer to the list\n        squares.append(i * i)\n    \n    return squares", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-10, -1]]}], "Mbpp/591": [{"task_id": "Mbpp/591", "solution": "def swap_List(lst):\n    \"\"\"\n    This function takes a list as input and returns a new list with the first and last elements swapped.\n    \n    Parameters:\n    lst (list): The list whose first and last elements are to be swapped.\n    \n    Returns:\n    list: A new list with the first and last elements swapped.\n    \"\"\"\n    # Check if the list is empty or has only one element\n    if len(lst) <= 1:\n        return lst\n    \n    # Swap the first and last elements\n    lst[0], lst[-1] = lst[-1], lst[0]\n    \n    return lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/590": [{"task_id": "Mbpp/590", "solution": "import cmath\nimport math\ndef polar_rect(r, theta):\n    \"\"\"\n    Convert polar coordinates to rectangular coordinates.\n\n    Parameters:\n    r (float): The radius or magnitude.\n    theta (float): The angle in radians.\n\n    Returns:\n    tuple: A tuple containing:\n        - A tuple with the rectangular coordinates (x, y).\n        - A complex number representing the same point.\n    \"\"\"\n    # Convert polar to rectangular coordinates\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    \n    # Create a complex number from polar coordinates\n    complex_num = cmath.rect(r, theta)\n    \n    return ((x, y), complex_num)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 4]], "plus_fail_tests": [[0, 0]]}], "Mbpp/592": [{"task_id": "Mbpp/592", "solution": "def sum_of_product(n):\n    \"\"\"\n    This function calculates the sum of the product of consecutive binomial coefficients for a given n.\n    \"\"\"\n    # Function to calculate binomial coefficient C(n, k)\n    def binomial_coefficient(n, k):\n        if k > n:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        # Use the property C(n, k) = C(n-1, k-1) + C(n-1, k)\n        return binomial_coefficient(n-1, k-1) + binomial_coefficient(n-1, k)\n\n    # Calculate the sum of the product of consecutive binomial coefficients\n    total_sum = 0\n    for k in range(n):\n        total_sum += binomial_coefficient(n, k) * binomial_coefficient(n, k+1)\n    \n    return total_sum\n\n# Test the function with the given assertion\nassert sum_of_product(3) == 15\n\n# Additional test cases\nprint(sum_of_product(1))  # Output: 1\nprint(sum_of_product(2))  # Output: 4\nprint(sum_of_product(4))  # Output: 40\nprint(sum_of_product(5))  # Output: 105", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/594": [{"task_id": "Mbpp/594", "solution": "def diff_even_odd(numbers):\n    \"\"\"\n    This function finds the difference between the first even and the first odd number in a given list.\n    \n    :param numbers: List of integers\n    :return: Difference between the first even and the first odd number\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in numbers:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        \n        # If both first_even and first_odd are found, break the loop\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # Calculate the difference\n    if first_even is not None and first_odd is not None:\n        return abs(first_even - first_odd)\n    else:\n        raise ValueError(\"The list must contain at least one even and one odd number.\")", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 5, 3, 6, 1, 4, 9, 8, 7]]]}], "Mbpp/593": [{"task_id": "Mbpp/593", "solution": "def removezero_ip(ip_address):\n    # Split the IP address into its components\n    parts = ip_address.split('.')\n    # Remove leading zeros from each part\n    cleaned_parts = [str(int(part)) for part in parts]\n    # Join the cleaned parts back into a single string\n    cleaned_ip = '.'.join(cleaned_parts)\n    return cleaned_ip", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["0.0.0.0"]]}], "Mbpp/596": [{"task_id": "Mbpp/596", "solution": "import sys\ndef tuple_size(t):\n    \"\"\"\n    This function returns the size in bytes of the given tuple.\n    \n    Parameters:\n    t (tuple): The tuple whose size is to be calculated.\n    \n    Returns:\n    int: The size of the tuple in bytes.\n    \"\"\"\n    return sys.getsizeof(t)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/598": [{"task_id": "Mbpp/598", "solution": "def armstrong_number(n):\n    \"\"\"\n    Check if a number is an Armstrong number.\n\n    An Armstrong number (also known as a narcissistic number) is a number that is equal to the sum of its own digits each raised to the power of the number of digits.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is an Armstrong number, False otherwise.\n    \"\"\"\n    # Convert the number to a string to easily iterate over digits\n    digits = str(n)\n    # Calculate the number of digits\n    num_digits = len(digits)\n    # Calculate the sum of each digit raised to the power of the number of digits\n    sum_of_powers = sum(int(digit) ** num_digits for digit in digits)\n    # Check if the sum of powers is equal to the original number\n    return sum_of_powers == n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/597": [{"task_id": "Mbpp/597", "solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element from the two sorted arrays.\n    \n    :param arr1: List[int] - First sorted array\n    :param arr2: List[int] - Second sorted array\n    :param k: int - The kth position (1-based index)\n    :return: int - The kth element in the merged sorted array\n    \"\"\"\n    # Initialize pointers for both arrays\n    index1, index2 = 0, 0\n    len1, len2 = len(arr1), len(arr2)\n    \n    # We need to find the kth element, so we iterate k times\n    for _ in range(k):\n        # If one array is exhausted, take elements from the other array\n        if index1 < len1 and (index2 >= len2 or arr1[index1] <= arr2[index2]):\n            kth_element = arr1[index1]\n            index1 += 1\n        else:\n            kth_element = arr2[index2]\n            index2 += 1\n    \n    return kth_element", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 1], [], 3]]}], "Mbpp/599": [{"task_id": "Mbpp/599", "solution": "def sum_average(n):\n    \"\"\"\n    Calculate the sum and average of the first n natural numbers.\n\n    Parameters:\n    n (int): The number of natural numbers to consider.\n\n    Returns:\n    tuple: A tuple containing the sum and average of the first n natural numbers.\n    \"\"\"\n    # Calculate the sum of the first n natural numbers using the formula n * (n + 1) / 2\n    total_sum = n * (n + 1) // 2\n    \n    # Calculate the average by dividing the sum by n\n    average = total_sum / n\n    \n    return total_sum, average", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/600": [{"task_id": "Mbpp/600", "solution": "def is_Even(number):\n    \"\"\"\n    This function checks whether the given number is even or not.\n    \n    Parameters:\n    number (int): The number to check.\n    \n    Returns:\n    bool: True if the number is even, False otherwise.\n    \"\"\"\n    return number % 2 == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/602": [{"task_id": "Mbpp/602", "solution": "def first_repeated_char(s):\n    \"\"\"\n    This function finds the first repeated character in a given string.\n    \n    :param s: The input string\n    :return: The first repeated character or None if no repetition is found\n    \"\"\"\n    seen = set()\n    for char in s:\n        if char in seen:\n            return char\n        seen.add(char)\n    return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/604": [{"task_id": "Mbpp/604", "solution": "def reverse_words(s: str) -> str:\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list of words back into a string with spaces\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/603": [{"task_id": "Mbpp/603", "solution": "def get_ludic(n):\n    \"\"\"\n    Function to get all ludic numbers smaller than or equal to a given integer n.\n    \"\"\"\n    # Initialize the list of numbers from 1 to n\n    numbers = list(range(1, n + 1))\n    \n    # Start with the first number in the list, which is always 1\n    i = 1\n    while i < len(numbers):\n        # The current number is a ludic number\n        current_ludic = numbers[i]\n        \n        # Remove every current_ludic-th number from the list, starting from the current position\n        numbers = [num for j, num in enumerate(numbers) if (j % current_ludic) != 0 or j == i]\n        \n        # Move to the next number in the list\n        i += 1\n    \n    return numbers", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[100]]}], "Mbpp/605": [{"task_id": "Mbpp/605", "solution": "def prime_num(n):\n    \"\"\"Check if the given integer is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/607": [{"task_id": "Mbpp/607", "solution": "import re\ndef find_literals(text, pattern):\n    \"\"\"\n    Search for a regex pattern in a given string and return the matching substring,\n    start index, and end index.\n\n    :param text: The string to search within.\n    :param pattern: The regex pattern to search for.\n    :return: A tuple containing the matching substring, start index, and end index.\n    \"\"\"\n    match = re.search(pattern, text)\n    if match:\n        start_index = match.start()\n        end_index = match.end()\n        return (match.group(), start_index, end_index)\n    else:\n        return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/606": [{"task_id": "Mbpp/606", "solution": "import math\ndef radian_degree(degrees):\n    \"\"\"\n    Convert degrees to radians.\n\n    Parameters:\n    degrees (float): Angle in degrees.\n\n    Returns:\n    float: Angle in radians.\n    \"\"\"\n    return degrees * (math.pi / 180)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/608": [{"task_id": "Mbpp/608", "solution": "def bell_Number(n):\n    # Create a 2D array to store Bell numbers\n    bell = [[0 for i in range(n+1)] for j in range(n+1)]\n    \n    # Base case\n    bell[0][0] = 1\n    \n    # Fill the Bell triangle\n    for i in range(1, n+1):\n        # Explicitly put the last value of the previous row as the first value of the current row\n        bell[i][0] = bell[i-1][i-1]\n        \n        # Fill the rest of the current row\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    # The nth Bell number is the first element of the nth row\n    return bell[n][0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/610": [{"task_id": "Mbpp/610", "solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list.\n\n    Parameters:\n    lst (list): The list from which to remove the element.\n    k (int): The index of the element to remove.\n\n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    if k < 0 or k >= len(lst):\n        raise IndexError(\"Index out of range\")\n    return lst[:k] + lst[k+1:]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 1, 2, 3, 4, 4, 5, 1], 3]], "plus_fail_tests": [[[1, 2, 3, 4, 5], 1]]}], "Mbpp/611": [{"task_id": "Mbpp/611", "solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the n-th column in the given matrix.\n\n    :param matrix: List of lists where each sublist represents a row in the matrix.\n    :param n: The index of the column to find the maximum value of.\n    :return: The maximum value in the n-th column.\n    \"\"\"\n    # Extract the n-th column from the matrix\n    nth_column = [row[n] for row in matrix]\n    \n    # Return the maximum value in the n-th column\n    return max(nth_column)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/614": [{"task_id": "Mbpp/614", "solution": "def cumulative_sum(tuple_list):\n    \"\"\"\n    This function takes a list of tuples and returns the cumulative sum of all the values present in the tuples.\n    \n    :param tuple_list: List of tuples containing integers\n    :return: Integer representing the cumulative sum of all values in the tuples\n    \"\"\"\n    total_sum = 0\n    for tup in tuple_list:\n        total_sum += sum(tup)\n    return total_sum\n\n# Test the function with the provided example\nassert cumulative_sum([(1, 3), (5, 6, 7), (2, 6)]) == 30\n\n# Additional test cases\nprint(cumulative_sum([(1, 2), (3, 4), (5,)]))  # Output should be 15\nprint(cumulative_sum([(0, 0), (0, 0), (0, 0)]))  # Output should be 0\nprint(cumulative_sum([(10,), (20, 30), (40, 50, 60)]))  # Output should be 210\nprint(cumulative_sum([]))  # Output should be 0, as there are no tuples", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/612": [{"task_id": "Mbpp/612", "solution": "def merge(list_of_lists):\n    # Initialize two empty lists to hold the first and second elements\n    first_elements = []\n    second_elements = []\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Append the first element of the sublist to the first_elements list\n        first_elements.append(sublist[0])\n        # Append the second element of the sublist to the second_elements list\n        second_elements.append(sublist[1])\n    \n    # Return a list containing the two lists\n    return [first_elements, second_elements]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/615": [{"task_id": "Mbpp/615", "solution": "def average_tuple(tuples):\n    \"\"\"\n    This function takes a tuple of tuples and returns a list containing the average value of each tuple.\n    \n    :param tuples: A tuple of tuples, where each inner tuple contains numeric values.\n    :return: A list of average values for each inner tuple.\n    \"\"\"\n    averages = []\n    for t in tuples:\n        avg = sum(t) / len(t)\n        averages.append(avg)\n    return averages", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]]], "plus_fail_tests": [[[[7, 8, 9], [-2, -4, -6], [0, 20, 30]]]]}], "Mbpp/618": [{"task_id": "Mbpp/618", "solution": "def div_list(list1, list2):\n    \"\"\"\n    Divides elements of list1 by elements of list2 element-wise.\n    \n    Parameters:\n    list1 (list of numbers): The dividend list.\n    list2 (list of numbers): The divisor list.\n    \n    Returns:\n    list of floats: A new list containing the result of element-wise division.\n    \n    Raises:\n    ValueError: If the lists are not of the same length.\n    ZeroDivisionError: If an element in list2 is zero.\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Both lists must have the same length.\")\n    \n    result = []\n    for a, b in zip(list1, list2):\n        if b == 0:\n            raise ZeroDivisionError(\"Division by zero encountered in list2.\")\n        result.append(a / b)\n    \n    return result\nlist1 = [10, 20, 30]\nlist2 = [2, 4, 5]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/616": [{"task_id": "Mbpp/616", "solution": "def tuple_modulo(tuple1, tuple2):\n    \"\"\"\n    Takes two tuples of the same length and performs element-wise modulo operation.\n    \n    Parameters:\n    tuple1 (tuple): The first tuple of integers.\n    tuple2 (tuple): The second tuple of integers.\n    \n    Returns:\n    tuple: A tuple containing the result of element-wise modulo operation.\n    \"\"\"\n    # Ensure both tuples are of the same length\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Both tuples must be of the same length.\")\n    \n    # Perform element-wise modulo operation\n    result = tuple(a % b for a, b in zip(tuple1, tuple2))\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/619": [{"task_id": "Mbpp/619", "solution": "def move_num(s):\n    # Separate letters and numbers\n    letters = []\n    numbers = []\n    \n    # Iterate over each character in the string\n    for char in s:\n        if char.isdigit():\n            numbers.append(char)\n        else:\n            letters.append(char)\n    \n    # Join letters and numbers separately and concatenate them\n    return ''.join(letters) + ''.join(numbers)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/620": [{"task_id": "Mbpp/620", "solution": "def largest_subset(nums):\n    if not nums:\n        return 0\n\n    nums.sort()\n    n = len(nums)\n    dp = [1] * n  # dp[i] will store the size of the largest subset ending with nums[i]\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] % nums[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[9, 3, 12, 7, 16, 3, 11, 8, 4, 13, 13]]]}], "Mbpp/622": [{"task_id": "Mbpp/622", "solution": "def get_median(arr1, arr2, n):\n    \"\"\"\n    Function to find the median of two sorted arrays of the same size.\n    \n    Parameters:\n    arr1 (list): First sorted list.\n    arr2 (list): Second sorted list.\n    n (int): Size of each list.\n    \n    Returns:\n    float: The median of the two sorted lists.\n    \"\"\"\n    # Initialize pointers for both arrays\n    i = 0  # Current index of arr1\n    j = 0  # Current index of arr2\n    \n    # Since there are 2n elements, median will be average of elements at index n-1 and n\n    m1 = -1  # To store the element at index n-1\n    m2 = -1  # To store the element at index n\n    \n    # Loop through the arrays to find the median\n    for count in range(n + 1):\n        # If all elements of arr1 are smaller than smallest (or first) element of arr2\n        if i == n:\n            m1 = m2\n            m2 = arr2[0]\n            break\n        \n        # If all elements of arr2 are smaller than smallest (or first) element of arr1\n        elif j == n:\n            m1 = m2\n            m2 = arr1[0]\n            break\n        \n        # Compare elements of arr1 and arr2 to find the median\n        if arr1[i] <= arr2[j]:\n            m1 = m2  # Store the previous median\n            m2 = arr1[i]\n            i += 1\n        else:\n            m1 = m2  # Store the previous median\n            m2 = arr2[j]\n            j += 1\n    \n    # Return the average of the two middle elements\n    return (m1 + m2) / 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/624": [{"task_id": "Mbpp/624", "solution": "def is_upper(s):\n    \"\"\"\n    Convert a given string to uppercase.\n\n    Parameters:\n    s (str): The string to convert.\n\n    Returns:\n    str: The uppercase version of the input string.\n    \"\"\"\n    return s.upper()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/623": [{"task_id": "Mbpp/623", "solution": "def nth_nums(numbers, n):\n    \"\"\"\n    This function takes a list of numbers and an integer n, and returns a new list\n    where each number is raised to the n-th power.\n\n    :param numbers: List of numbers\n    :param n: The power to which each number should be raised\n    :return: A list of numbers raised to the n-th power\n    \"\"\"\n    return [x ** n for x in numbers]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/626": [{"task_id": "Mbpp/626", "solution": "import math\ndef triangle_area(radius):\n    \"\"\"\n    Calculate the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n    \n    Parameters:\n    radius (float): The radius of the semicircle. Must be a non-negative number.\n    \n    Returns:\n    float: The area of the largest inscribed triangle, or None if the radius is negative.\n    \"\"\"\n    if radius < 0:\n        return None\n    \n    # The largest triangle that can be inscribed in a semicircle is a right triangle\n    # with the hypotenuse as the diameter of the semicircle.\n    # The base and height of this triangle are both equal to the radius of the semicircle.\n    base = radius\n    height = radius\n    \n    # Area of the triangle = 0.5 * base * height\n    area = 0.5 * base * height\n    return area", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[0.5]]}], "Mbpp/629": [{"task_id": "Mbpp/629", "solution": "def find_even_numbers(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns a list of even numbers from the input list.\n\n    :param numbers: List of integers\n    :return: List of even integers\n    \"\"\"\n    return [num for num in numbers if num % 2 == 0]\n\n# Test the function with the provided assertion\nassert find_even_numbers([1, 2, 3, 4, 5]) == [2, 4]\n\n# Additional test cases\nprint(find_even_numbers([10, 15, 20, 25, 30]))  # Output: [10, 20, 30]\nprint(find_even_numbers([1, 3, 5, 7]))          # Output: []\nprint(find_even_numbers([2, 4, 6, 8, 10]))      # Output: [2, 4, 6, 8, 10]\nprint(find_even_numbers([]))                    # Output: []", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/628": [{"task_id": "Mbpp/628", "solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces all spaces in the given string with '%20'.\n\n    Parameters:\n    input_string (str): The string in which spaces need to be replaced.\n\n    Returns:\n    str: The modified string with spaces replaced by '%20'.\n    \"\"\"\n    return input_string.replace(' ', '%20')", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/631": [{"task_id": "Mbpp/631", "solution": "def replace_spaces(s):\n    # Create a translation table for replacing spaces with underscores and vice versa\n    translation_table = str.maketrans(' _', '_ ')\n    # Use the translate method to apply the translation table to the string\n    return s.translate(translation_table)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/632": [{"task_id": "Mbpp/632", "solution": "def move_zero(lst):\n    \"\"\"\n    This function takes a list of integers and moves all zeroes to the end\n    while maintaining the order of non-zero elements.\n    \n    Parameters:\n    lst (list): A list of integers.\n    \n    Returns:\n    list: A list with all zeroes moved to the end.\n    \"\"\"\n    # Count the number of zeroes in the list\n    zero_count = lst.count(0)\n    \n    # Create a new list with all non-zero elements\n    non_zero_list = [num for num in lst if num != 0]\n    \n    # Append the zeroes to the end of the non-zero list\n    non_zero_list.extend([0] * zero_count)\n    \n    return non_zero_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/633": [{"task_id": "Mbpp/633", "solution": "def pair_xor_sum(arr, n):\n    \"\"\"\n    Function to find the sum of XOR of all pairs of numbers in the given list.\n    \n    Parameters:\n    arr (list): List of integers.\n    n (int): Length of the list.\n    \n    Returns:\n    int: Sum of XOR of all pairs.\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum\n\n# Test the function with the provided test case\nassert pair_xor_sum([5, 9, 7, 6], 4) == 47\n\n# Additional test cases\nprint(pair_xor_sum([1, 2, 3], 3))  # Expected output: 6 (1^2 + 1^3 + 2^3 = 3 + 2 + 1 = 6)\nprint(pair_xor_sum([0, 0, 0], 3))  # Expected output: 0 (0^0 + 0^0 + 0^0 = 0)\nprint(pair_xor_sum([1, 1, 1, 1], 4))  # Expected output: 0 (all pairs XOR to 0)\nprint(pair_xor_sum([10, 20, 30], 3))  # Expected output: 62 (10^20 + 10^30 + 20^30 = 30 + 20 + 12 = 62)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/635": [{"task_id": "Mbpp/635", "solution": "def heap_sort(arr):\n    \"\"\"\n    Function to perform heap sort on a list.\n    :param arr: List of elements to be sorted\n    :return: Sorted list\n    \"\"\"\n    n = len(arr)\n\n    # Build a maxheap.\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    # One by one extract elements\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]  # swap\n        heapify(arr, i, 0)\n\n    return arr", "base_status": "fail", "plus_status": "pass", "base_fail_tests": [[[1, 3, 5, 7, 9, 2, 4, 6, 8, 0]]], "plus_fail_tests": []}], "Mbpp/630": [{"task_id": "Mbpp/630", "solution": "def get_coordinates(coord):\n    \"\"\"\n    Given a coordinate tuple (x, y), this function returns a list of all adjacent coordinates\n    including the coordinate itself. The adjacent coordinates are those that differ by at most\n    1 in either the x or y direction.\n    \n    :param coord: A tuple (x, y) representing the coordinate.\n    :return: A list of lists, where each inner list is a coordinate [x, y].\n    \"\"\"\n    x, y = coord\n    adjacent_coords = []\n\n    # Iterate over the range x-1 to x+1 and y-1 to y+1 to get all adjacent coordinates\n    for i in range(x - 1, x + 2):\n        for j in range(y - 1, y + 2):\n            adjacent_coords.append([i, j])\n\n    return adjacent_coords", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 1, 1]]]}], "Mbpp/637": [{"task_id": "Mbpp/637", "solution": "def noprofit_noloss(cost_price, selling_price):\n    \"\"\"\n    This function checks whether there is no profit and no loss for the given cost price and selling price.\n    \n    Parameters:\n    cost_price (float): The cost price of the item.\n    selling_price (float): The selling price of the item.\n    \n    Returns:\n    bool: True if there is no profit and no loss, False otherwise.\n    \"\"\"\n    return cost_price == selling_price", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/638": [{"task_id": "Mbpp/638", "solution": "def wind_chill(velocity_kmh, temperature_celsius):\n    \"\"\"\n    Calculate the wind chill index given the wind velocity in km/h and temperature in Celsius.\n    The formula used is the one provided by Environment Canada for temperatures in Celsius and wind speeds in km/h.\n    The result is rounded to the nearest integer.\n\n    Parameters:\n    velocity_kmh (float): Wind velocity in kilometers per hour.\n    temperature_celsius (float): Temperature in degrees Celsius.\n\n    Returns:\n    int: The wind chill index rounded to the nearest integer.\n    \"\"\"\n    if velocity_kmh < 4.8:\n        # If the wind speed is less than 4.8 km/h, the wind chill effect is negligible\n        return round(temperature_celsius)\n    \n    # Wind chill formula for Celsius and km/h\n    wind_chill_index = (13.12 + 0.6215 * temperature_celsius \n                        - 11.37 * (velocity_kmh ** 0.16) \n                        + 0.3965 * temperature_celsius * (velocity_kmh ** 0.16))\n    \n    return round(wind_chill_index)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0, 0]]}], "Mbpp/639": [{"task_id": "Mbpp/639", "solution": "def sample_nam(names):\n    # Filter out names that start with a lowercase letter\n    filtered_names = [name for name in names if not name[0].islower()]\n    # Calculate the sum of the lengths of the remaining names\n    total_length = sum(len(name) for name in filtered_names)\n    return total_length", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["AbCdE", "fGH", "IJKLMnOp", "qrs", "TUVW", "xyz"]]]}], "Mbpp/641": [{"task_id": "Mbpp/641", "solution": "def is_nonagonal(n):\n    \"\"\"\n    Calculate the nth nonagonal number.\n\n    A nonagonal number is a figurate number that extends the concept of\n    triangular and square numbers to the nonagon (a nine-sided polygon).\n    The formula for the nth nonagonal number is:\n    \n    N(n) = n * (7n - 5) / 2\n\n    Parameters:\n    n (int): The position of the nonagonal number to find.\n\n    Returns:\n    int: The nth nonagonal number.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (7 * n - 5) // 2", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0]]}], "Mbpp/644": [{"task_id": "Mbpp/644", "solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position (0-based index).\n    \n    Parameters:\n    arr (list): The list of elements to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with elements reversed up to the k-th position.\n    \"\"\"\n    # Ensure k is within the bounds of the array\n    if k < 0 or k >= len(arr):\n        raise ValueError(\"k must be within the bounds of the array indices.\")\n    \n    # Reverse the portion of the array from start to k (inclusive)\n    reversed_part = arr[:k+1][::-1]\n    # Concatenate the reversed part with the rest of the array\n    return reversed_part + arr[k+1:]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 5, 6], 4]], "plus_fail_tests": [[[6, 9, 2, 1, 5, 3], 4]]}], "Mbpp/643": [{"task_id": "Mbpp/643", "solution": "def text_match_wordz_middle(s):\n    \"\"\"\n    This function checks if the string contains the letter 'z', except at the start and end of the word.\n    \n    Parameters:\n    s (str): The input string to check.\n    \n    Returns:\n    bool: True if 'z' is found in the middle of the string, False otherwise.\n    \"\"\"\n    # Check if the string is long enough to have a middle\n    if len(s) <= 2:\n        return False\n    \n    # Check for 'z' in the middle of the string\n    for i in range(1, len(s) - 1):\n        if s[i] == 'z':\n            return True\n    \n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/720": [{"task_id": "Mbpp/720", "solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    This function takes a tuple and a dictionary as input and returns a new tuple\n    with the dictionary added as the last element of the tuple.\n    \n    Parameters:\n    tup (tuple): The original tuple.\n    dictionary (dict): The dictionary to add to the tuple.\n    \n    Returns:\n    tuple: A new tuple with the dictionary added as the last element.\n    \"\"\"\n    # Create a new tuple by concatenating the original tuple with a single-element tuple containing the dictionary\n    return tup + (dictionary,)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/722": [{"task_id": "Mbpp/722", "solution": "def filter_data(students, min_height, min_weight):\n    \"\"\"\n    Filters students based on minimum height and weight criteria.\n\n    Parameters:\n    students (dict): A dictionary with student names as keys and a tuple of (height, weight) as values.\n    min_height (float): The minimum height requirement.\n    min_weight (float): The minimum weight requirement.\n\n    Returns:\n    dict: A dictionary of students who meet both the height and weight criteria.\n    \"\"\"\n    # Initialize an empty dictionary to store the filtered students\n    filtered_students = {}\n\n    # Iterate over the students dictionary\n    for student, (height, weight) in students.items():\n        # Check if both height and weight are above the minimum requirements\n        if height > min_height and weight > min_weight:\n            # Add the student to the filtered dictionary\n            filtered_students[student] = (height, weight)\n\n    return filtered_students\nmin_height = 6.0\nmin_weight = 70", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"Cierra Vega": [6.2, 70], "Alden Cantrell": [5.9, 65], "Kierra Gentry": [6.0, 68], "Pierre Cox": [5.8, 66]}, 6.0, 70]], "plus_fail_tests": [[{"Alice": [5.6, 60], "Bob": [6.1, 70], "Charlie": [5.9, 65], "Dave": [5.11, 72], "Eve": [6.0, 68], "Frank": [5.7, 63]}, 5.8, 65]]}], "Mbpp/721": [{"task_id": "Mbpp/721", "solution": "def maxAverageOfPath(matrix):\n    if not matrix or not matrix[0]:\n        return 0\n\n    N = len(matrix)\n    dp = [[0] * N for _ in range(N)]\n    count = [[0] * N for _ in range(N)]\n\n    # Initialize the starting point\n    dp[0][0] = matrix[0][0]\n    count[0][0] = 1\n\n    # Fill the first row\n    for j in range(1, N):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n        count[0][j] = count[0][j-1] + 1\n\n    # Fill the first column\n    for i in range(1, N):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n        count[i][0] = count[i-1][0] + 1\n\n    # Fill the rest of the dp and count tables\n    for i in range(1, N):\n        for j in range(1, N):\n            if dp[i-1][j] > dp[i][j-1]:\n                dp[i][j] = dp[i-1][j] + matrix[i][j]\n                count[i][j] = count[i-1][j] + 1\n            else:\n                dp[i][j] = dp[i][j-1] + matrix[i][j]\n                count[i][j] = count[i][j-1] + 1\n\n    # Calculate the maximum average\n    total_cost = dp[N-1][N-1]\n    total_cells = count[N-1][N-1]\n    max_average = total_cost / total_cells\n\n    return max_average", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/723": [{"task_id": "Mbpp/723", "solution": "def count_same_pair(list1, list2):\n    \"\"\"\n    This function takes two lists of the same length and returns the count of indices where the lists have the same values.\n    \n    Parameters:\n    list1 (list): The first list of elements.\n    list2 (list): The second list of elements, must be of the same length as list1.\n    \n    Returns:\n    int: The count of indices where the elements in list1 and list2 are the same.\n    \"\"\"\n    # Ensure both lists are of the same length\n    if len(list1) != len(list2):\n        raise ValueError(\"Both lists must be of the same length.\")\n    \n    # Initialize a counter for the same values\n    count = 0\n    \n    # Iterate over the lists and compare elements at each index\n    for i in range(len(list1)):\n        if list1[i] == list2[i]:\n            count += 1\n    \n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/725": [{"task_id": "Mbpp/725", "solution": "def extract_quotation(s):\n    import re\n    # Use regular expression to find all substrings enclosed in double quotes\n    return re.findall(r'\"(.*?)\"', s)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/724": [{"task_id": "Mbpp/724", "solution": "def power_base_sum(base, power):\n    # Calculate base raised to the power\n    result = base ** power\n    \n    # Convert the result to a string to iterate over each digit\n    result_str = str(result)\n    \n    # Calculate the sum of all digits\n    digit_sum = sum(int(digit) for digit in result_str)\n    \n    return digit_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/726": [{"task_id": "Mbpp/726", "solution": "def multiply_elements(t):\n    \"\"\"\n    This function takes a tuple of numbers and returns a new tuple where each element is the product\n    of consecutive elements from the input tuple.\n\n    :param t: A tuple of numbers (t_1, t_2, ..., t_{N+1})\n    :return: A tuple of length N where each element is t_i * t_{i+1}\n    \"\"\"\n    # Calculate the length of the resulting tuple\n    n = len(t) - 1\n    \n    # Use a list comprehension to generate the products of consecutive elements\n    result = tuple(t[i] * t[i+1] for i in range(n))\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/728": [{"task_id": "Mbpp/728", "solution": "def sum_list(list1, list2):\n    \"\"\"\n    Takes two lists of equal length and returns a new list where each element is the sum of the elements\n    at the corresponding positions in the input lists.\n\n    Parameters:\n    list1 (list): The first list of numbers.\n    list2 (list): The second list of numbers.\n\n    Returns:\n    list: A list containing the sums of the corresponding elements of list1 and list2.\n    \"\"\"\n    # Check if the lists are of the same length\n    if len(list1) != len(list2):\n        raise ValueError(\"Both lists must have the same length\")\n\n    # Use a list comprehension to sum corresponding elements\n    return [a + b for a, b in zip(list1, list2)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/730": [{"task_id": "Mbpp/730", "solution": "def consecutive_duplicates(lst):\n    if not lst:\n        return []\n    \n    result = [lst[0]]\n    for i in range(1, len(lst)):\n        if lst[i] != lst[i - 1]:\n            result.append(lst[i])\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/732": [{"task_id": "Mbpp/732", "solution": "def replace_specialchar(text):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in the input text with a colon.\n\n    Parameters:\n    text (str): The input string to be processed.\n\n    Returns:\n    str: The processed string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Define the characters to be replaced\n    chars_to_replace = \" ,.\"\n    \n    # Use str.replace in a loop to replace each character with a colon\n    for char in chars_to_replace:\n        text = text.replace(char, ':')\n    \n    return text", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/731": [{"task_id": "Mbpp/731", "solution": "import math\ndef lateralsurface_cone(r, h):\n    \"\"\"\n    Calculate the lateral surface area of a cone.\n\n    Parameters:\n    r (float): The radius of the base of the cone.\n    h (float): The height of the cone.\n\n    Returns:\n    float: The lateral surface area of the cone.\n    \"\"\"\n    # Calculate the slant height of the cone\n    l = math.sqrt(r**2 + h**2)\n    \n    # Calculate the lateral surface area\n    lateral_surface_area = math.pi * r * l\n    \n    return lateral_surface_area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/733": [{"task_id": "Mbpp/733", "solution": "def find_first_occurrence(arr, target):\n    \"\"\"\n    This function finds the index of the first occurrence of a given number in a sorted array.\n    \n    :param arr: List[int] - A sorted list of integers\n    :param target: int - The target number to find\n    :return: int - The index of the first occurrence of the target number, or -1 if not found\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    result = -1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if arr[mid] == target:\n            result = mid\n            right = mid - 1  # Continue searching in the left half\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/735": [{"task_id": "Mbpp/735", "solution": "def toggle_middle_bits(n):\n    \"\"\"\n    Toggle all bits of the number except the first and the last bit.\n    \n    Parameters:\n    n (int): The input number whose middle bits are to be toggled.\n    \n    Returns:\n    int: The number after toggling the middle bits.\n    \"\"\"\n    # Convert the number to binary string\n    binary_str = bin(n)[2:]  # Remove the '0b' prefix\n    \n    # If the number has less than 3 bits, toggling middle bits doesn't make sense\n    if len(binary_str) < 3:\n        return n\n    \n    # Extract the first and last bits\n    first_bit = binary_str[0]\n    last_bit = binary_str[-1]\n    \n    # Extract the middle bits\n    middle_bits = binary_str[1:-1]\n    \n    # Toggle the middle bits\n    toggled_middle_bits = ''.join('1' if bit == '0' else '0' for bit in middle_bits)\n    \n    # Reconstruct the binary string with toggled middle bits\n    toggled_binary_str = first_bit + toggled_middle_bits + last_bit\n    \n    # Convert the binary string back to an integer\n    return int(toggled_binary_str, 2)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[true]]}], "Mbpp/734": [{"task_id": "Mbpp/734", "solution": "def sum_Of_Subarray_Prod(lst):\n    \"\"\"\n    This function calculates the sum of products of all possible sublists of a given list.\n    \"\"\"\n    n = len(lst)\n    total_sum = 0\n\n    # Iterate over all possible sublists\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= lst[j]\n            total_sum += product\n\n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/736": [{"task_id": "Mbpp/736", "solution": "def left_insertion(arr, target):\n    \"\"\"\n    This function returns the index at which the target should be inserted to maintain sorted order.\n    It uses a binary search approach to find the leftmost insertion point.\n    \n    :param arr: List of sorted integers\n    :param target: Integer value to find the insertion point for\n    :return: Index at which the target should be inserted\n    \"\"\"\n    left, right = 0, len(arr)\n    \n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/737": [{"task_id": "Mbpp/737", "solution": "import re\ndef check_str(s):\n    \"\"\"\n    This function checks if the given string starts with a vowel using regex.\n    \n    Parameters:\n    s (str): The string to check.\n    \n    Returns:\n    bool: True if the string starts with a vowel, False otherwise.\n    \"\"\"\n    # Define a regex pattern to match strings starting with a vowel (case insensitive)\n    pattern = r'^[aeiouAEIOU]'\n    \n    # Use re.match to check if the string starts with a vowel\n    return bool(re.match(pattern, s))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/740": [{"task_id": "Mbpp/740", "solution": "def tuple_to_dict(tpl):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Parameters:\n    tpl (tuple): A tuple with an even number of elements.\n\n    Returns:\n    dict: A dictionary with keys and values from adjacent elements of the tuple.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(tpl) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements.\")\n\n    # Create a dictionary using a dictionary comprehension\n    return {tpl[i]: tpl[i + 1] for i in range(0, len(tpl), 2)}", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/741": [{"task_id": "Mbpp/741", "solution": "def all_Characters_Same(s: str) -> bool:\n    \"\"\"\n    Check whether all characters in the string are the same.\n\n    Parameters:\n    s (str): The input string to check.\n\n    Returns:\n    bool: True if all characters are the same, False otherwise.\n    \"\"\"\n    # If the string is empty or has only one character, return True\n    if len(s) <= 1:\n        return True\n    \n    # Compare each character with the first character\n    first_char = s[0]\n    for char in s:\n        if char != first_char:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/742": [{"task_id": "Mbpp/742", "solution": "import math\ndef area_tetrahedron(a):\n    \"\"\"\n    Calculate the surface area of a regular tetrahedron with side length a.\n    \n    Parameters:\n    a (float): The length of a side of the tetrahedron.\n    \n    Returns:\n    float: The surface area of the tetrahedron.\n    \"\"\"\n    return math.sqrt(3) * a**2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/743": [{"task_id": "Mbpp/743", "solution": "def rotate_right(lst, n):\n    \"\"\"\n    Rotates the list to the right by n elements.\n\n    Parameters:\n    lst (list): The list to be rotated.\n    n (int): The number of positions to rotate the list.\n\n    Returns:\n    list: The rotated list.\n    \"\"\"\n    if not lst:\n        return lst\n    \n    n = n % len(lst)  # In case n is greater than the length of the list\n    return lst[-n:] + lst[:-n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/744": [{"task_id": "Mbpp/744", "solution": "def check_none(input_tuple):\n    \"\"\"\n    This function checks if the given tuple contains any None value.\n\n    Parameters:\n    input_tuple (tuple): The tuple to check for None values.\n\n    Returns:\n    bool: True if there is at least one None value in the tuple, False otherwise.\n    \"\"\"\n    return None in input_tuple", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/745": [{"task_id": "Mbpp/745", "solution": "def divisible_by_digits(startnum, endnum):\n    def is_divisible_by_digits(num):\n        original_num = num\n        while num > 0:\n            digit = num % 10\n            if digit == 0 or original_num % digit != 0:\n                return False\n            num //= 10\n        return True\n\n    result = []\n    for num in range(startnum, endnum + 1):\n        if is_divisible_by_digits(num):\n            result.append(num)\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[false, true]]}], "Mbpp/748": [{"task_id": "Mbpp/748", "solution": "def capital_words_spaces(s):\n    \"\"\"\n    This function takes a string `s` and inserts spaces before each capital letter,\n    except the first letter if it is capitalized. It returns the modified string.\n    \"\"\"\n    result = []\n    for i, char in enumerate(s):\n        # Check if the character is uppercase and it's not the first character\n        if char.isupper() and i != 0:\n            result.append(' ')\n        result.append(char)\n    return ''.join(result)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["MyNameIsAIAndIAmHereToHelpYou"]]}], "Mbpp/749": [{"task_id": "Mbpp/749", "solution": "def sort_numeric_strings(string_list):\n    # Convert each string in the list to an integer\n    int_list = [int(num) for num in string_list]\n    # Sort the list of integers\n    int_list.sort()\n    return int_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/750": [{"task_id": "Mbpp/750", "solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Add the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The list with the tuple elements added.\n    \"\"\"\n    # Convert the tuple to a list and extend the original list\n    lst.extend(tpl)\n    return lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/751": [{"task_id": "Mbpp/751", "solution": "def check_min_heap(arr):\n    \"\"\"\n    Function to check if the given array represents a min heap.\n    \n    A min heap is a complete binary tree where the value of each node is less than or equal to the values of its children.\n    For an array representation of a binary tree, for any index i:\n    - The left child is at index 2*i + 1\n    - The right child is at index 2*i + 2\n    - The parent is at index (i-1) // 2\n    \n    Parameters:\n    arr (list): The array to check.\n    \n    Returns:\n    bool: True if the array represents a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Check for each node if it is less than or equal to its children\n    for i in range(n // 2):  # Only need to check up to the last parent node\n        left = 2 * i + 1\n        right = 2 * i + 2\n        \n        # If left child exists and is less than the current node, it's not a min heap\n        if left < n and arr[i] > arr[left]:\n            return False\n        \n        # If right child exists and is less than the current node, it's not a min heap\n        if right < n and arr[i] > arr[right]:\n            return False\n    \n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/752": [{"task_id": "Mbpp/752", "solution": "def jacobsthal_num(n):\n    \"\"\"\n    Calculate the nth Jacobsthal number using the recursive formula:\n    J(n) = J(n-1) + 2 * J(n-2)\n    with initial conditions J(0) = 0 and J(1) = 1.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        # Initialize the first two Jacobsthal numbers\n        j0, j1 = 0, 1\n        # Calculate the nth Jacobsthal number iteratively\n        for i in range(2, n + 1):\n            jn = j1 + 2 * j0\n            j0, j1 = j1, jn\n        return jn", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/753": [{"task_id": "Mbpp/753", "solution": "def min_k(records, k):\n    \"\"\"\n    This function takes a list of tuples and an integer k, and returns the k tuples with the smallest second element.\n    \n    :param records: List of tuples, where each tuple contains a name and a number.\n    :param k: Integer, the number of minimum records to return based on the second element of the tuples.\n    :return: List of k tuples with the smallest second element.\n    \"\"\"\n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/754": [{"task_id": "Mbpp/754", "solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function takes three lists as input and returns a list of elements that are common\n    to all three lists at the same index.\n    \n    Parameters:\n    l1, l2, l3 (list): Three lists of elements.\n    \n    Returns:\n    list: A list of elements that are common to all three lists at the same index.\n    \"\"\"\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Determine the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate over the range of the minimum length\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are the same, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    # Return the list of common elements\n    return common_elements", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/755": [{"task_id": "Mbpp/755", "solution": "def second_smallest(numbers):\n    \"\"\"\n    This function returns the second smallest number in a list.\n    If the list has fewer than 2 unique numbers, it returns None.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_numbers = set(numbers)\n    \n    # If there are fewer than 2 unique numbers, return None\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Convert the set back to a sorted list\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the second smallest number\n    return sorted_numbers[1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/757": [{"task_id": "Mbpp/757", "solution": "def count_reverse_pairs(string_list):\n    # Create a set to store the strings for quick lookup\n    string_set = set(string_list)\n    count = 0\n\n    # Iterate over each string in the list\n    for s in string_list:\n        # Reverse the current string\n        reversed_s = s[::-1]\n        # Check if the reversed string is in the set\n        if reversed_s in string_set:\n            count += 1\n            # Remove both the string and its reverse from the set to avoid double counting\n            string_set.remove(s)\n            string_set.remove(reversed_s)\n\n    return count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["app", "123", "ad3", "apple", "elppa", "xyx", "bat", "tab", "tacocat", "racecar", "abc", "zyx", "def", "fed"]]]}], "Mbpp/758": [{"task_id": "Mbpp/758", "solution": "def unique_sublists(lst):\n    \"\"\"\n    Count the occurrences of lists within a list and return a dictionary\n    where each list is converted to a tuple and the value is the count of its occurrences.\n\n    Parameters:\n    lst (list of lists): The input list containing sublists.\n\n    Returns:\n    dict: A dictionary with tuples as keys and their occurrence counts as values.\n    \"\"\"\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n\n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are not hashable)\n        sublist_tuple = tuple(sublist)\n        \n        # Increment the count of this tuple in the dictionary\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n\n    return count_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/759": [{"task_id": "Mbpp/759", "solution": "def is_decimal(s):\n    \"\"\"\n    Check if the given string is a decimal number with a precision of 2.\n\n    A valid decimal number with a precision of 2 should:\n    - Have exactly one decimal point.\n    - Have exactly two digits after the decimal point.\n    - Have at least one digit before the decimal point.\n\n    Parameters:\n    s (str): The string to check.\n\n    Returns:\n    bool: True if the string is a valid decimal number with a precision of 2, False otherwise.\n    \"\"\"\n    # Split the string by the decimal point\n    parts = s.split('.')\n    \n    # Check if there are exactly two parts (one decimal point)\n    if len(parts) != 2:\n        return False\n    \n    # Check if the part before the decimal point is a valid integer\n    if not parts[0].isdigit():\n        return False\n    \n    # Check if the part after the decimal point has exactly two digits\n    if len(parts[1]) != 2 or not parts[1].isdigit():\n        return False\n    \n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["123"]]}], "Mbpp/760": [{"task_id": "Mbpp/760", "solution": "def unique_Element(lst):\n    \"\"\"\n    This function checks whether a list contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(lst)\n    # Check if the length of the set is 1, meaning all elements in the list were the same\n    return len(unique_elements) == 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/762": [{"task_id": "Mbpp/762", "solution": "def check_monthnumber_number(month_number):\n    \"\"\"\n    This function checks if the given month number has 30 days.\n    \n    Parameters:\n    month_number (int): The month number (1 for January, 2 for February, ..., 12 for December)\n    \n    Returns:\n    bool: True if the month has 30 days, False otherwise\n    \"\"\"\n    # List of months with 30 days: April (4), June (6), September (9), November (11)\n    months_with_30_days = [4, 6, 9, 11]\n    \n    return month_number in months_with_30_days", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/739": [{"task_id": "Mbpp/739", "solution": "def find_Index(n):\n    \"\"\"\n    This function finds the index of the smallest triangular number with n digits.\n    A triangular number is a number that can be represented as a triangle with dots.\n    The nth triangular number is given by the formula: T(n) = n * (n + 1) / 2\n    \"\"\"\n    index = 1\n    while True:\n        # Calculate the nth triangular number\n        triangular_number = index * (index + 1) // 2\n        \n        # Check the number of digits in the triangular number\n        if len(str(triangular_number)) == n:\n            return index\n        \n        # Increment the index to check the next triangular number\n        index += 1", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[100]]}], "Mbpp/763": [{"task_id": "Mbpp/763", "solution": "def find_min_diff(arr, n):\n    \"\"\"\n    Function to find the minimum difference between any two elements in a given array.\n\n    Parameters:\n    arr (tuple): A tuple of integers.\n    n (int): The number of elements in the tuple.\n\n    Returns:\n    int: The minimum difference between any two elements.\n    \"\"\"\n    # Convert the tuple to a list and sort it\n    sorted_arr = sorted(arr)\n    \n    # Initialize the minimum difference to a large number\n    min_diff = float('inf')\n    \n    # Iterate through the sorted list and find the minimum difference\n    for i in range(n - 1):\n        diff = sorted_arr[i + 1] - sorted_arr[i]\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/764": [{"task_id": "Mbpp/764", "solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in the given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(1 for char in s if char.isdigit())", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/766": [{"task_id": "Mbpp/766", "solution": "def pair_wise(lst):\n    \"\"\"\n    This function takes a list and returns a list of tuples, \n    where each tuple contains a pair of consecutive items from the input list.\n    \n    :param lst: List of items\n    :return: List of tuples with consecutive pairs\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/767": [{"task_id": "Mbpp/767", "solution": "def get_pairs_count(numbers, target_sum):\n    \"\"\"\n    This function counts the number of pairs in the list 'numbers' whose sum is equal to 'target_sum'.\n    \n    :param numbers: List of integers\n    :param target_sum: Integer, the target sum for the pairs\n    :return: Integer, the count of pairs whose sum is equal to 'target_sum'\n    \"\"\"\n    count = 0\n    # Create a dictionary to store the frequency of each number in the list\n    freq = {}\n    \n    # Iterate over each number in the list\n    for number in numbers:\n        # Calculate the complement that would sum with the current number to reach the target_sum\n        complement = target_sum - number\n        \n        # If the complement is already in the frequency dictionary, it means we have found a pair\n        if complement in freq:\n            count += freq[complement]\n        \n        # Add the current number to the frequency dictionary\n        if number in freq:\n            freq[number] += 1\n        else:\n            freq[number] = 1\n    \n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/769": [{"task_id": "Mbpp/769", "solution": "def Diff(list1, list2):\n    \"\"\"\n    This function takes two lists and returns a list containing the elements\n    that are present in the first list but not in the second list.\n    \"\"\"\n    # Use list comprehension to filter out elements not in list2\n    return [item for item in list1 if item not in list2]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 5], [6, 7, 1]]], "plus_fail_tests": [[[], [1, 2, 3]]]}], "Mbpp/770": [{"task_id": "Mbpp/770", "solution": "def odd_num_sum(n):\n    \"\"\"\n    Calculate the sum of the fourth power of the first n odd natural numbers.\n\n    Parameters:\n    n (int): The number of odd natural numbers to consider.\n\n    Returns:\n    int: The sum of the fourth power of the first n odd natural numbers.\n    \"\"\"\n    # Initialize the sum\n    sum_of_powers = 0\n    \n    # Generate the first n odd natural numbers and calculate their fourth power\n    for i in range(n):\n        odd_number = 2 * i + 1\n        sum_of_powers += odd_number ** 4\n    \n    return sum_of_powers", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/771": [{"task_id": "Mbpp/771", "solution": "def check_expression(expression):\n    # Stack to keep track of opening brackets\n    stack = []\n    \n    # Dictionary to map closing brackets to their corresponding opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    # Iterate through each character in the expression\n    for char in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if char in bracket_map.values():\n            stack.append(char)\n        # If the character is a closing bracket\n        elif char in bracket_map:\n            # Check if the stack is empty or the top of the stack is not the matching opening bracket\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            # If it matches, pop the top of the stack\n            stack.pop()\n    \n    # If the stack is empty, all brackets were matched correctly\n    return not stack", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/772": [{"task_id": "Mbpp/772", "solution": "def remove_length(s, k):\n    # Split the string into words\n    words = s.split()\n    # Filter out words with length k\n    filtered_words = [word for word in words if len(word) != k]\n    # Join the filtered words back into a string\n    return ' '.join(filtered_words)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/773": [{"task_id": "Mbpp/773", "solution": "def occurance_substring(main_string, sub_string):\n    \"\"\"\n    This function finds the first occurrence and position of the substring within the main string.\n    It returns a tuple containing the substring, start index, and end index.\n    If the substring is not found, it returns None.\n    \"\"\"\n    start_index = main_string.find(sub_string)\n    if start_index == -1:\n        return None\n    end_index = start_index + len(sub_string)\n    return (sub_string, start_index, end_index)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/775": [{"task_id": "Mbpp/775", "solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in the given list.\n\n    Parameters:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    # Iterate over the list, checking only the odd indices\n    for i in range(1, len(lst), 2):\n        # If the number at the odd index is not odd, return False\n        if lst[i] % 2 == 0:\n            return False\n    # If all odd indices contain odd numbers, return True\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/777": [{"task_id": "Mbpp/777", "solution": "def find_sum(lst):\n    # Create a dictionary to count occurrences of each element\n    count_dict = {}\n    \n    # Count each element in the list\n    for num in lst:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Sum up elements that appear only once\n    sum_non_repeated = sum(num for num, count in count_dict.items() if count == 1)\n    \n    return sum_non_repeated", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 1, 1, 4, 5, 6]]], "plus_fail_tests": [[[-1, -2, -3, -1, -1, -4, -5, -6]]]}], "Mbpp/778": [{"task_id": "Mbpp/778", "solution": "def pack_consecutive_duplicates(lst):\n    if not lst:\n        return []\n    \n    packed_list = []\n    current_sublist = [lst[0]]\n    \n    for i in range(1, len(lst)):\n        if lst[i] == lst[i - 1]:\n            current_sublist.append(lst[i])\n        else:\n            packed_list.append(current_sublist)\n            current_sublist = [lst[i]]\n    \n    packed_list.append(current_sublist)\n    return packed_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/780": [{"task_id": "Mbpp/780", "solution": "def find_combinations(tuple_list):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each tuple in the list\n    for i in range(len(tuple_list)):\n        # For each tuple, iterate over the remaining tuples in the list\n        for j in range(i + 1, len(tuple_list)):\n            # Calculate the sum of the first elements and the sum of the second elements\n            sum_first_elements = tuple_list[i][0] + tuple_list[j][0]\n            sum_second_elements = tuple_list[i][1] + tuple_list[j][1]\n            # Append the resulting tuple to the result list\n            result.append((sum_first_elements, sum_second_elements))\n    \n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3], [3, 4, 5]]]], "plus_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15]]]]}], "Mbpp/781": [{"task_id": "Mbpp/781", "solution": "def count_divisors(n):\n    \"\"\"\n    This function checks whether the count of divisors of a given number n is even.\n    \n    Parameters:\n    n (int): The number for which to count the divisors.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    \n    return count % 2 == 0", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[987654321]]}], "Mbpp/765": [{"task_id": "Mbpp/765", "solution": "def is_polite(n):\n    \"\"\"\n    Function to find the nth polite number.\n    A polite number is a positive integer that is not a power of 2.\n    \"\"\"\n    def is_power_of_two(x):\n        # A number is a power of two if it has exactly one bit set in its binary representation\n        return (x & (x - 1)) == 0 and x != 0\n\n    count = 0\n    num = 1\n    while True:\n        if not is_power_of_two(num):\n            count += 1\n            if count == n:\n                return num\n        num += 1", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000000000]]}], "Mbpp/782": [{"task_id": "Mbpp/782", "solution": "def odd_length_sum(arr):\n    total_sum = 0\n    n = len(arr)\n    \n    # Iterate over all possible starting points of subarrays\n    for start in range(n):\n        # Iterate over all possible ending points of subarrays\n        for end in range(start, n):\n            # Calculate the length of the current subarray\n            length = end - start + 1\n            # Check if the length is odd\n            if length % 2 == 1:\n                # Sum the elements of the subarray\n                total_sum += sum(arr[start:end+1])\n    \n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/785": [{"task_id": "Mbpp/785", "solution": "def tuple_str_int(s):\n    # Remove the parentheses and split the string by comma\n    elements = s.strip('()').split(',')\n    # Convert each element to an integer and return as a tuple\n    return tuple(int(element) for element in elements)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/784": [{"task_id": "Mbpp/784", "solution": "def mul_even_odd(numbers):\n    \"\"\"\n    This function finds the product of the first even and the first odd number in the given list.\n    \n    :param numbers: List of integers\n    :return: Product of the first even and the first odd number\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in numbers:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        raise ValueError(\"The list must contain at least one even and one odd number.\")", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/786": [{"task_id": "Mbpp/786", "solution": "def right_insertion(arr, value):\n    \"\"\"\n    This function returns the index at which the specified value should be inserted\n    in the sorted array `arr` to maintain the sorted order. If the value is already\n    present, it returns the index after the last occurrence of the value.\n    \n    :param arr: List[int] - A list of integers sorted in non-decreasing order.\n    :param value: int - The value to find the right insertion point for.\n    :return: int - The index at which the value should be inserted.\n    \"\"\"\n    low, high = 0, len(arr)\n    \n    while low < high:\n        mid = (low + high) // 2\n        if arr[mid] <= value:\n            low = mid + 1\n        else:\n            high = mid\n    \n    return low", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/788": [{"task_id": "Mbpp/788", "solution": "def new_tuple(lst, string):\n    \"\"\"\n    Create a new tuple from the given list and string.\n\n    Parameters:\n    lst (list): A list of strings.\n    string (str): A string to be added to the tuple.\n\n    Returns:\n    tuple: A tuple containing the elements of the list followed by the string.\n    \"\"\"\n    # Convert the list to a tuple and add the string as the last element\n    return tuple(lst) + (string,)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/787": [{"task_id": "Mbpp/787", "solution": "import re\ndef text_match_three(text):\n    \"\"\"\n    This function checks if the input string contains an 'a' followed by exactly three 'b's.\n    \n    Parameters:\n    text (str): The input string to be checked.\n    \n    Returns:\n    bool: True if the pattern is found, False otherwise.\n    \"\"\"\n    # Define the regex pattern for 'a' followed by exactly three 'b's\n    pattern = r'ab{3}'\n    \n    # Use re.search to find the pattern in the text\n    if re.search(pattern, text):\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/790": [{"task_id": "Mbpp/790", "solution": "def even_position(lst):\n    \"\"\"\n    Check whether every even index contains even numbers in the given list.\n\n    Parameters:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if every even index contains an even number, False otherwise.\n    \"\"\"\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 1, 4, 2, 6, 1, 8, 2, 10, 1, 12]]]}], "Mbpp/791": [{"task_id": "Mbpp/791", "solution": "def remove_nested(input_tuple):\n    \"\"\"\n    This function takes a tuple as input and returns a new tuple with any nested tuples removed.\n    \n    Parameters:\n    input_tuple (tuple): The input tuple which may contain nested tuples.\n    \n    Returns:\n    tuple: A new tuple with all nested tuples removed.\n    \"\"\"\n    # Use a generator expression to filter out elements that are tuples\n    return tuple(item for item in input_tuple if not isinstance(item, tuple))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/792": [{"task_id": "Mbpp/792", "solution": "def count_list(list_of_lists):\n    \"\"\"\n    This function takes a list of lists as input and returns the count of lists within it.\n    \n    Parameters:\n    list_of_lists (list): A list containing other lists.\n    \n    Returns:\n    int: The number of lists contained within the input list.\n    \"\"\"\n    return len(list_of_lists)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 3, [4, [5, [6, [7, [8, 9]]]]]]]]}], "Mbpp/794": [{"task_id": "Mbpp/794", "solution": "import re\ndef text_starta_endb(s):\n    \"\"\"\n    This function checks if the input string matches the pattern:\n    a string that has an 'a' followed by anything, ending in 'b'.\n    \"\"\"\n    # Define the regex pattern\n    pattern = r'^a.*b$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    return bool(re.match(pattern, s))", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["xaabbyz1323ababb"]]}], "Mbpp/793": [{"task_id": "Mbpp/793", "solution": "def last(arr, target):\n    \"\"\"\n    Find the last position of an element in a sorted array.\n\n    Parameters:\n    arr (list): A sorted list of elements.\n    target (int): The element to find the last position of.\n\n    Returns:\n    int: The last position of the target element in the array, or -1 if not found.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    result = -1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if arr[mid] == target:\n            result = mid\n            left = mid + 1  # Continue searching in the right half\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/796": [{"task_id": "Mbpp/796", "solution": "def return_sum(dictionary):\n    \"\"\"\n    This function takes a dictionary as input and returns the sum of all its values.\n\n    :param dictionary: A dictionary with numeric values\n    :return: The sum of all values in the dictionary\n    \"\"\"\n    return sum(dictionary.values())", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/798": [{"task_id": "Mbpp/798", "solution": "def _sum(arr):\n    \"\"\"\n    This function takes a list of numbers and returns their sum.\n    \n    Parameters:\n    arr (list): A list of numbers (integers or floats).\n    \n    Returns:\n    int/float: The sum of the numbers in the list.\n    \"\"\"\n    return sum(arr)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/799": [{"task_id": "Mbpp/799", "solution": "def left_rotate(n, d):\n    \"\"\"\n    Rotate left bits by d bits for a given 32-bit number n.\n\n    :param n: The number to rotate (assumed to be 32-bit)\n    :param d: The number of bits to rotate to the left\n    :return: The result of the left rotation\n    \"\"\"\n    # Mask to ensure the number is treated as 32-bit\n    MAX_BITS = 32\n    # Perform the left rotation\n    rotated = ((n << d) | (n >> (MAX_BITS - d))) & 0xFFFFFFFF\n    return rotated", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/797": [{"task_id": "Mbpp/797", "solution": "def sum_in_range(l, r):\n    \"\"\"\n    This function calculates the sum of all odd natural numbers within the range l and r (inclusive).\n    \n    Parameters:\n    l (int): The lower bound of the range.\n    r (int): The upper bound of the range.\n    \n    Returns:\n    int: The sum of all odd natural numbers within the range.\n    \"\"\"\n    # Initialize the sum\n    total_sum = 0\n    \n    # Iterate over the range from l to r (inclusive)\n    for number in range(l, r + 1):\n        # Check if the number is odd\n        if number % 2 != 0:\n            # Add the odd number to the total sum\n            total_sum += number\n    \n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/800": [{"task_id": "Mbpp/800", "solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    This function removes all whitespaces from the given input string.\n\n    Parameters:\n    input_string (str): The string from which to remove all whitespaces.\n\n    Returns:\n    str: A new string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/803": [{"task_id": "Mbpp/803", "solution": "import math\ndef is_perfect_square(n):\n    \"\"\"\n    Check if a number is a perfect square.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/801": [{"task_id": "Mbpp/801", "solution": "def test_three_equal(a, b, c):\n    \"\"\"\n    This function takes three integers as input and returns the count of numbers that are equal.\n    If all three numbers are equal, it returns 3.\n    If two numbers are equal, it returns 2.\n    If no numbers are equal, it returns 0.\n    \"\"\"\n    if a == b == c:\n        return 3\n    elif a == b or b == c or a == c:\n        return 2\n    else:\n        return 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/804": [{"task_id": "Mbpp/804", "solution": "def is_product_even(numbers):\n    \"\"\"\n    This function checks whether the product of numbers in a list is even or not.\n    \n    Parameters:\n    numbers (list): A list of integers.\n    \n    Returns:\n    bool: True if the product is even, False otherwise.\n    \"\"\"\n    # If the list is empty, the product is considered 1, which is odd\n    if not numbers:\n        return False\n    \n    # Check if any number in the list is even\n    for number in numbers:\n        if number % 2 == 0:\n            return True\n    \n    # If no even number is found, the product is odd\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/806": [{"task_id": "Mbpp/806", "solution": "def max_run_uppercase(s):\n    max_run = 0\n    current_run = 0\n\n    for char in s:\n        if char.isupper():\n            current_run += 1\n            if current_run > max_run:\n                max_run = current_run\n        else:\n            current_run = 0\n\n    return max_run", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["Aaa"]]}], "Mbpp/805": [{"task_id": "Mbpp/805", "solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    This function takes a list of lists and returns the list whose sum of elements is the highest.\n    \n    :param list_of_lists: List[List[int]] - A list containing lists of integers\n    :return: List[int] - The list with the highest sum of elements\n    \"\"\"\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n\n    # Iterate over each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        # If the current sum is greater than the maximum sum found so far, update max_sum and max_list\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/807": [{"task_id": "Mbpp/807", "solution": "def first_odd(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns the first odd number found in the list.\n    If no odd number is found, it returns None.\n    \"\"\"\n    for number in numbers:\n        if number % 2 != 0:\n            return number\n    return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/808": [{"task_id": "Mbpp/808", "solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the element k.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n    k (any): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/809": [{"task_id": "Mbpp/809", "solution": "def check_smaller(tuple1, tuple2):\n    \"\"\"\n    Check if each element of the second tuple is smaller than its corresponding element in the first tuple.\n\n    Parameters:\n    tuple1 (tuple): The first tuple of numbers.\n    tuple2 (tuple): The second tuple of numbers.\n\n    Returns:\n    bool: True if each element of tuple2 is smaller than the corresponding element in tuple1, False otherwise.\n    \"\"\"\n    # Check if both tuples have the same length\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Both tuples must have the same length.\")\n    \n    # Iterate over the elements of both tuples and compare them\n    for a, b in zip(tuple1, tuple2):\n        if b >= a:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}]}, "pass_at_k": {"base": {"pass@1": 0.8835978835978836}, "plus": {"pass@1": 0.7275132275132276}}}