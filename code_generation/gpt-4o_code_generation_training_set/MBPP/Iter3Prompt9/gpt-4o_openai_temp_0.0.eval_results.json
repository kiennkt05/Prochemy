{"date": "2025-09-15 04:56", "hash": "ee43ecabebf20deef4bb776a405ac5b1", "eval": {"Mbpp/3": [{"task_id": "Mbpp/3", "solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # Any other even number is not prime\n    \n    # Check for factors from 3 to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True  # Found a factor, n is not prime\n    \n    return False  # No factors found, n is prime", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/2": [{"task_id": "Mbpp/2", "solution": "def similar_elements(list1, list2):\n    \"\"\"\n    This function takes two lists as input and returns a list of elements that are common to both lists.\n    \n    Parameters:\n    list1 (list): The first list of elements.\n    list2 (list): The second list of elements.\n    \n    Returns:\n    list: A list containing the shared elements between list1 and list2.\n    \"\"\"\n    # Convert both lists to sets to find the intersection\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Find the intersection of both sets\n    shared_elements = set1.intersection(set2)\n    \n    # Return the result as a list\n    return list(shared_elements)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/6": [{"task_id": "Mbpp/6", "solution": "def differ_At_One_Bit_Pos(num1, num2):\n    \"\"\"\n    Check if two numbers differ at exactly one bit position.\n\n    Parameters:\n    num1 (int): The first integer.\n    num2 (int): The second integer.\n\n    Returns:\n    bool: True if the numbers differ at exactly one bit position, False otherwise.\n    \"\"\"\n    # XOR the two numbers. The result will have bits set to 1 where num1 and num2 differ.\n    xor_result = num1 ^ num2\n    \n    # Check if the result of XOR is a power of two.\n    # A number is a power of two if it has exactly one bit set in its binary representation.\n    # This can be checked using the condition (xor_result & (xor_result - 1)) == 0\n    # and ensuring xor_result is not zero.\n    return xor_result != 0 and (xor_result & (xor_result - 1)) == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/4": [{"task_id": "Mbpp/4", "solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers and return them in descending order.\n\n    :param numbers: List of integers from which to find the largest numbers.\n    :param n: The number of largest integers to find.\n    :return: A list of the n largest integers in descending order.\n    \"\"\"\n    # Use heapq.nlargest to find the n largest numbers\n    largest_numbers = heapq.nlargest(n, numbers)\n    \n    # Return the numbers in descending order\n    return largest_numbers", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/7": [{"task_id": "Mbpp/7", "solution": "def find_char_long(s):\n    \"\"\"\n    This function takes a string as input and returns a list of words that are at least 4 characters long.\n    \n    :param s: A string containing words separated by spaces.\n    :return: A list of words that are at least 4 characters long.\n    \"\"\"\n    # Split the string into words\n    words = s.split()\n    \n    # Filter words that are at least 4 characters long\n    long_words = [word for word in words if len(word) >= 4]\n    \n    return long_words", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["This is a very long string with no words that are at least 4 characters long."]]}], "Mbpp/8": [{"task_id": "Mbpp/8", "solution": "def square_nums(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns a new list containing the squares of each number.\n\n    :param numbers: List of integers\n    :return: List of integers where each element is the square of the corresponding element in the input list\n    \"\"\"\n    # Using list comprehension to create a new list with squares of each element\n    return [num ** 2 for num in numbers]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/11": [{"task_id": "Mbpp/11", "solution": "def remove_Occ(s: str, char: str) -> str:\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n\n    Parameters:\n    s (str): The input string from which the character is to be removed.\n    char (str): The character to be removed from the string.\n\n    Returns:\n    str: The modified string with the first and last occurrence of the character removed.\n    \"\"\"\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n\n    # If the character is not found or only found once, return the string as is\n    if first_index == -1 or first_index == last_index:\n        return s\n\n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    # Adjust the last index since the string has been modified\n    last_index -= 1\n    # Remove the last occurrence\n    s = s[:last_index] + s[last_index + 1:]\n\n    return s", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["a", "a"]]}], "Mbpp/9": [{"task_id": "Mbpp/9", "solution": "def find_Rotations(s):\n    \"\"\"\n    This function finds the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Parameters:\n    s (str): The input string for which we need to find the minimum rotations.\n    \n    Returns:\n    int: The minimum number of rotations required to get the same string.\n    \"\"\"\n    # Get the length of the string\n    n = len(s)\n    \n    # Concatenate the string with itself\n    doubled_s = s + s\n    \n    # Iterate over possible rotation lengths\n    for i in range(1, n + 1):\n        # Check if the substring of doubled_s starting from i and of length n is equal to the original string\n        if doubled_s[i:i + n] == s:\n            return i\n    \n    # If no rotation is found, return the length of the string\n    return n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/14": [{"task_id": "Mbpp/14", "solution": "def find_volume(base_length, height_of_triangle, length_of_prism):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Parameters:\n    base_length (float): The base length of the triangular face.\n    height_of_triangle (float): The height of the triangular face.\n    length_of_prism (float): The length of the prism.\n\n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    # Calculate the area of the triangular base\n    area_of_triangle = 0.5 * base_length * height_of_triangle\n    \n    # Calculate the volume of the prism\n    volume = area_of_triangle * length_of_prism\n    \n    return volume\n\n# Test the function with the provided test case\nassert find_volume(10, 8, 6) == 240\n\n# Example usage\nprint(\"The volume of the triangular prism is:\", find_volume(10, 8, 6))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/12": [{"task_id": "Mbpp/12", "solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Parameters:\n    matrix (list of list of int): A 2D list where each sublist represents a row of the matrix.\n\n    Returns:\n    list of list of int: The matrix sorted by the sum of its rows in ascending order.\n    \"\"\"\n    # Sort the matrix using the sum of each row as the key\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/16": [{"task_id": "Mbpp/16", "solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    This function checks if the input string contains sequences of lowercase letters\n    joined with an underscore. It returns True if the condition is met, otherwise False.\n    \n    :param s: Input string to be checked\n    :return: Boolean value indicating if the string meets the condition\n    \"\"\"\n    import re\n    \n    # Regular expression pattern to match sequences of lowercase letters joined by an underscore\n    pattern = r'^[a-z]+(_[a-z]+)+$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    return bool(re.match(pattern, s))", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["a"]]}], "Mbpp/17": [{"task_id": "Mbpp/17", "solution": "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square given the side length.\n\n    Parameters:\n    side_length (float): The length of one side of the square.\n\n    Returns:\n    float: The perimeter of the square.\n    \"\"\"\n    # The perimeter of a square is calculated as 4 times the side length\n    return 4 * side_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/19": [{"task_id": "Mbpp/19", "solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if there are any duplicate elements in the array.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Convert the list to a set, which removes duplicates\n    unique_elements = set(arr)\n    \n    # If the length of the set is less than the length of the list,\n    # it means there were duplicates in the list.\n    return len(unique_elements) != len(arr)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/18": [{"task_id": "Mbpp/18", "solution": "def remove_dirty_chars(first_string, second_string):\n    \"\"\"\n    Remove characters from the first string which are present in the second string.\n\n    Parameters:\n    first_string (str): The string from which characters will be removed.\n    second_string (str): The string containing characters to be removed from the first string.\n\n    Returns:\n    str: A new string with characters removed.\n    \"\"\"\n    # Create a set of characters to be removed for faster lookup\n    chars_to_remove = set(second_string)\n    \n    # Use a list comprehension to filter out characters present in the second string\n    result = ''.join([char for char in first_string if char not in chars_to_remove])\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/20": [{"task_id": "Mbpp/20", "solution": "def is_woodall(number):\n    \"\"\"\n    Check if the given number is a Woodall number.\n    \n    A Woodall number is of the form n * 2^n - 1 for some positive integer n.\n    \n    Parameters:\n    number (int): The number to check.\n    \n    Returns:\n    bool: True if the number is a Woodall number, False otherwise.\n    \"\"\"\n    if number < 0:\n        return False\n    \n    n = 1\n    while True:\n        woodall_number = n * (2 ** n) - 1\n        if woodall_number == number:\n            return True\n        elif woodall_number > number:\n            return False\n        n += 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/56": [{"task_id": "Mbpp/56", "solution": "def check(number):\n    \"\"\"\n    Check if the given number is one less than twice its reverse.\n\n    Parameters:\n    number (int): The number to check.\n\n    Returns:\n    bool: True if the number is one less than twice its reverse, False otherwise.\n    \"\"\"\n    # Convert the number to a string to reverse it\n    reversed_number_str = str(number)[::-1]\n    \n    # Convert the reversed string back to an integer\n    reversed_number = int(reversed_number_str)\n    \n    # Check if the number is one less than twice its reverse\n    return number == 2 * reversed_number - 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/58": [{"task_id": "Mbpp/58", "solution": "def opposite_Signs(a, b):\n    \"\"\"\n    This function checks whether two integers have opposite signs.\n    \n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n    \n    Returns:\n    bool: True if the integers have opposite signs, False otherwise.\n    \"\"\"\n    # XOR operation between a and b will result in a negative number if they have opposite signs\n    return (a ^ b) < 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/57": [{"task_id": "Mbpp/57", "solution": "def find_Max_Num(digits):\n    \"\"\"\n    This function takes a list of digits and returns the largest number that can be formed by arranging these digits.\n\n    Parameters:\n    digits (list): A list of integers representing digits (0-9).\n\n    Returns:\n    int: The largest number that can be formed with the given digits.\n    \"\"\"\n    # Convert each digit to a string to facilitate sorting and joining\n    str_digits = map(str, digits)\n    \n    # Sort the digits in descending order to form the largest number\n    sorted_digits = sorted(str_digits, reverse=True)\n    \n    # Join the sorted digits to form the largest number as a string\n    largest_number_str = ''.join(sorted_digits)\n    \n    # Convert the result back to an integer\n    largest_number = int(largest_number_str)\n    \n    return largest_number", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/61": [{"task_id": "Mbpp/61", "solution": "def count_substrings(s):\n    \"\"\"\n    Count the number of substrings where the sum of digits equals the length of the substring.\n\n    Parameters:\n    s (str): The input string consisting of digits.\n\n    Returns:\n    int: The count of substrings meeting the criteria.\n    \"\"\"\n    count = 0\n    n = len(s)\n    \n    # Iterate over all possible starting points of substrings\n    for start in range(n):\n        sum_digits = 0\n        \n        # Iterate over all possible ending points of substrings starting from 'start'\n        for end in range(start, n):\n            # Convert the current character to an integer and add to sum_digits\n            sum_digits += int(s[end])\n            \n            # Calculate the length of the current substring\n            length = end - start + 1\n            \n            # Check if the sum of digits equals the length of the substring\n            if sum_digits == length:\n                count += 1\n    \n    return count\n\n# Test the function with the provided test case\nassert count_substrings('112112') == 6\n\n# Additional test cases\nprint(count_substrings('123'))  # Expected output: 3 (substrings: '1', '2', '3')\nprint(count_substrings('111'))  # Expected output: 6 (substrings: '1', '1', '1', '11', '11', '111')\nprint(count_substrings('000'))  # Expected output: 0 (no valid substrings)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/59": [{"task_id": "Mbpp/59", "solution": "def nth_octagonal_number(n):\n    \"\"\"\n    Calculate the nth octagonal number using the formula:\n    O_n = n * (3n - 2)\n    \n    :param n: The position of the octagonal number to find\n    :return: The nth octagonal number\n    \"\"\"\n    return n * (3 * n - 2)\n\n# Test the function with the provided assertion\nassert nth_octagonal_number(5) == 65\n\n# Example usage\nif __name__ == \"__main__\":\n    # Test the function with a few values\n    for i in range(1, 6):\n        print(f\"The {i}th octagonal number is: {nth_octagonal_number(i)}\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/62": [{"task_id": "Mbpp/62", "solution": "def smallest_num(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns the smallest number in the list.\n    \n    :param numbers: List of integers\n    :return: The smallest integer in the list\n    \"\"\"\n    # Check if the list is empty and raise an error if it is\n    if not numbers:\n        raise ValueError(\"The list is empty, cannot determine the smallest number.\")\n    \n    # Initialize the smallest number with the first element of the list\n    smallest = numbers[0]\n    \n    # Iterate through the list to find the smallest number\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    \n    return smallest", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/63": [{"task_id": "Mbpp/63", "solution": "def max_difference(tuple_list):\n    \"\"\"\n    This function takes a list of tuples and returns the maximum difference\n    between the elements of any tuple in the list.\n\n    :param tuple_list: List of tuples, where each tuple contains two integers\n    :return: The maximum difference between the two integers in any tuple\n    \"\"\"\n    # Initialize the maximum difference to a very small number\n    max_diff = float('-inf')\n    \n    # Iterate over each tuple in the list\n    for a, b in tuple_list:\n        # Calculate the absolute difference between the two elements of the tuple\n        diff = abs(a - b)\n        # Update max_diff if the current difference is greater\n        if diff > max_diff:\n            max_diff = diff\n    \n    return max_diff", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/64": [{"task_id": "Mbpp/64", "solution": "def subject_marks(marks):\n    \"\"\"\n    Sorts a list of tuples based on the second value of each tuple.\n\n    Parameters:\n    marks (list of tuples): A list where each tuple contains a subject and its corresponding mark.\n\n    Returns:\n    list of tuples: The list sorted in ascending order based on the second value of each tuple.\n    \"\"\"\n    # Sort the list of tuples using the second element of each tuple as the key\n    sorted_marks = sorted(marks, key=lambda x: x[1])\n    return sorted_marks", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/65": [{"task_id": "Mbpp/65", "solution": "def recursive_list_sum(lst):\n    \"\"\"\n    This function takes a nested list and returns the sum of all its elements.\n    It handles lists that contain other lists (nested lists) by recursively summing\n    the elements of each sublist.\n\n    :param lst: A list which may contain integers and other lists\n    :return: The sum of all integers in the list, including those in nested lists\n    \"\"\"\n    total = 0\n    for element in lst:\n        if isinstance(element, list):\n            # If the element is a list, recursively call the function\n            total += recursive_list_sum(element)\n        else:\n            # Otherwise, add the integer to the total\n            total += element\n    return total", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/66": [{"task_id": "Mbpp/66", "solution": "def pos_count(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns the count of positive numbers in the list.\n\n    :param numbers: List of integers\n    :return: Integer count of positive numbers\n    \"\"\"\n    # Initialize a counter for positive numbers\n    count = 0\n    \n    # Iterate through each number in the list\n    for num in numbers:\n        # Check if the number is positive\n        if num > 0:\n            # Increment the counter if the number is positive\n            count += 1\n    \n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/67": [{"task_id": "Mbpp/67", "solution": "def bell_number(n):\n    \"\"\"\n    Calculate the nth Bell number, which represents the number of ways to partition a set of n elements.\n    \n    Parameters:\n    n (int): The size of the set to partition.\n    \n    Returns:\n    int: The nth Bell number.\n    \"\"\"\n    # Create a 2D array to store Bell numbers\n    bell = [[0 for _ in range(n+1)] for _ in range(n+1)]\n    \n    # Base case: Bell(0) is 1\n    bell[0][0] = 1\n    \n    # Fill the Bell triangle\n    for i in range(1, n+1):\n        # Explicitly set the first value in the current row\n        bell[i][0] = bell[i-1][i-1]\n        \n        # Fill the rest of the current row\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    # The nth Bell number is the first element of the nth row\n    return bell[n][0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/68": [{"task_id": "Mbpp/68", "solution": "def is_Monotonic(array):\n    \"\"\"\n    Function to check if the given array is monotonic.\n    An array is considered monotonic if it is either entirely non-increasing or non-decreasing.\n\n    Parameters:\n    array (list): A list of integers.\n\n    Returns:\n    bool: True if the array is monotonic, False otherwise.\n    \"\"\"\n    if not array:\n        # An empty array is considered monotonic\n        return True\n\n    # Initialize flags for increasing and decreasing\n    is_increasing = True\n    is_decreasing = True\n\n    # Iterate through the array to check the monotonicity\n    for i in range(1, len(array)):\n        if array[i] > array[i - 1]:\n            is_decreasing = False\n        if array[i] < array[i - 1]:\n            is_increasing = False\n\n    # The array is monotonic if it is either entirely non-increasing or non-decreasing\n    return is_increasing or is_decreasing", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/69": [{"task_id": "Mbpp/69", "solution": "def is_sublist(main_list, sub_list):\n    \"\"\"\n    Check if sub_list is a contiguous sublist of main_list.\n\n    Parameters:\n    main_list (list): The list in which to search for the sublist.\n    sub_list (list): The sublist to search for.\n\n    Returns:\n    bool: True if sub_list is a contiguous sublist of main_list, False otherwise.\n    \"\"\"\n    # Get the lengths of the main list and the sublist\n    len_main = len(main_list)\n    len_sub = len(sub_list)\n\n    # Iterate over the main list to find the sublist\n    for i in range(len_main - len_sub + 1):\n        # Check if the slice of main_list starting at i matches sub_list\n        if main_list[i:i + len_sub] == sub_list:\n            return True\n\n    # If no match is found, return False\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/70": [{"task_id": "Mbpp/70", "solution": "def get_equal(tuples_list):\n    \"\"\"\n    This function checks if all tuples in the given list have the same length.\n\n    Parameters:\n    tuples_list (list of tuples): A list containing tuples to be checked.\n\n    Returns:\n    bool: True if all tuples have the same length, False otherwise.\n    \"\"\"\n    if not tuples_list:\n        # If the list is empty, we consider all tuples to have equal length by default.\n        return True\n\n    # Get the length of the first tuple\n    first_length = len(tuples_list[0])\n\n    # Check if all other tuples have the same length as the first one\n    for t in tuples_list:\n        if len(t) != first_length:\n            return False\n\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/71": [{"task_id": "Mbpp/71", "solution": "def comb_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the Comb Sort algorithm.\n    \n    Parameters:\n    arr (list): A list of elements to be sorted.\n    \n    Returns:\n    list: A new list containing the sorted elements.\n    \"\"\"\n    def get_next_gap(gap):\n        # Shrink factor of 1.3 is commonly used\n        gap = (gap * 10) // 13\n        if gap < 1:\n            return 1\n        return gap\n\n    n = len(arr)\n    gap = n\n    swapped = True\n\n    # Continue until the gap is 1 and the last pass did not cause a swap\n    while gap != 1 or swapped:\n        # Find the next gap\n        gap = get_next_gap(gap)\n        swapped = False\n\n        # Compare all elements with current gap\n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                # Swap arr[i] and arr[i + gap]\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                swapped = True\n\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/72": [{"task_id": "Mbpp/72", "solution": "def dif_Square(n):\n    \"\"\"\n    Check if a given number can be represented as the difference of two squares.\n    \n    A number n can be expressed as the difference of two squares if and only if n is not of the form 4k + 2 for any integer k.\n    This is because:\n    n = a^2 - b^2 = (a - b)(a + b)\n    For n to be of the form 4k + 2, both (a - b) and (a + b) would need to be even, which is not possible.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if n can be represented as the difference of two squares, False otherwise.\n    \"\"\"\n    # Check if n is of the form 4k + 2\n    return n % 4 != 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/74": [{"task_id": "Mbpp/74", "solution": "def is_samepatterns(values, patterns):\n    \"\"\"\n    Check if the sequence in 'values' follows the pattern given in 'patterns'.\n    \n    Parameters:\n    values (list): A list of elements to be checked against the pattern.\n    patterns (list): A list of pattern elements to be matched with 'values'.\n    \n    Returns:\n    bool: True if 'values' follows the same pattern as 'patterns', False otherwise.\n    \"\"\"\n    if len(values) != len(patterns):\n        return False\n    \n    # Create two dictionaries to map values to patterns and vice versa\n    value_to_pattern = {}\n    pattern_to_value = {}\n    \n    for value, pattern in zip(values, patterns):\n        # Check if the current value is already mapped to a different pattern\n        if value in value_to_pattern:\n            if value_to_pattern[value] != pattern:\n                return False\n        else:\n            value_to_pattern[value] = pattern\n        \n        # Check if the current pattern is already mapped to a different value\n        if pattern in pattern_to_value:\n            if pattern_to_value[pattern] != value:\n                return False\n        else:\n            pattern_to_value[pattern] = value\n    \n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["red", "red", "red", "red", "red", "red"], ["a", "b", "c", "a", "b", "c"]]]}], "Mbpp/75": [{"task_id": "Mbpp/75", "solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    This function takes a list of tuples and an integer k, and returns a list of tuples\n    where all elements in each tuple are divisible by k.\n\n    :param tuples_list: List of tuples containing integers\n    :param k: Integer by which divisibility is checked\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over each tuple in the list\n    for tup in tuples_list:\n        # Check if all elements in the tuple are divisible by k\n        if all(element % k == 0 for element in tup):\n            # If true, append the tuple to the result list\n            result.append(tup)\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/77": [{"task_id": "Mbpp/77", "solution": "def is_divisible_by_11(number):\n    \"\"\"\n    Determine if a given number is divisible by 11.\n\n    The rule for divisibility by 11 is:\n    - Take the alternating sum of the digits in the number.\n    - If the result is divisible by 11, then the original number is also divisible by 11.\n\n    Parameters:\n    number (int): The number to check for divisibility by 11.\n\n    Returns:\n    bool: True if the number is divisible by 11, False otherwise.\n    \"\"\"\n    # Convert the number to a string to easily access each digit\n    num_str = str(number)\n    \n    # Initialize the alternating sum\n    alternating_sum = 0\n    \n    # Iterate over the digits, alternating the sign\n    for i, digit in enumerate(num_str):\n        if i % 2 == 0:\n            alternating_sum += int(digit)\n        else:\n            alternating_sum -= int(digit)\n    \n    # Check if the alternating sum is divisible by 11\n    return alternating_sum % 11 == 0\n\n# Test the function with the provided test case\nassert is_divisible_by_11(12345) == False\n\n# Additional test cases\nprint(is_divisible_by_11(121))  # True, because 1 - 2 + 1 = 0, which is divisible by 11\nprint(is_divisible_by_11(123456789))  # False, alternating sum is not divisible by 11\nprint(is_divisible_by_11(11))  # True, because 1 - 1 = 0, which is divisible by 11\nprint(is_divisible_by_11(0))  # True, because 0 is divisible by 11", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/79": [{"task_id": "Mbpp/79", "solution": "def word_len(word):\n    \"\"\"\n    This function checks whether the length of the given word is odd or not.\n    \n    Parameters:\n    word (str): The word whose length is to be checked.\n    \n    Returns:\n    bool: True if the length of the word is odd, False otherwise.\n    \"\"\"\n    # Calculate the length of the word\n    length = len(word)\n    \n    # Check if the length is odd\n    return length % 2 != 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/80": [{"task_id": "Mbpp/80", "solution": "def tetrahedral_number(n):\n    \"\"\"\n    Calculate the nth tetrahedral number.\n\n    A tetrahedral number, T_n, is the sum of the first n triangular numbers.\n    It can also be calculated using the formula:\n    T_n = n * (n + 1) * (n + 2) / 6\n\n    Parameters:\n    n (int): The position of the tetrahedral number to find.\n\n    Returns:\n    int: The nth tetrahedral number.\n    \"\"\"\n    # Using the formula for the nth tetrahedral number\n    return n * (n + 1) * (n + 2) // 6", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/82": [{"task_id": "Mbpp/82", "solution": "import math\ndef volume_sphere(radius):\n    \"\"\"\n    Calculate the volume of a sphere given its radius.\n\n    Parameters:\n    radius (float): The radius of the sphere.\n\n    Returns:\n    float: The volume of the sphere.\n    \"\"\"\n    # Volume of a sphere formula: V = (4/3) * \u03c0 * r^3\n    volume = (4/3) * math.pi * radius**3\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/84": [{"task_id": "Mbpp/84", "solution": "def newman_conway_sequence(n):\n    \"\"\"\n    Calculate the nth number in the Newman-Conway sequence.\n    \n    The Newman-Conway sequence is defined as follows:\n    - P(1) = 1\n    - P(2) = 1\n    - For n > 2, P(n) = P(P(n - 1)) + P(n - P(n - 1))\n    \n    :param n: The position in the sequence (1-based index)\n    :return: The nth number in the Newman-Conway sequence\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    \n    # Base cases\n    if n == 1 or n == 2:\n        return 1\n    \n    # Initialize the sequence with base cases\n    sequence = [0, 1, 1]  # sequence[0] is a placeholder for 1-based index\n    \n    # Calculate the sequence up to the nth number\n    for i in range(3, n + 1):\n        next_value = sequence[sequence[i - 1]] + sequence[i - sequence[i - 1]]\n        sequence.append(next_value)\n    \n    return sequence[n]\n\n# Test the function with the provided assertion\nassert newman_conway_sequence(10) == 6\n\n# If the assertion passes, print a success message\nprint(\"The function works correctly for the test case.\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/85": [{"task_id": "Mbpp/85", "solution": "import math\ndef surfacearea_sphere(radius):\n    \"\"\"\n    Calculate the surface area of a sphere given its radius.\n\n    Parameters:\n    radius (float): The radius of the sphere.\n\n    Returns:\n    float: The surface area of the sphere.\n    \"\"\"\n    # Surface area of a sphere formula: 4 * \u03c0 * r^2\n    surface_area = 4 * math.pi * radius ** 2\n    return surface_area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/86": [{"task_id": "Mbpp/86", "solution": "def centered_hexagonal_number(n):\n    \"\"\"\n    Calculate the nth centered hexagonal number.\n\n    A centered hexagonal number is a centered figurate number that represents a hexagon\n    with a dot in the center and all other dots surrounding the center dot in a hexagonal lattice.\n\n    The formula for the nth centered hexagonal number is:\n    C_n = 3n(n - 1) + 1\n\n    Parameters:\n    n (int): The position of the centered hexagonal number to find.\n\n    Returns:\n    int: The nth centered hexagonal number.\n    \"\"\"\n    # Calculate the nth centered hexagonal number using the formula\n    return 3 * n * (n - 1) + 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/87": [{"task_id": "Mbpp/87", "solution": "def merge_dictionaries_three(dict1, dict2, dict3):\n    \"\"\"\n    Merges three dictionaries into a single dictionary.\n    If there are duplicate keys, the value from the last dictionary with that key is used.\n    \n    Parameters:\n    dict1 (dict): The first dictionary.\n    dict2 (dict): The second dictionary.\n    dict3 (dict): The third dictionary.\n    \n    Returns:\n    dict: A merged dictionary containing all key-value pairs from the three dictionaries.\n    \"\"\"\n    # Start with an empty dictionary\n    merged_dict = {}\n    \n    # Update the merged dictionary with each of the input dictionaries\n    # The order of updates ensures that the last dictionary's values are used in case of key conflicts\n    merged_dict.update(dict1)\n    merged_dict.update(dict2)\n    merged_dict.update(dict3)\n    \n    return merged_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/88": [{"task_id": "Mbpp/88", "solution": "def freq_count(lst):\n    \"\"\"\n    Calculate the frequency of each element in the list and return it as a dictionary.\n\n    Parameters:\n    lst (list): A list of elements for which the frequency count is to be calculated.\n\n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency_dict = {}\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # If the element is already in the dictionary, increment its count\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            frequency_dict[element] = 1\n    \n    return frequency_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/89": [{"task_id": "Mbpp/89", "solution": "def closest_num(n):\n    \"\"\"\n    This function returns the closest smaller number than the given number n.\n    If n is an integer, the closest smaller number is simply n - 1.\n    \n    Parameters:\n    n (int): The number for which we want to find the closest smaller number.\n    \n    Returns:\n    int: The closest smaller number than n.\n    \"\"\"\n    # The closest smaller number than n is n - 1\n    return n - 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/90": [{"task_id": "Mbpp/90", "solution": "def len_log(words):\n    \"\"\"\n    This function takes a list of words and returns the length of the longest word.\n    \n    :param words: List of strings\n    :return: Integer representing the length of the longest word\n    \"\"\"\n    # Initialize a variable to keep track of the maximum length found\n    max_length = 0\n    \n    # Iterate over each word in the list\n    for word in words:\n        # Update max_length if the current word's length is greater\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/91": [{"task_id": "Mbpp/91", "solution": "def find_substring(string_list, substring):\n    \"\"\"\n    This function checks if a given substring is present in any of the strings within a list.\n\n    Parameters:\n    string_list (list of str): The list of strings to search within.\n    substring (str): The substring to search for.\n\n    Returns:\n    bool: True if the substring is found in any of the strings, False otherwise.\n    \"\"\"\n    # Iterate over each string in the list\n    for string in string_list:\n        # Check if the substring is in the current string\n        if substring in string:\n            return True\n    # If the loop completes without finding the substring, return False\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/92": [{"task_id": "Mbpp/92", "solution": "def is_undulating(number):\n    \"\"\"\n    Check if a number is undulating.\n    \n    An undulating number is a number that has at least three digits and consists of two alternating digits.\n    For example, 1212121 is undulating because it alternates between 1 and 2.\n    \n    Parameters:\n    number (int): The number to check.\n    \n    Returns:\n    bool: True if the number is undulating, False otherwise.\n    \"\"\"\n    # Convert the number to a string to easily access each digit\n    num_str = str(number)\n    \n    # An undulating number must have at least three digits\n    if len(num_str) < 3:\n        return False\n    \n    # Extract the first two digits\n    first_digit = num_str[0]\n    second_digit = num_str[1]\n    \n    # Check if the first two digits are the same, which would disqualify it as undulating\n    if first_digit == second_digit:\n        return False\n    \n    # Check the alternating pattern\n    for i in range(2, len(num_str)):\n        # The current digit should match the digit two places before it\n        if num_str[i] != num_str[i - 2]:\n            return False\n    \n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[82]]}], "Mbpp/93": [{"task_id": "Mbpp/93", "solution": "def power(a, b):\n    \"\"\"\n    Calculate the value of 'a' raised to the power of 'b'.\n\n    Parameters:\n    a (int or float): The base number.\n    b (int): The exponent.\n\n    Returns:\n    int or float: The result of a raised to the power of b.\n    \"\"\"\n    # Using the built-in exponentiation operator '**' to calculate power\n    return a ** b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/94": [{"task_id": "Mbpp/94", "solution": "def index_minimum(tuples_list):\n    \"\"\"\n    This function takes a list of tuples and returns the first value of the tuple with the smallest second value.\n\n    :param tuples_list: List of tuples, where each tuple contains a string and an integer.\n    :return: The first value (string) of the tuple with the smallest second value (integer).\n    \"\"\"\n    # Check if the list is empty\n    if not tuples_list:\n        return None\n\n    # Initialize the minimum tuple with the first element of the list\n    min_tuple = tuples_list[0]\n\n    # Iterate over the list to find the tuple with the smallest second value\n    for current_tuple in tuples_list:\n        # Compare the second value of the current tuple with the minimum found so far\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/95": [{"task_id": "Mbpp/95", "solution": "def Find_Min_Length(list_of_lists):\n    \"\"\"\n    This function takes a list of lists as input and returns the length of the smallest list.\n    \n    Parameters:\n    list_of_lists (list): A list containing multiple lists.\n    \n    Returns:\n    int: The length of the smallest list in the list of lists.\n    \"\"\"\n    # Check if the input is empty, return 0 as there are no lists to compare\n    if not list_of_lists:\n        return 0\n    \n    # Initialize min_length with a large number\n    min_length = float('inf')\n    \n    # Iterate over each list in the list of lists\n    for lst in list_of_lists:\n        # Update min_length if the current list's length is smaller\n        if len(lst) < min_length:\n            min_length = len(lst)\n    \n    return min_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/97": [{"task_id": "Mbpp/97", "solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    This function takes a list of lists, flattens it, and returns a dictionary\n    with the frequency of each element in the flattened list.\n\n    :param list_of_lists: List of lists containing integers\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    from collections import defaultdict\n\n    # Initialize a default dictionary to store frequencies\n    frequency_dict = defaultdict(int)\n\n    # Iterate over each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Iterate over each element in the sublist\n        for element in sublist:\n            # Increment the count of the element in the dictionary\n            frequency_dict[element] += 1\n\n    # Convert defaultdict to a regular dictionary before returning\n    return dict(frequency_dict)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/96": [{"task_id": "Mbpp/96", "solution": "def divisor(n):\n    \"\"\"\n    This function calculates the number of divisors of a given integer n.\n\n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n\n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    # Initialize a counter for the number of divisors\n    count = 0\n    \n    # Iterate over all numbers from 1 to n\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the count\n        if n % i == 0:\n            count += 1\n    \n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/98": [{"task_id": "Mbpp/98", "solution": "def multiply_num(numbers):\n    \"\"\"\n    Multiplies all the numbers in the list and divides the result by the length of the list.\n\n    :param numbers: A list or tuple of numbers\n    :return: The result of the multiplication divided by the length of the list\n    \"\"\"\n    # Import the math module for the isclose function\n    import math\n\n    # Initialize the product to 1 (multiplicative identity)\n    product = 1\n\n    # Iterate over each number in the list and multiply it to the product\n    for number in numbers:\n        product *= number\n\n    # Calculate the result by dividing the product by the length of the list\n    result = product / len(numbers)\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/99": [{"task_id": "Mbpp/99", "solution": "def decimal_to_binary(n):\n    \"\"\"\n    Convert a decimal number to its binary equivalent as a string with no leading zeros.\n\n    Parameters:\n    n (int): The decimal number to convert.\n\n    Returns:\n    str: The binary representation of the number as a string.\n    \"\"\"\n    # Handle the special case where the number is zero\n    if n == 0:\n        return '0'\n    \n    # Initialize an empty string to store the binary representation\n    binary_str = ''\n    \n    # Convert the decimal number to binary\n    while n > 0:\n        # Get the remainder when n is divided by 2 (either 0 or 1)\n        remainder = n % 2\n        # Prepend the remainder to the binary string\n        binary_str = str(remainder) + binary_str\n        # Update n to be the quotient of n divided by 2\n        n = n // 2\n    \n    return binary_str", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-5]]}], "Mbpp/101": [{"task_id": "Mbpp/101", "solution": "def kth_element(arr, k):\n    \"\"\"\n    Returns the kth element from the array using 1-based indexing.\n    \n    Parameters:\n    arr (list): The list of elements.\n    k (int): The 1-based index of the element to retrieve.\n    \n    Returns:\n    The element at the kth position in the array.\n    \n    Raises:\n    IndexError: If k is out of the bounds of the array.\n    \"\"\"\n    # Convert 1-based index to 0-based index for Python list access\n    index = k - 1\n    \n    # Check if the index is within the bounds of the array\n    if index < 0 or index >= len(arr):\n        raise IndexError(\"Index out of bounds\")\n    \n    return arr[index]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/100": [{"task_id": "Mbpp/100", "solution": "def next_smallest_palindrome(n):\n    \"\"\"\n    Find the next smallest palindrome greater than the given integer n.\n\n    Parameters:\n    n (int): The integer for which to find the next smallest palindrome.\n\n    Returns:\n    int: The next smallest palindrome greater than n.\n    \"\"\"\n    def is_palindrome(num):\n        \"\"\"Check if a number is a palindrome.\"\"\"\n        return str(num) == str(num)[::-1]\n\n    # Start checking from the next number\n    n += 1\n    while not is_palindrome(n):\n        n += 1\n\n    return n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/102": [{"task_id": "Mbpp/102", "solution": "def snake_to_camel(snake_str):\n    \"\"\"\n    Convert a snake_case string to CamelCase string.\n\n    Parameters:\n    snake_str (str): The snake_case string to convert.\n\n    Returns:\n    str: The converted CamelCase string.\n    \"\"\"\n    # Split the snake_case string by underscores\n    components = snake_str.split('_')\n    # Capitalize the first letter of each component and join them\n    camel_case_str = ''.join(x.capitalize() for x in components)\n    return camel_case_str", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["___python_program"]]}], "Mbpp/103": [{"task_id": "Mbpp/103", "solution": "def eulerian_num(n, m):\n    \"\"\"\n    Calculate the Eulerian number a(n, m).\n    \n    Eulerian numbers are defined by the recurrence relation:\n    a(n, m) = (n - m) * a(n - 1, m - 1) + (m + 1) * a(n - 1, m)\n    with initial conditions:\n    a(0, 0) = 1\n    a(n, 0) = 1 for n > 0\n    a(n, m) = 0 for m >= n\n    \n    Parameters:\n    n (int): The number of elements.\n    m (int): The number of ascents.\n    \n    Returns:\n    int: The Eulerian number a(n, m).\n    \"\"\"\n    # Create a 2D list to store the Eulerian numbers\n    eulerian = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Base cases\n    eulerian[0][0] = 1\n    for i in range(1, n + 1):\n        eulerian[i][0] = 1\n    \n    # Fill the table using the recurrence relation\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            eulerian[i][j] = (i - j) * eulerian[i - 1][j - 1] + (j + 1) * eulerian[i - 1][j]\n    \n    return eulerian[n][m]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[0, 0]]}], "Mbpp/105": [{"task_id": "Mbpp/105", "solution": "def count_true_booleans(boolean_list):\n    \"\"\"\n    Count the number of True values in a list of booleans.\n\n    Parameters:\n    boolean_list (list): A list containing boolean values (True or False).\n\n    Returns:\n    int: The count of True values in the list.\n    \"\"\"\n    # Use the sum function to count True values, as True is equivalent to 1 and False is equivalent to 0\n    return sum(boolean_list)\n\n# Test the function with the provided test case\nassert count_true_booleans([True, False, True]) == 2\n\n# Additional test cases\nassert count_true_booleans([False, False, False]) == 0\nassert count_true_booleans([True, True, True, True]) == 4\nassert count_true_booleans([]) == 0\nassert count_true_booleans([True, False, False, True, False, True]) == 3\n\nprint(\"All test cases passed.\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/104": [{"task_id": "Mbpp/104", "solution": "def sort_sublists(list_of_lists):\n    \"\"\"\n    Sorts each sublist of strings in a given list of lists.\n\n    Parameters:\n    list_of_lists (list of list of str): A list containing sublists of strings.\n\n    Returns:\n    list of list of str: A new list with each sublist sorted alphabetically.\n    \"\"\"\n    # Use list comprehension to sort each sublist\n    return [sorted(sublist) for sublist in list_of_lists]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/108": [{"task_id": "Mbpp/108", "solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n    \n    Parameters:\n    list1 (list): The first list of integers.\n    list2 (list): The second list of integers.\n    list3 (list): The third list of integers.\n    \n    Returns:\n    list: A sorted list containing all elements from the three input lists.\n    \"\"\"\n    # Combine all three lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    \n    return sorted_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/106": [{"task_id": "Mbpp/106", "solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the elements of the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list of elements to append.\n    tpl (tuple): The tuple to which the list elements will be appended.\n\n    Returns:\n    tuple: A new tuple with the elements of the list appended to the original tuple.\n    \"\"\"\n    # Convert the list to a tuple and concatenate it with the original tuple\n    return tpl + tuple(lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/109": [{"task_id": "Mbpp/109", "solution": "def odd_Equivalent(binary_string, rotations):\n    \"\"\"\n    This function takes a binary string and a number of rotations,\n    and returns the count of rotations that result in an odd integer value.\n    \n    :param binary_string: A string representing a binary number.\n    :param rotations: An integer representing the number of rotations to perform.\n    :return: The count of odd integer values from the rotations.\n    \"\"\"\n    odd_count = 0\n    length = len(binary_string)\n    \n    # Perform the rotations\n    for i in range(rotations):\n        # Rotate the string\n        rotated_string = binary_string[i % length:] + binary_string[:i % length]\n        \n        # Convert the rotated binary string to an integer\n        number = int(rotated_string, 2)\n        \n        # Check if the number is odd\n        if number % 2 == 1:\n            odd_count += 1\n    \n    return odd_count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["10000100110011", 5]]}], "Mbpp/111": [{"task_id": "Mbpp/111", "solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    This function takes a list of lists (nested lists) and returns a list of elements\n    that are common to all the nested lists.\n\n    :param nested_lists: List of lists containing integers\n    :return: List of integers that are common to all nested lists\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Start with the first list's elements as the initial set of common elements\n    common_elements = set(nested_lists[0])\n\n    # Intersect with each subsequent list to find common elements\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    # Return the common elements as a list\n    return list(common_elements)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/113": [{"task_id": "Mbpp/113", "solution": "def check_integer(s):\n    \"\"\"\n    This function checks if the given string represents an integer.\n    \n    Parameters:\n    s (str): The string to check.\n    \n    Returns:\n    bool: True if the string represents an integer, False otherwise.\n    \"\"\"\n    # Strip any leading or trailing whitespace\n    s = s.strip()\n    \n    # Check if the string is empty after stripping\n    if not s:\n        return False\n    \n    # Check if the string is a valid integer\n    # This handles optional leading '+' or '-' and checks if the rest are digits\n    if s[0] in ('+', '-') and s[1:].isdigit():\n        return True\n    elif s.isdigit():\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/116": [{"task_id": "Mbpp/116", "solution": "def tuple_to_int(tup):\n    \"\"\"\n    Convert a tuple of positive integers into a single integer.\n\n    Parameters:\n    tup (tuple): A tuple containing positive integers.\n\n    Returns:\n    int: A single integer formed by concatenating the elements of the tuple.\n    \"\"\"\n    # Convert each integer in the tuple to a string and join them together\n    # Then convert the resulting string back to an integer\n    return int(''.join(map(str, tup)))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/118": [{"task_id": "Mbpp/118", "solution": "def string_to_list(input_string):\n    \"\"\"\n    Convert a string to a list of strings split on the space character.\n\n    Parameters:\n    input_string (str): The string to be split.\n\n    Returns:\n    list: A list of substrings split by spaces.\n    \"\"\"\n    # Use the split method to divide the string by spaces\n    return input_string.split()", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/119": [{"task_id": "Mbpp/119", "solution": "def search(arr):\n    \"\"\"\n    This function finds the element that appears only once in a sorted array where every other element appears exactly twice.\n    \n    :param arr: List[int] - A sorted list of integers where every element except one appears twice.\n    :return: int - The element that appears only once.\n    \"\"\"\n    # Initialize the low and high pointers for binary search\n    low, high = 0, len(arr) - 1\n    \n    # Binary search approach\n    while low < high:\n        mid = low + (high - low) // 2\n        \n        # Check if mid is even or odd\n        if mid % 2 == 0:\n            # If mid is even, the single element is on the right if arr[mid] == arr[mid + 1]\n            if arr[mid] == arr[mid + 1]:\n                low = mid + 2\n            else:\n                high = mid\n        else:\n            # If mid is odd, the single element is on the right if arr[mid] == arr[mid - 1]\n            if arr[mid] == arr[mid - 1]:\n                low = mid + 1\n            else:\n                high = mid\n    \n    # When low meets high, we have found the single element\n    return arr[low]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[]]]}], "Mbpp/120": [{"task_id": "Mbpp/120", "solution": "def max_product_tuple(pairs):\n    \"\"\"\n    This function takes a list of tuples, where each tuple contains two integers.\n    It calculates the absolute product of the numbers in each tuple and returns the maximum absolute product found.\n\n    :param pairs: List of tuples, where each tuple contains two integers\n    :return: Maximum absolute product of numbers in any tuple\n    \"\"\"\n    max_product = 0  # Initialize the maximum product to zero\n\n    for a, b in pairs:\n        # Calculate the absolute product of the current tuple\n        product = abs(a * b)\n        # Update the maximum product if the current product is greater\n        if product > max_product:\n            max_product = product\n\n    return max_product", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/124": [{"task_id": "Mbpp/124", "solution": "import math\ndef angle_complex(z):\n    \"\"\"\n    Calculate the angle (argument) of a complex number.\n\n    Parameters:\n    z (complex): A complex number.\n\n    Returns:\n    float: The angle of the complex number in radians.\n    \"\"\"\n    return math.atan2(z.imag, z.real)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["0.0", "1j"]], "plus_fail_tests": [["0.0", "0j"]]}], "Mbpp/125": [{"task_id": "Mbpp/125", "solution": "def find_length(binary_string):\n    \"\"\"\n    This function finds the maximum difference between the number of 0s and number of 1s\n    in any sub-string of the given binary string.\n    \n    :param binary_string: A string consisting of '0's and '1's\n    :return: The maximum difference between the number of 0s and 1s in any sub-string\n    \"\"\"\n    # Initialize variables to track the current difference and the maximum difference found\n    max_diff = 0\n    current_diff = 0\n    \n    # Iterate over each character in the binary string\n    for char in binary_string:\n        # If the character is '0', increase the current difference\n        if char == '0':\n            current_diff += 1\n        # If the character is '1', decrease the current difference\n        else:\n            current_diff -= 1\n        \n        # Update the maximum difference if the current difference is greater\n        if current_diff > max_diff:\n            max_diff = current_diff\n        \n        # If the current difference becomes negative, reset it to zero\n        # This is because a negative difference would not contribute to a maximum positive difference\n        if current_diff < 0:\n            current_diff = 0\n    \n    return max_diff", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/126": [{"task_id": "Mbpp/126", "solution": "def sum_of_common_divisors(a, b):\n    \"\"\"\n    This function calculates the sum of all common divisors of two given numbers a and b.\n    \n    Parameters:\n    a (int): The first number.\n    b (int): The second number.\n    \n    Returns:\n    int: The sum of all common divisors of a and b.\n    \"\"\"\n    def gcd(x, y):\n        \"\"\"Helper function to calculate the greatest common divisor using Euclid's algorithm.\"\"\"\n        while y:\n            x, y = y, x % y\n        return x\n\n    def divisors(n):\n        \"\"\"Helper function to find all divisors of a given number n.\"\"\"\n        divs = set()\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divs.add(i)\n                divs.add(n // i)\n        return divs\n\n    # Find the greatest common divisor of a and b\n    greatest_common_divisor = gcd(a, b)\n    \n    # Find all divisors of the greatest common divisor\n    common_divisors = divisors(greatest_common_divisor)\n    \n    # Return the sum of these common divisors\n    return sum(common_divisors)\n\n# Test the function with the provided test case\nassert sum_of_common_divisors(10, 15) == 6\n\n# Additional test cases\nprint(sum_of_common_divisors(12, 18))  # Output should be 12 (1 + 2 + 3 + 6)\nprint(sum_of_common_divisors(100, 80)) # Output should be 217 (1 + 2 + 4 + 5 + 10 + 20 + 40 + 80 + 100)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/127": [{"task_id": "Mbpp/127", "solution": "def multiply_int(a, b):\n    \"\"\"\n    Multiplies two integers and returns the result.\n\n    Parameters:\n    a (int): The first integer.\n    b (int): The second integer.\n\n    Returns:\n    int: The product of the two integers.\n    \"\"\"\n    return a * b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/128": [{"task_id": "Mbpp/128", "solution": "def long_words(n, sentence):\n    \"\"\"\n    This function takes an integer n and a sentence (string) as input.\n    It returns a list of words from the sentence that are longer than n characters.\n    \n    :param n: Integer, the minimum length of words to be included in the result.\n    :param sentence: String, the sentence from which words are extracted.\n    :return: List of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Use a list comprehension to filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/129": [{"task_id": "Mbpp/129", "solution": "def magic_square_test(matrix):\n    \"\"\"\n    This function checks if a given square matrix is a magic square.\n    A magic square is a square matrix in which the sum of every row, column, and both main diagonals are the same.\n    \n    :param matrix: List of lists, where each inner list represents a row of the matrix.\n    :return: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the magic sum\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/130": [{"task_id": "Mbpp/130", "solution": "def max_occurrences(lst):\n    \"\"\"\n    This function takes a list as input and returns the item with the maximum frequency.\n    If there are multiple items with the same maximum frequency, it returns the first one encountered.\n    \"\"\"\n    from collections import Counter\n    \n    # Count the frequency of each item in the list\n    frequency = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/131": [{"task_id": "Mbpp/131", "solution": "def reverse_vowels(s: str) -> str:\n    \"\"\"\n    Reverse only the vowels in the input string s.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: The string with vowels reversed.\n    \"\"\"\n    # Define a set of vowels for quick lookup\n    vowels = set(\"aeiouAEIOU\")\n    \n    # Convert the string to a list to allow modification\n    s_list = list(s)\n    \n    # Initialize two pointers\n    left, right = 0, len(s) - 1\n    \n    # Use two-pointer technique to find vowels from both ends\n    while left < right:\n        # Move the left pointer until a vowel is found\n        while left < right and s_list[left] not in vowels:\n            left += 1\n        # Move the right pointer until a vowel is found\n        while left < right and s_list[right] not in vowels:\n            right -= 1\n        \n        # Swap the vowels\n        s_list[left], s_list[right] = s_list[right], s_list[left]\n        \n        # Move both pointers towards the center\n        left += 1\n        right -= 1\n    \n    # Join the list back into a string\n    return ''.join(s_list)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/132": [{"task_id": "Mbpp/132", "solution": "def tup_string(tup):\n    \"\"\"\n    Convert a tuple of characters into a string.\n\n    Parameters:\n    tup (tuple): A tuple containing characters.\n\n    Returns:\n    str: A string formed by concatenating the characters in the tuple.\n    \"\"\"\n    # Use the join method to concatenate the tuple elements into a string\n    return ''.join(tup)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/133": [{"task_id": "Mbpp/133", "solution": "def sum_negativenum(numbers):\n    \"\"\"\n    Calculate the sum of the negative numbers in a given list of numbers.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The sum of the negative numbers in the list.\n    \"\"\"\n    # Initialize sum to 0\n    negative_sum = 0\n    \n    # Iterate through each number in the list\n    for num in numbers:\n        # Check if the number is negative\n        if num < 0:\n            # Add the negative number to the sum\n            negative_sum += num\n    \n    return negative_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/135": [{"task_id": "Mbpp/135", "solution": "def hexagonal_num(n):\n    \"\"\"\n    Calculate the nth hexagonal number using the formula:\n    H_n = n * (2n - 1)\n    \n    Parameters:\n    n (int): The position of the hexagonal number to find.\n    \n    Returns:\n    int: The nth hexagonal number.\n    \"\"\"\n    # Calculate the nth hexagonal number\n    return n * (2 * n - 1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/137": [{"task_id": "Mbpp/137", "solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    This function calculates the ratio of zeroes to non-zeroes in an array of integers.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    float: The ratio of zeroes to non-zeroes.\n    \"\"\"\n    # Count the number of zeroes in the array\n    zeroes = arr.count(0)\n    \n    # Count the number of non-zeroes in the array\n    non_zeroes = len(arr) - zeroes\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    # Handle the case where there are no non-zeroes to avoid division by zero\n    if non_zeroes == 0:\n        return float('inf')  # or return 0 if you prefer to handle it differently\n    \n    ratio = zeroes / non_zeroes\n    return ratio", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/123": [{"task_id": "Mbpp/123", "solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    total = 1  # 1 is a proper divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Calculate the sum of all amicable numbers up to a specified limit.\"\"\"\n    amicable_sum = 0\n    for num in range(2, limit + 1):\n        sum_div = sum_of_divisors(num)\n        if sum_div != num and sum_of_divisors(sum_div) == num:\n            amicable_sum += num\n    return amicable_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/138": [{"task_id": "Mbpp/138", "solution": "def is_Sum_Of_Powers_Of_Two(n):\n    \"\"\"\n    Check if a given number can be represented as a sum of non-zero powers of 2.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number can be represented as a sum of non-zero powers of 2, False otherwise.\n    \"\"\"\n    # A number can be represented as a sum of non-zero powers of 2 if its binary representation\n    # consists only of 1s and 0s. This is because each 1 in the binary representation corresponds\n    # to a power of 2 that contributes to the sum.\n    \n    # If n is less than or equal to 0, it cannot be represented as a sum of non-zero powers of 2.\n    if n <= 0:\n        return False\n    \n    # Check if n is a sum of non-zero powers of 2 by examining its binary representation.\n    # If n is a sum of non-zero powers of 2, its binary representation will have no zeroes\n    # between the 1s (e.g., 1010 is valid because it represents 2^3 + 2^1).\n    # We can simply check if n is positive and return True, as any positive integer can be\n    # represented as a sum of distinct powers of 2.\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[7]], "plus_fail_tests": [[123456789]]}], "Mbpp/139": [{"task_id": "Mbpp/139", "solution": "import math\ndef circle_circumference(radius):\n    \"\"\"\n    Calculate the circumference of a circle given its radius.\n\n    Parameters:\n    radius (float): The radius of the circle.\n\n    Returns:\n    float: The circumference of the circle.\n    \"\"\"\n    # The formula for the circumference of a circle is 2 * \u03c0 * radius\n    return 2 * math.pi * radius", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/140": [{"task_id": "Mbpp/140", "solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Parameters:\n    list_of_lists (list of lists/tuples): A list containing lists or tuples of numbers.\n\n    Returns:\n    set: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    result_set = set()\n    \n    # Iterate over each sublist/tuple in the list_of_lists\n    for sublist in list_of_lists:\n        # Update the result_set with elements from the current sublist/tuple\n        result_set.update(sublist)\n    \n    return result_set", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/141": [{"task_id": "Mbpp/141", "solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the Pancake Sort algorithm.\n    \n    Parameters:\n    arr (list): A list of integers to be sorted.\n    \n    Returns:\n    list: A sorted list of integers.\n    \"\"\"\n    def flip(sublist, k):\n        \"\"\"\n        Reverses the order of the first k elements of the sublist.\n        \n        Parameters:\n        sublist (list): The list to be flipped.\n        k (int): The number of elements from the start of the list to flip.\n        \"\"\"\n        start = 0\n        while start < k:\n            sublist[start], sublist[k] = sublist[k], sublist[start]\n            start += 1\n            k -= 1\n\n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0:size]\n        max_index = max(range(size), key=arr.__getitem__)\n        \n        # Move the maximum element to the end of the current array\n        if max_index != size - 1:\n            # Flip the maximum number to the front if it's not already there\n            flip(arr, max_index)\n            # Flip it to the end of the current array\n            flip(arr, size - 1)\n    \n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/142": [{"task_id": "Mbpp/142", "solution": "def count_samepair(list1, list2, list3):\n    \"\"\"\n    Count the number of items that are identical in the same position across three given lists.\n\n    Parameters:\n    list1, list2, list3 (list): Three lists of equal length to compare.\n\n    Returns:\n    int: The count of identical items in the same position across the three lists.\n    \"\"\"\n    # Initialize a counter for identical items\n    count = 0\n    \n    # Iterate over the lists using zip to pair elements at the same index\n    for item1, item2, item3 in zip(list1, list2, list3):\n        # Check if all three items are identical\n        if item1 == item2 == item3:\n            count += 1\n    \n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/145": [{"task_id": "Mbpp/145", "solution": "def max_Abs_Diff(arr):\n    \"\"\"\n    This function takes a tuple of integers and returns the maximum absolute difference\n    between any two elements in the array.\n\n    :param arr: Tuple of integers\n    :return: Integer representing the maximum absolute difference\n    \"\"\"\n    if not arr or len(arr) < 2:\n        # If the array is empty or has less than 2 elements, return 0\n        return 0\n\n    # Find the minimum and maximum elements in the array\n    min_element = min(arr)\n    max_element = max(arr)\n\n    # The maximum absolute difference will be between the min and max elements\n    max_diff = max_element - min_element\n\n    return max_diff", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/160": [{"task_id": "Mbpp/160", "solution": "def extended_gcd(a, b):\n    \"\"\"\n    Extended Euclidean Algorithm.\n    Returns a tuple (g, x, y) such that g = gcd(a, b) and ax + by = g.\n    \"\"\"\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, x, y = extended_gcd(b % a, a)\n        return (g, y - (b // a) * x, x)\ndef find_solution(a, b, n):\n    \"\"\"\n    Finds integers x and y such that ax + by = n.\n    Returns a tuple (x, y) or None if no solution exists.\n    \"\"\"\n    g, x, y = extended_gcd(a, b)\n    \n    # Check if n is divisible by the gcd of a and b\n    if n % g != 0:\n        return None\n    \n    # Scale the solution of ax + by = g to ax + by = n\n    x *= n // g\n    y *= n // g\n    \n    return (x, y)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2, 3, 7]], "plus_fail_tests": [[25, 10, 500]]}], "Mbpp/161": [{"task_id": "Mbpp/161", "solution": "def remove_elements(original_list, elements_to_remove):\n    \"\"\"\n    Removes all elements from original_list that are present in elements_to_remove.\n\n    Parameters:\n    original_list (list): The list from which elements need to be removed.\n    elements_to_remove (list): The list of elements that need to be removed from the original_list.\n\n    Returns:\n    list: A new list with the specified elements removed.\n    \"\"\"\n    # Convert elements_to_remove to a set for O(1) average time complexity lookups\n    elements_to_remove_set = set(elements_to_remove)\n    \n    # Use list comprehension to filter out elements present in elements_to_remove_set\n    result_list = [element for element in original_list if element not in elements_to_remove_set]\n    \n    return result_list", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, "apple", [1, 2], [3, 4], {"name": "John"}, 5.5], [2, "apple", [3, 4], {"name": "John"}, 5.5]]]}], "Mbpp/165": [{"task_id": "Mbpp/165", "solution": "def count_char_position(s):\n    \"\"\"\n    Count the number of characters in a string that occur at the same position\n    in the string as in the English alphabet (case insensitive).\n\n    Parameters:\n    s (str): The input string to be evaluated.\n\n    Returns:\n    int: The count of characters that match their position in the alphabet.\n    \"\"\"\n    # Convert the string to lowercase to handle case insensitivity\n    s = s.lower()\n    \n    # Initialize a counter for matching characters\n    count = 0\n    \n    # Iterate over the string with index\n    for index, char in enumerate(s):\n        # Calculate the position of the character in the alphabet (1-based index)\n        # ord('a') is 97, so subtract 96 to get 1-based index\n        alphabet_position = ord(char) - ord('a') + 1\n        \n        # Check if the character's position in the alphabet matches its position in the string\n        # Note: index is 0-based, so add 1 to compare with 1-based alphabet position\n        if alphabet_position == index + 1:\n            count += 1\n    \n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/166": [{"task_id": "Mbpp/166", "solution": "def find_even_pair(nums):\n    \"\"\"\n    This function counts the number of pairs of integers in a list that XOR to an even number.\n    \n    Parameters:\n    nums (list): A list of integers.\n    \n    Returns:\n    int: The number of pairs that XOR to an even number.\n    \"\"\"\n    # Initialize counters for even and odd numbers\n    even_count = 0\n    odd_count = 0\n    \n    # Count the number of even and odd numbers in the list\n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Calculate the number of pairs that XOR to an even number\n    # An XOR of two numbers is even if both numbers are even or both are odd\n    even_pairs = (even_count * (even_count - 1)) // 2  # Pairs of even numbers\n    odd_pairs = (odd_count * (odd_count - 1)) // 2    # Pairs of odd numbers\n    \n    # Total pairs that XOR to an even number\n    total_even_xor_pairs = even_pairs + odd_pairs\n    \n    return total_even_xor_pairs", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/167": [{"task_id": "Mbpp/167", "solution": "def next_power_of_2(n):\n    \"\"\"\n    Find the smallest power of 2 greater than or equal to n.\n    \n    Parameters:\n    n (int): The input number for which we need to find the smallest power of 2 greater than or equal to it.\n    \n    Returns:\n    int: The smallest power of 2 greater than or equal to n.\n    \"\"\"\n    if n < 1:\n        return 1\n    \n    # Start with the smallest power of 2\n    power = 1\n    \n    # Double the power until it is greater than or equal to n\n    while power < n:\n        power *= 2\n    \n    return power", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/168": [{"task_id": "Mbpp/168", "solution": "def frequency(lst, number):\n    \"\"\"\n    Count the number of occurrences of a number in a given list.\n\n    Parameters:\n    lst (list): The list in which to count occurrences.\n    number (int): The number to count in the list.\n\n    Returns:\n    int: The count of occurrences of the number in the list.\n    \"\"\"\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # If the element matches the number, increment the counter\n        if element == number:\n            count += 1\n    \n    # Return the final count\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/170": [{"task_id": "Mbpp/170", "solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Parameters:\n    numbers (list): A list of integers.\n    start_index (int): The starting index of the range (inclusive).\n    end_index (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0 or end_index >= len(numbers) or start_index > end_index:\n        raise ValueError(\"Invalid indices: start_index and end_index must be within the list bounds and start_index <= end_index.\")\n    \n    # Calculate the sum of the numbers within the specified range\n    return sum(numbers[start_index:end_index + 1])", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 7, 5]]}], "Mbpp/171": [{"task_id": "Mbpp/171", "solution": "def perimeter_pentagon(side_length):\n    \"\"\"\n    Calculate the perimeter of a regular pentagon.\n\n    Parameters:\n    side_length (float): The length of one side of the pentagon.\n\n    Returns:\n    float: The perimeter of the pentagon.\n    \"\"\"\n    # A regular pentagon has 5 equal sides\n    num_sides = 5\n    # Calculate the perimeter by multiplying the side length by the number of sides\n    perimeter = num_sides * side_length\n    return perimeter", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/172": [{"task_id": "Mbpp/172", "solution": "def count_occurance(input_string):\n    \"\"\"\n    Count the number of occurrences of the substring 'std' in the given input string.\n\n    Parameters:\n    input_string (str): The string in which to count occurrences of 'std'.\n\n    Returns:\n    int: The number of times 'std' occurs in the input string.\n    \"\"\"\n    # Use the str.count() method to count occurrences of 'std'\n    return input_string.count('std')", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/222": [{"task_id": "Mbpp/222", "solution": "def check_type(input_tuple):\n    \"\"\"\n    This function checks if all elements in the given tuple have the same data type.\n\n    Parameters:\n    input_tuple (tuple): The tuple to check.\n\n    Returns:\n    bool: True if all elements have the same data type, False otherwise.\n    \"\"\"\n    if not input_tuple:\n        # If the tuple is empty, we consider it as having the same data type\n        return True\n\n    # Get the type of the first element\n    first_type = type(input_tuple[0])\n\n    # Check if all elements have the same type as the first element\n    for element in input_tuple:\n        if type(element) != first_type:\n            return False\n\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/223": [{"task_id": "Mbpp/223", "solution": "def is_majority(arr, n, element):\n    \"\"\"\n    Determines if the given element is the majority element in the sorted array.\n    \n    Parameters:\n    arr (list): A sorted list of elements.\n    n (int): The length of the list.\n    element (int): The element to check for majority status.\n    \n    Returns:\n    bool: True if the element is the majority element, False otherwise.\n    \"\"\"\n    # Calculate the minimum number of occurrences needed for majority\n    majority_count = n // 2 + 1\n    \n    # Use binary search to find the first occurrence of the element\n    def find_first_occurrence(arr, n, element):\n        low, high = 0, n - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] < element:\n                low = mid + 1\n            elif arr[mid] > element:\n                high = mid - 1\n            else:\n                if mid == 0 or arr[mid - 1] != element:\n                    return mid\n                high = mid - 1\n        return -1\n    \n    # Find the first occurrence of the element\n    first_occurrence = find_first_occurrence(arr, n, element)\n    \n    # If the element is not found, it cannot be the majority\n    if first_occurrence == -1:\n        return False\n    \n    # Check if the element occurs more than n/2 times\n    if first_occurrence + majority_count - 1 < n and arr[first_occurrence + majority_count - 1] == element:\n        return True\n    \n    return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 1, 0]]}], "Mbpp/224": [{"task_id": "Mbpp/224", "solution": "def count_set_bits(n):\n    \"\"\"\n    Count the number of set bits (1s) in the binary representation of a given integer.\n\n    Parameters:\n    n (int): The integer whose set bits are to be counted.\n\n    Returns:\n    int: The number of set bits in the binary representation of the integer.\n    \"\"\"\n    count = 0\n    while n > 0:\n        # Check if the least significant bit is 1\n        count += n & 1\n        # Right shift the bits of n by 1\n        n >>= 1\n    return count\n\n# Test the function with the provided test case\nassert count_set_bits(2) == 1\n\n# Additional test cases\nassert count_set_bits(0) == 0  # No set bits in 0\nassert count_set_bits(1) == 1  # Binary: 1\nassert count_set_bits(3) == 2  # Binary: 11\nassert count_set_bits(7) == 3  # Binary: 111\nassert count_set_bits(15) == 4 # Binary: 1111\n\nprint(\"All test cases passed.\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/226": [{"task_id": "Mbpp/226", "solution": "def odd_values_string(s):\n    \"\"\"\n    This function takes a string `s` and returns a new string\n    containing only the characters from `s` that are at even indices.\n    \n    Parameters:\n    s (str): The input string from which characters at odd indices are removed.\n    \n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    # Use list comprehension to select characters at even indices\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 0])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/162": [{"task_id": "Mbpp/162", "solution": "def sum_series(n):\n    \"\"\"\n    Calculate the sum of the series (n - 2*i) from i=0 to n // 2.\n    \n    Parameters:\n    n (int): The starting integer of the series.\n    \n    Returns:\n    int: The sum of the series.\n    \"\"\"\n    total_sum = 0\n    i = 0\n    while n - 2 * i >= 0:\n        total_sum += n - 2 * i\n        i += 1\n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/227": [{"task_id": "Mbpp/227", "solution": "def min_of_three(a, b, c):\n    \"\"\"\n    Returns the minimum of three numbers.\n    \n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n    c (int or float): The third number.\n    \n    Returns:\n    int or float: The minimum of the three numbers.\n    \"\"\"\n    # Use the built-in min function to find the minimum of the three numbers\n    return min(a, b, c)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/230": [{"task_id": "Mbpp/230", "solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replaces all blank spaces in the input_string with the specified replacement_char.\n\n    Parameters:\n    input_string (str): The string in which spaces need to be replaced.\n    replacement_char (str): The character that will replace the spaces.\n\n    Returns:\n    str: The modified string with spaces replaced by the replacement_char.\n    \"\"\"\n    # Replace spaces with the specified character\n    return input_string.replace(' ', replacement_char)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/232": [{"task_id": "Mbpp/232", "solution": "def larg_nnum(lst, n):\n    \"\"\"\n    Returns a list containing the n largest items from the input list.\n\n    Parameters:\n    lst (list): The list from which to find the n largest items.\n    n (int): The number of largest items to return.\n\n    Returns:\n    list: A list containing the n largest items from the input list.\n    \"\"\"\n    # Sort the list in descending order and take the first n elements\n    return sorted(lst, reverse=True)[:n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/233": [{"task_id": "Mbpp/233", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/234": [{"task_id": "Mbpp/234", "solution": "def volume_cube(side_length):\n    \"\"\"\n    Calculate the volume of a cube given the side length.\n\n    Parameters:\n    side_length (float): The length of a side of the cube.\n\n    Returns:\n    float: The volume of the cube.\n    \"\"\"\n    # The volume of a cube is calculated as side_length^3\n    return side_length ** 3", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/235": [{"task_id": "Mbpp/235", "solution": "def even_bit_set_number(n):\n    \"\"\"\n    Set all even bits of the given number to 1.\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The number with all even bits set to 1.\n    \"\"\"\n    # Initialize a mask with all even bits set to 1\n    mask = 0\n    bit_position = 0\n    \n    # We assume a 32-bit integer for the mask\n    # You can adjust the range for different bit lengths\n    for i in range(0, 32, 2):\n        mask |= (1 << i)\n    \n    # Set the even bits of n using the mask\n    return n | mask", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[999999999]]}], "Mbpp/237": [{"task_id": "Mbpp/237", "solution": "def check_occurences(tuples_list):\n    \"\"\"\n    This function takes a list of tuples and returns a dictionary where each unique tuple is a key,\n    and the value is the number of times that tuple (or its reverse) appears in the list.\n    \n    Args:\n    tuples_list (list of tuples): A list containing tuples of integers.\n    \n    Returns:\n    dict: A dictionary with tuples as keys and their occurrence counts as values.\n    \"\"\"\n    # Dictionary to store the count of each unique tuple\n    occurrences = {}\n    \n    for t in tuples_list:\n        # Sort the tuple to handle (a, b) and (b, a) as the same\n        sorted_tuple = tuple(sorted(t))\n        \n        # Increment the count for the sorted tuple\n        if sorted_tuple in occurrences:\n            occurrences[sorted_tuple] += 1\n        else:\n            occurrences[sorted_tuple] = 1\n    \n    return occurrences", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/238": [{"task_id": "Mbpp/238", "solution": "def number_of_substrings(s: str) -> int:\n    \"\"\"\n    Calculate the number of non-empty substrings of a given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The number of non-empty substrings.\n    \"\"\"\n    # The number of non-empty substrings of a string of length n is given by the formula n * (n + 1) / 2\n    n = len(s)\n    return n * (n + 1) // 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/240": [{"task_id": "Mbpp/240", "solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements of list2.\n\n    Parameters:\n    list1 (list): The first list whose last element will be replaced.\n    list2 (list): The second list whose elements will replace the last element of list1.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by all elements of list2.\n    \"\"\"\n    # Check if list1 is not empty to avoid index errors\n    if not list1:\n        raise ValueError(\"The first list should not be empty.\")\n    \n    # Create a new list by slicing list1 up to the last element and appending list2\n    return list1[:-1] + list2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/242": [{"task_id": "Mbpp/242", "solution": "def count_charac(s):\n    \"\"\"\n    This function takes a string `s` as input and returns the total number of characters in the string.\n    \n    Parameters:\n    s (str): The input string whose characters are to be counted.\n    \n    Returns:\n    int: The total number of characters in the input string.\n    \"\"\"\n    # Return the length of the string using the built-in len() function\n    return len(s)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/244": [{"task_id": "Mbpp/244", "solution": "import math\ndef next_Perfect_Square(n):\n    \"\"\"\n    This function finds the next perfect square greater than a given number n.\n    \n    Parameters:\n    n (int): The number for which we want to find the next perfect square.\n    \n    Returns:\n    int: The next perfect square greater than n.\n    \"\"\"\n    # Calculate the square root of the given number\n    root = math.sqrt(n)\n    \n    # Find the next integer greater than the square root\n    next_root = math.ceil(root)\n    \n    # Calculate the next perfect square\n    next_perfect_square = next_root ** 2\n    \n    return next_perfect_square", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[9]], "plus_fail_tests": [[-5]]}], "Mbpp/245": [{"task_id": "Mbpp/245", "solution": "def max_sum_bitonic_subsequence(arr):\n    n = len(arr)\n    \n    # Initialize the increasing and decreasing subsequence sum arrays\n    inc = [0] * n\n    dec = [0] * n\n    \n    # Fill the increasing subsequence sum array\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n    \n    # Fill the decreasing subsequence sum array\n    for i in range(n-1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(n-1, i, -1):\n            if arr[j] < arr[i] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n    \n    # Find the maximum sum of bitonic subsequence\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n    \n    return max_sum\n\n# Test the function with the provided test case\nassert max_sum_bitonic_subsequence([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/247": [{"task_id": "Mbpp/247", "solution": "def lps(s: str) -> int:\n    \"\"\"\n    Function to find the length of the longest palindromic subsequence in the given string.\n    \n    :param s: Input string\n    :return: Length of the longest palindromic subsequence\n    \"\"\"\n    n = len(s)\n    \n    # Create a 2D array to store the length of longest palindromic subsequence\n    dp = [[0] * n for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Build the table. The outer loop is for substrings of increasing length\n    for cl in range(2, n + 1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if s[i] == s[j] and cl == 2:\n                dp[i][j] = 2\n            elif s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n    \n    # The length of the longest palindromic subseq is in dp[0][n-1]\n    return dp[0][n - 1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/250": [{"task_id": "Mbpp/250", "solution": "def count_X(tup, element):\n    \"\"\"\n    Counts the occurrences of a specified element in a given tuple.\n\n    Parameters:\n    tup (tuple): The tuple in which to count occurrences of the element.\n    element: The element to count within the tuple.\n\n    Returns:\n    int: The number of times the element appears in the tuple.\n    \"\"\"\n    # Use the count method of tuple to count occurrences of the element\n    return tup.count(element)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/251": [{"task_id": "Mbpp/251", "solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Parameters:\n    lst (list): The original list of elements.\n    element (any): The element to insert before each element in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each item in the original list\n    for item in lst:\n        # Append the element to be inserted\n        result.append(element)\n        # Append the current item from the original list\n        result.append(item)\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/252": [{"task_id": "Mbpp/252", "solution": "import cmath\ndef convert(complex_number):\n    \"\"\"\n    Convert a complex number to its polar coordinates representation.\n\n    Parameters:\n    complex_number (complex): A complex number to be converted.\n\n    Returns:\n    tuple: A tuple containing the magnitude and phase angle (in radians) of the complex number.\n    \"\"\"\n    # Use cmath.polar to convert the complex number to polar coordinates\n    magnitude, angle = cmath.polar(complex_number)\n    return (magnitude, angle)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/253": [{"task_id": "Mbpp/253", "solution": "def count_integer(lst):\n    \"\"\"\n    This function takes a list as input and returns the number of integer elements in the list.\n    \n    Parameters:\n    lst (list): The list containing various elements.\n    \n    Returns:\n    int: The count of integer elements in the list.\n    \"\"\"\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # Check if the element is an integer\n        if isinstance(element, int):\n            # Increment the counter if the element is an integer\n            count += 1\n    \n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/239": [{"task_id": "Mbpp/239", "solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    This function calculates the number of possible sequences of length n,\n    where each element is a positive integer, greater than or equal to twice\n    the previous element, and less than or equal to m.\n\n    :param m: The maximum value any element in the sequence can take.\n    :param n: The length of the sequence.\n    :return: The total number of valid sequences.\n    \"\"\"\n    # Initialize a memoization table where dp[i][j] represents the number of\n    # sequences of length j that end with the integer i.\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Base case: There is one sequence of length 1 for each number from 1 to m.\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n\n    # Fill the dp table\n    for length in range(2, n + 1):\n        for current in range(1, m + 1):\n            # Calculate the number of sequences of length `length` ending with `current`\n            for previous in range(1, current // 2 + 1):\n                dp[current][length] += dp[previous][length - 1]\n\n    # Sum up all sequences of length n\n    total_sequences = sum(dp[i][n] for i in range(1, m + 1))\n    return total_sequences", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/256": [{"task_id": "Mbpp/256", "solution": "def count_primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \n    Parameters:\n    n (int): A non-negative integer.\n    \n    Returns:\n    int: The count of prime numbers less than n.\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to track prime status of numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Implement the Sieve of Eratosthenes\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of primes\n    return sum(is_prime)\n\n# Test the function with the provided test case\nassert count_primes_nums(5) == 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/257": [{"task_id": "Mbpp/257", "solution": "def swap_numbers(a, b):\n    \"\"\"\n    This function takes two numbers as input and returns a tuple with the second number first and the first number second.\n\n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n\n    Returns:\n    tuple: A tuple with the second number first and the first number second.\n    \"\"\"\n    return (b, a)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/259": [{"task_id": "Mbpp/259", "solution": "def maximize_elements(tuple1, tuple2):\n    \"\"\"\n    This function takes two tuples of tuples as input and returns a new tuple of tuples.\n    Each element in the resulting tuple is formed by taking the maximum of the corresponding elements\n    from the input tuples.\n    \n    :param tuple1: A tuple of tuples, where each inner tuple contains two integers.\n    :param tuple2: A tuple of tuples, where each inner tuple contains two integers.\n    :return: A tuple of tuples, where each inner tuple contains the maximum of the corresponding elements\n             from the input tuples.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the pairs of tuples from both input tuples\n    for t1, t2 in zip(tuple1, tuple2):\n        # Create a new tuple with the maximum of corresponding elements from t1 and t2\n        max_tuple = (max(t1[0], t2[0]), max(t1[1], t2[1]))\n        # Append the new tuple to the result list\n        result.append(max_tuple)\n    \n    # Convert the result list back to a tuple of tuples and return\n    return tuple(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/255": [{"task_id": "Mbpp/255", "solution": "from itertools import product\ndef combinations_colors(elements, n):\n    \"\"\"\n    Generate all combinations (with repetition) of the elements of the list of length n.\n\n    :param elements: List of elements to combine\n    :param n: Length of each combination\n    :return: List of tuples, each representing a combination\n    \"\"\"\n    # Use itertools.product to generate combinations with repetition\n    return list(product(elements, repeat=n))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Red", "Green", "Blue"], 2]], "plus_fail_tests": [[["A", "B", "C", "D"], 4]]}], "Mbpp/260": [{"task_id": "Mbpp/260", "solution": "def newman_prime(n):\n    \"\"\"\n    Calculate the nth Newman\u2013Shanks\u2013Williams prime number.\n    \n    The Newman\u2013Shanks\u2013Williams (NSW) prime numbers are a sequence of prime numbers\n    that are also part of the sequence of numbers defined by the recurrence relation:\n    S(0) = 1, S(1) = 1, and S(n) = 2 * S(n-1) + S(n-2) for n > 1.\n    \n    This function finds the nth NSW prime number.\n    \n    :param n: The index of the NSW prime number to find (1-based index).\n    :return: The nth NSW prime number.\n    \"\"\"\n    def is_prime(num):\n        \"\"\"Check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    # Initialize the sequence\n    S = [1, 1]\n    index = 2  # Start from S(2)\n    count = 0  # Count of NSW primes found\n\n    while count < n:\n        # Calculate the next number in the sequence\n        next_S = 2 * S[index - 1] + S[index - 2]\n        S.append(next_S)\n        \n        # Check if it's a prime number\n        if is_prime(next_S):\n            count += 1\n            if count == n:\n                return next_S\n        \n        index += 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[100]]}], "Mbpp/261": [{"task_id": "Mbpp/261", "solution": "def division_elements(tuple1, tuple2):\n    \"\"\"\n    Perform element-wise division of two tuples.\n    \n    Parameters:\n    tuple1 (tuple): The first tuple containing dividend elements.\n    tuple2 (tuple): The second tuple containing divisor elements.\n    \n    Returns:\n    tuple: A tuple containing the result of element-wise division.\n    \n    Raises:\n    ValueError: If the tuples are not of the same length.\n    ZeroDivisionError: If any element in tuple2 is zero.\n    \"\"\"\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Both tuples must be of the same length.\")\n    \n    result = []\n    for a, b in zip(tuple1, tuple2):\n        if b == 0:\n            raise ZeroDivisionError(\"Division by zero encountered in tuple2.\")\n        result.append(a // b)  # Use integer division as per the example\n    \n    return tuple(result)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[5, 2, 3, 3], [5, 2, 3, 4]]]}], "Mbpp/262": [{"task_id": "Mbpp/262", "solution": "def split_two_parts(lst, L):\n    \"\"\"\n    Splits the given list into two parts where the length of the first part is L.\n    \n    Parameters:\n    lst (list): The list to be split.\n    L (int): The length of the first part of the list.\n    \n    Returns:\n    tuple: A tuple containing the two parts of the list.\n    \"\"\"\n    # Ensure L is not greater than the length of the list\n    if L > len(lst):\n        raise ValueError(\"L cannot be greater than the length of the list\")\n    \n    # Split the list into two parts\n    first_part = lst[:L]\n    second_part = lst[L:]\n    \n    return (first_part, second_part)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/264": [{"task_id": "Mbpp/264", "solution": "def dog_age(human_years):\n    \"\"\"\n    Calculate a dog's age in dog's years based on the given human years.\n    \n    The common rule of thumb is that the first two years of a dog's life count as 10.5 dog years each,\n    and every year after that counts as 4 dog years.\n    \n    Parameters:\n    human_years (int): The age of the dog in human years.\n    \n    Returns:\n    int: The age of the dog in dog years.\n    \"\"\"\n    if human_years <= 0:\n        return 0\n    elif human_years == 1:\n        return 10.5\n    elif human_years == 2:\n        return 21\n    else:\n        # First two years are 21 dog years, each subsequent year is 4 dog years\n        return 21 + (human_years - 2) * 4", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/265": [{"task_id": "Mbpp/265", "solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits the input list into n lists, where each list contains every nth element from the original list.\n    \n    Parameters:\n    input_list (list): The list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, where each sublist contains every nth element from the input list.\n    \"\"\"\n    # Initialize a list of empty lists to hold the result\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the input list and distribute elements into the result lists\n    for index, element in enumerate(input_list):\n        # Determine which sublist the current element should go into\n        result[index % n].append(element)\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/266": [{"task_id": "Mbpp/266", "solution": "def lateralsurface_cube(side_length):\n    \"\"\"\n    Calculate the lateral surface area of a cube.\n\n    The lateral surface area of a cube is the sum of the areas of the four vertical faces.\n    Each face of a cube is a square with an area of side_length^2.\n    Therefore, the lateral surface area is 4 times the area of one face.\n\n    Parameters:\n    side_length (float): The length of a side of the cube.\n\n    Returns:\n    float: The lateral surface area of the cube.\n    \"\"\"\n    # Calculate the area of one face of the cube\n    face_area = side_length ** 2\n    \n    # Calculate the lateral surface area (4 vertical faces)\n    lateral_surface_area = 4 * face_area\n    \n    return lateral_surface_area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/267": [{"task_id": "Mbpp/267", "solution": "def square_Sum(n):\n    \"\"\"\n    This function calculates the sum of the squares of the first n odd natural numbers.\n\n    Parameters:\n    n (int): The number of odd natural numbers to consider.\n\n    Returns:\n    int: The sum of the squares of the first n odd natural numbers.\n    \"\"\"\n    # Initialize the sum\n    sum_of_squares = 0\n    \n    # Initialize the first odd number\n    odd_number = 1\n    \n    # Loop through the first n odd numbers\n    for _ in range(n):\n        # Add the square of the current odd number to the sum\n        sum_of_squares += odd_number ** 2\n        # Move to the next odd number\n        odd_number += 2\n    \n    return sum_of_squares", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000000.0]]}], "Mbpp/268": [{"task_id": "Mbpp/268", "solution": "def find_star_num(n):\n    \"\"\"\n    Calculate the nth star number using the formula:\n    S_n = 6n(n - 1) + 1\n\n    Parameters:\n    n (int): The position of the star number to find.\n\n    Returns:\n    int: The nth star number.\n    \"\"\"\n    # Calculate the nth star number using the formula\n    star_number = 6 * n * (n - 1) + 1\n    return star_number", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/269": [{"task_id": "Mbpp/269", "solution": "def ascii_value(character):\n    \"\"\"\n    This function takes a single character as input and returns its ASCII value.\n    \n    :param character: A single character string whose ASCII value is to be found.\n    :return: The ASCII value of the input character.\n    \"\"\"\n    # Ensure the input is a single character\n    if len(character) != 1:\n        raise ValueError(\"Input must be a single character.\")\n    \n    # Return the ASCII value using the ord() function\n    return ord(character)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/270": [{"task_id": "Mbpp/270", "solution": "def sum_even_and_even_index(numbers):\n    \"\"\"\n    This function calculates the sum of even numbers that are located at even indices in the given list.\n    \n    Parameters:\n    numbers (list): A list of integers.\n    \n    Returns:\n    int: The sum of even numbers at even indices.\n    \"\"\"\n    # Initialize the sum to zero\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index in range(0, len(numbers), 2):  # Only consider even indices\n        if numbers[index] % 2 == 0:  # Check if the number at the even index is even\n            total_sum += numbers[index]  # Add it to the total sum\n    \n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/272": [{"task_id": "Mbpp/272", "solution": "def rear_extract(tuples_list):\n    \"\"\"\n    This function takes a list of tuples and returns a list containing the rear element of each tuple.\n\n    :param tuples_list: List of tuples\n    :return: List of rear elements from each tuple\n    \"\"\"\n    # Initialize an empty list to store the rear elements\n    rear_elements = []\n    \n    # Iterate over each tuple in the list\n    for tup in tuples_list:\n        # Append the last element of the tuple to the rear_elements list\n        rear_elements.append(tup[-1])\n    \n    return rear_elements", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/273": [{"task_id": "Mbpp/273", "solution": "def subtract_elements(tuple1, tuple2):\n    \"\"\"\n    Subtracts elements of the second tuple from the first tuple element-wise.\n    \n    Parameters:\n    tuple1 (tuple): The first tuple containing numbers.\n    tuple2 (tuple): The second tuple containing numbers.\n    \n    Returns:\n    tuple: A tuple containing the result of the element-wise subtraction.\n    \"\"\"\n    # Ensure both tuples are of the same length\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Both tuples must be of the same length.\")\n    \n    # Perform element-wise subtraction\n    result = tuple(a - b for a, b in zip(tuple1, tuple2))\n    \n    return result\n\n# Test the function with the provided test case\nassert subtract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)\n\n# Additional test cases\nassert subtract_elements((1, 2, 3), (1, 1, 1)) == (0, 1, 2)\nassert subtract_elements((0, 0, 0), (0, 0, 0)) == (0, 0, 0)\nassert subtract_elements((5, 10, 15), (5, 5, 5)) == (0, 5, 10)\n\nprint(\"All test cases passed.\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/274": [{"task_id": "Mbpp/274", "solution": "def even_binomial_Coeff_Sum(n):\n    \"\"\"\n    Calculate the sum of even index binomial coefficients for a given positive integer n.\n    \n    The binomial coefficients for a given n are the coefficients of the polynomial expansion of (1 + x)^n.\n    The even index binomial coefficients are those at indices 0, 2, 4, ..., etc.\n    \n    Parameters:\n    n (int): A positive integer representing the power of the binomial expansion.\n    \n    Returns:\n    int: The sum of the even index binomial coefficients.\n    \"\"\"\n    # Initialize the sum of even index binomial coefficients\n    even_sum = 0\n    \n    # Calculate the binomial coefficients using the formula C(n, k) = n! / (k! * (n-k)!)\n    # We only sum the coefficients where k is even\n    from math import comb\n    \n    for k in range(0, n + 1, 2):\n        even_sum += comb(n, k)\n    \n    return even_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/276": [{"task_id": "Mbpp/276", "solution": "import math\ndef volume_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder given its radius and height.\n\n    Parameters:\n    radius (float): The radius of the cylinder's base.\n    height (float): The height of the cylinder.\n\n    Returns:\n    float: The volume of the cylinder.\n    \"\"\"\n    # Volume of a cylinder formula: V = \u03c0 * r^2 * h\n    volume = math.pi * (radius ** 2) * height\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/277": [{"task_id": "Mbpp/277", "solution": "def dict_filter(input_dict, n):\n    \"\"\"\n    Filters the input dictionary to only include entries with values greater than or equal to n.\n\n    Parameters:\n    input_dict (dict): The dictionary to filter.\n    n (int): The threshold value.\n\n    Returns:\n    dict: A new dictionary with entries that have values >= n.\n    \"\"\"\n    # Use dictionary comprehension to filter the dictionary\n    filtered_dict = {key: value for key, value in input_dict.items() if value >= n}\n    return filtered_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/278": [{"task_id": "Mbpp/278", "solution": "def count_first_elements(tup):\n    \"\"\"\n    This function takes a tuple as input and returns the number of elements\n    that occur before the first tuple element within the given tuple.\n\n    Parameters:\n    tup (tuple): The input tuple which may contain various types of elements.\n\n    Returns:\n    int: The count of elements before the first tuple element in the input tuple.\n    \"\"\"\n    # Iterate over the elements of the tuple with their indices\n    for index, element in enumerate(tup):\n        # Check if the current element is a tuple\n        if isinstance(element, tuple):\n            # Return the index which is the count of elements before this tuple\n            return index\n    # If no tuple is found, return the length of the tuple\n    return len(tup)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6]]]}], "Mbpp/279": [{"task_id": "Mbpp/279", "solution": "def nth_decagonal_number(n):\n    \"\"\"\n    Calculate the nth decagonal number using the formula:\n    D_n = 4n^2 - 3n\n    \"\"\"\n    return 4 * n**2 - 3 * n\n\n# Test the function with the provided assertion\nassert nth_decagonal_number(3) == 27\n\n# Example usage\nif __name__ == \"__main__\":\n    # Calculate and print the first 10 decagonal numbers\n    for i in range(1, 11):\n        print(f\"The {i}th decagonal number is: {nth_decagonal_number(i)}\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/280": [{"task_id": "Mbpp/280", "solution": "def sequential_search(arr, element):\n    \"\"\"\n    Perform a sequential search on the array to find the element.\n\n    Parameters:\n    arr (list): The list in which to search for the element.\n    element: The element to search for in the list.\n\n    Returns:\n    tuple: A tuple containing a boolean indicating if the element is found,\n           and the index of the element in the list (or -1 if not found).\n    \"\"\"\n    # Iterate over the array with index\n    for index, current_element in enumerate(arr):\n        # Check if the current element matches the target element\n        if current_element == element:\n            return (True, index)\n    \n    # If the element is not found, return (False, -1)\n    return (False, -1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/281": [{"task_id": "Mbpp/281", "solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    # Convert the list to a set, which removes duplicates\n    unique_elements = set(lst)\n    \n    # Compare the length of the set with the original list\n    return len(unique_elements) == len(lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/282": [{"task_id": "Mbpp/282", "solution": "def sub_list(list1, list2):\n    \"\"\"\n    Subtracts elements of list2 from list1 element-wise.\n    \n    Parameters:\n    list1 (list of int/float): The first list of numbers.\n    list2 (list of int/float): The second list of numbers.\n    \n    Returns:\n    list of int/float: A new list containing the result of element-wise subtraction.\n    \n    Raises:\n    ValueError: If the input lists are not of the same length.\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Both lists must have the same length.\")\n    \n    # Perform element-wise subtraction\n    result = [a - b for a, b in zip(list1, list2)]\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/283": [{"task_id": "Mbpp/283", "solution": "def validate(number):\n    \"\"\"\n    This function checks whether the frequency of each digit in the integer is less than or equal to the digit itself.\n    \n    Parameters:\n    number (int): The integer to be checked.\n    \n    Returns:\n    bool: True if the frequency of each digit is less than or equal to the digit itself, False otherwise.\n    \"\"\"\n    # Convert the number to a string to iterate over each digit\n    num_str = str(number)\n    \n    # Create a dictionary to count the frequency of each digit\n    digit_count = {}\n    \n    # Count the frequency of each digit\n    for digit in num_str:\n        if digit in digit_count:\n            digit_count[digit] += 1\n        else:\n            digit_count[digit] = 1\n    \n    # Check if the frequency of each digit is less than or equal to the digit itself\n    for digit, count in digit_count.items():\n        if count > int(digit):\n            return False\n    \n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/284": [{"task_id": "Mbpp/284", "solution": "def check_element(lst, element):\n    \"\"\"\n    This function checks whether all items in the list are equal to the given element.\n\n    Parameters:\n    lst (list): The list of items to check.\n    element: The element to compare against each item in the list.\n\n    Returns:\n    bool: True if all items in the list are equal to the element, False otherwise.\n    \"\"\"\n    # Iterate through each item in the list\n    for item in lst:\n        # If any item is not equal to the element, return False\n        if item != element:\n            return False\n    # If all items are equal to the element, return True\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/285": [{"task_id": "Mbpp/285", "solution": "import re\ndef text_match_two_three(text):\n    \"\"\"\n    This function checks if the input string contains the character 'a' \n    followed by exactly two or three 'b' characters.\n    \n    Parameters:\n    text (str): The input string to be checked.\n    \n    Returns:\n    bool: True if the pattern 'a' followed by two or three 'b's is found, False otherwise.\n    \"\"\"\n    # Define the regex pattern for 'a' followed by two or three 'b's\n    pattern = r'ab{2,3}'\n    \n    # Use re.search to find if the pattern exists in the text\n    if re.search(pattern, text):\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/286": [{"task_id": "Mbpp/286", "solution": "def max_sub_array_sum_repeated(arr, n, k):\n    \"\"\"\n    Find the largest sum of a contiguous subarray in the modified array\n    which is formed by repeating the given array k times.\n\n    :param arr: List[int] - The original array\n    :param n: int - The length of the original array\n    :param k: int - The number of times the array is repeated\n    :return: int - The largest sum of a contiguous subarray\n    \"\"\"\n    def kadane(arr):\n        \"\"\"Helper function to find the maximum subarray sum using Kadane's algorithm.\"\"\"\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    # Calculate the sum of the original array\n    total_sum = sum(arr)\n\n    # Use Kadane's algorithm to find the maximum subarray sum in one array\n    max_kadane = kadane(arr)\n\n    if k == 1:\n        # If the array is repeated only once, return the result of Kadane's algorithm\n        return max_kadane\n\n    # Find the maximum prefix sum and suffix sum\n    max_prefix_sum = max_suffix_sum = float('-inf')\n    current_prefix_sum = current_suffix_sum = 0\n\n    for i in range(n):\n        current_prefix_sum += arr[i]\n        max_prefix_sum = max(max_prefix_sum, current_prefix_sum)\n\n    for i in range(n-1, -1, -1):\n        current_suffix_sum += arr[i]\n        max_suffix_sum = max(max_suffix_sum, current_suffix_sum)\n\n    # Calculate the maximum sum for the case when the array is repeated\n    if total_sum > 0:\n        # If the total sum of the array is positive, consider the contribution of the middle arrays\n        max_sum = max(max_kadane, max_prefix_sum + max_suffix_sum + (k-2) * total_sum)\n    else:\n        # If the total sum is non-positive, only consider the prefix and suffix\n        max_sum = max(max_kadane, max_prefix_sum + max_suffix_sum)\n\n    return max_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/287": [{"task_id": "Mbpp/287", "solution": "def square_Sum(n):\n    \"\"\"\n    This function calculates the sum of squares of the first n even natural numbers.\n\n    Parameters:\n    n (int): The number of even natural numbers to consider.\n\n    Returns:\n    int: The sum of squares of the first n even natural numbers.\n    \"\"\"\n    # Initialize the sum to zero\n    sum_of_squares = 0\n    \n    # Loop through the first n even numbers\n    for i in range(1, n + 1):\n        even_number = 2 * i  # Calculate the i-th even number\n        sum_of_squares += even_number ** 2  # Add its square to the sum\n    \n    return sum_of_squares", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000000]]}], "Mbpp/290": [{"task_id": "Mbpp/290", "solution": "def max_length(list_of_lists):\n    \"\"\"\n    This function takes a list of lists as input and returns a tuple containing\n    the maximum length of the lists and one of the lists with that maximum length.\n    \n    Parameters:\n    list_of_lists (list of lists): A list containing multiple lists.\n    \n    Returns:\n    tuple: A tuple where the first element is the maximum length of the lists,\n           and the second element is one of the lists with that maximum length.\n    \"\"\"\n    # Initialize variables to track the maximum length and the corresponding list\n    max_len = 0\n    max_list = []\n\n    # Iterate over each list in the list of lists\n    for lst in list_of_lists:\n        # Check if the current list's length is greater than the current maximum length\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = lst\n\n    return max_len, max_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/292": [{"task_id": "Mbpp/292", "solution": "def find(dividend, divisor):\n    \"\"\"\n    This function returns the quotient of two numbers rounded down to the nearest integer.\n    \n    Parameters:\n    dividend (int): The number to be divided.\n    divisor (int): The number by which to divide.\n    \n    Returns:\n    int: The quotient rounded down to the nearest integer.\n    \"\"\"\n    # Use floor division to get the quotient rounded down\n    return dividend // divisor", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/293": [{"task_id": "Mbpp/293", "solution": "import math\ndef otherside_rightangle(a, b):\n    \"\"\"\n    Calculate the third side of a right-angled triangle given two sides.\n    \n    Parameters:\n    a (float): Length of the first side.\n    b (float): Length of the second side.\n    \n    Returns:\n    float: Length of the third side.\n    \"\"\"\n    # Determine which side is the hypotenuse\n    if a > b:\n        # a is the hypotenuse\n        third_side = math.sqrt(a**2 - b**2)\n    else:\n        # b is the hypotenuse\n        third_side = math.sqrt(b**2 - a**2)\n    \n    return third_side", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[7, 8]], "plus_fail_tests": [[2.5, 3.5]]}], "Mbpp/294": [{"task_id": "Mbpp/294", "solution": "def max_val(heterogeneous_list):\n    \"\"\"\n    This function takes a heterogeneous list as input and returns the maximum\n    numeric value found in the list. Non-numeric values are ignored.\n\n    :param heterogeneous_list: List containing elements of various data types\n    :return: Maximum numeric value in the list\n    \"\"\"\n    # Initialize a variable to store the maximum value found\n    max_value = None\n\n    # Iterate over each element in the list\n    for item in heterogeneous_list:\n        # Check if the item is an integer or a float\n        if isinstance(item, (int, float)):\n            # If max_value is None or the current item is greater than max_value, update max_value\n            if max_value is None or item > max_value:\n                max_value = item\n\n    # Return the maximum value found, or None if no numeric values were present\n    return max_value", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["3.14", false, 7.5]]]}], "Mbpp/296": [{"task_id": "Mbpp/296", "solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all the remaining elements in the left subarray\n            # (arr[i...mid]) are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid-i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n        \n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right)//2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0]*len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/297": [{"task_id": "Mbpp/297", "solution": "def flatten_list(nested_list):\n    \"\"\"\n    Flattens a nested list structure into a single list of elements.\n\n    Parameters:\n    nested_list (list): A list that may contain other lists as elements.\n\n    Returns:\n    list: A flattened list containing all the elements from the nested structure.\n    \"\"\"\n    # Initialize an empty list to store the flattened elements\n    flat_list = []\n\n    # Define a helper function to recursively flatten the list\n    def flatten(sublist):\n        for item in sublist:\n            if isinstance(item, list):\n                # If the item is a list, recursively flatten it\n                flatten(item)\n            else:\n                # If the item is not a list, append it to the flat_list\n                flat_list.append(item)\n\n    # Start the flattening process\n    flatten(nested_list)\n    return flat_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/299": [{"task_id": "Mbpp/299", "solution": "def max_aggregate(scores):\n    \"\"\"\n    Calculate the maximum aggregate score from a list of tuples.\n\n    Parameters:\n    scores (list of tuples): A list where each tuple contains a name (str) and a score (int).\n\n    Returns:\n    tuple: A tuple containing the name with the highest aggregate score and the score itself.\n    \"\"\"\n    # Dictionary to store the aggregate scores for each name\n    aggregate_scores = {}\n\n    # Iterate over each tuple in the list\n    for name, score in scores:\n        # If the name is already in the dictionary, add the score to the existing aggregate\n        if name in aggregate_scores:\n            aggregate_scores[name] += score\n        else:\n            # Otherwise, initialize the aggregate score for this name\n            aggregate_scores[name] = score\n\n    # Find the name with the maximum aggregate score\n    max_name = max(aggregate_scores, key=aggregate_scores.get)\n    max_score = aggregate_scores[max_name]\n\n    return (max_name, max_score)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/300": [{"task_id": "Mbpp/300", "solution": "import math\ndef count_binary_seq(n):\n    # Initialize a 2D list to store the number of ways to achieve a certain sum\n    # dp[i][j] will store the number of ways to achieve sum j with i bits\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Base case: There's one way to achieve sum 0 with 0 bits\n    dp[0][0] = 1\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for j in range(n + 1):\n            # If we don't include the current bit, the number of ways is the same as without this bit\n            dp[i][j] = dp[i - 1][j]\n            # If we include the current bit, add the number of ways to achieve the sum j-1 with i-1 bits\n            if j >= 1:\n                dp[i][j] += dp[i - 1][j - 1]\n    \n    # The result is the square of the number of ways to achieve sum n/2 with n bits\n    # because we need to match the sum of the first n bits with the last n bits\n    return dp[n][n // 2] ** 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1]], "plus_fail_tests": [[4]]}], "Mbpp/301": [{"task_id": "Mbpp/301", "solution": "def dict_depth(d):\n    \"\"\"\n    Recursively find the maximum depth of a dictionary.\n    \n    Parameters:\n    d (dict): The dictionary whose depth is to be calculated.\n    \n    Returns:\n    int: The maximum depth of the dictionary.\n    \"\"\"\n    if not isinstance(d, dict) or not d:\n        # If it's not a dictionary or it's an empty dictionary, depth is 1\n        return 1\n    else:\n        # Calculate the depth of each value in the dictionary\n        return 1 + max(dict_depth(value) for value in d.values())", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"a": 1, "b": {"c": "python"}}]], "plus_fail_tests": [[{"1": null, "2": {"3": [1, 2, 3, "four", {"five": []}]}}]]}], "Mbpp/305": [{"task_id": "Mbpp/305", "solution": "def start_withp(word_list):\n    # Initialize an empty list to store words starting with 'p'\n    p_words = []\n    \n    # Iterate over each string in the list\n    for sentence in word_list:\n        # Split the sentence into individual words\n        words = sentence.split()\n        # Check each word to see if it starts with 'p' or 'P'\n        for word in words:\n            if word.lower().startswith('p'):\n                # Add the word to the list if it starts with 'p'\n                p_words.append(word)\n                # If we have found two words, return them as a tuple\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    \n    # If less than two words are found, return a tuple with the found words\n    return tuple(p_words)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[]]]}], "Mbpp/306": [{"task_id": "Mbpp/306", "solution": "def max_sum_increasing_subseq(arr, n, i, k):\n    \"\"\"\n    Function to find the maximum sum of increasing subsequence from prefix until ith index\n    and also including a given kth element which is after i.\n    \n    :param arr: List of integers\n    :param n: Length of the list\n    :param i: Index up to which we consider the prefix\n    :param k: Index of the element to be included in the subsequence\n    :return: Maximum sum of the increasing subsequence\n    \"\"\"\n    # Initialize a list to store the maximum sum of increasing subsequence up to each index\n    max_sum = [0] * n\n    \n    # Calculate the maximum sum of increasing subsequences up to index i\n    for j in range(i + 1):\n        max_sum[j] = arr[j]\n        for m in range(j):\n            if arr[m] < arr[j]:\n                max_sum[j] = max(max_sum[j], max_sum[m] + arr[j])\n    \n    # Find the maximum sum of increasing subsequence up to index i\n    max_sum_i = max(max_sum[:i + 1])\n    \n    # Check if the kth element can be added to the subsequence\n    if arr[i] < arr[k]:\n        max_sum_i += arr[k]\n    \n    return max_sum_i", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 101, 2, 3, 100, 4, 5], 7, 4, 6]], "plus_fail_tests": [[[5, 2, 4, 1, 3, 6], 6, 1, 3]]}], "Mbpp/308": [{"task_id": "Mbpp/308", "solution": "def large_product(list1, list2, n):\n    \"\"\"\n    This function finds the specified number of largest products from two given lists,\n    selecting one factor from each list.\n\n    Parameters:\n    list1 (list): The first list of integers.\n    list2 (list): The second list of integers.\n    n (int): The number of largest products to return.\n\n    Returns:\n    list: A list containing the n largest products in descending order.\n    \"\"\"\n    # Create a list to store all possible products\n    products = []\n\n    # Calculate the product of each pair of elements from list1 and list2\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n\n    # Sort the products in descending order\n    products.sort(reverse=True)\n\n    # Return the first n products\n    return products[:n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/309": [{"task_id": "Mbpp/309", "solution": "def maximum(a, b):\n    \"\"\"\n    Returns the maximum of two numbers a and b.\n    \n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n    \n    Returns:\n    int or float: The maximum of the two numbers.\n    \"\"\"\n    # Use the built-in max function to determine the maximum\n    return max(a, b)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/310": [{"task_id": "Mbpp/310", "solution": "def string_to_tuple(s):\n    \"\"\"\n    Convert a given string to a tuple of characters.\n\n    Parameters:\n    s (str): The input string to be converted.\n\n    Returns:\n    tuple: A tuple containing each character of the input string.\n    \"\"\"\n    # Convert the string to a tuple by using the tuple() constructor\n    return tuple(s)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["python 3.0"]], "plus_fail_tests": [["hello   world"]]}], "Mbpp/311": [{"task_id": "Mbpp/311", "solution": "def set_left_most_unset_bit(n):\n    \"\"\"\n    This function takes an integer n and sets the leftmost unset (0) bit to 1.\n    It returns the modified integer.\n    \"\"\"\n    # Start with a mask of 1 (binary 0001)\n    mask = 1\n    \n    # Iterate over each bit position\n    while mask <= n:\n        # If the current bit is unset (0), set it and return the result\n        if (n & mask) == 0:\n            return n | mask\n        # Move the mask to the next bit position to the left\n        mask <<= 1\n    \n    # If all bits in n are set, the mask will be just beyond the highest set bit\n    # So, we set the next higher bit\n    return n | mask", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[255]]}], "Mbpp/312": [{"task_id": "Mbpp/312", "solution": "import math\ndef volume_cone(radius, height):\n    \"\"\"\n    Calculate the volume of a cone given its radius and height.\n\n    The formula for the volume of a cone is:\n    V = (1/3) * \u03c0 * r^2 * h\n    where r is the radius and h is the height of the cone.\n\n    Parameters:\n    radius (float): The radius of the base of the cone.\n    height (float): The height of the cone.\n\n    Returns:\n    float: The volume of the cone.\n    \"\"\"\n    # Calculate the volume using the formula\n    volume = (1/3) * math.pi * radius**2 * height\n    return volume", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/388": [{"task_id": "Mbpp/388", "solution": "def highest_power_of_2(n):\n    \"\"\"\n    This function finds the highest power of 2 that is less than or equal to the given number n.\n    \n    Parameters:\n    n (int): The number to compare against powers of 2.\n    \n    Returns:\n    int: The highest power of 2 less than or equal to n.\n    \"\"\"\n    # Start with the highest power of 2 as 1 (2^0)\n    power = 1\n    \n    # Double the power until it exceeds n\n    while power * 2 <= n:\n        power *= 2\n    \n    return power\n\n# Test the function with the provided test case\nassert highest_power_of_2(10) == 8\n\n# Additional test cases\nassert highest_power_of_2(1) == 1  # 2^0 = 1\nassert highest_power_of_2(2) == 2  # 2^1 = 2\nassert highest_power_of_2(15) == 8 # 2^3 = 8\nassert highest_power_of_2(16) == 16 # 2^4 = 16\nassert highest_power_of_2(31) == 16 # 2^4 = 16\nassert highest_power_of_2(32) == 32 # 2^5 = 32\n\nprint(\"All test cases passed.\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/389": [{"task_id": "Mbpp/389", "solution": "def find_lucas(n):\n    \"\"\"\n    Function to find the n-th Lucas number.\n    \n    The Lucas numbers are a sequence similar to the Fibonacci numbers, \n    except they start with 2 and 1. The sequence is defined as:\n    L(0) = 2\n    L(1) = 1\n    L(n) = L(n-1) + L(n-2) for n > 1\n    \n    Parameters:\n    n (int): The index of the Lucas number to find.\n    \n    Returns:\n    int: The n-th Lucas number.\n    \"\"\"\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # Initialize the first two Lucas numbers\n    prev, curr = 2, 1\n    \n    # Compute the Lucas number iteratively\n    for _ in range(2, n + 1):\n        prev, curr = curr, prev + curr\n    \n    return curr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/390": [{"task_id": "Mbpp/390", "solution": "def add_string(elements, format_string):\n    \"\"\"\n    Apply a given format string to all of the elements in a list.\n\n    Parameters:\n    elements (list): A list of elements to which the format string will be applied.\n    format_string (str): A format string that includes a placeholder for the element.\n\n    Returns:\n    list: A new list with each element formatted according to the format string.\n    \"\"\"\n    # Use a list comprehension to apply the format string to each element\n    return [format_string.format(element) for element in elements]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/391": [{"task_id": "Mbpp/391", "solution": "def convert_list_dictionary(ids, names, scores):\n    \"\"\"\n    Convert three lists into a list of nested dictionaries.\n    \n    Parameters:\n    ids (list): A list of unique identifiers.\n    names (list): A list of names corresponding to each identifier.\n    scores (list): A list of scores corresponding to each name.\n    \n    Returns:\n    list: A list of dictionaries where each dictionary contains an id as the key,\n          and a nested dictionary with the name as the key and the score as the value.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the zipped lists to create the nested dictionaries\n    for id, name, score in zip(ids, names, scores):\n        # Create a nested dictionary for each set of id, name, and score\n        nested_dict = {id: {name: score}}\n        # Append the nested dictionary to the result list\n        result.append(nested_dict)\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/392": [{"task_id": "Mbpp/392", "solution": "def get_max_sum(n, memo=None):\n    \"\"\"\n    Function to find the maximum sum possible using the given equation:\n    f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n    \n    Parameters:\n    n (int): The integer for which we want to find the maximum sum.\n    memo (dict): A dictionary to store previously computed results for memoization.\n    \n    Returns:\n    int: The maximum sum possible for the given n.\n    \"\"\"\n    # Initialize memoization dictionary if not provided\n    if memo is None:\n        memo = {}\n    \n    # Base case: if n is 0, the maximum sum is 0\n    if n == 0:\n        return 0\n    \n    # Check if the result is already computed and stored in memo\n    if n in memo:\n        return memo[n]\n    \n    # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n    sum_parts = (get_max_sum(n // 2, memo) +\n                 get_max_sum(n // 3, memo) +\n                 get_max_sum(n // 4, memo) +\n                 get_max_sum(n // 5, memo))\n    \n    # Calculate the maximum of the sum_parts and n\n    result = max(sum_parts, n)\n    \n    # Store the result in memo to avoid redundant calculations\n    memo[n] = result\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/394": [{"task_id": "Mbpp/394", "solution": "def check_distinct(input_tuple):\n    \"\"\"\n    This function checks if the given tuple contains no duplicates.\n    \n    Parameters:\n    input_tuple (tuple): The tuple to check for duplicates.\n    \n    Returns:\n    bool: True if the tuple contains no duplicates, False otherwise.\n    \"\"\"\n    # Convert the tuple to a set, which automatically removes duplicates\n    unique_elements = set(input_tuple)\n    \n    # Compare the length of the set with the original tuple\n    # If they are the same, there are no duplicates\n    return len(unique_elements) == len(input_tuple)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/395": [{"task_id": "Mbpp/395", "solution": "def first_non_repeating_character(s):\n    \"\"\"\n    This function finds the first non-repeated character in a given string.\n    If all characters are repeated, it returns None.\n\n    :param s: The input string to search for the first non-repeated character.\n    :return: The first non-repeated character or None if all characters are repeated.\n    \"\"\"\n    # Dictionary to store the count of each character\n    char_count = {}\n\n    # First pass: Count the occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Second pass: Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    # If no non-repeated character is found, return None\n    return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/271": [{"task_id": "Mbpp/271", "solution": "def even_Power_Sum(n):\n    \"\"\"\n    This function calculates the sum of the first n even natural numbers raised to the fifth power.\n\n    Parameters:\n    n (int): The number of even natural numbers to consider.\n\n    Returns:\n    int: The sum of the first n even natural numbers raised to the fifth power.\n    \"\"\"\n    # Initialize the sum\n    total_sum = 0\n    \n    # Loop through the first n even numbers\n    for i in range(1, n + 1):\n        even_number = 2 * i  # Calculate the i-th even number\n        total_sum += even_number ** 5  # Add its fifth power to the total sum\n    \n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/397": [{"task_id": "Mbpp/397", "solution": "def median_numbers(a, b, c):\n    \"\"\"\n    This function takes three numbers as input and returns the median of the three numbers.\n    The median is the middle value when the numbers are sorted in order.\n    \"\"\"\n    # Create a list of the numbers\n    numbers = [a, b, c]\n    \n    # Sort the list\n    numbers.sort()\n    \n    # Return the middle element, which is the median\n    return numbers[1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/404": [{"task_id": "Mbpp/404", "solution": "def minimum(a, b):\n    \"\"\"\n    Returns the minimum of two numbers a and b.\n    \n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n    \n    Returns:\n    int or float: The minimum of a and b.\n    \"\"\"\n    return a if a < b else b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/398": [{"task_id": "Mbpp/398", "solution": "def sum_of_digits(numbers):\n    \"\"\"\n    Computes the sum of digits of each number in the given list.\n\n    Parameters:\n    numbers (list of int): A list of non-negative integers.\n\n    Returns:\n    int: The sum of all digits of the numbers in the list.\n    \"\"\"\n    total_sum = 0\n    for number in numbers:\n        # Convert the number to a string to iterate over each digit\n        for digit in str(number):\n            # Convert the digit back to an integer and add to the total sum\n            total_sum += int(digit)\n    return total_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[10, 20, 4, 5, "b", 70, "a"]]]], "plus_fail_tests": [[[-10, 15, 0, -5, 2]]]}], "Mbpp/405": [{"task_id": "Mbpp/405", "solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    element (any): The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    # Use the 'in' keyword to check for the presence of the element in the tuple\n    return element in tup", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/406": [{"task_id": "Mbpp/406", "solution": "def find_Parity(number):\n    \"\"\"\n    This function checks if the parity of a given number is odd.\n    \n    Parity refers to whether the number of 1-bits in the binary representation of the number is odd or even.\n    If the number of 1-bits is odd, the parity is odd, otherwise, it is even.\n    \n    Parameters:\n    number (int): The number to check the parity of.\n    \n    Returns:\n    bool: True if the parity is odd, False otherwise.\n    \"\"\"\n    # Count the number of 1s in the binary representation of the number\n    count_of_ones = bin(number).count('1')\n    \n    # Check if the count of 1s is odd\n    return count_of_ones % 2 != 0", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[2]]}], "Mbpp/409": [{"task_id": "Mbpp/409", "solution": "def min_product_tuple(pairs):\n    \"\"\"\n    This function takes a list of tuples, where each tuple contains two integers.\n    It calculates the product of the integers in each tuple and returns the minimum product found.\n\n    :param pairs: List of tuples, where each tuple contains two integers\n    :return: The minimum product of the integers in the tuples\n    \"\"\"\n    # Initialize the minimum product with a large number\n    min_product = float('inf')\n    \n    # Iterate over each tuple in the list\n    for a, b in pairs:\n        # Calculate the product of the current tuple\n        product = a * b\n        # Update the minimum product if the current product is smaller\n        if product < min_product:\n            min_product = product\n    \n    return min_product", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/412": [{"task_id": "Mbpp/412", "solution": "def remove_odd(numbers):\n    \"\"\"\n    This function takes a list of integers and returns a new list with all odd numbers removed.\n\n    :param numbers: List of integers\n    :return: List of integers with odd numbers removed\n    \"\"\"\n    # Use list comprehension to filter out odd numbers\n    return [num for num in numbers if num % 2 == 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/410": [{"task_id": "Mbpp/410", "solution": "def min_val(heterogeneous_list):\n    \"\"\"\n    This function takes a heterogeneous list as input and returns the minimum\n    numeric value found in the list. Non-numeric values are ignored.\n\n    :param heterogeneous_list: List containing elements of different types\n    :return: Minimum numeric value in the list\n    \"\"\"\n    # Initialize a variable to store the minimum value, starting with None\n    min_value = None\n\n    # Iterate over each element in the list\n    for item in heterogeneous_list:\n        # Check if the item is an integer or a float\n        if isinstance(item, (int, float)):\n            # If min_value is None or the current item is less than min_value, update min_value\n            if min_value is None or item < min_value:\n                min_value = item\n\n    # Return the minimum value found\n    return min_value", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["Python", 10, 5, 2.5, 2.5, "version"]]]}], "Mbpp/413": [{"task_id": "Mbpp/413", "solution": "def extract_nth_element(tuples_list, n):\n    \"\"\"\n    Extracts the nth element from each tuple in a list of tuples.\n\n    Parameters:\n    tuples_list (list of tuples): The list of tuples from which to extract elements.\n    n (int): The index of the element to extract from each tuple.\n\n    Returns:\n    list: A list containing the nth element from each tuple.\n    \"\"\"\n    # Initialize an empty list to store the extracted elements\n    extracted_elements = []\n\n    # Iterate over each tuple in the list\n    for tup in tuples_list:\n        # Append the nth element of the current tuple to the result list\n        extracted_elements.append(tup[n])\n\n    return extracted_elements", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/415": [{"task_id": "Mbpp/415", "solution": "def max_Product(arr):\n    \"\"\"\n    This function finds a pair of numbers in the given array that has the highest product.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    tuple: A tuple containing the pair of integers with the highest product.\n    \"\"\"\n    if len(arr) < 2:\n        raise ValueError(\"Array must contain at least two elements to form a pair.\")\n    \n    # Initialize variables to store the maximum and second maximum numbers\n    max1 = max2 = float('-inf')\n    \n    # Initialize variables to store the minimum and second minimum numbers\n    # This is useful for handling negative numbers\n    min1 = min2 = float('inf')\n    \n    for num in arr:\n        # Update the maximum and second maximum numbers\n        if num > max1:\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max2 = num\n        \n        # Update the minimum and second minimum numbers\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n    \n    # Calculate the product of the two largest numbers\n    max_product = max1 * max2\n    # Calculate the product of the two smallest numbers (in case of negative numbers)\n    min_product = min1 * min2\n    \n    # Determine which pair gives the highest product\n    if max_product > min_product:\n        return (max1, max2)\n    else:\n        return (min1, min2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 7, 0, 8, 4]]], "plus_fail_tests": [[[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]]}], "Mbpp/414": [{"task_id": "Mbpp/414", "solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (iterable): The first sequence to check.\n    seq2 (iterable): The second sequence to check against.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    # Convert the second sequence to a set for O(1) average time complexity lookups\n    set_seq2 = set(seq2)\n    \n    # Check each element in seq1 to see if it exists in seq2\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/418": [{"task_id": "Mbpp/418", "solution": "def Find_Max(list_of_lists):\n    \"\"\"\n    This function takes a list of lists as input and returns the sublist with the maximum length.\n    \n    Parameters:\n    list_of_lists (list): A list containing sublists.\n    \n    Returns:\n    list: The sublist with the maximum length.\n    \"\"\"\n    # Initialize a variable to keep track of the sublist with the maximum length\n    max_length_list = []\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Check if the current sublist is longer than the current max_length_list\n        if len(sublist) > len(max_length_list):\n            # Update max_length_list to the current sublist\n            max_length_list = sublist\n    \n    return max_length_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/420": [{"task_id": "Mbpp/420", "solution": "def cube_sum(n):\n    \"\"\"\n    Calculate the sum of cubes of the first n even natural numbers.\n\n    Parameters:\n    n (int): The number of even natural numbers to consider.\n\n    Returns:\n    int: The sum of cubes of the first n even natural numbers.\n    \"\"\"\n    # Initialize the sum to zero\n    sum_of_cubes = 0\n    \n    # Loop through the first n even natural numbers\n    for i in range(1, n + 1):\n        even_number = 2 * i  # Calculate the i-th even number\n        sum_of_cubes += even_number ** 3  # Add its cube to the sum\n    \n    return sum_of_cubes\n\n# Test the function with the provided test case\nassert cube_sum(2) == 72\n\n# Additional test cases\nprint(cube_sum(1))  # Should print 8, since 2^3 = 8\nprint(cube_sum(3))  # Should print 288, since 2^3 + 4^3 + 6^3 = 288\nprint(cube_sum(4))  # Should print 800, since 2^3 + 4^3 + 6^3 + 8^3 = 800", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/419": [{"task_id": "Mbpp/419", "solution": "def round_and_sum(numbers):\n    \"\"\"\n    This function takes a list of numbers, rounds each number to the nearest integer,\n    calculates the sum of these rounded numbers, and then multiplies the sum by the\n    length of the list. It returns the final result.\n\n    :param numbers: List of float numbers\n    :return: Integer result of the sum of rounded numbers multiplied by the length of the list\n    \"\"\"\n    # Round each number in the list\n    rounded_numbers = [round(num) for num in numbers]\n    \n    # Calculate the sum of the rounded numbers\n    total_sum = sum(rounded_numbers)\n    \n    # Multiply the sum by the length of the list\n    result = total_sum * len(numbers)\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/421": [{"task_id": "Mbpp/421", "solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the input tuple into a single string, separated by the specified delimiter.\n\n    Parameters:\n    input_tuple (tuple): The tuple containing elements to be concatenated.\n    delimiter (str): The delimiter to use between elements. Default is '-'.\n\n    Returns:\n    str: A single string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    # Convert all elements of the tuple to strings\n    string_elements = map(str, input_tuple)\n    \n    # Join the string elements with the specified delimiter\n    result = delimiter.join(string_elements)\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/422": [{"task_id": "Mbpp/422", "solution": "def find_Average_Of_Cube(n):\n    \"\"\"\n    Calculate the average of the cubes of the first n natural numbers.\n\n    Parameters:\n    n (int): The number of natural numbers to consider.\n\n    Returns:\n    float: The average of the cubes of the first n natural numbers.\n    \"\"\"\n    # Calculate the sum of cubes of the first n natural numbers\n    sum_of_cubes = sum(i**3 for i in range(1, n + 1))\n    \n    # Calculate the average by dividing the sum of cubes by n\n    average_of_cubes = sum_of_cubes / n\n    \n    return average_of_cubes", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/424": [{"task_id": "Mbpp/424", "solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    strings_tuple (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list containing the last character of each string in the tuple.\n    \"\"\"\n    # Use a list comprehension to iterate over each string in the tuple\n    # and extract the last character of each string.\n    return [s[-1] for s in strings_tuple]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/426": [{"task_id": "Mbpp/426", "solution": "def filter_oddnumbers(numbers):\n    \"\"\"\n    This function takes a list of integers and returns a new list containing only the odd numbers from the original list.\n\n    :param numbers: List of integers\n    :return: List of odd integers\n    \"\"\"\n    # Use list comprehension to filter out odd numbers\n    odd_numbers = [num for num in numbers if num % 2 != 0]\n    return odd_numbers", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/425": [{"task_id": "Mbpp/425", "solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    list_of_lists (list of lists): A list containing sublists.\n    element (any): The element to search for in the sublists.\n\n    Returns:\n    int: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/427": [{"task_id": "Mbpp/427", "solution": "def change_date_format(date_str):\n    \"\"\"\n    Convert a date from yyyy-mm-dd format to dd-mm-yyyy format.\n\n    Parameters:\n    date_str (str): A date string in the format 'yyyy-mm-dd'.\n\n    Returns:\n    str: The date string converted to 'dd-mm-yyyy' format.\n    \"\"\"\n    # Split the input date string by the '-' delimiter\n    year, month, day = date_str.split('-')\n    \n    # Reformat the date to 'dd-mm-yyyy'\n    new_date_format = f\"{day}-{month}-{year}\"\n    \n    return new_date_format", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["2021-1-026"]]}], "Mbpp/429": [{"task_id": "Mbpp/429", "solution": "def and_tuples(tuple1, tuple2):\n    \"\"\"\n    This function takes two tuples of integers and returns a new tuple where each element is the result\n    of the bitwise AND operation between the corresponding elements of the input tuples.\n    \n    Parameters:\n    tuple1 (tuple): The first tuple of integers.\n    tuple2 (tuple): The second tuple of integers.\n    \n    Returns:\n    tuple: A tuple containing the result of the bitwise AND operation for each pair of elements.\n    \"\"\"\n    # Ensure both tuples are of the same length\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Both tuples must be of the same length.\")\n    \n    # Perform elementwise bitwise AND operation\n    result = tuple(a & b for a, b in zip(tuple1, tuple2))\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/428": [{"task_id": "Mbpp/428", "solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            # Save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n\n        # Reduce the gap for the next element\n        gap //= 2\n\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/430": [{"task_id": "Mbpp/430", "solution": "def parabola_directrix(a, b, c):\n    \"\"\"\n    Calculate the directrix of a parabola given its coefficients a, b, and c.\n    \n    Parameters:\n    a (int): Coefficient of x^2\n    b (int): Coefficient of x\n    c (int): Constant term\n    \n    Returns:\n    int: The y-coordinate of the directrix\n    \"\"\"\n    # Calculate the directrix using the formula\n    directrix = (4 * a * c - b**2 - 1) / (4 * a)\n    \n    # Return the directrix as an integer\n    return int(directrix)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5, 3, 2]], "plus_fail_tests": [[0, 0, 0]]}], "Mbpp/432": [{"task_id": "Mbpp/432", "solution": "def median_trapezium(a, b, h):\n    \"\"\"\n    Calculate the median length of a trapezium.\n\n    Parameters:\n    a (float): Length of the first parallel side.\n    b (float): Length of the second parallel side.\n    h (float): Height of the trapezium (not used in median calculation).\n\n    Returns:\n    float: The median length of the trapezium.\n    \"\"\"\n    # The median of a trapezium is the average of the lengths of the two parallel sides\n    median = (a + b) / 2\n    return median", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/433": [{"task_id": "Mbpp/433", "solution": "def check_greater(arr, num):\n    \"\"\"\n    This function checks if the given number is greater than all elements in the provided array.\n\n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to compare against the elements of the array.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    # Iterate through each element in the array\n    for element in arr:\n        # If the number is not greater than the current element, return False\n        if num <= element:\n            return False\n    # If the loop completes without returning False, the number is greater than all elements\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/436": [{"task_id": "Mbpp/436", "solution": "def neg_nos(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns a list containing only the negative numbers.\n\n    :param numbers: List of integers\n    :return: List of negative integers\n    \"\"\"\n    # Use list comprehension to filter out negative numbers\n    return [num for num in numbers if num < 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/435": [{"task_id": "Mbpp/435", "solution": "def last_Digit(number):\n    \"\"\"\n    This function returns the last digit of a given integer number.\n    \n    Parameters:\n    number (int): The number from which to find the last digit.\n    \n    Returns:\n    int: The last digit of the number.\n    \"\"\"\n    # Convert the number to a string, get the last character, and convert it back to an integer\n    return int(str(number)[-1])", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[true]]}], "Mbpp/437": [{"task_id": "Mbpp/437", "solution": "def remove_odd(s):\n    \"\"\"\n    This function removes characters at odd indices from the input string.\n\n    Parameters:\n    s (str): The input string from which odd-indexed characters will be removed.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    # Use list comprehension to select characters at even indices\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 0])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["python"]], "plus_fail_tests": [["Hello, world!"]]}], "Mbpp/440": [{"task_id": "Mbpp/440", "solution": "import re\ndef find_adverb_position(sentence):\n    \"\"\"\n    This function finds the first adverb in a given sentence and returns its start and end positions along with the adverb itself.\n    An adverb is identified as a word ending with 'ly'.\n    \n    Parameters:\n    sentence (str): The input sentence in which to find the adverb.\n    \n    Returns:\n    tuple: A tuple containing the start position, end position, and the adverb itself.\n    \"\"\"\n    # Regular expression to find words ending with 'ly'\n    adverb_pattern = r'\\b\\w+ly\\b'\n    \n    # Search for the first occurrence of an adverb\n    match = re.search(adverb_pattern, sentence)\n    \n    if match:\n        # Extract the start and end positions and the adverb\n        start_pos = match.start()\n        end_pos = match.end()\n        adverb = match.group()\n        return (start_pos, end_pos, adverb)\n    else:\n        # Return None if no adverb is found\n        return None", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["awaquicklyy"]]}], "Mbpp/439": [{"task_id": "Mbpp/439", "solution": "def multiple_to_single(numbers):\n    \"\"\"\n    Joins a list of integers into a single integer.\n\n    Parameters:\n    numbers (list): A list of integers to be joined.\n\n    Returns:\n    int: A single integer formed by concatenating the integers in the list.\n    \"\"\"\n    # Convert each integer in the list to a string and join them\n    joined_string = ''.join(map(str, numbers))\n    # Convert the concatenated string back to an integer\n    return int(joined_string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/441": [{"task_id": "Mbpp/441", "solution": "def surfacearea_cube(side_length):\n    \"\"\"\n    Calculate the surface area of a cube given the side length.\n\n    Parameters:\n    side_length (float): The length of one side of the cube.\n\n    Returns:\n    float: The surface area of the cube.\n    \"\"\"\n    # A cube has 6 faces, each with an area of side_length^2\n    surface_area = 6 * (side_length ** 2)\n    return surface_area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/445": [{"task_id": "Mbpp/445", "solution": "def index_multiplication(tuple1, tuple2):\n    \"\"\"\n    Perform index-wise multiplication of elements in the given two tuples.\n    \n    Args:\n    tuple1: A tuple of tuples, where each inner tuple contains two integers.\n    tuple2: A tuple of tuples, where each inner tuple contains two integers.\n    \n    Returns:\n    A tuple of tuples, where each inner tuple contains the product of the corresponding elements\n    from the input tuples.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the tuples using zip to pair corresponding elements\n    for (a, b), (c, d) in zip(tuple1, tuple2):\n        # Multiply corresponding elements and append the result as a tuple\n        result.append((a * c, b * d))\n    \n    # Convert the result list back to a tuple of tuples\n    return tuple(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/446": [{"task_id": "Mbpp/446", "solution": "def count_occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    Parameters:\n    tup (tuple): A tuple containing elements to be counted.\n    lst (list): A list of elements whose occurrences need to be counted in the tuple.\n\n    Returns:\n    int: The total count of occurrences of the list elements in the tuple.\n    \"\"\"\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # Count the occurrences of the element in the tuple and add to the counter\n        count += tup.count(element)\n    \n    return count\n\n# Test the function with the provided test case\nassert count_occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3\n\n# Additional test cases\nprint(count_occurrence(('x', 'y', 'z', 'x', 'x'), ['x', 'y']))  # Output should be 4\nprint(count_occurrence(('1', '2', '3', '4', '5'), ['6', '7']))  # Output should be 0\nprint(count_occurrence((), ['a', 'b']))  # Output should be 0\nprint(count_occurrence(('a', 'b', 'c'), []))  # Output should be 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/448": [{"task_id": "Mbpp/448", "solution": "def perrin_number(n):\n    \"\"\"\n    Calculate the nth Perrin number using a recursive approach with memoization.\n    \n    The Perrin sequence is defined as:\n    P(0) = 3, P(1) = 0, P(2) = 2\n    P(n) = P(n-2) + P(n-3) for n > 2\n    \"\"\"\n    # Base cases\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    \n    # Memoization dictionary to store previously calculated Perrin numbers\n    memo = {0: 3, 1: 0, 2: 2}\n    \n    def perrin_recursive(k):\n        if k not in memo:\n            memo[k] = perrin_recursive(k - 2) + perrin_recursive(k - 3)\n        return memo[k]\n    \n    return perrin_recursive(n)\ndef cal_sum(n):\n    \"\"\"\n    Calculate the sum of the first n Perrin numbers.\n    \n    :param n: The number of terms in the Perrin sequence to sum.\n    :return: The sum of the first n Perrin numbers.\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        total_sum += perrin_number(i)\n    return total_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[9]], "plus_fail_tests": [[-5]]}], "Mbpp/447": [{"task_id": "Mbpp/447", "solution": "def cube_nums(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns a new list containing the cubes of the original numbers.\n    \n    :param numbers: List of integers\n    :return: List of integers where each element is the cube of the corresponding element in the input list\n    \"\"\"\n    # Using list comprehension to compute the cube of each number in the list\n    return [num ** 3 for num in numbers]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/450": [{"task_id": "Mbpp/450", "solution": "def extract_string(strings, size):\n    \"\"\"\n    Extract strings from the given list that have the specified size.\n\n    Parameters:\n    strings (list of str): The list of strings to search through.\n    size (int): The size of strings to extract.\n\n    Returns:\n    list of str: A list containing strings of the specified size.\n    \"\"\"\n    # Initialize an empty list to store strings of the specified size\n    result = []\n\n    # Iterate over each string in the input list\n    for string in strings:\n        # Check if the length of the string matches the specified size\n        if len(string) == size:\n            # If it matches, add the string to the result list\n            result.append(string)\n\n    # Return the list of strings that match the specified size\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/453": [{"task_id": "Mbpp/453", "solution": "def sum_of_even_factors(n):\n    \"\"\"\n    Calculate the sum of even factors of a given number n.\n\n    Parameters:\n    n (int): The number for which to find the sum of even factors.\n\n    Returns:\n    int: The sum of even factors of n.\n    \"\"\"\n    # Initialize sum to 0\n    sum_even_factors = 0\n    \n    # Iterate over all numbers from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a factor of n and if it is even\n        if n % i == 0 and i % 2 == 0:\n            sum_even_factors += i\n    \n    return sum_even_factors\n\n# Test the function with the provided test case\nassert sum_of_even_factors(18) == 26\n\n# Additional test cases\nprint(sum_of_even_factors(12))  # Expected output: 18 (2 + 4 + 6 + 12)\nprint(sum_of_even_factors(20))  # Expected output: 42 (2 + 4 + 10 + 20)\nprint(sum_of_even_factors(1))   # Expected output: 0 (no even factors)\nprint(sum_of_even_factors(2))   # Expected output: 2 (only 2 is an even factor)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/451": [{"task_id": "Mbpp/451", "solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    This function removes all whitespaces from the given string.\n\n    Parameters:\n    input_string (str): The string from which to remove whitespaces.\n\n    Returns:\n    str: A new string with all whitespaces removed.\n    \"\"\"\n    # Use the replace method to remove all spaces\n    return input_string.replace(\" \", \"\")", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/454": [{"task_id": "Mbpp/454", "solution": "import re\ndef text_match_wordz(text):\n    \"\"\"\n    This function checks if the input text contains a word with the letter 'z'.\n    \n    Parameters:\n    text (str): The input string to be checked.\n    \n    Returns:\n    bool: True if there is a word containing 'z', False otherwise.\n    \"\"\"\n    # Regular expression to find a word containing 'z'\n    pattern = r'\\b\\w*z\\w*\\b'\n    \n    # Search for the pattern in the text\n    match = re.search(pattern, text)\n    \n    # Return True if a match is found, otherwise False\n    return match is not None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/456": [{"task_id": "Mbpp/456", "solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Parameters:\n    strings (list of str): A list of strings to be reversed.\n\n    Returns:\n    list of str: A new list with each string reversed.\n    \"\"\"\n    # Use a list comprehension to reverse each string in the list\n    return [s[::-1] for s in strings]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/455": [{"task_id": "Mbpp/455", "solution": "def check_month_number(month):\n    \"\"\"\n    This function checks if the given month number contains 31 days.\n    \n    Parameters:\n    month (int): The month number (1 for January, 2 for February, ..., 12 for December)\n    \n    Returns:\n    bool: True if the month has 31 days, False otherwise.\n    \"\"\"\n    # List of months with 31 days: January, March, May, July, August, October, December\n    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]\n    \n    # Check if the given month is in the list of months with 31 days\n    return month in months_with_31_days\n\n# Test cases\nassert check_month_number(5) == True  # May has 31 days\nassert check_month_number(2) == False # February does not have 31 days\nassert check_month_number(11) == False # November does not have 31 days\nassert check_month_number(7) == True  # July has 31 days\nassert check_month_number(12) == True # December has 31 days", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/457": [{"task_id": "Mbpp/457", "solution": "def Find_Min(sublists):\n    \"\"\"\n    This function takes a list of sublists and returns the sublist with the minimum length.\n    If there are multiple sublists with the same minimum length, it returns the first one encountered.\n\n    :param sublists: List of sublists\n    :return: Sublist with the minimum length\n    \"\"\"\n    # Initialize the minimum sublist as None and minimum length as infinity\n    min_sublist = None\n    min_length = float('inf')\n    \n    # Iterate over each sublist\n    for sublist in sublists:\n        # Check the length of the current sublist\n        current_length = len(sublist)\n        # If the current sublist is shorter than the previously found shortest\n        if current_length < min_length:\n            # Update the minimum sublist and its length\n            min_sublist = sublist\n            min_length = current_length\n    \n    return min_sublist", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/458": [{"task_id": "Mbpp/458", "solution": "def rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    Parameters:\n    length (float): The length of the rectangle.\n    width (float): The width of the rectangle.\n\n    Returns:\n    float: The area of the rectangle.\n    \"\"\"\n    # Calculate the area by multiplying length and width\n    return length * width", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/459": [{"task_id": "Mbpp/459", "solution": "def remove_uppercase(s):\n    \"\"\"\n    This function removes uppercase substrings from the given string.\n    \n    Parameters:\n    s (str): The input string from which uppercase substrings need to be removed.\n    \n    Returns:\n    str: A new string with all uppercase substrings removed.\n    \"\"\"\n    result = []\n    i = 0\n    while i < len(s):\n        if s[i].isupper():\n            # Skip over the entire uppercase substring\n            while i < len(s) and s[i].isupper():\n                i += 1\n        else:\n            # Append lowercase characters to the result\n            result.append(s[i])\n            i += 1\n    return ''.join(result)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["ThiS%^%!s&a(mY)TesTStR%i*ng"]]}], "Mbpp/462": [{"task_id": "Mbpp/462", "solution": "from itertools import combinations\ndef combinations_list(elements):\n    \"\"\"\n    Generate all possible combinations of the elements in the given list.\n    \n    Parameters:\n    elements (list): A list of elements to find combinations for.\n    \n    Returns:\n    list: A list of lists, where each sublist is a possible combination of the input elements.\n    \"\"\"\n    # Initialize the result list with an empty list to include the empty combination\n    result = [[]]\n    \n    # Iterate over all possible combination lengths from 1 to the length of the list\n    for r in range(1, len(elements) + 1):\n        # Use itertools.combinations to generate combinations of length r\n        for combo in combinations(elements, r):\n            # Append each combination as a list to the result\n            result.append(list(combo))\n    \n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["orange", "red", "green", "blue"]]], "plus_fail_tests": [[["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"]]]}], "Mbpp/460": [{"task_id": "Mbpp/460", "solution": "def extract_first_elements(nested_list):\n    \"\"\"\n    This function takes a list of lists (nested_list) and returns a list containing\n    the first element of each sublist.\n\n    :param nested_list: List of lists from which to extract the first element of each sublist\n    :return: List of first elements from each sublist\n    \"\"\"\n    # Use a list comprehension to extract the first element from each sublist\n    return [sublist[0] for sublist in nested_list if sublist]\n\n# Test the function with the provided test case\nassert extract_first_elements([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n\n# Additional test cases\nassert extract_first_elements([[10], [20, 30], [40, 50, 60]]) == [10, 20, 40]\nassert extract_first_elements([[1], [2], [3]]) == [1, 2, 3]\nassert extract_first_elements([[], [1, 2], [3, 4]]) == [1, 3]  # Handles empty sublists\nassert extract_first_elements([]) == []  # Handles empty list", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/463": [{"task_id": "Mbpp/463", "solution": "def max_subarray_product(nums):\n    \"\"\"\n    Function to find the maximum product subarray in a given list of integers.\n    \n    Parameters:\n    nums (list): A list of integers.\n    \n    Returns:\n    int: The maximum product of any contiguous subarray.\n    \"\"\"\n    if not nums:\n        return 0\n\n    # Initialize variables to store the maximum product, minimum product, and result\n    max_product = nums[0]\n    min_product = nums[0]\n    result = nums[0]\n\n    # Iterate through the array starting from the second element\n    for i in range(1, len(nums)):\n        num = nums[i]\n\n        # If the current number is negative, swap max_product and min_product\n        if num < 0:\n            max_product, min_product = min_product, max_product\n\n        # Calculate the maximum and minimum product up to the current position\n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n\n        # Update the result with the maximum product found so far\n        result = max(result, max_product)\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/468": [{"task_id": "Mbpp/468", "solution": "def max_product(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n\n    # Initialize a list to store the maximum product of increasing subsequences\n    max_product_dp = arr[:]  # Start with each element as the max product of its own subsequence\n\n    # Iterate over the array to fill the max_product_dp list\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                # Update the max product for the subsequence ending at i\n                max_product_dp[i] = max(max_product_dp[i], max_product_dp[j] * arr[i])\n\n    # The result is the maximum value in the max_product_dp list\n    return max(max_product_dp)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 100, 4, 5, 150, 6]]], "plus_fail_tests": [[[2, 3, 3, 4, 5, 3, 6]]]}], "Mbpp/465": [{"task_id": "Mbpp/465", "solution": "def drop_empty(input_dict):\n    \"\"\"\n    This function takes a dictionary as input and returns a new dictionary\n    with all items that have non-empty values. An empty value is considered\n    to be None or an empty string.\n\n    :param input_dict: Dictionary to process\n    :return: Dictionary with non-empty items\n    \"\"\"\n    # Create a new dictionary using dictionary comprehension\n    # Only include items where the value is not None and not an empty string\n    return {key: value for key, value in input_dict.items() if value is not None and value != ''}", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[{"1": "", "2": "Red", "3": "Green"}]]}], "Mbpp/470": [{"task_id": "Mbpp/470", "solution": "def add_pairwise(input_tuple):\n    \"\"\"\n    This function takes a tuple of integers and returns a new tuple containing the sum of each pair of neighboring elements.\n    \n    :param input_tuple: A tuple of integers\n    :return: A tuple containing the pairwise sums of neighboring elements\n    \"\"\"\n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate over the tuple, stopping at the second to last element\n    for i in range(len(input_tuple) - 1):\n        # Add the current element and the next element\n        pair_sum = input_tuple[i] + input_tuple[i + 1]\n        # Append the result to the list\n        result.append(pair_sum)\n    \n    # Convert the list to a tuple before returning\n    return tuple(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/471": [{"task_id": "Mbpp/471", "solution": "def find_remainder(arr, n):\n    \"\"\"\n    This function calculates the product of all elements in the array and then returns\n    the remainder when this product is divided by n.\n\n    Parameters:\n    arr (list): A list of integers.\n    n (int): The divisor for the modulo operation.\n\n    Returns:\n    int: The remainder of the product of the array elements divided by n.\n    \"\"\"\n    # Initialize the product to 1 (multiplicative identity)\n    product = 1\n    \n    # Iterate over each element in the array\n    for num in arr:\n        # Multiply the current product by the current number\n        product *= num\n    \n    # Return the remainder of the product divided by n\n    return product % n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/472": [{"task_id": "Mbpp/472", "solution": "def check_consecutive(numbers):\n    \"\"\"\n    This function checks if the given list contains consecutive numbers.\n    \n    Parameters:\n    numbers (list): A list of integers.\n    \n    Returns:\n    bool: True if the list contains consecutive numbers, False otherwise.\n    \"\"\"\n    if not numbers:\n        # An empty list cannot have consecutive numbers\n        return False\n    \n    # Sort the list to check for consecutive numbers\n    sorted_numbers = sorted(numbers)\n    \n    # Check if each number is exactly one more than the previous number\n    for i in range(1, len(sorted_numbers)):\n        if sorted_numbers[i] != sorted_numbers[i - 1] + 1:\n            return False\n    \n    return True\n\n# Test cases\nassert check_consecutive([1, 2, 3, 4, 5]) == True\nassert check_consecutive([2, 3, 4, 5, 6]) == True\nassert check_consecutive([1, 3, 4, 5, 6]) == False\nassert check_consecutive([10, 11, 12, 13, 14]) == True\nassert check_consecutive([1]) == True  # A single number is trivially consecutive\nassert check_consecutive([]) == False  # An empty list is not consecutive\n\n# Additional test cases\nassert check_consecutive([5, 4, 3, 2, 1]) == True  # Unordered but consecutive\nassert check_consecutive([1, 2, 4, 5, 6]) == False  # Missing a number in sequence\nassert check_consecutive([7, 8, 9, 10, 11, 12]) == True\nassert check_consecutive([100, 101, 102, 103]) == True\nassert check_consecutive([1, 2, 2, 3, 4]) == False  # Duplicate numbers break consecutiveness", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/474": [{"task_id": "Mbpp/474", "solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the string s.\n\n    Parameters:\n    s (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n\n    Returns:\n    str: The modified string with old_char replaced by new_char.\n    \"\"\"\n    # Use the str.replace() method to replace old_char with new_char\n    return s.replace(old_char, new_char)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/473": [{"task_id": "Mbpp/473", "solution": "def tuple_intersection(list1, list2):\n    \"\"\"\n    This function finds the intersection of tuples from two lists, considering tuples as sets of elements.\n    It returns a set of tuples that are present in both lists, irrespective of the order of elements in the tuples.\n    \n    Parameters:\n    list1 (list of tuples): The first list of tuples.\n    list2 (list of tuples): The second list of tuples.\n    \n    Returns:\n    set of tuples: A set containing the intersection of tuples from both lists.\n    \"\"\"\n    # Convert each tuple in the lists to a frozenset to ignore the order of elements\n    set1 = {frozenset(t) for t in list1}\n    set2 = {frozenset(t) for t in list2}\n    \n    # Find the intersection of these sets\n    intersection = set1.intersection(set2)\n    \n    # Convert the frozensets back to tuples for the final result\n    result = {tuple(sorted(t)) for t in intersection}\n    \n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[1, 2, 3], [4, 5, 6, 4], [7, 8, 9]], [[4, 5, 6], [1, 2, 3]]]]}], "Mbpp/475": [{"task_id": "Mbpp/475", "solution": "def sort_counter(d):\n    \"\"\"\n    Sorts a dictionary by its values in descending order and returns a list of tuples.\n\n    Parameters:\n    d (dict): A dictionary where the keys are strings and the values are integers.\n\n    Returns:\n    list: A list of tuples sorted by the dictionary's values in descending order.\n    \"\"\"\n    # Sort the dictionary items by value in descending order\n    sorted_items = sorted(d.items(), key=lambda item: item[1], reverse=True)\n    return sorted_items", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/477": [{"task_id": "Mbpp/477", "solution": "def is_lower(input_string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    # Use the built-in lower() method to convert the string to lower case\n    return input_string.lower()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/476": [{"task_id": "Mbpp/476", "solution": "def big_sum(arr):\n    \"\"\"\n    This function takes a list of numbers as input and returns the sum of the largest and smallest numbers in the list.\n    \n    :param arr: List of integers\n    :return: Integer sum of the largest and smallest numbers in the list\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array should not be empty\")\n    \n    # Find the smallest and largest values in the array\n    smallest = min(arr)\n    largest = max(arr)\n    \n    # Return the sum of the smallest and largest values\n    return smallest + largest", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/478": [{"task_id": "Mbpp/478", "solution": "def remove_lowercase(s):\n    \"\"\"\n    This function removes all lowercase substrings from the given string.\n    A substring is considered lowercase if it consists entirely of lowercase letters.\n    \n    Parameters:\n    s (str): The input string from which lowercase substrings are to be removed.\n    \n    Returns:\n    str: A new string with all lowercase substrings removed.\n    \"\"\"\n    result = []\n    current_substring = []\n    \n    for char in s:\n        if char.islower():\n            # If the character is lowercase, we add it to the current substring\n            current_substring.append(char)\n        else:\n            # If the character is not lowercase, we check if there was a lowercase substring\n            if current_substring:\n                # Clear the current substring as it is a lowercase substring\n                current_substring = []\n            # Add the non-lowercase character to the result\n            result.append(char)\n    \n    # Join the result list to form the final string\n    return ''.join(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/479": [{"task_id": "Mbpp/479", "solution": "def first_digit(number):\n    \"\"\"\n    This function takes an integer as input and returns the first digit of the number.\n    \n    Parameters:\n    number (int): The number from which to extract the first digit.\n    \n    Returns:\n    int: The first digit of the given number.\n    \"\"\"\n    # Convert the number to a string to easily access the first character\n    number_str = str(number)\n    \n    # Return the first character converted back to an integer\n    return int(number_str[0])\n\n# Test the function with the provided test case\nassert first_digit(123) == 1\n\n# Additional test cases\nassert first_digit(987654) == 9\nassert first_digit(5) == 5\nassert first_digit(1000) == 1\nassert first_digit(0) == 0\n\nprint(\"All test cases passed.\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/554": [{"task_id": "Mbpp/554", "solution": "def Split(numbers):\n    \"\"\"\n    This function takes a list of integers and returns a new list containing only the odd integers.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    list: A list containing only the odd integers from the input list.\n    \"\"\"\n    # Use list comprehension to filter out even numbers and keep only odd numbers\n    odd_numbers = [num for num in numbers if num % 2 != 0]\n    return odd_numbers", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/556": [{"task_id": "Mbpp/556", "solution": "def find_Odd_Pair(arr, n):\n    # Count the number of odd and even numbers in the array\n    odd_count = sum(1 for x in arr if x % 2 != 0)\n    even_count = n - odd_count  # Total count minus odd count gives even count\n\n    # The number of pairs with one odd and one even number\n    # is the product of the number of odd numbers and even numbers\n    return odd_count * even_count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1]]}], "Mbpp/555": [{"task_id": "Mbpp/555", "solution": "def difference(n):\n    \"\"\"\n    Calculate the difference between the sum of cubes of the first n natural numbers\n    and the sum of the first n natural numbers.\n\n    Parameters:\n    n (int): The number of natural numbers to consider.\n\n    Returns:\n    int: The difference between the sum of cubes and the sum of the numbers.\n    \"\"\"\n    # Calculate the sum of the first n natural numbers\n    sum_of_numbers = sum(range(1, n + 1))\n    \n    # Calculate the sum of cubes of the first n natural numbers\n    sum_of_cubes = sum(i**3 for i in range(1, n + 1))\n    \n    # Return the difference\n    return sum_of_cubes - sum_of_numbers", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/557": [{"task_id": "Mbpp/557", "solution": "def toggle_string(s):\n    \"\"\"\n    This function takes a string `s` and returns a new string with the case of each character toggled.\n    \n    Parameters:\n    s (str): The input string whose characters' cases need to be toggled.\n    \n    Returns:\n    str: A new string with each character's case toggled.\n    \"\"\"\n    # Use a list comprehension to iterate over each character in the string `s`\n    # and apply the `swapcase()` method to toggle its case.\n    toggled = [char.swapcase() for char in s]\n    \n    # Join the list of toggled characters back into a single string and return it.\n    return ''.join(toggled)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/559": [{"task_id": "Mbpp/559", "solution": "def max_sub_array_sum(arr, n):\n    \"\"\"\n    Function to find the sum of the largest contiguous sublist in the given list.\n    \n    Parameters:\n    arr (list): The input list of integers.\n    n (int): The number of elements in the list.\n    \n    Returns:\n    int: The sum of the largest contiguous sublist.\n    \"\"\"\n    # Initialize variables\n    max_so_far = float('-inf')  # This will store the maximum sum found so far\n    max_ending_here = 0  # This will store the maximum sum of the sublist ending at the current position\n\n    for i in range(n):\n        # Add the current element to the max_ending_here\n        max_ending_here += arr[i]\n        \n        # Update max_so_far if max_ending_here is greater\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        \n        # If max_ending_here becomes negative, reset it to 0\n        if max_ending_here < 0:\n            max_ending_here = 0\n\n    return max_so_far", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 0]]}], "Mbpp/558": [{"task_id": "Mbpp/558", "solution": "def digit_distance_nums(num1, num2):\n    \"\"\"\n    Calculate the sum of the per-digit difference between two integers.\n\n    Parameters:\n    num1 (int): The first integer.\n    num2 (int): The second integer.\n\n    Returns:\n    int: The sum of the per-digit differences.\n    \"\"\"\n    # Convert both numbers to strings to easily access each digit\n    str_num1 = str(num1)\n    str_num2 = str(num2)\n    \n    # Pad the shorter number with leading zeros to match the length of the longer number\n    max_length = max(len(str_num1), len(str_num2))\n    str_num1 = str_num1.zfill(max_length)\n    str_num2 = str_num2.zfill(max_length)\n    \n    # Initialize the sum of differences\n    sum_of_differences = 0\n    \n    # Iterate over each digit and calculate the absolute difference\n    for digit1, digit2 in zip(str_num1, str_num2):\n        sum_of_differences += abs(int(digit1) - int(digit2))\n    \n    return sum_of_differences", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/560": [{"task_id": "Mbpp/560", "solution": "def union_elements(tuple1, tuple2):\n    \"\"\"\n    This function takes two tuples as input and returns a tuple containing the union of the elements\n    from both tuples, sorted in ascending order.\n\n    Parameters:\n    tuple1 (tuple): The first input tuple.\n    tuple2 (tuple): The second input tuple.\n\n    Returns:\n    tuple: A tuple containing the sorted union of the elements from both input tuples.\n    \"\"\"\n    # Convert tuples to sets to find the union of elements\n    set1 = set(tuple1)\n    set2 = set(tuple2)\n    \n    # Find the union of the two sets\n    union_set = set1.union(set2)\n    \n    # Convert the union set back to a sorted tuple\n    sorted_union_tuple = tuple(sorted(union_set))\n    \n    return sorted_union_tuple", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/562": [{"task_id": "Mbpp/562", "solution": "def Find_Max_Length(list_of_lists):\n    \"\"\"\n    This function takes a list of lists as input and returns the length of the longest sublist.\n    \n    Parameters:\n    list_of_lists (list): A list containing sublists of varying lengths.\n    \n    Returns:\n    int: The length of the longest sublist.\n    \"\"\"\n    # Initialize a variable to keep track of the maximum length found\n    max_length = 0\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Update max_length if the current sublist is longer than the current max_length\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n    \n    return max_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/563": [{"task_id": "Mbpp/563", "solution": "def extract_values(s):\n    \"\"\"\n    Extracts values between quotation marks from a given string.\n\n    Parameters:\n    s (str): The input string containing values enclosed in quotation marks.\n\n    Returns:\n    list: A list of values extracted from between the quotation marks.\n    \"\"\"\n    import re\n    # Use regular expression to find all occurrences of text between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/565": [{"task_id": "Mbpp/565", "solution": "def split(string):\n    \"\"\"\n    Splits the input string into a list of its characters.\n\n    Parameters:\n    string (str): The string to be split.\n\n    Returns:\n    list: A list containing each character of the input string as an element.\n    \"\"\"\n    # Convert the string into a list of characters using list()\n    return list(string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/564": [{"task_id": "Mbpp/564", "solution": "def count_pairs(nums, n):\n    \"\"\"\n    Count the number of possible unordered pairs where both elements are unequal.\n\n    Parameters:\n    nums (list): A list of integers.\n    n (int): The number of elements in the list.\n\n    Returns:\n    int: The count of unordered pairs with unequal elements.\n    \"\"\"\n    # Initialize a counter for the pairs\n    count = 0\n    \n    # Iterate over each pair of elements in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the elements are unequal\n            if nums[i] != nums[j]:\n                count += 1\n    \n    return count\n\n# Test the function with the provided test case\nassert count_pairs([1, 2, 1], 3) == 2\n\n# Additional test cases\nprint(count_pairs([1, 2, 3], 3))  # Expected output: 3\nprint(count_pairs([1, 1, 1], 3))  # Expected output: 0\nprint(count_pairs([1, 2, 3, 4], 4))  # Expected output: 6\nprint(count_pairs([1, 2, 2, 3], 4))  # Expected output: 5", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/566": [{"task_id": "Mbpp/566", "solution": "def sum_digits(n):\n    \"\"\"\n    Calculate the sum of the digits of a non-negative integer.\n\n    Parameters:\n    n (int): A non-negative integer whose digits will be summed.\n\n    Returns:\n    int: The sum of the digits of the integer.\n    \"\"\"\n    # Convert the integer to a string to iterate over each digit\n    return sum(int(digit) for digit in str(n))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/568": [{"task_id": "Mbpp/568", "solution": "def empty_list(n):\n    \"\"\"\n    Create a list of N empty dictionaries.\n\n    Parameters:\n    n (int): The number of empty dictionaries to create.\n\n    Returns:\n    list: A list containing N empty dictionaries.\n    \"\"\"\n    # Create a list with N empty dictionaries using list comprehension\n    return [{} for _ in range(n)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/567": [{"task_id": "Mbpp/567", "solution": "def is_sorted_list(lst):\n    \"\"\"\n    Check if the given list is sorted in non-decreasing order.\n\n    Parameters:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if the list is sorted, False otherwise.\n    \"\"\"\n    # Iterate through the list and check if each element is less than or equal to the next\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True\n\n# Test the function with the provided test case\nassert is_sorted_list([1, 2, 4, 6, 8, 10, 12, 14, 16, 17]) == True\n\n# Additional test cases\nassert is_sorted_list([1, 2, 3, 4, 5]) == True  # Sorted list\nassert is_sorted_list([5, 4, 3, 2, 1]) == False  # Descending order\nassert is_sorted_list([1, 1, 2, 2, 3, 3]) == True  # List with duplicates\nassert is_sorted_list([1]) == True  # Single element list\nassert is_sorted_list([]) == True  # Empty list", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/569": [{"task_id": "Mbpp/569", "solution": "def sort_sublists(list_of_lists):\n    \"\"\"\n    Sort each sublist of strings in a given list of lists.\n\n    Parameters:\n    list_of_lists (list of list of str): A list containing sublists of strings.\n\n    Returns:\n    list of list of str: A new list with each sublist sorted alphabetically.\n    \"\"\"\n    # Use list comprehension to sort each sublist\n    return [sorted(sublist) for sublist in list_of_lists]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/572": [{"task_id": "Mbpp/572", "solution": "def two_unique_nums(nums):\n    \"\"\"\n    This function takes a list of numbers and returns a new list containing only the numbers\n    that appear exactly once in the input list.\n\n    :param nums: List of integers\n    :return: List of integers that appear exactly once in the input list\n    \"\"\"\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Count each number's occurrences\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Collect numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/573": [{"task_id": "Mbpp/573", "solution": "def unique_product(numbers):\n    \"\"\"\n    Calculate the product of the unique numbers in a given list.\n\n    :param numbers: List of integers\n    :return: Product of unique integers\n    \"\"\"\n    # Use a set to store unique numbers\n    unique_numbers = set(numbers)\n    \n    # Initialize product to 1 (multiplicative identity)\n    product = 1\n    \n    # Calculate the product of unique numbers\n    for number in unique_numbers:\n        product *= number\n    \n    return product", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/577": [{"task_id": "Mbpp/577", "solution": "def last_digit_factorial(n):\n    \"\"\"\n    This function calculates the last non-zero digit of the factorial of a given number n.\n    \n    Parameters:\n    n (int): The number for which the factorial's last non-zero digit is to be found.\n    \n    Returns:\n    int: The last non-zero digit of n!.\n    \"\"\"\n    if n == 0:\n        return 1  # 0! is 1, and the last non-zero digit is 1\n\n    # Initialize variables to calculate factorial\n    last_digit = 1\n\n    # Calculate factorial and track the last non-zero digit\n    for i in range(2, n + 1):\n        last_digit *= i\n\n        # Remove trailing zeros by continuously dividing by 10\n        while last_digit % 10 == 0:\n            last_digit //= 10\n\n        # Keep only the last digit to prevent overflow\n        last_digit %= 10\n\n    return last_digit\n\n# Test the function with the provided test case\nassert last_digit_factorial(4) == 4\n\n# Additional test cases\nprint(last_digit_factorial(5))  # Output should be 2 (5! = 120, last non-zero digit is 2)\nprint(last_digit_factorial(10)) # Output should be 8 (10! = 3628800, last non-zero digit is 8)\nprint(last_digit_factorial(0))  # Output should be 1 (0! = 1, last non-zero digit is 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/576": [{"task_id": "Mbpp/576", "solution": "def is_Sub_Array(main_list, sub_list):\n    \"\"\"\n    Check if sub_list is a sublist of main_list.\n\n    Parameters:\n    main_list (list): The list in which to search for the sublist.\n    sub_list (list): The list to check as a sublist.\n\n    Returns:\n    bool: True if sub_list is a sublist of main_list, False otherwise.\n    \"\"\"\n    # Get the lengths of both lists\n    len_main = len(main_list)\n    len_sub = len(sub_list)\n    \n    # If the sub_list is longer than the main_list, it cannot be a sublist\n    if len_sub > len_main:\n        return False\n    \n    # Iterate over the main_list to find the sub_list\n    for i in range(len_main - len_sub + 1):\n        # Check if the slice of main_list matches the sub_list\n        if main_list[i:i+len_sub] == sub_list:\n            return True\n    \n    return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5], [1, 3, 5]]]}], "Mbpp/578": [{"task_id": "Mbpp/578", "solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Parameters:\n    list1 (list): The first list to interleave.\n    list2 (list): The second list to interleave.\n    list3 (list): The third list to interleave.\n\n    Returns:\n    list: A new list with elements interleaved from the three input lists.\n    \"\"\"\n    # Check if all lists have the same length\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length\")\n\n    # Initialize an empty list to store the interleaved result\n    interleaved_list = []\n\n    # Iterate over the indices of the lists\n    for i in range(len(list1)):\n        # Append elements from each list in order\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n\n    return interleaved_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/580": [{"task_id": "Mbpp/580", "solution": "def extract_even(mixed_tuple):\n    \"\"\"\n    Recursively remove uneven elements from a nested mixed tuple.\n    \n    Parameters:\n    mixed_tuple (tuple): A tuple that may contain integers and other tuples.\n    \n    Returns:\n    tuple: A new tuple with only even integers, preserving the original structure.\n    \"\"\"\n    def is_even(n):\n        \"\"\"Check if a number is even.\"\"\"\n        return n % 2 == 0\n\n    def process_element(element):\n        \"\"\"\n        Process an element which can be an integer or a tuple.\n        \n        If it's an integer, return it if it's even.\n        If it's a tuple, recursively process it.\n        \"\"\"\n        if isinstance(element, int):\n            return (element,) if is_even(element) else ()\n        elif isinstance(element, tuple):\n            return extract_even(element)\n        else:\n            return ()\n\n    # Process each element in the mixed_tuple and filter out empty results\n    return tuple(filter(None, (process_element(el) for el in mixed_tuple)))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[4, 5, [7, 6, [2, 4]], 6, 8]]], "plus_fail_tests": [[[1, 2, 3, [4, 5, [6, 7, [8, 9, [10, 11, [12, 13, [14, 15, [16, 17, [18, 19, [20]]]]]]]]]]]]}], "Mbpp/579": [{"task_id": "Mbpp/579", "solution": "def find_dissimilar(tuple1, tuple2):\n    \"\"\"\n    This function takes two tuples as input and returns a tuple containing elements\n    that are present in either of the tuples but not in both.\n    \n    Parameters:\n    tuple1 (tuple): The first input tuple.\n    tuple2 (tuple): The second input tuple.\n    \n    Returns:\n    tuple: A tuple containing the dissimilar elements.\n    \"\"\"\n    # Convert tuples to sets to perform set operations\n    set1 = set(tuple1)\n    set2 = set(tuple2)\n    \n    # Find elements that are in either set1 or set2 but not in both\n    dissimilar_elements = set1.symmetric_difference(set2)\n    \n    # Convert the result back to a tuple\n    return tuple(dissimilar_elements)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/581": [{"task_id": "Mbpp/581", "solution": "def surface_area(base_edge, height):\n    \"\"\"\n    Calculate the surface area of a square pyramid.\n\n    Parameters:\n    base_edge (float): The length of the base edge of the square pyramid.\n    height (float): The height of the square pyramid from the base to the apex.\n\n    Returns:\n    float: The surface area of the square pyramid.\n    \"\"\"\n    # Calculate the area of the base (a square)\n    base_area = base_edge ** 2\n    \n    # Calculate the slant height using the Pythagorean theorem\n    slant_height = (height ** 2 + (base_edge / 2) ** 2) ** 0.5\n    \n    # Calculate the lateral surface area (4 triangles)\n    lateral_area = 2 * base_edge * slant_height\n    \n    # Total surface area is the sum of the base area and the lateral area\n    total_surface_area = base_area + lateral_area\n    \n    return total_surface_area\n\n# Test the function with the given test case\nassert surface_area(3, 4) == 33\n\n# Example usage\nprint(\"Surface area of the square pyramid:\", surface_area(3, 4))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/585": [{"task_id": "Mbpp/585", "solution": "def expensive_items(items, n):\n    \"\"\"\n    This function takes a list of dictionaries (items) and an integer n, and returns a list of the n most expensive items.\n    Each item is represented as a dictionary with 'name' and 'price' keys.\n    \n    :param items: List[Dict[str, Union[str, float]]] - A list of dictionaries, each containing 'name' and 'price' keys.\n    :param n: int - The number of most expensive items to return.\n    :return: List[Dict[str, Union[str, float]]] - A list of the n most expensive items.\n    \"\"\"\n    # Sort the items by price in descending order\n    sorted_items = sorted(items, key=lambda x: x['price'], reverse=True)\n    \n    # Return the top n items\n    return sorted_items[:n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/583": [{"task_id": "Mbpp/583", "solution": "def catalan_number(n):\n    \"\"\"\n    Calculate the nth Catalan number using a dynamic programming approach.\n    \n    The nth Catalan number can be calculated using the formula:\n    C(n) = (2n)! / ((n + 1)! * n!)\n    \n    Alternatively, it can be calculated using the recursive formula:\n    C(n) = sum(C(i) * C(n-i-1) for i in range(n))\n    \n    This function uses a dynamic programming approach to efficiently compute\n    the nth Catalan number.\n    \n    :param n: The index of the Catalan number to compute.\n    :return: The nth Catalan number.\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    \n    # Initialize a list to store computed Catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1\n    catalan[1] = 1\n    \n    # Fill the catalan array using the recursive formula\n    for i in range(2, n + 1):\n        catalan[i] = 0\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    \n    return catalan[n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/586": [{"task_id": "Mbpp/586", "solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list `arr` at the nth element and appends the first part to the end.\n    \n    Parameters:\n    arr (list): The list to be split and rearranged.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: A new list with the elements rearranged.\n    \"\"\"\n    # Split the list into two parts: from the nth element to the end, and from the start to the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Concatenate the second part with the first part\n    result = second_part + first_part\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/587": [{"task_id": "Mbpp/587", "solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    input_list (list): The list to be converted to a tuple.\n\n    Returns:\n    tuple: A tuple containing the elements of the input list.\n    \"\"\"\n    # Convert the list to a tuple using the tuple() constructor\n    return tuple(input_list)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/588": [{"task_id": "Mbpp/588", "solution": "def big_diff(numbers):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a list.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The difference between the largest and smallest integers in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list should not be empty.\")\n    \n    # Find the maximum and minimum values in the list\n    max_value = max(numbers)\n    min_value = min(numbers)\n    \n    # Calculate the difference\n    difference = max_value - min_value\n    \n    return difference", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/590": [{"task_id": "Mbpp/590", "solution": "import math\nimport cmath\ndef polar_rect(r, theta):\n    # Calculate rectangular coordinates\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    \n    # Create a complex number representation\n    complex_representation = cmath.rect(r, theta)\n    \n    # Return both the tuple and the complex number\n    return ((x, y), complex_representation)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 4]], "plus_fail_tests": [[0, 0]]}], "Mbpp/589": [{"task_id": "Mbpp/589", "solution": "import math\ndef perfect_squares(start, end):\n    \"\"\"\n    This function finds all perfect squares between two given numbers, inclusive.\n    \n    Parameters:\n    start (int): The starting number of the range.\n    end (int): The ending number of the range.\n    \n    Returns:\n    list: A list of perfect squares within the given range.\n    \"\"\"\n    # Initialize an empty list to store perfect squares\n    squares = []\n    \n    # Calculate the smallest integer greater than or equal to the square root of the start\n    start_sqrt = math.ceil(math.sqrt(start))\n    \n    # Calculate the largest integer less than or equal to the square root of the end\n    end_sqrt = math.floor(math.sqrt(end))\n    \n    # Iterate over the range of integers from start_sqrt to end_sqrt\n    for i in range(start_sqrt, end_sqrt + 1):\n        # Calculate the square of the current integer\n        square = i * i\n        # Append the square to the list\n        squares.append(square)\n    \n    return squares", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-10, -1]]}], "Mbpp/591": [{"task_id": "Mbpp/591", "solution": "def swap_List(lst):\n    \"\"\"\n    This function takes a list as input and swaps the first and last elements of the list.\n    \n    Parameters:\n    lst (list): The list whose first and last elements are to be swapped.\n    \n    Returns:\n    list: The list with the first and last elements interchanged.\n    \"\"\"\n    # Check if the list is empty or has only one element, in which case no swap is needed\n    if len(lst) <= 1:\n        return lst\n    \n    # Swap the first and last elements\n    lst[0], lst[-1] = lst[-1], lst[0]\n    \n    return lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/593": [{"task_id": "Mbpp/593", "solution": "def removezero_ip(ip_address):\n    \"\"\"\n    This function takes an IP address as a string and removes any leading zeroes from each octet.\n    \n    Parameters:\n    ip_address (str): The IP address with potential leading zeroes in its octets.\n    \n    Returns:\n    str: The IP address with leading zeroes removed from each octet.\n    \"\"\"\n    # Split the IP address into its octets\n    octets = ip_address.split('.')\n    \n    # Remove leading zeroes from each octet by converting them to integers and back to strings\n    cleaned_octets = [str(int(octet)) for octet in octets]\n    \n    # Join the cleaned octets back into a single IP address string\n    cleaned_ip_address = '.'.join(cleaned_octets)\n    \n    return cleaned_ip_address", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["0.0.0.0"]]}], "Mbpp/592": [{"task_id": "Mbpp/592", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/594": [{"task_id": "Mbpp/594", "solution": "def diff_even_odd(numbers):\n    \"\"\"\n    This function finds the difference between the first even and the first odd number in a given list.\n    \n    Parameters:\n    numbers (list): A list of integers.\n    \n    Returns:\n    int: The difference between the first even and the first odd number.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in numbers:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        \n        # If both first_even and first_odd are found, break the loop\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # Calculate the difference\n    if first_even is not None and first_odd is not None:\n        return abs(first_even - first_odd)\n    else:\n        raise ValueError(\"The list must contain at least one even and one odd number.\")", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 5, 3, 6, 1, 4, 9, 8, 7]]]}], "Mbpp/596": [{"task_id": "Mbpp/596", "solution": "import sys\ndef tuple_size(t):\n    \"\"\"\n    This function returns the size in bytes of the given tuple.\n    \n    Parameters:\n    t (tuple): The tuple whose size is to be calculated.\n    \n    Returns:\n    int: The size of the tuple in bytes.\n    \"\"\"\n    return sys.getsizeof(t)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/597": [{"task_id": "Mbpp/597", "solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element from the two sorted arrays.\n\n    Parameters:\n    arr1 (list): First sorted array.\n    arr2 (list): Second sorted array.\n    k (int): The kth position (1-based index) to find the element.\n\n    Returns:\n    int: The kth element in the merged sorted array.\n    \"\"\"\n    # Initialize pointers for both arrays\n    index1, index2 = 0, 0\n\n    # Loop until we find the kth element\n    while True:\n        # If arr1 is exhausted, return the kth element from arr2\n        if index1 == len(arr1):\n            return arr2[index2 + k - 1]\n        \n        # If arr2 is exhausted, return the kth element from arr1\n        if index2 == len(arr2):\n            return arr1[index1 + k - 1]\n        \n        # If k is 1, return the minimum of the current elements\n        if k == 1:\n            return min(arr1[index1], arr2[index2])\n        \n        # Calculate the middle index for both arrays\n        mid1 = min(index1 + k // 2 - 1, len(arr1) - 1)\n        mid2 = min(index2 + k // 2 - 1, len(arr2) - 1)\n        \n        # Compare the elements at the middle indices\n        if arr1[mid1] <= arr2[mid2]:\n            # Move the pointer in arr1\n            k -= (mid1 - index1 + 1)\n            index1 = mid1 + 1\n        else:\n            # Move the pointer in arr2\n            k -= (mid2 - index2 + 1)\n            index2 = mid2 + 1", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 1], [], 3]]}], "Mbpp/599": [{"task_id": "Mbpp/599", "solution": "def sum_average(n):\n    \"\"\"\n    Calculate the sum and average of the first n natural numbers.\n\n    Parameters:\n    n (int): The number of natural numbers to consider.\n\n    Returns:\n    tuple: A tuple containing the sum and average of the first n natural numbers.\n    \"\"\"\n    # Calculate the sum of the first n natural numbers using the formula n * (n + 1) / 2\n    total_sum = n * (n + 1) // 2\n    \n    # Calculate the average by dividing the sum by n\n    average = total_sum / n\n    \n    return total_sum, average", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/598": [{"task_id": "Mbpp/598", "solution": "def armstrong_number(n):\n    \"\"\"\n    Check if a number is an Armstrong number.\n\n    An Armstrong number (also known as a narcissistic number) is a number that is equal to the sum of its own digits each raised to the power of the number of digits.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is an Armstrong number, False otherwise.\n    \"\"\"\n    # Convert the number to a string to easily iterate over digits\n    digits = str(n)\n    # Calculate the number of digits\n    num_digits = len(digits)\n    # Calculate the sum of each digit raised to the power of the number of digits\n    sum_of_powers = sum(int(digit) ** num_digits for digit in digits)\n    # Check if the sum of powers is equal to the original number\n    return sum_of_powers == n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/600": [{"task_id": "Mbpp/600", "solution": "def is_Even(number):\n    \"\"\"\n    This function checks whether a given number is even or not.\n    \n    Parameters:\n    number (int): The number to check.\n    \n    Returns:\n    bool: True if the number is even, False otherwise.\n    \"\"\"\n    # A number is even if it is divisible by 2 with no remainder\n    return number % 2 == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/603": [{"task_id": "Mbpp/603", "solution": "def get_ludic(n):\n    \"\"\"\n    Function to return all ludic numbers less than or equal to a given integer n.\n    \n    A ludic number is a number that remains after a sieving process similar to the Sieve of Eratosthenes.\n    The process is as follows:\n    1. Start with a list of integers from 1 to n.\n    2. Remove every second number, starting with the second number.\n    3. The first number in the list is a ludic number.\n    4. Remove every third number from the remaining list, starting with the third number.\n    5. Repeat the process, each time removing every k-th number, where k is the next number in the list.\n    6. Continue until the list cannot be reduced further.\n    \n    Parameters:\n    n (int): The upper limit integer to find ludic numbers up to.\n    \n    Returns:\n    list: A list of ludic numbers less than or equal to n.\n    \"\"\"\n    if n < 1:\n        return []\n\n    # Initialize the list of numbers from 1 to n\n    numbers = list(range(1, n + 1))\n    index = 1  # Start with the second number (index 1 in zero-based index)\n\n    while index < len(numbers):\n        # The current number at this index is the next ludic number\n        current_ludic = numbers[index]\n        \n        # Remove every current_ludic-th number from the list, starting from the current index\n        numbers = [num for i, num in enumerate(numbers) if (i + 1) % current_ludic != 0]\n        \n        # Move to the next index\n        index += 1\n\n    return numbers", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[100]]}], "Mbpp/602": [{"task_id": "Mbpp/602", "solution": "def first_repeated_char(s):\n    \"\"\"\n    This function finds the first repeated character in a given string.\n    \n    :param s: The input string to search for repeated characters.\n    :return: The first repeated character if found, otherwise None.\n    \"\"\"\n    # Create a set to keep track of characters we have seen\n    seen_chars = set()\n    \n    # Iterate over each character in the string\n    for char in s:\n        # If the character is already in the set, it's the first repeated character\n        if char in seen_chars:\n            return char\n        # Otherwise, add the character to the set\n        seen_chars.add(char)\n    \n    # If no repeated character is found, return None\n    return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/604": [{"task_id": "Mbpp/604", "solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in a given string.\n\n    Parameters:\n    s (str): A string containing words separated by spaces.\n\n    Returns:\n    str: A string with the words in reverse order.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list of words back into a string with spaces\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/606": [{"task_id": "Mbpp/606", "solution": "import math\ndef radian_degree(degrees):\n    \"\"\"\n    Convert degrees to radians.\n\n    Parameters:\n    degrees (float): Angle in degrees.\n\n    Returns:\n    float: Angle in radians.\n    \"\"\"\n    # Convert degrees to radians using the formula: radians = degrees * (pi / 180)\n    radians = degrees * (math.pi / 180)\n    return radians", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/605": [{"task_id": "Mbpp/605", "solution": "def is_prime(n):\n    \"\"\"\n    Check if the given integer n is a prime number.\n\n    Parameters:\n    n (int): The integer to check for primality.\n\n    Returns:\n    bool: True if n is a prime number, False otherwise.\n    \"\"\"\n    # Handle edge cases for numbers less than 2\n    if n <= 1:\n        return False\n    # 2 is the only even prime number\n    if n == 2:\n        return True\n    # Eliminate all other even numbers\n    if n % 2 == 0:\n        return False\n    # Check for factors from 3 to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\n# Test the function with the given assertion\nassert is_prime(13) == True\n\n# Additional test cases\nassert is_prime(1) == False  # 1 is not a prime number\nassert is_prime(2) == True   # 2 is a prime number\nassert is_prime(4) == False  # 4 is not a prime number\nassert is_prime(17) == True  # 17 is a prime number\nassert is_prime(18) == False # 18 is not a prime number\nassert is_prime(19) == True  # 19 is a prime number\n\nprint(\"All tests passed.\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/607": [{"task_id": "Mbpp/607", "solution": "import re\ndef find_literals(text, pattern):\n    \"\"\"\n    Searches for a regex pattern in a given string and returns the matching substring,\n    along with its start and end indices.\n\n    Parameters:\n    text (str): The string to search within.\n    pattern (str): The regex pattern to search for.\n\n    Returns:\n    tuple: A tuple containing the matching substring, start index, and end index.\n           Returns None if no match is found.\n    \"\"\"\n    # Use re.search to find the first occurrence of the pattern\n    match = re.search(pattern, text)\n    \n    if match:\n        # Extract the start and end indices from the match object\n        start_index = match.start()\n        end_index = match.end()\n        # Extract the matching substring\n        matching_substring = match.group()\n        return (matching_substring, start_index, end_index)\n    \n    # Return None if no match is found\n    return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/610": [{"task_id": "Mbpp/610", "solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list.\n\n    Parameters:\n    lst (list): The list from which to remove the element.\n    k (int): The index of the element to remove.\n\n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    # Check if k is within the valid range\n    if k < 0 or k >= len(lst):\n        raise IndexError(\"Index k is out of bounds for the list.\")\n    \n    # Return a new list with the k'th element removed\n    return lst[:k] + lst[k+1:]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 1, 2, 3, 4, 4, 5, 1], 3]], "plus_fail_tests": [[[1, 2, 3, 4, 5], 1]]}], "Mbpp/608": [{"task_id": "Mbpp/608", "solution": "def bell_Number(n):\n    \"\"\"\n    Calculate the nth Bell number.\n    \n    The Bell number is defined as the number of ways to partition a set of n elements.\n    \n    Parameters:\n    n (int): The index of the Bell number to calculate.\n    \n    Returns:\n    int: The nth Bell number.\n    \"\"\"\n    # Create a 2D array to store Bell numbers\n    bell = [[0 for i in range(n+1)] for j in range(n+1)]\n    \n    # Base case: Bell(0) is 1\n    bell[0][0] = 1\n    \n    # Fill the Bell triangle\n    for i in range(1, n+1):\n        # Explicitly put the last value of the previous row as the first value of the current row\n        bell[i][0] = bell[i-1][i-1]\n        \n        # Fill the rest of the current row\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    # The nth Bell number is the first element of the nth row\n    return bell[n][0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/611": [{"task_id": "Mbpp/611", "solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the n-th column in the given matrix.\n\n    :param matrix: List of lists where each inner list represents a row of the matrix.\n    :param n: The index of the column to find the maximum value of.\n    :return: The maximum value in the n-th column.\n    \"\"\"\n    # Extract the n-th column from the matrix\n    nth_column = [row[n] for row in matrix]\n    \n    # Return the maximum value in the n-th column\n    return max(nth_column)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/612": [{"task_id": "Mbpp/612", "solution": "def merge(list_of_lists):\n    \"\"\"\n    This function takes a list of lists, where each sublist contains exactly two elements.\n    It returns a list of two lists:\n    - The first list contains the first element of each sublist.\n    - The second list contains the second element of each sublist.\n    \n    :param list_of_lists: List of lists, where each sublist has exactly two elements.\n    :return: A list of two lists as described above.\n    \"\"\"\n    # Initialize two empty lists to hold the first and second elements\n    first_elements = []\n    second_elements = []\n    \n    # Iterate over each sublist in the input list\n    for sublist in list_of_lists:\n        # Append the first element of the sublist to the first_elements list\n        first_elements.append(sublist[0])\n        # Append the second element of the sublist to the second_elements list\n        second_elements.append(sublist[1])\n    \n    # Return a list containing the two lists\n    return [first_elements, second_elements]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/614": [{"task_id": "Mbpp/614", "solution": "def cumulative_sum(tuple_list):\n    \"\"\"\n    Calculate the cumulative sum of all the values present in the given list of tuples.\n\n    Parameters:\n    tuple_list (list of tuples): A list where each element is a tuple containing integers.\n\n    Returns:\n    int: The cumulative sum of all integers in the tuples.\n    \"\"\"\n    # Initialize the sum to zero\n    total_sum = 0\n    \n    # Iterate over each tuple in the list\n    for tup in tuple_list:\n        # Add the sum of the current tuple to the total sum\n        total_sum += sum(tup)\n    \n    return total_sum\n\n# Test the function with the provided test case\nassert cumulative_sum([(1, 3), (5, 6, 7), (2, 6)]) == 30\n\n# Additional test cases\nprint(cumulative_sum([(0, 0), (0, 0, 0), (0, 0)]))  # Expected output: 0\nprint(cumulative_sum([(1, 2, 3), (4, 5), (6,)]))   # Expected output: 21\nprint(cumulative_sum([(10,), (20, 30), (40, 50)])) # Expected output: 150", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/616": [{"task_id": "Mbpp/616", "solution": "def tuple_modulo(tuple1, tuple2):\n    \"\"\"\n    Perform element-wise modulo operation on two tuples of the same length.\n\n    Parameters:\n    tuple1 (tuple): The first tuple containing integers.\n    tuple2 (tuple): The second tuple containing integers.\n\n    Returns:\n    tuple: A tuple containing the result of element-wise modulo operation.\n    \"\"\"\n    # Ensure both tuples are of the same length\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Both tuples must be of the same length.\")\n    \n    # Perform element-wise modulo operation\n    result = tuple(a % b for a, b in zip(tuple1, tuple2))\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/615": [{"task_id": "Mbpp/615", "solution": "def average_tuple(tuples):\n    \"\"\"\n    This function takes a tuple of tuples and returns a list containing the average value of each inner tuple.\n    \n    Parameters:\n    tuples (tuple of tuples): A tuple containing multiple tuples of numbers.\n    \n    Returns:\n    list: A list of average values for each tuple.\n    \"\"\"\n    averages = []\n    for t in tuples:\n        # Calculate the average of the current tuple\n        avg = sum(t) / len(t)\n        # Append the average to the result list\n        averages.append(avg)\n    return averages", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]]], "plus_fail_tests": [[[[7, 8, 9], [-2, -4, -6], [0, 20, 30]]]]}], "Mbpp/618": [{"task_id": "Mbpp/618", "solution": "def div_list(list1, list2):\n    \"\"\"\n    Divides elements of two lists element-wise.\n\n    Parameters:\n    list1 (list of int/float): The dividend list.\n    list2 (list of int/float): The divisor list.\n\n    Returns:\n    list of float: A list containing the result of element-wise division.\n    \n    Raises:\n    ValueError: If the lists are not of the same length.\n    ZeroDivisionError: If an element in list2 is zero.\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Both lists must have the same length.\")\n    \n    result = []\n    for i in range(len(list1)):\n        if list2[i] == 0:\n            raise ZeroDivisionError(\"Division by zero encountered in list2 at index {}\".format(i))\n        result.append(list1[i] / list2[i])\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/620": [{"task_id": "Mbpp/620", "solution": "def largest_subset(nums):\n    if not nums:\n        return 0\n\n    # Sort the numbers to ensure that for any pair (nums[i], nums[j]) with i < j, nums[j] % nums[i] is checked correctly\n    nums.sort()\n    \n    # dp[i] will store the size of the largest divisible subset that ends with nums[i]\n    dp = [1] * len(nums)\n    \n    # Iterate over each number and check divisibility with previous numbers\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] % nums[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    # The result is the maximum value in the dp array\n    return max(dp)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[9, 3, 12, 7, 16, 3, 11, 8, 4, 13, 13]]]}], "Mbpp/619": [{"task_id": "Mbpp/619", "solution": "def move_num(s):\n    # Initialize two lists to separate characters and numbers\n    chars = []\n    nums = []\n    \n    # Temporary variable to store consecutive digits\n    current_num = ''\n    \n    for char in s:\n        if char.isdigit():\n            # If the character is a digit, add it to the current number\n            current_num += char\n        else:\n            # If the character is not a digit, append any collected number to nums\n            if current_num:\n                nums.append(current_num)\n                current_num = ''\n            # Append the non-digit character to chars\n            chars.append(char)\n    \n    # If there's a number left at the end, append it to nums\n    if current_num:\n        nums.append(current_num)\n    \n    # Join the characters and numbers separately and concatenate them\n    return ''.join(chars) + ''.join(nums)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/622": [{"task_id": "Mbpp/622", "solution": "def get_median(arr1, arr2, n):\n    \"\"\"\n    Find the median of two sorted arrays of the same size.\n\n    Parameters:\n    arr1 (list): First sorted list.\n    arr2 (list): Second sorted list.\n    n (int): Size of each list.\n\n    Returns:\n    float: The median of the two lists.\n    \"\"\"\n    # Base case for recursion\n    if n <= 0:\n        return -1\n    if n == 1:\n        return (arr1[0] + arr2[0]) / 2\n    if n == 2:\n        return (max(arr1[0], arr2[0]) + min(arr1[1], arr2[1])) / 2\n\n    # Calculate medians of the arrays\n    m1 = median(arr1, n)\n    m2 = median(arr2, n)\n\n    # If medians are equal, return either\n    if m1 == m2:\n        return m1\n\n    # If m1 < m2, then median must be in arr1[m1...] and arr2[...m2]\n    if m1 < m2:\n        if n % 2 == 0:\n            return get_median(arr1[n//2 - 1:], arr2[:n//2 + 1], n - n//2 + 1)\n        return get_median(arr1[n//2:], arr2[:n//2 + 1], n - n//2)\n\n    # If m1 > m2, then median must be in arr1[...m1] and arr2[m2...]\n    if n % 2 == 0:\n        return get_median(arr1[:n//2 + 1], arr2[n//2 - 1:], n - n//2 + 1)\n    return get_median(arr1[:n//2 + 1], arr2[n//2:], n - n//2)\ndef median(arr, n):\n    \"\"\"\n    Helper function to find the median of a sorted array.\n\n    Parameters:\n    arr (list): Sorted list.\n    n (int): Size of the list.\n\n    Returns:\n    float: The median of the list.\n    \"\"\"\n    if n % 2 == 0:\n        return (arr[n//2] + arr[n//2 - 1]) / 2\n    else:\n        return arr[n//2]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1], [2], 0]]}], "Mbpp/623": [{"task_id": "Mbpp/623", "solution": "def nth_nums(numbers, n):\n    \"\"\"\n    Compute the n-th power of each number in a list.\n\n    Parameters:\n    numbers (list of int): A list of integers.\n    n (int): The power to which each number in the list should be raised.\n\n    Returns:\n    list of int: A list containing each number in the input list raised to the n-th power.\n    \"\"\"\n    # Use list comprehension to apply the power operation to each element in the list\n    return [num ** n for num in numbers]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/624": [{"task_id": "Mbpp/624", "solution": "def is_upper(s):\n    \"\"\"\n    Convert a given string to uppercase.\n\n    Parameters:\n    s (str): The string to be converted to uppercase.\n\n    Returns:\n    str: The uppercase version of the input string.\n    \"\"\"\n    # Use the built-in str.upper() method to convert the string to uppercase\n    return s.upper()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/628": [{"task_id": "Mbpp/628", "solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces all spaces in the given string with '%20'.\n\n    Parameters:\n    input_string (str): The string in which spaces need to be replaced.\n\n    Returns:\n    str: A new string with all spaces replaced by '%20'.\n    \"\"\"\n    # Use the built-in string method `replace` to substitute spaces with '%20'\n    return input_string.replace(' ', '%20')", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/626": [{"task_id": "Mbpp/626", "solution": "def triangle_area(radius):\n    \"\"\"\n    Calculate the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n    \n    Parameters:\n    radius (float): The radius of the semicircle.\n    \n    Returns:\n    float: The area of the largest inscribed triangle, or None if the radius is negative.\n    \"\"\"\n    if radius < 0:\n        return None\n    # The largest triangle is a right triangle with base and height equal to the radius\n    return (radius ** 2) / 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[0.5]]}], "Mbpp/629": [{"task_id": "Mbpp/629", "solution": "def find_even_numbers(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns a list of even numbers.\n    \n    :param numbers: List of integers\n    :return: List of even integers\n    \"\"\"\n    # Use list comprehension to filter even numbers\n    even_numbers = [num for num in numbers if num % 2 == 0]\n    return even_numbers\n\n# Test the function with an example\nassert find_even_numbers([1, 2, 3, 4, 5]) == [2, 4]\n\n# Example usage\nif __name__ == \"__main__\":\n    numbers = [10, 15, 20, 25, 30]\n    print(\"Even numbers:\", find_even_numbers(numbers))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/631": [{"task_id": "Mbpp/631", "solution": "def replace_spaces(input_string):\n    \"\"\"\n    This function takes a string as input and replaces all whitespaces with underscores\n    and all underscores with whitespaces.\n\n    :param input_string: The string to be modified.\n    :return: A new string with whitespaces and underscores swapped.\n    \"\"\"\n    # Create a translation table for swapping spaces and underscores\n    translation_table = str.maketrans(' _', '_ ')\n    \n    # Translate the input string using the translation table\n    return input_string.translate(translation_table)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/632": [{"task_id": "Mbpp/632", "solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Parameters:\n    lst (list): The list of integers to process.\n\n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    # Initialize a list to store non-zero elements\n    non_zero_elements = []\n    \n    # Count the number of zeroes\n    zero_count = 0\n    \n    # Iterate through the list\n    for num in lst:\n        if num != 0:\n            # Append non-zero elements to the non_zero_elements list\n            non_zero_elements.append(num)\n        else:\n            # Increment zero_count for each zero encountered\n            zero_count += 1\n    \n    # Extend the non_zero_elements list with zeroes at the end\n    non_zero_elements.extend([0] * zero_count)\n    \n    return non_zero_elements", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/633": [{"task_id": "Mbpp/633", "solution": "def pair_xor_sum(arr, n):\n    \"\"\"\n    Calculate the sum of XOR for all pairs in the given list.\n\n    Parameters:\n    arr (list): A list of integers.\n    n (int): The number of elements in the list.\n\n    Returns:\n    int: The sum of XOR of all pairs.\n    \"\"\"\n    xor_sum = 0\n    # Iterate over all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate XOR for the pair and add to the total sum\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum\n\n# Test the function with the provided test case\nassert pair_xor_sum([5, 9, 7, 6], 4) == 47\n\n# Additional test cases\nprint(pair_xor_sum([1, 2, 3], 3))  # Expected output: 6 (1^2 + 1^3 + 2^3 = 3 + 2 + 1)\nprint(pair_xor_sum([0, 0, 0], 3))  # Expected output: 0 (all pairs XOR to 0)\nprint(pair_xor_sum([1, 1, 1, 1], 4))  # Expected output: 0 (all pairs XOR to 0)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/635": [{"task_id": "Mbpp/635", "solution": "def heap_sort(arr):\n    \"\"\"\n    Function to perform heap sort on a list.\n    :param arr: List of elements to be sorted\n    :return: Sorted list\n    \"\"\"\n    n = len(arr)\n\n    # Build a maxheap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    # One by one extract elements\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]  # Swap\n        heapify(arr, i, 0)\n\n    return arr", "base_status": "fail", "plus_status": "pass", "base_fail_tests": [[[1, 3, 5, 7, 9, 2, 4, 6, 8, 0]]], "plus_fail_tests": []}], "Mbpp/637": [{"task_id": "Mbpp/637", "solution": "def noprofit_noloss(cost_price, selling_price):\n    \"\"\"\n    This function checks if there is no profit and no loss.\n    \n    Parameters:\n    cost_price (float): The cost price of the item.\n    selling_price (float): The selling price of the item.\n    \n    Returns:\n    bool: True if there is no profit and no loss, False otherwise.\n    \"\"\"\n    # Check if the cost price is equal to the selling price\n    return cost_price == selling_price", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/638": [{"task_id": "Mbpp/638", "solution": "def wind_chill(velocity, temperature):\n    \"\"\"\n    Calculate the wind chill index given the wind velocity in km/h and temperature in Celsius.\n    The result is rounded to the nearest integer.\n    \n    Parameters:\n    velocity (float): Wind velocity in km/h\n    temperature (float): Temperature in Celsius\n    \n    Returns:\n    int: Wind chill index rounded to the nearest integer\n    \"\"\"\n    # Calculate the wind chill using the formula\n    wind_chill_index = (13.12 + 0.6215 * temperature \n                        - 11.37 * (velocity ** 0.16) \n                        + 0.3965 * temperature * (velocity ** 0.16))\n    \n    # Round the result to the nearest integer\n    return round(wind_chill_index)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/639": [{"task_id": "Mbpp/639", "solution": "def sum_name_lengths(names):\n    \"\"\"\n    This function takes a list of names and returns the sum of the lengths of the names\n    that do not start with a lowercase letter.\n    \n    :param names: List of names (strings)\n    :return: Sum of the lengths of names that start with an uppercase letter\n    \"\"\"\n    # Filter out names that start with a lowercase letter\n    filtered_names = [name for name in names if not name[0].islower()]\n    \n    # Calculate the sum of the lengths of the remaining names\n    total_length = sum(len(name) for name in filtered_names)\n    \n    return total_length\n\n# Test the function with the provided test case\nassert sum_name_lengths(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16\n\n# Additional test cases\nprint(sum_name_lengths(['Alice', 'bob', 'Charlie', 'dave']))  # Expected output: 11 (Alice + Charlie)\nprint(sum_name_lengths(['Eve', 'Frank', 'george']))           # Expected output: 9 (Eve + Frank)\nprint(sum_name_lengths(['harry', 'Irene', 'Jack']))           # Expected output: 8 (Irene + Jack)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/641": [{"task_id": "Mbpp/641", "solution": "def nth_nonagonal_number(n):\n    \"\"\"\n    Calculate the nth nonagonal number using the formula:\n    N(n) = (7n^2 - 5n) / 2\n    \"\"\"\n    return (7 * n * n - 5 * n) // 2\ndef is_nonagonal(n):\n    \"\"\"\n    Wrapper function to find the nth nonagonal number.\n    \"\"\"\n    return nth_nonagonal_number(n)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/630": [{"task_id": "Mbpp/630", "solution": "def get_coordinates(coord):\n    \"\"\"\n    Given a coordinate tuple (x, y), this function returns a list of all adjacent coordinates\n    including the coordinate itself. The adjacent coordinates are those that differ by at most\n    1 in either the x or y direction.\n\n    :param coord: A tuple (x, y) representing the coordinate.\n    :return: A list of lists, where each inner list is an adjacent coordinate [x, y].\n    \"\"\"\n    x, y = coord\n    adjacent_coords = []\n\n    # Iterate over the range x-1 to x+1 and y-1 to y+1 to get all adjacent coordinates\n    for i in range(x - 1, x + 2):\n        for j in range(y - 1, y + 2):\n            adjacent_coords.append([i, j])\n\n    return adjacent_coords", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 1, 1]]]}], "Mbpp/643": [{"task_id": "Mbpp/643", "solution": "def text_match_wordz_middle(s):\n    \"\"\"\n    This function checks if the string contains the letter 'z', \n    except at the start and end of the word.\n    \n    Parameters:\n    s (str): The input string to check.\n    \n    Returns:\n    bool: True if 'z' is found in the middle of the string, False otherwise.\n    \"\"\"\n    # Check if the string is long enough to have a middle\n    if len(s) <= 2:\n        return False\n    \n    # Check for 'z' in the middle of the string (excluding first and last character)\n    return 'z' in s[1:-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/720": [{"task_id": "Mbpp/720", "solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    This function takes a tuple and a dictionary as inputs and returns a new tuple\n    with the dictionary added as the last element of the tuple.\n\n    :param input_tuple: A tuple to which the dictionary will be added\n    :param input_dict: A dictionary to be added to the tuple\n    :return: A new tuple with the dictionary added as the last element\n    \"\"\"\n    # Create a new tuple by concatenating the input tuple with a single-element tuple containing the dictionary\n    result_tuple = input_tuple + (input_dict,)\n    return result_tuple", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/644": [{"task_id": "Mbpp/644", "solution": "def reverse_array_upto_k(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position (0-based index).\n    \n    Parameters:\n    arr (list): The list of elements to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with elements reversed up to the k-th position.\n    \"\"\"\n    # Ensure k is within the bounds of the array\n    if k < 0 or k >= len(arr):\n        raise ValueError(\"k must be within the bounds of the array indices.\")\n    \n    # Reverse the portion of the array from the start up to the k-th position\n    reversed_part = arr[:k][::-1]\n    # Concatenate the reversed part with the rest of the array\n    result = reversed_part + arr[k:]\n    \n    return result\n\n# Test the function with the provided test case\nassert reverse_array_upto_k([1, 2, 3, 4, 5, 6], 4) == [4, 3, 2, 1, 5, 6]\n\n# Additional test cases\nprint(reverse_array_upto_k([1, 2, 3, 4, 5, 6], 4))  # Output: [4, 3, 2, 1, 5, 6]\nprint(reverse_array_upto_k([10, 20, 30, 40, 50], 3))  # Output: [30, 20, 10, 40, 50]\nprint(reverse_array_upto_k([7, 8, 9], 2))  # Output: [8, 7, 9]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/721": [{"task_id": "Mbpp/721", "solution": "def maxAverageOfPath(matrix):\n    \"\"\"\n    This function calculates the maximum average path from the top-left to the bottom-right\n    of a given square matrix, where you can only move right or down.\n    \n    :param matrix: List of lists representing the square matrix with costs.\n    :return: Maximum average of any path from top-left to bottom-right.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return 0\n\n    N = len(matrix)\n    \n    # Create a dp table to store the maximum sum up to each cell\n    dp = [[0] * N for _ in range(N)]\n    \n    # Initialize the starting point\n    dp[0][0] = matrix[0][0]\n    \n    # Fill the first row (can only come from the left)\n    for j in range(1, N):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    \n    # Fill the first column (can only come from above)\n    for i in range(1, N):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    \n    # Fill the rest of the dp table\n    for i in range(1, N):\n        for j in range(1, N):\n            # The cell can be reached either from the left or from above\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    # The maximum sum path to the bottom-right corner\n    max_sum = dp[N-1][N-1]\n    \n    # The number of cells in the path from top-left to bottom-right\n    num_cells = 2 * N - 1\n    \n    # Calculate the maximum average\n    max_average = max_sum / num_cells\n    \n    return max_average", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/722": [{"task_id": "Mbpp/722", "solution": "def filter_data(students, min_height, min_weight):\n    \"\"\"\n    Filters students based on minimum height and weight criteria.\n\n    Parameters:\n    students (dict): A dictionary where the key is the student's name and the value is a tuple (height, weight).\n    min_height (float): The minimum height requirement.\n    min_weight (float): The minimum weight requirement.\n\n    Returns:\n    dict: A dictionary of students who meet both the height and weight criteria.\n    \"\"\"\n    # Initialize an empty dictionary to store students who meet the criteria\n    filtered_students = {}\n\n    # Iterate over each student in the dictionary\n    for student, (height, weight) in students.items():\n        # Check if both height and weight are above the minimum requirements\n        if height > min_height and weight > min_weight:\n            # Add the student to the filtered dictionary\n            filtered_students[student] = (height, weight)\n\n    return filtered_students", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"Cierra Vega": [6.2, 70], "Alden Cantrell": [5.9, 65], "Kierra Gentry": [6.0, 68], "Pierre Cox": [5.8, 66]}, 6.0, 70]], "plus_fail_tests": [[{"Alice": [5.6, 60], "Bob": [6.1, 70], "Charlie": [5.9, 65], "Dave": [5.11, 72], "Eve": [6.0, 68], "Frank": [5.7, 63]}, 5.8, 65]]}], "Mbpp/723": [{"task_id": "Mbpp/723", "solution": "def count_same_pair(list1, list2):\n    \"\"\"\n    This function takes two lists of the same length and returns the count of indices\n    where the elements in both lists are the same.\n\n    Parameters:\n    list1 (list): The first list of elements.\n    list2 (list): The second list of elements.\n\n    Returns:\n    int: The count of indices where the elements in both lists are the same.\n    \"\"\"\n    # Initialize a counter to keep track of matching indices\n    count = 0\n    \n    # Iterate over the indices of the lists\n    for i in range(len(list1)):\n        # Check if the elements at the current index are the same\n        if list1[i] == list2[i]:\n            # Increment the counter if they are the same\n            count += 1\n    \n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/725": [{"task_id": "Mbpp/725", "solution": "def extract_quotation(s):\n    \"\"\"\n    Extracts and returns a list of substrings found between quotation marks in the given string.\n\n    Parameters:\n    s (str): The input string from which to extract quoted substrings.\n\n    Returns:\n    list: A list of substrings found between quotation marks.\n    \"\"\"\n    import re\n    # Use a regular expression to find all substrings enclosed in double quotes\n    return re.findall(r'\"(.*?)\"', s)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/724": [{"task_id": "Mbpp/724", "solution": "def power_base_sum(base, power):\n    \"\"\"\n    Calculate the sum of all digits of the base raised to the specified power.\n\n    Parameters:\n    base (int): The base number.\n    power (int): The power to which the base is raised.\n\n    Returns:\n    int: The sum of the digits of the result.\n    \"\"\"\n    # Calculate base raised to the power\n    result = base ** power\n    \n    # Convert the result to a string to iterate over each digit\n    result_str = str(result)\n    \n    # Calculate the sum of the digits\n    digit_sum = sum(int(digit) for digit in result_str)\n    \n    return digit_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/726": [{"task_id": "Mbpp/726", "solution": "def multiply_elements(input_tuple):\n    \"\"\"\n    This function takes a tuple of numbers and returns a new tuple where each element is the product\n    of consecutive elements from the input tuple.\n\n    :param input_tuple: A tuple of numbers (t_1, t_2, ..., t_{N+1})\n    :return: A tuple of length N where each element is t_i * t_{i+1}\n    \"\"\"\n    # Initialize an empty list to store the products\n    result = []\n    \n    # Iterate over the input tuple, stopping at the second to last element\n    for i in range(len(input_tuple) - 1):\n        # Calculate the product of the current element and the next element\n        product = input_tuple[i] * input_tuple[i + 1]\n        # Append the product to the result list\n        result.append(product)\n    \n    # Convert the result list to a tuple and return it\n    return tuple(result)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/730": [{"task_id": "Mbpp/730", "solution": "def consecutive_duplicates(lst):\n    \"\"\"\n    Remove consecutive duplicates from the list.\n    \n    Parameters:\n    lst (list): The input list from which consecutive duplicates need to be removed.\n    \n    Returns:\n    list: A new list with consecutive duplicates removed.\n    \"\"\"\n    if not lst:\n        return []  # Return an empty list if the input list is empty\n\n    # Initialize the result list with the first element of the input list\n    result = [lst[0]]\n\n    # Iterate over the input list starting from the second element\n    for i in range(1, len(lst)):\n        # Add the current element to the result list if it's different from the last added element\n        if lst[i] != lst[i - 1]:\n            result.append(lst[i])\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/728": [{"task_id": "Mbpp/728", "solution": "def sum_list(list_a, list_b):\n    \"\"\"\n    Takes two lists of equal length and returns a new list where each element is the sum of the elements\n    at the corresponding positions in the input lists.\n\n    Parameters:\n    list_a (list): The first list of numbers.\n    list_b (list): The second list of numbers.\n\n    Returns:\n    list: A list containing the sums of the corresponding elements of list_a and list_b.\n    \"\"\"\n    # Check if both lists have the same length\n    if len(list_a) != len(list_b):\n        raise ValueError(\"Both lists must have the same length.\")\n    \n    # Use a list comprehension to sum corresponding elements from both lists\n    return [a + b for a, b in zip(list_a, list_b)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/731": [{"task_id": "Mbpp/731", "solution": "import math\ndef lateralsurface_cone(r, h):\n    \"\"\"\n    Calculate the lateral surface area of a cone.\n\n    Parameters:\n    r (float): The radius of the base of the cone.\n    h (float): The height of the cone.\n\n    Returns:\n    float: The lateral surface area of the cone.\n    \"\"\"\n    # Calculate the slant height of the cone using the Pythagorean theorem\n    slant_height = math.sqrt(r**2 + h**2)\n    \n    # Calculate the lateral surface area\n    lateral_surface_area = math.pi * r * slant_height\n    \n    return lateral_surface_area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/733": [{"task_id": "Mbpp/733", "solution": "def find_first_occurrence(arr, target):\n    \"\"\"\n    Finds the index of the first occurrence of the target number in a sorted array.\n    \n    Parameters:\n    arr (list of int): A sorted list of integers.\n    target (int): The number to find the first occurrence of.\n    \n    Returns:\n    int: The index of the first occurrence of the target number, or -1 if the target is not found.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    result = -1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        # Check if the mid element is the target\n        if arr[mid] == target:\n            result = mid\n            # Move left to find the first occurrence\n            right = mid - 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/732": [{"task_id": "Mbpp/732", "solution": "def replace_specialchar(text):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots in the input text with a colon.\n\n    Parameters:\n    text (str): The input string to be processed.\n\n    Returns:\n    str: The processed string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Define the characters to be replaced\n    special_chars = \" ,.\"\n    \n    # Replace each special character with a colon\n    for char in special_chars:\n        text = text.replace(char, ':')\n    \n    return text", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/734": [{"task_id": "Mbpp/734", "solution": "def sum_of_subarray_prod(lst):\n    \"\"\"\n    Calculate the sum of products of all possible sublists of the given list.\n\n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    int: The sum of products of all possible sublists.\n    \"\"\"\n    from itertools import combinations\n    total_sum = 0\n    \n    # Iterate over all possible sublist lengths (1 to len(lst))\n    for r in range(1, len(lst) + 1):\n        # Generate all combinations of the current length\n        for sublist in combinations(lst, r):\n            # Calculate the product of the current sublist\n            product = 1\n            for num in sublist:\n                product *= num\n            # Add the product to the total sum\n            total_sum += product\n    \n    return total_sum\n\n# Test the function with the provided test case\nassert sum_of_subarray_prod([1, 2, 3]) == 20\n\n# Example usage\nif __name__ == \"__main__\":\n    print(sum_of_subarray_prod([1, 2, 3]))  # Output should be 20", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/735": [{"task_id": "Mbpp/735", "solution": "def toggle_middle_bits(n):\n    \"\"\"\n    Toggle all bits of the number `n` except the first and the last bit.\n    \n    Parameters:\n    n (int): The input number whose middle bits are to be toggled.\n    \n    Returns:\n    int: The number after toggling the middle bits.\n    \"\"\"\n    # Convert the number to its binary representation as a string\n    binary_str = bin(n)[2:]  # Remove the '0b' prefix\n    \n    # If the binary representation has less than 3 bits, no middle bits to toggle\n    if len(binary_str) <= 2:\n        return n\n    \n    # Extract the first and last bits\n    first_bit = binary_str[0]\n    last_bit = binary_str[-1]\n    \n    # Extract the middle bits and toggle them\n    middle_bits = binary_str[1:-1]\n    toggled_middle_bits = ''.join('1' if bit == '0' else '0' for bit in middle_bits)\n    \n    # Reconstruct the binary string with toggled middle bits\n    toggled_binary_str = first_bit + toggled_middle_bits + last_bit\n    \n    # Convert the toggled binary string back to an integer\n    return int(toggled_binary_str, 2)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[true]]}], "Mbpp/736": [{"task_id": "Mbpp/736", "solution": "def left_insertion(sorted_list, value):\n    \"\"\"\n    This function finds the left insertion point for a specified value in a sorted list.\n    The left insertion point is the index at which the value can be inserted while maintaining\n    the sorted order of the list. If the value is already present, it returns the index of the\n    first occurrence of the value.\n\n    :param sorted_list: List of sorted integers\n    :param value: Integer value to find the insertion point for\n    :return: Integer index representing the left insertion point\n    \"\"\"\n    # Initialize the left and right pointers for binary search\n    left, right = 0, len(sorted_list)\n    \n    # Perform binary search to find the left insertion point\n    while left < right:\n        mid = (left + right) // 2\n        if sorted_list[mid] < value:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/737": [{"task_id": "Mbpp/737", "solution": "import re\ndef check_str(s):\n    \"\"\"\n    This function checks if the given string starts with a vowel (case-insensitive).\n    \n    Parameters:\n    s (str): The string to check.\n    \n    Returns:\n    bool: True if the string starts with a vowel, False otherwise.\n    \"\"\"\n    # Define a regex pattern to match strings starting with a vowel (case-insensitive)\n    pattern = r'^[aeiouAEIOU]'\n    \n    # Use re.match to check if the string starts with a vowel\n    return bool(re.match(pattern, s))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/740": [{"task_id": "Mbpp/740", "solution": "def tuple_to_dict(tpl):\n    \"\"\"\n    Convert a tuple into a dictionary using adjacent elements as key-value pairs.\n\n    Parameters:\n    tpl (tuple): A tuple with an even number of elements.\n\n    Returns:\n    dict: A dictionary with keys and values from adjacent elements of the tuple.\n    \"\"\"\n    # Initialize an empty dictionary to store the key-value pairs\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2 to get adjacent elements\n    for i in range(0, len(tpl), 2):\n        # Assign the current element as the key and the next element as the value\n        result_dict[tpl[i]] = tpl[i + 1]\n    \n    return result_dict", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/741": [{"task_id": "Mbpp/741", "solution": "def all_Characters_Same(s: str) -> bool:\n    \"\"\"\n    Check if all characters in the string are the same.\n\n    Parameters:\n    s (str): The input string to check.\n\n    Returns:\n    bool: True if all characters are the same, False otherwise.\n    \"\"\"\n    # If the string is empty or has only one character, all characters are trivially the same\n    if len(s) <= 1:\n        return True\n    \n    # Compare each character with the first character\n    first_char = s[0]\n    for char in s:\n        if char != first_char:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/742": [{"task_id": "Mbpp/742", "solution": "import math\ndef area_tetrahedron(side_length):\n    \"\"\"\n    Calculate the surface area of a regular tetrahedron given the side length.\n\n    Parameters:\n    side_length (float): The length of a side of the tetrahedron.\n\n    Returns:\n    float: The surface area of the tetrahedron.\n    \"\"\"\n    # Calculate the area using the formula for the surface area of a regular tetrahedron\n    area = math.sqrt(3) * (side_length ** 2)\n    return area", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/743": [{"task_id": "Mbpp/743", "solution": "def rotate_right(lst, k):\n    \"\"\"\n    Rotates the list `lst` to the right by `k` positions.\n\n    Parameters:\n    lst (list): The list to be rotated.\n    k (int): The number of positions to rotate the list.\n\n    Returns:\n    list: The rotated list.\n    \"\"\"\n    # Handle edge cases where the list is empty or k is zero\n    if not lst or k == 0:\n        return lst\n    \n    # Calculate the effective number of rotations needed\n    k = k % len(lst)\n    \n    # Rotate the list by slicing\n    return lst[-k:] + lst[:-k]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/744": [{"task_id": "Mbpp/744", "solution": "def check_none(input_tuple):\n    \"\"\"\n    This function checks if the given tuple contains any None value.\n    \n    Parameters:\n    input_tuple (tuple): The tuple to check for None values.\n    \n    Returns:\n    bool: True if there is at least one None value in the tuple, False otherwise.\n    \"\"\"\n    # Iterate through each element in the tuple\n    for element in input_tuple:\n        # Check if the current element is None\n        if element is None:\n            return True\n    # If no None value is found, return False\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/745": [{"task_id": "Mbpp/745", "solution": "def divisible_by_digits(startnum, endnum):\n    def is_divisible_by_digits(number):\n        # Convert the number to a string to iterate over each digit\n        num_str = str(number)\n        for digit_char in num_str:\n            digit = int(digit_char)\n            # Skip if the digit is zero to avoid division by zero\n            if digit == 0:\n                return False\n            # Check if the number is divisible by this digit\n            if number % digit != 0:\n                return False\n        return True\n\n    # List to store numbers that meet the criteria\n    result = []\n    # Iterate over the range from startnum to endnum (inclusive)\n    for num in range(startnum, endnum + 1):\n        if is_divisible_by_digits(num):\n            result.append(num)\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/748": [{"task_id": "Mbpp/748", "solution": "def capital_words_spaces(s):\n    \"\"\"\n    This function takes a string `s` and inserts spaces before each capital letter,\n    except the first character if it is capitalized. It returns the modified string.\n    \n    Parameters:\n    s (str): The input string containing words starting with capital letters.\n    \n    Returns:\n    str: A new string with spaces inserted before each capital letter.\n    \"\"\"\n    # Initialize an empty list to store the characters with spaces\n    result = []\n    \n    # Iterate over each character in the string\n    for i, char in enumerate(s):\n        # Check if the character is uppercase and it's not the first character\n        if char.isupper() and i != 0:\n            # Add a space before the uppercase character\n            result.append(' ')\n        # Add the current character to the result list\n        result.append(char)\n    \n    # Join the list into a string and return\n    return ''.join(result)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["MyNameIsAIAndIAmHereToHelpYou"]]}], "Mbpp/749": [{"task_id": "Mbpp/749", "solution": "def sort_numeric_strings(string_list):\n    \"\"\"\n    Sorts a list of strings representing numbers in numerical order.\n\n    Parameters:\n    string_list (list of str): A list of strings, each representing a number.\n\n    Returns:\n    list of int: A list of integers sorted in numerical order.\n    \"\"\"\n    # Convert each string in the list to an integer\n    int_list = [int(num) for num in string_list]\n    \n    # Sort the list of integers\n    int_list.sort()\n    \n    return int_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/750": [{"task_id": "Mbpp/750", "solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple whose elements are to be added to the list.\n\n    Returns:\n    list: The list with the tuple elements added at the end.\n    \"\"\"\n    # Extend the list with the elements of the tuple\n    lst.extend(tpl)\n    return lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/751": [{"task_id": "Mbpp/751", "solution": "def check_min_heap(arr):\n    \"\"\"\n    Function to check if the given array represents a min heap.\n    \n    A min heap is a complete binary tree where the value of each node is less than or equal to the values of its children.\n    \n    Parameters:\n    arr (list): The array to be checked.\n    \n    Returns:\n    bool: True if the array represents a min heap, False otherwise.\n    \"\"\"\n    n = len(arr)\n    \n    # Iterate over each parent node in the array\n    for i in range((n - 2) // 2 + 1):\n        # Check if the left child exists and is greater than the parent\n        if 2 * i + 1 < n and arr[i] > arr[2 * i + 1]:\n            return False\n        # Check if the right child exists and is greater than the parent\n        if 2 * i + 2 < n and arr[i] > arr[2 * i + 2]:\n            return False\n    \n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/752": [{"task_id": "Mbpp/752", "solution": "def jacobsthal_num(n):\n    \"\"\"\n    Calculate the nth Jacobsthal number using the recursive formula:\n    J(n) = J(n-1) + 2 * J(n-2)\n    with base cases:\n    J(0) = 0\n    J(1) = 1\n\n    :param n: The index of the Jacobsthal number to calculate\n    :return: The nth Jacobsthal number\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"The index n must be a non-negative integer.\")\n    \n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Initialize the first two Jacobsthal numbers\n    j0, j1 = 0, 1\n    \n    # Calculate the nth Jacobsthal number iteratively\n    for i in range(2, n + 1):\n        jn = j1 + 2 * j0\n        j0, j1 = j1, jn\n    \n    return j1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/753": [{"task_id": "Mbpp/753", "solution": "def min_k(records, k):\n    \"\"\"\n    This function takes a list of tuples and an integer k, and returns the k tuples with the smallest second element.\n    \n    :param records: List of tuples, where each tuple contains a name and a numeric value.\n    :param k: Integer, the number of minimum records to return based on the numeric value.\n    :return: List of k tuples with the smallest numeric values.\n    \"\"\"\n    # Sort the list of tuples based on the second element of each tuple (the numeric value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/754": [{"task_id": "Mbpp/754", "solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function takes three lists as input and returns a list of elements that are common\n    across all three lists at the same index.\n\n    Parameters:\n    l1, l2, l3 (list): Three lists of potentially different lengths.\n\n    Returns:\n    list: A list of elements that are common in all three lists at the same index.\n    \"\"\"\n    # Determine the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate over the range of the minimum length\n    for i in range(min_length):\n        # Check if the element at index i is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If so, append it to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/755": [{"task_id": "Mbpp/755", "solution": "def second_smallest(numbers):\n    \"\"\"\n    Function to find the second smallest number in a list.\n    \n    :param numbers: List of integers\n    :return: The second smallest integer in the list\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two distinct elements.\")\n    \n    # Initialize the first and second smallest to infinity\n    first, second = float('inf'), float('inf')\n    \n    for number in numbers:\n        # Update first and second smallest if a new smallest is found\n        if number < first:\n            second = first\n            first = number\n        # Update second smallest if a new second smallest is found\n        elif first < number < second:\n            second = number\n    \n    # If second is still infinity, it means there was no second distinct smallest number\n    if second == float('inf'):\n        raise ValueError(\"List must contain at least two distinct elements.\")\n    \n    return second", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[2, 2]]], "plus_fail_tests": [[[]]]}], "Mbpp/757": [{"task_id": "Mbpp/757", "solution": "def count_reverse_pairs(string_list):\n    \"\"\"\n    Count the pairs of reverse strings in the given string list.\n\n    Parameters:\n    string_list (list of str): A list of strings to check for reverse pairs.\n\n    Returns:\n    int: The number of reverse string pairs in the list.\n    \"\"\"\n    # Create a set to store the strings for quick lookup\n    string_set = set(string_list)\n    # Initialize a counter for reverse pairs\n    reverse_pair_count = 0\n\n    # Iterate over each string in the list\n    for string in string_list:\n        # Reverse the current string\n        reversed_string = string[::-1]\n        # Check if the reversed string is in the set\n        if reversed_string in string_set:\n            # Increment the counter\n            reverse_pair_count += 1\n            # Remove both the string and its reverse from the set to avoid double counting\n            string_set.remove(string)\n            string_set.remove(reversed_string)\n\n    return reverse_pair_count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["app", "123", "ad3", "apple", "elppa", "xyx", "bat", "tab", "tacocat", "racecar", "abc", "zyx", "def", "fed"]]]}], "Mbpp/758": [{"task_id": "Mbpp/758", "solution": "def unique_sublists(lst):\n    \"\"\"\n    This function takes a list of lists and returns a dictionary where each sublist is converted to a tuple.\n    The dictionary's keys are these tuples, and the values are the counts of how many times each sublist appears in the original list.\n    \n    :param lst: List of lists\n    :return: Dictionary with tuples as keys and their occurrence counts as values\n    \"\"\"\n    # Initialize an empty dictionary to store the counts\n    sublist_count = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are not hashable and cannot be used as dictionary keys)\n        sublist_tuple = tuple(sublist)\n        \n        # Increment the count for this tuple in the dictionary\n        if sublist_tuple in sublist_count:\n            sublist_count[sublist_tuple] += 1\n        else:\n            sublist_count[sublist_tuple] = 1\n    \n    return sublist_count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/759": [{"task_id": "Mbpp/759", "solution": "def is_decimal(s):\n    \"\"\"\n    Check if the given string is a decimal number with a precision of 2.\n\n    Parameters:\n    s (str): The string to check.\n\n    Returns:\n    bool: True if the string is a decimal number with a precision of 2, False otherwise.\n    \"\"\"\n    # Split the string by the decimal point\n    parts = s.split('.')\n    \n    # Check if there are exactly two parts (before and after the decimal point)\n    if len(parts) != 2:\n        return False\n    \n    # Check if both parts are digits\n    if not (parts[0].isdigit() and parts[1].isdigit()):\n        return False\n    \n    # Check if the part after the decimal point has exactly two digits\n    if len(parts[1]) != 2:\n        return False\n    \n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["123"]]}], "Mbpp/760": [{"task_id": "Mbpp/760", "solution": "def unique_element(lst):\n    \"\"\"\n    This function checks whether a list contains only one distinct element.\n    \n    Parameters:\n    lst (list): A list of numbers.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(lst)\n    \n    # If the length of the set is 1, it means all elements in the list are the same\n    return len(unique_elements) == 1\n\n# Test cases\nassert unique_element([1, 1, 1]) == True\nassert unique_element([1, 2, 1]) == False\nassert unique_element([2, 2, 2, 2]) == True\nassert unique_element([3]) == True  # Edge case: single element list\nassert unique_element([]) == False  # Edge case: empty list", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/739": [{"task_id": "Mbpp/739", "solution": "def find_Index(n):\n    \"\"\"\n    Find the index of the smallest triangular number with n digits.\n    \n    Parameters:\n    n (int): The number of digits required in the triangular number.\n    \n    Returns:\n    int: The index of the smallest triangular number with n digits.\n    \"\"\"\n    # Start with the first triangular number\n    k = 1\n    \n    while True:\n        # Calculate the k-th triangular number\n        triangular_number = k * (k + 1) // 2\n        \n        # Check the number of digits in the triangular number\n        if len(str(triangular_number)) == n:\n            return k\n        \n        # Increment k to check the next triangular number\n        k += 1", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[100]]}], "Mbpp/762": [{"task_id": "Mbpp/762", "solution": "def check_month_number(month):\n    \"\"\"\n    Function to check whether the given month number contains 30 days or not.\n    \n    Parameters:\n    month (int): The month number (1 for January, 2 for February, ..., 12 for December)\n    \n    Returns:\n    bool: True if the month has 30 days, False otherwise\n    \"\"\"\n    # List of months with 30 days: April (4), June (6), September (9), November (11)\n    months_with_30_days = [4, 6, 9, 11]\n    \n    # Check if the given month is in the list of months with 30 days\n    return month in months_with_30_days\n\n# Test the function with the provided test case\nassert check_month_number(6) == True\n\n# Additional test cases\nassert check_month_number(4) == True  # April\nassert check_month_number(9) == True  # September\nassert check_month_number(11) == True # November\nassert check_month_number(1) == False # January\nassert check_month_number(2) == False # February\nassert check_month_number(3) == False # March\nassert check_month_number(5) == False # May\nassert check_month_number(7) == False # July\nassert check_month_number(8) == False # August\nassert check_month_number(10) == False # October\nassert check_month_number(12) == False # December\n\nprint(\"All test cases passed.\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/763": [{"task_id": "Mbpp/763", "solution": "def find_min_diff(arr, n):\n    \"\"\"\n    Function to find the minimum difference between any two elements in a given array.\n    \n    Parameters:\n    arr (tuple): A tuple of integers.\n    n (int): The number of elements in the tuple.\n    \n    Returns:\n    int: The minimum difference between any two elements in the array.\n    \"\"\"\n    # Convert the tuple to a list and sort it\n    sorted_arr = sorted(arr)\n    \n    # Initialize the minimum difference to a large number\n    min_diff = float('inf')\n    \n    # Iterate through the sorted array and find the minimum difference\n    for i in range(n - 1):\n        # Calculate the difference between consecutive elements\n        diff = sorted_arr[i + 1] - sorted_arr[i]\n        # Update the minimum difference if a smaller difference is found\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/765": [{"task_id": "Mbpp/765", "solution": "def is_polite(number):\n    \"\"\"\n    Check if a number is polite.\n    A number is polite if it is not a power of 2.\n    \"\"\"\n    # A number is a power of 2 if it has only one bit set in its binary representation.\n    return (number & (number - 1)) != 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[7]], "plus_fail_tests": [[10000000]]}], "Mbpp/764": [{"task_id": "Mbpp/764", "solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in the given string.\n\n    Parameters:\n    s (str): The input string to be analyzed.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    # Initialize a counter for digits\n    digit_count = 0\n    \n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the digit counter\n            digit_count += 1\n    \n    return digit_count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/766": [{"task_id": "Mbpp/766", "solution": "def pair_wise(lst):\n    \"\"\"\n    This function takes a list as input and returns a list of tuples,\n    where each tuple contains a pair of consecutive items from the input list.\n    \n    :param lst: List of items\n    :return: List of tuples with consecutive pairs\n    \"\"\"\n    # Initialize an empty list to store the pairs\n    pairs = []\n    \n    # Iterate over the list using index to access consecutive elements\n    for i in range(len(lst) - 1):\n        # Append a tuple of the current and next element to the pairs list\n        pairs.append((lst[i], lst[i + 1]))\n    \n    return pairs", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/767": [{"task_id": "Mbpp/767", "solution": "def get_pairs_count(numbers, target_sum):\n    \"\"\"\n    This function counts the number of pairs in the list 'numbers' whose sum is equal to 'target_sum'.\n    \n    :param numbers: List of integers\n    :param target_sum: Integer, the target sum for the pairs\n    :return: Integer, the count of pairs whose sum is equal to 'target_sum'\n    \"\"\"\n    # Dictionary to store the frequency of each number in the list\n    frequency = {}\n    \n    # Count the frequency of each number in the list\n    for number in numbers:\n        if number in frequency:\n            frequency[number] += 1\n        else:\n            frequency[number] = 1\n    \n    # Initialize count of pairs\n    count = 0\n    \n    # Iterate over each number in the list\n    for number in numbers:\n        # Calculate the complement that would sum with the current number to the target_sum\n        complement = target_sum - number\n        \n        # Check if the complement exists in the frequency dictionary\n        if complement in frequency:\n            count += frequency[complement]\n        \n        # If complement and number are the same, we need to decrease the count by one\n        # because the pair (number, complement) is counted twice\n        if complement == number:\n            count -= 1\n    \n    # Each pair is counted twice, so divide the count by 2\n    return count // 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/769": [{"task_id": "Mbpp/769", "solution": "def Diff(list1, list2):\n    \"\"\"\n    This function takes two lists as input and returns a list containing the elements\n    that are present in the first list but not in the second list.\n    \n    Parameters:\n    list1 (list): The first list from which elements will be compared.\n    list2 (list): The second list which will be used to filter elements from the first list.\n    \n    Returns:\n    list: A list containing elements that are in list1 but not in list2.\n    \"\"\"\n    # Use a list comprehension to filter out elements in list1 that are not in list2\n    difference = [item for item in list1 if item not in list2]\n    return difference", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 5], [6, 7, 1]]], "plus_fail_tests": [[[], [1, 2, 3]]]}], "Mbpp/771": [{"task_id": "Mbpp/771", "solution": "def check_expression(expression):\n    \"\"\"\n    This function checks if the given expression has balanced parentheses, brackets, and braces.\n    \n    Args:\n    expression (str): The input string containing the expression to be checked.\n    \n    Returns:\n    bool: True if the expression is balanced, False otherwise.\n    \"\"\"\n    # Stack to keep track of opening brackets\n    stack = []\n    \n    # Dictionary to map closing brackets to their corresponding opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    # Iterate over each character in the expression\n    for char in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if char in bracket_map.values():\n            stack.append(char)\n        # If the character is a closing bracket\n        elif char in bracket_map:\n            # Check if the stack is not empty and the top of the stack matches the corresponding opening bracket\n            if stack and stack[-1] == bracket_map[char]:\n                stack.pop()  # Pop the matched opening bracket from the stack\n            else:\n                return False  # Unmatched closing bracket found\n    \n    # If the stack is empty, all opening brackets were matched\n    return not stack", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/770": [{"task_id": "Mbpp/770", "solution": "def odd_num_sum(n):\n    \"\"\"\n    Calculate the sum of the fourth power of the first n odd natural numbers.\n\n    Parameters:\n    n (int): The number of odd natural numbers to consider.\n\n    Returns:\n    int: The sum of the fourth power of the first n odd natural numbers.\n    \"\"\"\n    # Initialize the sum\n    sum_of_powers = 0\n    \n    # Generate the first n odd natural numbers and calculate their fourth power\n    for i in range(n):\n        odd_number = 2 * i + 1  # Formula to get the i-th odd number\n        sum_of_powers += odd_number ** 4  # Add the fourth power of the odd number to the sum\n    \n    return sum_of_powers", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/772": [{"task_id": "Mbpp/772", "solution": "def remove_length(input_string, k):\n    \"\"\"\n    Remove all words with length k from the input string.\n\n    Parameters:\n    input_string (str): The string from which words need to be removed.\n    k (int): The length of words to be removed.\n\n    Returns:\n    str: A new string with the specified words removed.\n    \"\"\"\n    # Split the input string into words\n    words = input_string.split()\n    \n    # Filter out words that have the specified length k\n    filtered_words = [word for word in words if len(word) != k]\n    \n    # Join the filtered words back into a single string\n    result = ' '.join(filtered_words)\n    \n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/775": [{"task_id": "Mbpp/775", "solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index in the list contains an odd number.\n\n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    # Iterate over the list, checking only the odd indices\n    for i in range(1, len(lst), 2):\n        # If an even number is found at an odd index, return False\n        if lst[i] % 2 == 0:\n            return False\n    # If all odd indices contain odd numbers, return True\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/773": [{"task_id": "Mbpp/773", "solution": "def occurrence_substring(main_string, substring):\n    \"\"\"\n    This function finds the first occurrence of a substring within a main string.\n    It returns a tuple containing the substring, the start index, and the end index of the first occurrence.\n    If the substring is not found, it returns None.\n    \n    :param main_string: The string in which to search for the substring.\n    :param substring: The substring to search for.\n    :return: A tuple (substring, start_index, end_index) or None if the substring is not found.\n    \"\"\"\n    # Find the start index of the first occurrence of the substring\n    start_index = main_string.find(substring)\n    \n    # If the substring is not found, return None\n    if start_index == -1:\n        return None\n    \n    # Calculate the end index of the substring\n    end_index = start_index + len(substring)\n    \n    # Return the tuple with the substring, start index, and end index\n    return (substring, start_index, end_index)\n\n# Test the function with the provided test case\nassert occurrence_substring('python programming, python language', 'python') == ('python', 0, 6)\n\n# Additional test cases\nprint(occurrence_substring('hello world', 'world'))  # Expected: ('world', 6, 11)\nprint(occurrence_substring('hello world', 'python'))  # Expected: None\nprint(occurrence_substring('abcabcabc', 'abc'))  # Expected: ('abc', 0, 3)\nprint(occurrence_substring('abcabcabc', 'bca'))  # Expected: ('bca', 1, 4)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/777": [{"task_id": "Mbpp/777", "solution": "def find_sum(lst):\n    \"\"\"\n    This function calculates the sum of non-repeated elements in the given list.\n    \n    Parameters:\n    lst (list): A list of integers.\n    \n    Returns:\n    int: The sum of non-repeated elements.\n    \"\"\"\n    # Create a dictionary to count occurrences of each element\n    element_count = {}\n    \n    # Count each element in the list\n    for element in lst:\n        if element in element_count:\n            element_count[element] += 1\n        else:\n            element_count[element] = 1\n    \n    # Calculate the sum of elements that appear only once\n    non_repeated_sum = sum(element for element, count in element_count.items() if count == 1)\n    \n    return non_repeated_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 1, 1, 4, 5, 6]]], "plus_fail_tests": [[[-1, -2, -3, -1, -1, -4, -5, -6]]]}], "Mbpp/780": [{"task_id": "Mbpp/780", "solution": "from itertools import combinations\ndef find_combinations(tuple_list):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Generate all possible combinations of two tuples from the list\n    for (a, b) in combinations(tuple_list, 2):\n        # Calculate the sum of the first elements and the sum of the second elements\n        sum_tuple = (a[0] + b[0], a[1] + b[1])\n        # Append the resulting tuple to the result list\n        result.append(sum_tuple)\n    \n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3], [3, 4, 5]]]], "plus_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15]]]]}], "Mbpp/778": [{"task_id": "Mbpp/778", "solution": "def pack_consecutive_duplicates(lst):\n    \"\"\"\n    This function takes a list and packs consecutive duplicates into sublists.\n    \n    Parameters:\n    lst (list): The input list containing elements that may have consecutive duplicates.\n    \n    Returns:\n    list: A list of lists, where each sublist contains consecutive duplicate elements from the input list.\n    \"\"\"\n    if not lst:\n        return []\n\n    packed_list = []  # This will store the final packed list of sublists\n    current_sublist = [lst[0]]  # Start with the first element in a new sublist\n\n    for i in range(1, len(lst)):\n        if lst[i] == lst[i - 1]:\n            # If the current element is the same as the previous, add it to the current sublist\n            current_sublist.append(lst[i])\n        else:\n            # If it's different, add the current sublist to the packed list and start a new sublist\n            packed_list.append(current_sublist)\n            current_sublist = [lst[i]]\n\n    # Don't forget to add the last sublist to the packed list\n    packed_list.append(current_sublist)\n\n    return packed_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/782": [{"task_id": "Mbpp/782", "solution": "def odd_length_sum(arr):\n    \"\"\"\n    Calculate the sum of all odd length subarrays of the given array.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The sum of all odd length subarrays.\n    \"\"\"\n    total_sum = 0\n    n = len(arr)\n    \n    # Iterate over all possible starting points of subarrays\n    for start in range(n):\n        # Iterate over all possible ending points of subarrays\n        for end in range(start, n):\n            # Calculate the length of the current subarray\n            length = end - start + 1\n            # Check if the length is odd\n            if length % 2 == 1:\n                # Sum the elements of the current subarray\n                total_sum += sum(arr[start:end+1])\n    \n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/784": [{"task_id": "Mbpp/784", "solution": "def mul_even_odd(numbers):\n    \"\"\"\n    This function takes a list of integers and returns the product of the first even number\n    and the first odd number found in the list. If either an even or odd number is not found,\n    the function returns None.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    \n    for num in numbers:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        # If both first_even and first_odd are found, break the loop\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # If both an even and an odd number are found, return their product\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/785": [{"task_id": "Mbpp/785", "solution": "def tuple_str_int(tuple_str):\n    \"\"\"\n    Convert a string representation of a tuple into an integer tuple.\n\n    Parameters:\n    tuple_str (str): A string representation of a tuple, e.g., \"(7, 8, 9)\".\n\n    Returns:\n    tuple: A tuple of integers extracted from the string.\n    \"\"\"\n    # Remove the parentheses and split the string by commas\n    # Strip any whitespace and convert each element to an integer\n    return tuple(int(num.strip()) for num in tuple_str.strip('()').split(','))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/786": [{"task_id": "Mbpp/786", "solution": "def right_insertion(sorted_list, value):\n    \"\"\"\n    This function finds the right insertion point for a specified value in a sorted list.\n    The insertion point is the index at which the value would be inserted to maintain sorted order.\n    \n    Parameters:\n    sorted_list (list): A list of sorted integers.\n    value (int): The value to find the insertion point for.\n    \n    Returns:\n    int: The index at which the value should be inserted.\n    \"\"\"\n    # Initialize the left and right pointers for binary search\n    left, right = 0, len(sorted_list)\n    \n    # Perform binary search to find the right insertion point\n    while left < right:\n        mid = (left + right) // 2\n        if sorted_list[mid] <= value:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/787": [{"task_id": "Mbpp/787", "solution": "import re\ndef text_match_three(text):\n    \"\"\"\n    This function checks if the input string contains an 'a' followed by exactly three 'b's.\n    \n    Parameters:\n    text (str): The input string to be checked.\n    \n    Returns:\n    bool: True if the pattern is found, False otherwise.\n    \"\"\"\n    # Define the regular expression pattern for 'a' followed by exactly three 'b's\n    pattern = r'ab{3}'\n    \n    # Use re.search to find the pattern in the text\n    if re.search(pattern, text):\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/788": [{"task_id": "Mbpp/788", "solution": "def new_tuple(lst, string):\n    \"\"\"\n    This function takes a list and a string as input and returns a new tuple\n    that combines the elements of the list with the string as the last element.\n\n    Parameters:\n    lst (list): A list of strings.\n    string (str): A single string to be added to the end of the tuple.\n\n    Returns:\n    tuple: A tuple containing the elements of the list followed by the string.\n    \"\"\"\n    # Convert the list to a tuple and add the string as the last element\n    result_tuple = tuple(lst) + (string,)\n    return result_tuple", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/790": [{"task_id": "Mbpp/790", "solution": "def even_position(lst):\n    \"\"\"\n    This function checks whether every even index in the given list contains an even number.\n    \n    Parameters:\n    lst (list): A list of integers.\n    \n    Returns:\n    bool: True if every even index contains an even number, False otherwise.\n    \"\"\"\n    # Iterate over the list, checking only the even indices\n    for i in range(0, len(lst), 2):\n        # If the number at an even index is not even, return False\n        if lst[i] % 2 != 0:\n            return False\n    # If all even indices contain even numbers, return True\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 1, 4, 2, 6, 1, 8, 2, 10, 1, 12]]]}], "Mbpp/791": [{"task_id": "Mbpp/791", "solution": "def remove_nested(input_tuple):\n    \"\"\"\n    This function takes a tuple as input and returns a new tuple with any nested tuples removed.\n    \n    Parameters:\n    input_tuple (tuple): The input tuple which may contain nested tuples.\n    \n    Returns:\n    tuple: A new tuple with all nested tuples removed.\n    \"\"\"\n    # Use a tuple comprehension to filter out elements that are tuples\n    return tuple(item for item in input_tuple if not isinstance(item, tuple))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/792": [{"task_id": "Mbpp/792", "solution": "def count_list(list_of_lists):\n    \"\"\"\n    Count the number of lists in a given list of lists.\n\n    Parameters:\n    list_of_lists (list): A list containing other lists.\n\n    Returns:\n    int: The number of lists contained within the input list.\n    \"\"\"\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate over each element in the list_of_lists\n    for element in list_of_lists:\n        # Check if the element is a list\n        if isinstance(element, list):\n            # Increment the counter if the element is a list\n            count += 1\n    \n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/793": [{"task_id": "Mbpp/793", "solution": "def last(arr, target):\n    \"\"\"\n    Find the last position of an element in a sorted array.\n\n    Parameters:\n    arr (list): A sorted list of elements.\n    target (int): The element to find the last position of.\n\n    Returns:\n    int: The last position of the target element in the array, or -1 if not found.\n    \"\"\"\n    # Initialize the position to -1, assuming the target is not found\n    position = -1\n    \n    # Iterate over the array to find the last occurrence of the target\n    for i in range(len(arr)):\n        if arr[i] == target:\n            position = i  # Update position whenever the target is found\n    \n    return position", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/794": [{"task_id": "Mbpp/794", "solution": "import re\ndef text_starta_endb(s):\n    \"\"\"\n    This function checks if the input string matches the pattern:\n    - Starts with 'a'\n    - Followed by any characters (including none)\n    - Ends with 'b'\n    \n    Parameters:\n    s (str): The input string to be checked.\n    \n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Define the regular expression pattern\n    pattern = r'^a.*b$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    return bool(re.match(pattern, s))", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["xaabbyz1323ababb"]]}], "Mbpp/796": [{"task_id": "Mbpp/796", "solution": "def return_sum(dictionary):\n    \"\"\"\n    This function takes a dictionary as input and returns the sum of all its values.\n\n    Parameters:\n    dictionary (dict): A dictionary with numeric values.\n\n    Returns:\n    int/float: The sum of all the values in the dictionary.\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over all values in the dictionary and add them to the total_sum\n    for value in dictionary.values():\n        total_sum += value\n    \n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/797": [{"task_id": "Mbpp/797", "solution": "def sum_in_range(l, r):\n    \"\"\"\n    Calculate the sum of all odd natural numbers within the range l and r (inclusive).\n\n    Parameters:\n    l (int): The lower bound of the range.\n    r (int): The upper bound of the range.\n\n    Returns:\n    int: The sum of all odd natural numbers within the range.\n    \"\"\"\n    # Initialize the sum\n    total_sum = 0\n    \n    # Iterate over the range from l to r inclusive\n    for number in range(l, r + 1):\n        # Check if the number is odd\n        if number % 2 != 0:\n            # Add the odd number to the total sum\n            total_sum += number\n    \n    return total_sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/798": [{"task_id": "Mbpp/798", "solution": "def _sum(arr):\n    \"\"\"\n    Calculate the sum of elements in an array.\n\n    Parameters:\n    arr (list): A list of numbers.\n\n    Returns:\n    int/float: The sum of the numbers in the list.\n    \"\"\"\n    # Initialize a variable to store the sum\n    total = 0\n    \n    # Iterate over each element in the array and add it to the total\n    for num in arr:\n        total += num\n    \n    return total", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/799": [{"task_id": "Mbpp/799", "solution": "def left_rotate(n, d):\n    \"\"\"\n    Rotate the bits of a 32-bit integer `n` to the left by `d` positions.\n\n    Parameters:\n    n (int): The number to be rotated.\n    d (int): The number of positions to rotate the bits to the left.\n\n    Returns:\n    int: The result of rotating `n` to the left by `d` positions.\n    \"\"\"\n    # Define the number of bits in the integer\n    BITS = 32\n    \n    # Ensure d is within the range of 0 to 31\n    d = d % BITS\n    \n    # Perform the left rotation\n    # Shift `n` left by `d` bits and use bitwise OR with the right-shifted bits\n    rotated = (n << d) | (n >> (BITS - d))\n    \n    # Mask the result to ensure it remains a 32-bit integer\n    return rotated & ((1 << BITS) - 1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/800": [{"task_id": "Mbpp/800", "solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    This function removes all whitespace characters from the input string.\n\n    Parameters:\n    input_string (str): The string from which to remove whitespaces.\n\n    Returns:\n    str: A new string with all whitespaces removed.\n    \"\"\"\n    # Use the replace method to remove all spaces\n    return input_string.replace(\" \", \"\")", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/801": [{"task_id": "Mbpp/801", "solution": "def test_three_equal(a, b, c):\n    \"\"\"\n    This function takes three integers as input and returns the count of numbers that are equal.\n    If all three numbers are equal, it returns 3.\n    If two numbers are equal, it returns 2.\n    If no numbers are equal, it returns 0.\n    \"\"\"\n    # Check if all three numbers are equal\n    if a == b == c:\n        return 3\n    # Check if any two numbers are equal\n    elif a == b or b == c or a == c:\n        return 2\n    # If no numbers are equal\n    else:\n        return 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/803": [{"task_id": "Mbpp/803", "solution": "import math\ndef is_perfect_square(n):\n    \"\"\"\n    Check if a given number is a perfect square.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False  # Negative numbers cannot be perfect squares\n\n    # Calculate the square root of the number\n    sqrt_n = math.isqrt(n)\n    \n    # Check if the square of the integer square root equals the original number\n    return sqrt_n * sqrt_n == n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/804": [{"task_id": "Mbpp/804", "solution": "def is_product_even(numbers):\n    \"\"\"\n    This function checks whether the product of numbers in a list is even or not.\n    \n    Parameters:\n    numbers (list): A list of integers.\n    \n    Returns:\n    bool: True if the product is even, False otherwise.\n    \"\"\"\n    # If the list is empty, the product is considered 1 (odd), so return False\n    if not numbers:\n        return False\n    \n    # Check if any number in the list is even\n    for number in numbers:\n        if number % 2 == 0:\n            return True\n    \n    # If no even number is found, the product is odd\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/781": [{"task_id": "Mbpp/781", "solution": "def count_divisors(n):\n    \"\"\"\n    This function checks whether the count of divisors of a given number n is even.\n    \n    Parameters:\n    n (int): The number for which to count the divisors.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize the count of divisors\n    divisor_count = 0\n    \n    # Iterate over all numbers from 1 to n\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the count\n        if n % i == 0:\n            divisor_count += 1\n    \n    # Check if the count of divisors is even\n    return divisor_count % 2 == 0", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[987654321]]}], "Mbpp/806": [{"task_id": "Mbpp/806", "solution": "def max_run_uppercase(s):\n    \"\"\"\n    This function finds the maximum run of consecutive uppercase characters in the given string.\n    \n    Parameters:\n    s (str): The input string to be analyzed.\n    \n    Returns:\n    int: The length of the longest run of consecutive uppercase characters.\n    \"\"\"\n    max_run = 0  # Initialize the maximum run length\n    current_run = 0  # Initialize the current run length\n\n    for char in s:\n        if char.isupper():\n            current_run += 1  # Increment current run if the character is uppercase\n            max_run = max(max_run, current_run)  # Update max_run if current_run is greater\n        else:\n            current_run = 0  # Reset current run if the character is not uppercase\n\n    return max_run", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["Aaa"]]}], "Mbpp/805": [{"task_id": "Mbpp/805", "solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    This function takes a list of lists as input and returns the list with the highest sum of elements.\n    \n    Parameters:\n    list_of_lists (list of lists): A list containing multiple lists of numbers.\n    \n    Returns:\n    list: The list with the highest sum of elements.\n    \"\"\"\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n\n    # Iterate over each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # If the current sum is greater than the maximum sum found so far, update max_sum and max_list\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/807": [{"task_id": "Mbpp/807", "solution": "def first_odd(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns the first odd number found in the list.\n    If no odd number is found, it returns None.\n    \n    :param numbers: List of integers\n    :return: The first odd integer in the list or None if no odd number is found\n    \"\"\"\n    for number in numbers:\n        if number % 2 != 0:  # Check if the number is odd\n            return number\n    return None  # Return None if no odd number is found", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/809": [{"task_id": "Mbpp/809", "solution": "def check_smaller(tuple1, tuple2):\n    \"\"\"\n    This function checks if each element of the second tuple is smaller than its corresponding element in the first tuple.\n    \n    Parameters:\n    tuple1 (tuple): The first tuple containing elements to compare against.\n    tuple2 (tuple): The second tuple containing elements to be compared.\n    \n    Returns:\n    bool: True if each element in tuple2 is smaller than the corresponding element in tuple1, False otherwise.\n    \"\"\"\n    # Check if both tuples have the same length\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Both tuples must have the same length.\")\n    \n    # Iterate over the elements of both tuples and compare them\n    for a, b in zip(tuple1, tuple2):\n        if b >= a:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/808": [{"task_id": "Mbpp/808", "solution": "def check_K(tup, k):\n    \"\"\"\n    Function to check if the given tuple contains the element k.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    k (any): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    # Check if k is in the tuple\n    return k in tup", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}]}, "pass_at_k": {"base": {"pass@1": 0.8174603174603174}, "plus": {"pass@1": 0.6878306878306878}}}