{"task_id": "MBPP/938", "entry_point": "find_closet", "completion": "To solve the problem of finding the three closest elements from three sorted arrays, we can follow these steps:\n\n1. **Initialize Pointers**: Use three pointers, one for each of the three arrays, starting at the beginning of each array.\n2. **Calculate the Current Closest**: At each step, calculate the maximum and minimum values among the elements pointed to by the three pointers. The goal is to minimize the difference between the maximum and minimum values.\n3. **Update Closest Elements**: If the current combination of elements is closer than the previously found combination, update the closest elements.\n4. **Move the Pointer**: To potentially find a closer combination, move the pointer that points to the smallest element among the three.\n5. **Repeat**: Continue this process until one of the pointers reaches the end of its respective array.\n\nHere is the implementation of the above logic in Python:\n\n```python\ndef find_closest(arr1, arr2, arr3, n1, n2, n3):\n    # Initialize pointers for each array\n    i, j, k = 0, 0, 0\n    # Initialize the closest elements and the minimum difference\n    closest = (0, 0, 0)\n    min_diff = float('inf')\n    \n    # Loop until we reach the end of any of the arrays\n    while i < n1 and j < n2 and k < n3:\n        # Get the current elements from each array\n        a, b, c = arr1[i], arr2[j], arr3[k]\n        \n        # Find the maximum and minimum of the three elements\n        current_max = max(a, b, c)\n        current_min = min(a, b, c)\n        \n        # Update the closest elements if the current difference is smaller\n        if current_max - current_min < min_diff:\n            min_diff = current_max - current_min\n            closest = (a, b, c)\n        \n        # Move the pointer that points to the smallest element\n        if current_min == a:\n            i += 1\n        elif current_min == b:\n            j += 1\n        else:\n            k += 1\n    \n    return closest\n\n# Test case\nassert find_closest([1, 4, 10], [2, 15, 20], [10, 12], 3, 3, 2) == (10, 15, 10)\n```\n\n### Explanation of the Code:\n- The function `find_closest` takes three sorted arrays and their respective sizes as input.\n- It initializes three pointers (`i`, `j`, `k`) to traverse the arrays.\n- It calculates the maximum and minimum of the current elements pointed to by the pointers and checks if the current combination is closer than the previously found combination.\n- The pointer for the smallest element is incremented to explore potentially closer combinations.\n- The process continues until one of the pointers reaches the end of its array.\n- Finally, the function returns the closest elements found.\n\n### Assumptions:\n- The input arrays are sorted in ascending order.\n- The sizes of the arrays are provided and are valid (greater than zero)."}
