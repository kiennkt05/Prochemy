{"task_id": "MBPP/495", "completion": "import re\n\ndef remove_lowercase(str1):\n    \"\"\"\n    Remove all lowercase substrings from the given string using regex.\n\n    Parameters:\n    str1 (str): The input string from which lowercase letters will be removed.\n\n    Returns:\n    str: A new string with all lowercase letters removed.\n    \"\"\"\n    # Use regex to substitute all lowercase letters with an empty string\n    result = re.sub(r'[a-z]', '', str1)\n    return result"}
{"task_id": "MBPP/173", "completion": "def remove_splchar(text):\n    \"\"\"\n    Remove everything except alphanumeric characters from a string.\n\n    Parameters:\n    text (str): The input string from which to remove special characters.\n\n    Returns:\n    str: A string containing only alphanumeric characters.\n    \"\"\"\n    # Using a list comprehension to filter out non-alphanumeric characters\n    return ''.join(char for char in text if char.isalnum())\n\n# Example usage\nif __name__ == \"__main__\":\n    print(remove_splchar('python  @#&^%$*program123'))  # Output: 'pythonprogram123'"}
{"task_id": "MBPP/801", "completion": "def test_three_equal(x, y, z):\n    \"\"\"\n    Count the number of equal integers among three given integers.\n\n    Parameters:\n    x (int): The first integer.\n    y (int): The second integer.\n    z (int): The third integer.\n\n    Returns:\n    int: The count of equal integers (0, 2, or 3).\n    \"\"\"\n    if x == y == z:\n        return 3  # All three are equal\n    elif x == y or y == z or x == z:\n        return 2  # Two are equal\n    else:\n        return 0  # All are different"}
{"task_id": "MBPP/131", "completion": "def reverse_vowels(str1):\n    \"\"\"\n    Reverse only the vowels of a given string.\n    \n    Parameters:\n    str1 (str): The input string from which vowels will be reversed.\n    \n    Returns:\n    str: A new string with the vowels reversed.\n    \n    Examples:\n    >>> reverse_vowels(\"Python\")\n    'Python'\n    >>> reverse_vowels(\"hello\")\n    'holle'\n    >>> reverse_vowels(\"LeetCode\")\n    'LeotCede'\n    \"\"\"\n    if not isinstance(str1, str):\n        raise ValueError(\"Input must be a string.\")\n    \n    vowels = \"aeiouAEIOU\"\n    vowel_list = [char for char in str1 if char in vowels]\n    reversed_vowels = vowel_list[::-1]\n    \n    result = []\n    vowel_index = 0\n    \n    for char in str1:\n        if char in vowels:\n            result.append(reversed_vowels[vowel_index])\n            vowel_index += 1\n        else:\n            result.append(char)\n    \n    return ''.join(result)\n\n# Test cases\ndef test_reverse_vowels():\n    assert reverse_vowels(\"Python\") == \"Python\"\n    assert reverse_vowels(\"hello\") == \"holle\"\n    assert reverse_vowels(\"LeetCode\") == \"LeotCede\"\n    assert reverse_vowels(\"aA\") == \"Aa\"\n    assert reverse_vowels(\"\") == \"\"\n    assert reverse_vowels(\"bcd\") == \"bcd\"\n    assert reverse_vowels(\"racecar\") == \"racecar\"\n    assert reverse_vowels(\"1234\") == \"1234\"\n    \n    print(\"All tests passed!\")\n\n# Run tests\ntest_reverse_vowels()"}
{"task_id": "MBPP/645", "completion": "def find_k_product(test_list, K):\n    \"\"\"\n    Find the product of the Kth index elements in the given list of tuples.\n\n    Parameters:\n    test_list (list of tuples): A list containing tuples of numbers.\n    K (int): The index of the elements to multiply.\n\n    Returns:\n    int: The product of the Kth index elements.\n\n    Raises:\n    IndexError: If K is out of bounds for any tuple in the list.\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not test_list:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    product = 1\n    for tup in test_list:\n        if K >= len(tup):\n            raise IndexError(f\"K={K} is out of bounds for tuple {tup}.\")\n        product *= tup[K]\n    \n    return product\n\n# Test cases\nif __name__ == \"__main__\":\n    # Provided test case\n    assert find_k_product([(5, 6, 7), (1, 3, 5), (8, 9, 19)], 2) == 665\n    \n    # Additional test cases\n    assert find_k_product([(2, 3, 4), (5, 6, 7), (8, 9, 10)], 1) == 162  # 3 * 6 * 9\n    assert find_k_product([(1, 2), (3, 4), (5, 6)], 0) == 15  # 1 * 3 * 5\n    assert find_k_product([(1, 2, 3)], 2) == 3  # Single tuple case\n    try:\n        find_k_product([], 0)  # Should raise ValueError\n    except ValueError as e:\n        print(e)  # Expected output\n    try:\n        find_k_product([(1, 2)], 2)  # Should raise IndexError\n    except IndexError as e:\n        print(e)  # Expected output"}
{"task_id": "MBPP/954", "completion": "def profit_amount(actual_cost, sale_amount):\n    \"\"\"\n    Calculate the profit amount from the actual cost and sale amount.\n    \n    If the sale amount is greater than the actual cost, return the profit amount.\n    If there is no profit (sale amount is less than or equal to actual cost), return None.\n    \n    Parameters:\n    actual_cost (float): The cost price of the item.\n    sale_amount (float): The selling price of the item.\n    \n    Returns:\n    float or None: The profit amount if there is a profit, otherwise None.\n    \"\"\"\n    # Validate input types\n    if not isinstance(actual_cost, (int, float)) or not isinstance(sale_amount, (int, float)):\n        raise ValueError(\"Both actual_cost and sale_amount must be numbers.\")\n    \n    # Calculate profit\n    profit = sale_amount - actual_cost\n    \n    # Return profit if positive, otherwise None\n    return profit if profit > 0 else None\n\n# Test cases\ndef test_profit_amount():\n    assert profit_amount(1500, 1200) is None, \"Test Case 1 Failed\"\n    assert profit_amount(1500, 1600) == 100, \"Test Case 2 Failed\"\n    assert profit_amount(1000, 1000) is None, \"Test Case 3 Failed\"\n    assert profit_amount(200, 300) == 100, \"Test Case 4 Failed\"\n    assert profit_amount(0, 100) == 100, \"Test Case 5 Failed\"\n    assert profit_amount(100, 0) is None, \"Test Case 6 Failed\"\n    assert profit_amount(50.5, 100.5) == 50.0, \"Test Case 7 Failed\"\n    \n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_profit_amount()"}
{"task_id": "MBPP/929", "completion": "def count_tuplex(tuplex, value):\n    \"\"\"\n    Count the occurrences of a specific value in a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple in which to count occurrences.\n    value: The value to count in the tuple.\n\n    Returns:\n    int: The count of occurrences of value in tuplex.\n\n    Example:\n    >>> count_tuplex((2, 4, 5, 6, 2, 3, 4, 4, 7), 4)\n    3\n    \"\"\"\n    if not isinstance(tuplex, tuple):\n        raise TypeError(\"The first argument must be a tuple.\")\n    \n    return tuplex.count(value)\n\n# Example usage\nif __name__ == \"__main__\":\n    print(count_tuplex((2, 4, 5, 6, 2, 3, 4, 4, 7), 4))  # Output: 3"}
{"task_id": "MBPP/460", "completion": "def Extract(lst):\n    \"\"\"\n    Extract the first element of each sublist in a list of lists.\n\n    Parameters:\n    lst (list of list): A list containing sublists from which to extract the first elements.\n\n    Returns:\n    list: A list containing the first elements of each sublist.\n\n    Raises:\n    ValueError: If any sublist is empty.\n    \"\"\"\n    first_elements = []\n    for sublist in lst:\n        if not sublist:  # Check if the sublist is empty\n            raise ValueError(\"One of the sublists is empty.\")\n        first_elements.append(sublist[0])  # Append the first element of the sublist\n    return first_elements\n\n# Test cases\ndef test_Extract():\n    # Normal case\n    assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n    \n    # Edge case: sublists with one element\n    assert Extract([[10], [20], [30]]) == [10, 20, 30]\n    \n    # Edge case: sublists with multiple elements\n    assert Extract([[1, 2, 3], [4, 5], [6]]) == [1, 4, 6]\n    \n    # Edge case: empty sublist should raise ValueError\n    try:\n        Extract([[1, 2], [], [3, 4]])\n    except ValueError as e:\n        assert str(e) == \"One of the sublists is empty.\"\n    \n    # Edge case: all sublists are empty\n    try:\n        Extract([[], [], []])\n    except ValueError as e:\n        assert str(e) == \"One of the sublists is empty.\"\n\n# Run the tests\ntest_Extract()\nprint(\"All tests passed!\")"}
{"task_id": "MBPP/402", "completion": "def factorial_mod(n, p):\n    \"\"\"Compute factorials modulo p up to n.\"\"\"\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = (fact[i - 1] * i) % p\n    return fact\n\ndef mod_inverse(a, p):\n    \"\"\"Compute the modular inverse of a under modulo p using Fermat's Little Theorem.\"\"\"\n    return pow(a, p - 2, p)\n\ndef ncr_modp(n, r, p):\n    \"\"\"\n    Compute the value of nCr % p.\n    \n    Parameters:\n    n (int): The total number of items.\n    r (int): The number of items to choose.\n    p (int): The modulus.\n    \n    Returns:\n    int: The value of nCr % p.\n    \"\"\"\n    if r > n:\n        return 0  # nCr is 0 if r > n\n    \n    # Precompute factorials modulo p\n    fact = factorial_mod(n, p)\n    \n    # Calculate nCr % p\n    numerator = fact[n]\n    denominator = (fact[r] * fact[n - r]) % p\n    \n    # Use modular inverse to compute the result\n    result = (numerator * mod_inverse(denominator, p)) % p\n    return result\n\n# Test case\nassert ncr_modp(10, 2, 13) == 6\n\n# Additional test cases\nassert ncr_modp(5, 2, 7) == 3  # 5C2 % 7 = 10 % 7 = 3\nassert ncr_modp(10, 5, 100) == 252  # 10C5 % 100 = 252 % 100 = 52\nassert ncr_modp(0, 0, 13) == 1  # 0C0 % 13 = 1\nassert ncr_modp(10, 11, 13) == 0  # 10C11 % 13 = 0\nassert ncr_modp(100, 50, 1000000007) == 33322150  # Large case"}
{"task_id": "MBPP/865", "completion": "def ntimes_list(nums, n):\n    \"\"\"\n    Multiplies each element in the list 'nums' by the integer 'n' using the map function.\n\n    Parameters:\n    nums (list): A list of numbers to be multiplied.\n    n (int): The multiplier.\n\n    Returns:\n    list: A new list containing the multiplied values.\n\n    Example:\n    >>> ntimes_list([1, 2, 3, 4, 5, 6, 7], 3)\n    [3, 6, 9, 12, 15, 18, 21]\n    \"\"\"\n    return list(map(lambda x: x * n, nums))"}
{"task_id": "MBPP/4_2", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    \n    :param strs: List of strings\n    :return: Longest common prefix string or empty string if none exists\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the prefix\n    prefix = strs[0]\n    \n    for string in strs[1:]:\n        # Compare the current string with the prefix\n        while string[:len(prefix)] != prefix:\n            # Shorten the prefix by one character\n            prefix = prefix[:-1]\n            # If the prefix is empty, return immediately\n            if not prefix:\n                return \"\"\n    \n    return prefix\n\n# Test cases\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'\nassert longest_common_prefix(['dog', 'racecar', 'car']) == ''\nassert longest_common_prefix(['a']) == 'a'\nassert longest_common_prefix(['']) == ''\nassert longest_common_prefix([]) == ''\nassert longest_common_prefix(['abc', 'ab', 'a']) == 'a'\nassert longest_common_prefix(['interspecies', 'interstellar', 'interstate']) == 'inter'"}
{"task_id": "MBPP/4_1", "completion": "def fibonacci(n):\n    \"\"\"\n    Return the n-th Fibonacci number.\n    \n    The Fibonacci sequence is defined as:\n    F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) for n > 1.\n    \n    Parameters:\n    n (int): The index of the Fibonacci number to return (non-negative integer).\n    \n    Returns:\n    int: The n-th Fibonacci number.\n    \n    Raises:\n    ValueError: If n is a negative integer.\n    \n    Example:\n    >>> fibonacci(5)\n    5\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\n# Test cases\nif __name__ == \"__main__\":\n    # Basic test cases\n    assert fibonacci(0) == 0\n    assert fibonacci(1) == 1\n    assert fibonacci(2) == 1\n    assert fibonacci(3) == 2\n    assert fibonacci(4) == 3\n    assert fibonacci(5) == 5\n    assert fibonacci(6) == 8\n    assert fibonacci(7) == 13\n    assert fibonacci(10) == 55\n    \n    # Edge case\n    try:\n        fibonacci(-1)\n    except ValueError as e:\n        assert str(e) == \"Input must be a non-negative integer.\"\n    \n    print(\"All tests passed!\")"}
{"task_id": "MBPP/4_3", "completion": "def gcd(a, b):\n    \"\"\"\n    Calculate the greatest common divisor (GCD) of two non-negative integers using the Euclidean algorithm.\n\n    Parameters:\n    a (int): The first non-negative integer.\n    b (int): The second non-negative integer.\n\n    Returns:\n    int: The GCD of a and b.\n\n    Raises:\n    ValueError: If either a or b is negative.\n\n    Example:\n    >>> gcd(48, 18)\n    6\n    \"\"\"\n    # Input validation\n    if a < 0 or b < 0:\n        raise ValueError(\"Both numbers must be non-negative integers.\")\n    \n    while b != 0:\n        a, b = b, a % b\n    return a\n\n# Test case\nif __name__ == \"__main__\":\n    assert gcd(48, 18) == 6, \"Test case failed!\"\n    assert gcd(56, 98) == 14, \"Test case failed!\"\n    assert gcd(101, 10) == 1, \"Test case failed!\"\n    assert gcd(0, 5) == 5, \"Test case failed!\"\n    assert gcd(0, 0) == 0, \"Test case failed!\"  # GCD(0, 0) is often defined as 0\n    print(\"All test cases passed!\")"}
{"task_id": "MBPP/4_6", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string among an array of strings.\n    \n    :param strs: List of strings\n    :return: Longest common prefix string or empty string if none exists\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the prefix\n    prefix = strs[0]\n    \n    for string in strs[1:]:\n        # Compare the current string with the prefix\n        while string[:len(prefix)] != prefix and prefix:\n            # Reduce the prefix by one character from the end\n            prefix = prefix[:-1]\n            if not prefix:  # If prefix becomes empty, return immediately\n                return \"\"\n    \n    return prefix"}
{"task_id": "MBPP/4_7", "completion": "def max_value(arr):\n    \"\"\"\n    Find the maximum value in a list of integers.\n\n    Parameters:\n    arr (list of int): A list of integers.\n\n    Returns:\n    int: The maximum integer in the list.\n\n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The input list cannot be empty.\")\n    \n    max_val = arr[0]  # Start with the first element as the maximum\n    for num in arr:\n        if num > max_val:\n            max_val = num  # Update max_val if a larger number is found\n    \n    return max_val"}
{"task_id": "MBPP/4_4", "completion": "def rotate_matrix(matrix):\n    \"\"\"\n    Rotate a given matrix by 90 degrees clockwise.\n\n    Args:\n    matrix (list of list of int): The input matrix to be rotated.\n\n    Returns:\n    list of list of int: The rotated matrix.\n\n    Raises:\n    ValueError: If the input is not a valid matrix.\n    \"\"\"\n    # Validate input\n    if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix):\n        raise ValueError(\"Input must be a list of lists.\")\n    \n    if len(matrix) == 0 or any(len(row) != len(matrix[0]) for row in matrix):\n        raise ValueError(\"All rows must have the same length.\")\n\n    # Get the dimensions of the original matrix\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    # Create a new matrix for the rotated version\n    rotated = [[0] * rows for _ in range(cols)]\n    \n    # Fill the rotated matrix\n    for i in range(rows):\n        for j in range(cols):\n            rotated[j][rows - 1 - i] = matrix[i][j]\n    \n    return rotated\n\n# Test cases\ndef test_rotate_matrix():\n    assert rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n    assert rotate_matrix([[1]]) == [[1]]\n    assert rotate_matrix([[1, 2], [3, 4]]) == [[3, 1], [4, 2]]\n    assert rotate_matrix([[1, 2, 3], [4, 5, 6]]) == [[4, 1], [5, 2], [6, 3]]\n    \n    # Edge case: empty matrix\n    assert rotate_matrix([]) == []\n    \n    # Edge case: non-square matrix\n    assert rotate_matrix([[1, 2], [3, 4], [5, 6]]) == [[5, 3, 1], [6, 4, 2]]\n\n    print(\"All tests passed!\")\n\n# Run the tests\ntest_rotate_matrix()"}
{"task_id": "MBPP/4_5", "completion": "def longest_common_substring(s1, s2):\n    \"\"\"\n    Find the length of the longest common substring between two strings.\n    \n    Parameters:\n    s1 (str): The first string.\n    s2 (str): The second string.\n    \n    Returns:\n    int: The length of the longest common substring.\n    \"\"\"\n    if not s1 or not s2:\n        return 0\n\n    # Create a 2D array to store lengths of longest common suffixes\n    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n    max_length = 0\n\n    # Build the dp array\n    for i in range(1, len(s1) + 1):\n        for j in range(1, len(s2) + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                max_length = max(max_length, dp[i][j])\n            else:\n                dp[i][j] = 0  # Not necessary, but for clarity\n\n    return max_length\n\n# Test cases\nassert longest_common_substring('abcdef', 'zcdemf') == 3  # 'cde' is the longest common substring\nassert longest_common_substring('hello', 'yell') == 3     # 'ell' is the longest common substring\nassert longest_common_substring('abc', 'xyz') == 0        # No common substring\nassert longest_common_substring('', 'abc') == 0            # One string is empty\nassert longest_common_substring('abc', '') == 0            # One string is empty\nassert longest_common_substring('', '') == 0               # Both strings are empty\nassert longest_common_substring('a', 'a') == 1             # Single character match\nassert longest_common_substring('abcde', 'abcxyz') == 3    # 'abc' is the longest common substring"}
{"task_id": "MBPP/4_9", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the prefix\n    prefix = strs[0]\n    \n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:  # If prefix is empty, return \"\"\n                return \"\"\n    \n    return prefix\n\n# Test cases\nassert longest_common_prefix(['flower', 'flow', 'flight']) == 'fl'\nassert longest_common_prefix(['dog', 'racecar', 'car']) == ''\nassert longest_common_prefix(['']) == ''\nassert longest_common_prefix(['a']) == 'a'\nassert longest_common_prefix(['ab', 'a']) == 'a'\nassert longest_common_prefix([]) == ''"}
{"task_id": "MBPP/4_8", "completion": "def longest_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    \n    :param strs: List of strings to find the common prefix from\n    :return: The longest common prefix string, or an empty string if none exists\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the initial prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character from the prefix\n            if not prefix:  # If prefix is empty, return immediately\n                return \"\"\n    \n    return prefix"}
{"task_id": "MBPP/4_0", "completion": "def longest_common_subsequence(s1, s2):\n    \"\"\"\n    Find the length of the longest common subsequence of two strings.\n\n    Parameters:\n    s1 (str): The first string.\n    s2 (str): The second string.\n\n    Returns:\n    int: The length of the longest common subsequence.\n    \"\"\"\n    # Input validation\n    if not isinstance(s1, str) or not isinstance(s2, str):\n        raise ValueError(\"Both inputs must be strings.\")\n    \n    len_s1 = len(s1)\n    len_s2 = len(s2)\n\n    # Create a 2D array to store lengths of longest common subsequence.\n    dp = [[0] * (len_s2 + 1) for _ in range(len_s1 + 1)]\n\n    # Build the dp array\n    for i in range(1, len_s1 + 1):\n        for j in range(1, len_s2 + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[len_s1][len_s2]\n\n# Test cases\nif __name__ == \"__main__\":\n    assert longest_common_subsequence('abcde', 'ace') == 3\n    assert longest_common_subsequence('abc', 'abc') == 3\n    assert longest_common_subsequence('abc', 'def') == 0\n    assert longest_common_subsequence('', 'abc') == 0\n    assert longest_common_subsequence('abc', '') == 0\n    assert longest_common_subsequence('a', 'a') == 1\n    assert longest_common_subsequence('a', 'b') == 0\n    assert longest_common_subsequence('abcdef', 'acf') == 3\n    assert longest_common_subsequence('AGGTAB', 'GXTXAYB') == 4\n\n    print(\"All test cases passed!\")"}
