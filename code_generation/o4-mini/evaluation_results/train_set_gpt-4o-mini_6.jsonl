{"task_id": "auto/7", "completion": "from typing import List\n\ndef find_max_difference(numbers: List[int]) -> int:\n    \"\"\" Find the maximum absolute difference between any two elements in the list.\n    \n    The function calculates the maximum difference by finding the maximum and minimum\n    values in the list and returning their difference. If the list is empty, it returns 0.\n    \n    >>> find_max_difference([1, 2, 3, 4])\n    3\n    >>> find_max_difference([5, 5, 5, 5])\n    0\n    >>> find_max_difference([-1, -2, -3, -4])\n    3\n    >>> find_max_difference([10])\n    0\n    >>> find_max_difference([])\n    0\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        return 0\n    \n    max_value = max(numbers)  # Find the maximum value in the list\n    min_value = min(numbers)  # Find the minimum value in the list\n    \n    return max_value - min_value  # Return the difference\n\n# Test cases\nif __name__ == \"__main__\":\n    print(find_max_difference([1, 2, 3, 4]))  # Expected output: 3\n    print(find_max_difference([5, 5, 5, 5]))  # Expected output: 0\n    print(find_max_difference([-1, -2, -3, -4]))  # Expected output: 3\n    print(find_max_difference([10]))  # Expected output: 0\n    print(find_max_difference([]))  # Expected output: 0"}
{"task_id": "auto/0", "completion": "from typing import List\n\ndef are_anagrams(word1: str, word2: str) -> bool:\n    \"\"\" Check if two strings are anagrams. Two words are anagrams if they contain the same letters in a different order.\n    \n    Args:\n        word1 (str): The first word to compare.\n        word2 (str): The second word to compare.\n    \n    Returns:\n        bool: True if the words are anagrams, False otherwise.\n    \n    Examples:\n        >>> are_anagrams('listen', 'silent')\n        True\n        >>> are_anagrams('hello', 'world')\n        False\n    \"\"\"\n    # Normalize the words by converting them to lowercase and sorting the letters\n    return sorted(word1.lower()) == sorted(word2.lower())\n\n# Test cases to validate the functionality of the are_anagrams function\nif __name__ == \"__main__\":\n    assert are_anagrams('listen', 'silent') == True, \"Test case 1 failed\"\n    assert are_anagrams('hello', 'world') == False, \"Test case 2 failed\"\n    assert are_anagrams('Triangle', 'Integral') == True, \"Test case 3 failed\"\n    assert are_anagrams('Apple', 'Papel') == True, \"Test case 4 failed\"\n    assert are_anagrams('A gentleman', 'Elegant man') == True, \"Test case 5 failed\"\n    assert are_anagrams('Test', 'Set') == False, \"Test case 6 failed\"\n    print(\"All test cases passed!\")"}
{"task_id": "auto/2", "completion": "from typing import List\n\ndef count_unique_numbers(numbers: List[int]) -> int:\n    \"\"\" Count the number of unique integers in the given list.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n        \n    Returns:\n        int: The count of unique integers in the list.\n    \n    Examples:\n        >>> count_unique_numbers([1, 2, 2, 3])\n        3\n        >>> count_unique_numbers([4, 4, 4, 4])\n        1\n    \"\"\"\n    # Use a set to store unique numbers since sets automatically handle duplicates\n    unique_numbers = set(numbers)\n    # Return the size of the set, which represents the count of unique numbers\n    return len(unique_numbers)\n\n# Test cases to validate the functionality of the count_unique_numbers function\nif __name__ == \"__main__\":\n    assert count_unique_numbers([1, 2, 2, 3]) == 3, \"Test case 1 failed\"\n    assert count_unique_numbers([4, 4, 4, 4]) == 1, \"Test case 2 failed\"\n    assert count_unique_numbers([]) == 0, \"Test case 3 failed\"  # Edge case: empty list\n    assert count_unique_numbers([1, 1, 1, 1, 1]) == 1, \"Test case 4 failed\"  # All elements are the same\n    assert count_unique_numbers([1, 2, 3, 4, 5]) == 5, \"Test case 5 failed\"  # All unique elements\n    assert count_unique_numbers([-1, -2, -2, -3]) == 3, \"Test case 6 failed\"  # Negative numbers\n    print(\"All test cases passed!\")"}
{"task_id": "auto/4", "completion": "from typing import List, Tuple\n\ndef max_difference(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Given a list of integers, return the pair of integers with the maximum difference.\n    \n    The function finds the minimum and maximum values in the list and returns them as a tuple.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n        \n    Returns:\n        Tuple[int, int]: A tuple containing the pair of integers with the maximum difference.\n        \n    Examples:\n        >>> max_difference([1, 2, 3, 10, 8])\n        (3, 10)\n        >>> max_difference([-1, -5, -3, 0])\n        (-5, 0)\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list must not be empty.\")\n    \n    min_value = min(numbers)\n    max_value = max(numbers)\n    \n    return (min_value, max_value)\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test case 1: Normal case with positive integers\n    print(max_difference([1, 2, 3, 10, 8]))  # Expected output: (3, 10)\n    \n    # Test case 2: Normal case with negative integers\n    print(max_difference([-1, -5, -3, 0]))  # Expected output: (-5, 0)\n    \n    # Test case 3: List with a single element\n    print(max_difference([5]))  # Expected output: (5, 5)\n    \n    # Test case 4: List with all identical elements\n    print(max_difference([2, 2, 2, 2]))  # Expected output: (2, 2)\n    \n    # Test case 5: Empty list should raise ValueError\n    try:\n        print(max_difference([]))  # Expected to raise ValueError\n    except ValueError as e:\n        print(e)  # Output the error message"}
{"task_id": "auto/6", "completion": "from typing import List\n\ndef is_anagram(str1: str, str2: str) -> bool:\n    \"\"\" Determines if two given strings are anagrams of each other. An anagram is a rearrangement of letters of a word to form another word.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: True if str1 and str2 are anagrams, False otherwise.\n    \n    Examples:\n        >>> is_anagram('listen', 'silent')\n        True\n        >>> is_anagram('triangle', 'integral')\n        True\n        >>> is_anagram('apple', 'pale')\n        False\n    \"\"\"\n    # Normalize the strings by converting them to lowercase and sorting the characters\n    return sorted(str1.lower()) == sorted(str2.lower())\n\n# Test cases to validate the functionality of the is_anagram function\nif __name__ == \"__main__\":\n    assert is_anagram('listen', 'silent') == True\n    assert is_anagram('triangle', 'integral') == True\n    assert is_anagram('apple', 'pale') == False\n    assert is_anagram('Dormitory', 'Dirty room') == True  # Ignoring spaces and case\n    assert is_anagram('The eyes', 'They see') == True  # Ignoring spaces and case\n    assert is_anagram('Hello', 'World') == False\n    assert is_anagram('', '') == True  # Edge case: empty strings are anagrams\n    print(\"All test cases passed!\")"}
{"task_id": "auto/1", "completion": "from typing import List\n\ndef is_palindrome(s: str) -> bool:\n    \"\"\" Check if the given string is a palindrome (reads the same backward as forward).\n    \n    Args:\n        s (str): The string to check.\n        \n    Returns:\n        bool: True if s is a palindrome, False otherwise.\n    \n    Examples:\n        >>> is_palindrome('racecar')\n        True\n        >>> is_palindrome('hello')\n        False\n        >>> is_palindrome('A man a plan a canal Panama')\n        True\n        >>> is_palindrome('No lemon no melon')\n        True\n        >>> is_palindrome('12321')\n        True\n        >>> is_palindrome('12345')\n        False\n    \"\"\"\n    # Normalize the string: remove spaces and convert to lowercase\n    normalized_str = ''.join(s.split()).lower()\n    # Check if the normalized string is equal to its reverse\n    return normalized_str == normalized_str[::-1]\n\n# Test cases to validate the functionality\nif __name__ == \"__main__\":\n    assert is_palindrome('racecar') == True\n    assert is_palindrome('hello') == False\n    assert is_palindrome('A man a plan a canal Panama') == True\n    assert is_palindrome('No lemon no melon') == True\n    assert is_palindrome('12321') == True\n    assert is_palindrome('12345') == False\n    assert is_palindrome('') == True  # An empty string is a palindrome\n    assert is_palindrome('a') == True  # A single character is a palindrome\n    print(\"All test cases passed!\")"}
{"task_id": "auto/5", "completion": "from typing import List\n\ndef find_duplicate(numbers: List[int]) -> bool:\n    \"\"\" Check if there are any duplicate numbers in a list.\n    \n    Args:\n        numbers (List[int]): A list of integers to check for duplicates.\n        \n    Returns:\n        bool: True if there are duplicates, False otherwise.\n    \n    Examples:\n        >>> find_duplicate([1, 2, 3, 4])\n        False\n        >>> find_duplicate([1, 2, 3, 4, 2])\n        True\n    \"\"\"\n    # Use a set to track seen numbers\n    seen = set()\n    \n    for number in numbers:\n        # If the number is already in the set, we found a duplicate\n        if number in seen:\n            return True\n        # Otherwise, add the number to the set\n        seen.add(number)\n    \n    # If we finish the loop without finding duplicates, return False\n    return False\n\n# Test cases to validate the functionality\nif __name__ == \"__main__\":\n    assert find_duplicate([1, 2, 3, 4]) == False, \"Test case 1 failed\"\n    assert find_duplicate([1, 2, 3, 4, 2]) == True, \"Test case 2 failed\"\n    assert find_duplicate([5, 6, 7, 8, 5]) == True, \"Test case 3 failed\"\n    assert find_duplicate([]) == False, \"Test case 4 failed\"\n    assert find_duplicate([1]) == False, \"Test case 5 failed\"\n    assert find_duplicate([1, 1]) == True, \"Test case 6 failed\"\n    \n    print(\"All test cases passed!\")"}
{"task_id": "auto/8", "completion": "from typing import List\n\ndef find_missing_number(numbers: List[int], n: int) -> int:\n    \"\"\" \n    Given a list of unique integers ranging from 1 to n, where one number is missing, \n    find and return the missing number.\n    \n    Args:\n    numbers (List[int]): A list of unique integers from 1 to n with one missing.\n    n (int): The upper limit of the range (1 to n).\n    \n    Returns:\n    int: The missing number in the range from 1 to n.\n    \n    Examples:\n    >>> find_missing_number([3, 7, 1, 2, 8, 4, 5], 8)\n    6\n    >>> find_missing_number([1, 2, 4], 4)\n    3\n    \"\"\"\n    # Calculate the expected sum of numbers from 1 to n using the formula n*(n+1)/2\n    expected_sum = n * (n + 1) // 2\n    # Calculate the actual sum of the numbers in the list\n    actual_sum = sum(numbers)\n    # The missing number is the difference between the expected sum and the actual sum\n    return expected_sum - actual_sum\n\n# Test cases to validate the functionality of the code\nif __name__ == \"__main__\":\n    assert find_missing_number([3, 7, 1, 2, 8, 4, 5], 8) == 6\n    assert find_missing_number([1, 2, 4], 4) == 3\n    assert find_missing_number([1], 1) == 2  # Edge case: missing number is 2\n    assert find_missing_number([2, 3, 4, 5], 5) == 1  # Edge case: missing number is 1\n    assert find_missing_number([1, 3], 3) == 2  # Missing number is 2\n    print(\"All test cases passed!\")"}
{"task_id": "auto/9", "completion": "from typing import List\n\ndef find_longest_sequence(numbers: List[int]) -> int:\n    \"\"\" Given a list of integers, find the length of the longest contiguous subsequence of consecutive integers.\n    \n    Args:\n        numbers (List[int]): A list of integers to analyze.\n        \n    Returns:\n        int: The length of the longest contiguous subsequence of consecutive integers.\n        \n    Examples:\n        >>> find_longest_sequence([1, 2, 9, 3, 4, 5])\n        3\n        >>> find_longest_sequence([1, 2, 3, 4])\n        4\n        >>> find_longest_sequence([10, 1, 2, 3, 4, 5, 0])\n        6\n    \"\"\"\n    if not numbers:\n        return 0  # Return 0 for an empty list\n\n    numbers = sorted(set(numbers))  # Remove duplicates and sort the list\n    longest_streak = 1\n    current_streak = 1\n\n    for i in range(1, len(numbers)):\n        if numbers[i] == numbers[i - 1] + 1:  # Check if current number is consecutive\n            current_streak += 1\n        else:\n            longest_streak = max(longest_streak, current_streak)  # Update longest streak if needed\n            current_streak = 1  # Reset current streak\n\n    longest_streak = max(longest_streak, current_streak)  # Final check for the last streak\n    return longest_streak\n\n# Test cases to validate the functionality\nif __name__ == \"__main__\":\n    assert find_longest_sequence([1, 2, 9, 3, 4, 5]) == 3\n    assert find_longest_sequence([1, 2, 3, 4]) == 4\n    assert find_longest_sequence([10, 1, 2, 3, 4, 5, 0]) == 6\n    assert find_longest_sequence([]) == 0  # Edge case: empty list\n    assert find_longest_sequence([1, 2, 2, 3, 4, 5]) == 5  # Duplicates in the list\n    assert find_longest_sequence([5, 3, 2, 1, 4]) == 5  # Unordered input\n    assert find_longest_sequence([100, 200, 300]) == 1  # No consecutive numbers"}
{"task_id": "auto/3", "completion": "from typing import List\n\ndef is_sorted(numbers: List[int]) -> bool:\n    \"\"\" Check if the given list of integers is sorted in ascending order.\n    \n    Args:\n        numbers (List[int]): A list of integers to check.\n        \n    Returns:\n        bool: True if the list is sorted in ascending order, False otherwise.\n    \n    Examples:\n        >>> is_sorted([1, 2, 3])\n        True\n        >>> is_sorted([3, 2, 1])\n        False\n        >>> is_sorted([1, 1, 2, 2, 3])\n        True\n        >>> is_sorted([])\n        True\n        >>> is_sorted([1])\n        True\n    \"\"\"\n    # An empty list or a list with one element is considered sorted\n    if len(numbers) <= 1:\n        return True\n    \n    # Check if each element is less than or equal to the next element\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n            \n    return True\n\n# Test cases to validate the functionality of the is_sorted function\nif __name__ == \"__main__\":\n    assert is_sorted([1, 2, 3]) == True\n    assert is_sorted([3, 2, 1]) == False\n    assert is_sorted([1, 1, 2, 2, 3]) == True\n    assert is_sorted([]) == True\n    assert is_sorted([1]) == True\n    assert is_sorted([1, 2, 2, 3, 4]) == True\n    assert is_sorted([1, 3, 2]) == False\n    print(\"All test cases passed!\")"}
