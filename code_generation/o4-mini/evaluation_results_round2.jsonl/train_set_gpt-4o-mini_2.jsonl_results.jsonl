{"task_id": "auto/2", "completion": "from typing import List\n\ndef count_unique_numbers(numbers: List[int]) -> int:\n    \"\"\" Count the number of unique integers in the given list.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n        \n    Returns:\n        int: The count of unique integers in the list.\n    \n    Examples:\n        >>> count_unique_numbers([1, 2, 2, 3])\n        3\n        >>> count_unique_numbers([4, 4, 4, 4])\n        1\n    \"\"\"\n    # Use a set to store unique numbers since sets automatically handle duplicates\n    unique_numbers = set(numbers)\n    \n    # Return the length of the set, which represents the count of unique numbers\n    return len(unique_numbers)\n\n# If you want to run the examples as tests, you can uncomment the following lines:\n# if __name__ == \"__main__\":\n#     import doctest\n#     doctest.testmod()", "result": "passed", "passed": true}
{"task_id": "auto/3", "completion": "from typing import List\n\ndef is_sorted(numbers: List[int]) -> bool:\n    \"\"\" Check if the given list of integers is sorted in ascending order.\n    \n    Args:\n        numbers (List[int]): A list of integers to check.\n        \n    Returns:\n        bool: True if the list is sorted in ascending order, False otherwise.\n    \n    Examples:\n        >>> is_sorted([1, 2, 3])\n        True\n        >>> is_sorted([3, 2, 1])\n        False\n        >>> is_sorted([1, 1, 2, 2, 3])\n        True\n        >>> is_sorted([])\n        True\n    \"\"\"\n    # An empty list is considered sorted\n    if not numbers:\n        return True\n    \n    # Iterate through the list and check if each element is less than or equal to the next\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n            \n    return True", "result": "passed", "passed": true}
{"task_id": "auto/7", "completion": "from typing import List\n\ndef find_max_difference(numbers: List[int]) -> int:\n    \"\"\" Find the maximum absolute difference between any two elements in the list.\n    \n    The function calculates the maximum difference by finding the maximum and minimum\n    values in the list and returning their absolute difference.\n    \n    >>> find_max_difference([1, 2, 3, 4])\n    3\n    >>> find_max_difference([5, 5, 5, 5])\n    0\n    >>> find_max_difference([-1, -2, -3, -4])\n    3\n    >>> find_max_difference([10, 20, 30, 40])\n    30\n    >>> find_max_difference([1])\n    0\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        return 0  # Return 0 for an empty list as there are no elements to compare\n\n    max_value = max(numbers)  # Find the maximum value in the list\n    min_value = min(numbers)  # Find the minimum value in the list\n    \n    return abs(max_value - min_value)  # Return the absolute difference\n\n# Example test cases\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "result": "passed", "passed": true}
{"task_id": "auto/0", "completion": "from typing import List\n\ndef are_anagrams(word1: str, word2: str) -> bool:\n    \"\"\" Check if two strings are anagrams. Two words are anagrams if they contain the same letters in a different order.\n    \n    >>> are_anagrams('listen', 'silent')\n    True\n    >>> are_anagrams('hello', 'world')\n    False\n    >>> are_anagrams('triangle', 'integral')\n    True\n    >>> are_anagrams('apple', 'pale')\n    False\n    >>> are_anagrams('anagram', 'nagaram')\n    True\n    \"\"\"\n    # Normalize the words by converting them to lowercase\n    word1 = word1.lower()\n    word2 = word2.lower()\n    \n    # Sort the characters of both words and compare\n    return sorted(word1) == sorted(word2)\n\n# If you want to run the tests, you can use the following code:\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "result": "passed", "passed": true}
{"task_id": "auto/6", "completion": "from typing import List\n\ndef is_anagram(str1: str, str2: str) -> bool:\n    \"\"\" Determines if two given strings are anagrams of each other. An anagram is a rearrangement of letters of a word to form another word.\n    \n    Args:\n        str1 (str): The first string to compare.\n        str2 (str): The second string to compare.\n    \n    Returns:\n        bool: True if str1 and str2 are anagrams, False otherwise.\n    \n    Examples:\n    >>> is_anagram('listen', 'silent')\n    True\n    >>> is_anagram('triangle', 'integral')\n    True\n    >>> is_anagram('apple', 'pale')\n    False\n    \"\"\"\n    # Normalize the strings by converting them to lowercase\n    str1 = str1.lower()\n    str2 = str2.lower()\n    \n    # Sort the characters of both strings and compare\n    return sorted(str1) == sorted(str2)\n\n# If you want to run the test cases, you can use the following code:\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()", "result": "passed", "passed": true}
{"task_id": "auto/8", "completion": "from typing import List\n\ndef find_missing_number(numbers: List[int], n: int) -> int:\n    \"\"\" Given a list of unique integers ranging from 1 to n, where one number is missing, \n    find and return the missing number.\n    \n    >>> find_missing_number([3, 7, 1, 2, 8, 4, 5], 8)\n    6\n    >>> find_missing_number([1, 2, 4], 4)\n    3\n    \"\"\"\n    # Calculate the expected sum of numbers from 1 to n using the formula n * (n + 1) // 2\n    expected_sum = n * (n + 1) // 2\n    \n    # Calculate the actual sum of the numbers in the list\n    actual_sum = sum(numbers)\n    \n    # The missing number is the difference between the expected sum and the actual sum\n    missing_number = expected_sum - actual_sum\n    \n    return missing_number\n\n# If you want to run the test cases, you can uncomment the following lines:\n# if __name__ == \"__main__\":\n#     import doctest\n#     doctest.testmod()", "result": "failed: invalid syntax (<string>, line 10)", "passed": false}
{"task_id": "auto/1", "completion": "from typing import List\n\ndef is_palindrome(s: str) -> bool:\n    \"\"\" Check if the given string is a palindrome (reads the same backward as forward).\n    \n    A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    \n    Args:\n        s (str): The string to check for palindrome properties.\n    \n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \n    Examples:\n    >>> is_palindrome('racecar')\n    True\n    >>> is_palindrome('hello')\n    False\n    >>> is_palindrome('A man a plan a canal Panama')\n    True\n    >>> is_palindrome('No lemon, no melon')\n    True\n    \"\"\"\n    # Normalize the string: remove non-alphanumeric characters and convert to lowercase\n    normalized_str = ''.join(char.lower() for char in s if char.isalnum())\n    \n    # Check if the normalized string is equal to its reverse\n    return normalized_str == normalized_str[::-1]\n\n# Test cases to validate the function\nif __name__ == \"__main__\":\n    assert is_palindrome('racecar') == True\n    assert is_palindrome('hello') == False\n    assert is_palindrome('A man a plan a canal Panama') == True\n    assert is_palindrome('No lemon, no melon') == True\n    assert is_palindrome('') == True  # An empty string is a palindrome\n    assert is_palindrome('Was it a car or a cat I saw?') == True\n    print(\"All tests passed!\")", "result": "failed: ", "passed": false}
{"task_id": "auto/5", "completion": "from typing import List\n\ndef find_duplicate(numbers: List[int]) -> bool:\n    \"\"\" Check if there are any duplicate numbers in a list.\n    \n    Args:\n        numbers (List[int]): A list of integers to check for duplicates.\n    \n    Returns:\n        bool: True if there are duplicates, False otherwise.\n    \n    Examples:\n    >>> find_duplicate([1, 2, 3, 4])\n    False\n    >>> find_duplicate([1, 2, 3, 4, 2])\n    True\n    \"\"\"\n    seen = set()  # Create a set to track seen numbers\n    for number in numbers:\n        if number in seen:  # Check if the number is already in the set\n            return True  # Duplicate found\n        seen.add(number)  # Add the number to the set\n    return False  # No duplicates found", "result": "passed", "passed": true}
{"task_id": "auto/4", "completion": "from typing import List, Tuple\n\ndef max_difference(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Given a list of integers, return the pair of integers with the maximum difference.\n    \n    The function finds the minimum and maximum values in the list and returns them as a tuple.\n    \n    >>> max_difference([1, 2, 3, 10, 8])\n    (3, 10)\n    >>> max_difference([-1, -5, -3, 0])\n    (-5, 0)\n    \"\"\"\n    # Check if the list is empty or has only one element\n    if not numbers or len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two integers.\")\n    \n    # Find the minimum and maximum values in the list\n    min_value = min(numbers)\n    max_value = max(numbers)\n    \n    # Return the pair of integers with the maximum difference\n    return (min_value, max_value)\n\n# Example test cases\nif __name__ == \"__main__\":\n    print(max_difference([1, 2, 3, 10, 8]))  # Output: (3, 10)\n    print(max_difference([-1, -5, -3, 0]))   # Output: (-5, 0)", "result": "failed: ", "passed": false}
{"task_id": "auto/9", "completion": "from typing import List\n\ndef find_longest_sequence(numbers: List[int]) -> int:\n    \"\"\" Given a list of integers, find the length of the longest contiguous subsequence of consecutive integers.\n    \n    Args:\n        numbers (List[int]): A list of integers.\n        \n    Returns:\n        int: The length of the longest contiguous subsequence of consecutive integers.\n    \n    Examples:\n    >>> find_longest_sequence([1, 2, 9, 3, 4, 5])\n    3\n    >>> find_longest_sequence([1, 2, 3, 4])\n    4\n    >>> find_longest_sequence([10, 1, 2, 3, 4, 5, 0])\n    6\n    \"\"\"\n    if not numbers:\n        return 0  # Return 0 if the list is empty\n\n    # Sort the numbers to find consecutive sequences\n    numbers = sorted(set(numbers))  # Remove duplicates and sort the list\n    max_length = 1  # Initialize the maximum length of consecutive sequence\n    current_length = 1  # Initialize the current length of consecutive sequence\n\n    # Iterate through the sorted list to find the longest consecutive sequence\n    for i in range(1, len(numbers)):\n        if numbers[i] == numbers[i - 1] + 1:\n            current_length += 1  # Increment current length if consecutive\n        else:\n            max_length = max(max_length, current_length)  # Update max length if needed\n            current_length = 1  # Reset current length for new sequence\n\n    # Final check to update max_length in case the longest sequence ends at the last element\n    max_length = max(max_length, current_length)\n\n    return max_length  # Return the length of the longest consecutive sequence", "result": "failed: ", "passed": false}
