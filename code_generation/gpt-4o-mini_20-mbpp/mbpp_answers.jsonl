{"task_id": "MBPP/3", "entry_point": "is_not_prime", "completion": "def is_not_prime(n):\n    if n < 2:\n        return True  # Numbers less than 2 are not prime\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # Found a divisor, so n is not prime\n    return False  # No divisors found, so n is prime\n\n# Test case\nassert is_not_prime(2) == False"}
{"task_id": "MBPP/10", "entry_point": "small_nnum", "completion": "import heapq\n\ndef small_nnum(data, n):\n    \"\"\"Return the n smallest items from the dataset.\"\"\"\n    return heapq.nsmallest(n, data)\n\n# Test the function with the provided assertion\nassert small_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100], 2) == [10, 20]"}
{"task_id": "MBPP/2", "entry_point": "similar_elements", "completion": "def similar_elements(tuple1, tuple2):\n    # Convert tuples to sets to find the intersection\n    set1 = set(tuple1)\n    set2 = set(tuple2)\n    \n    # Find the intersection of both sets\n    similar = set1.intersection(set2)\n    \n    # Return the result as a sorted tuple\n    return tuple(sorted(similar))\n\n# Test the function with the provided assertion\nassert similar_elements((3, 4, 5, 6), (5, 7, 4, 10)) == (4, 5)"}
{"task_id": "MBPP/7", "entry_point": "find_char_long", "completion": "import re\n\ndef find_char_long(input_string):\n    # Use regex to find all words with at least 4 characters\n    return re.findall(r'\\b\\w{4,}\\b', input_string)\n\n# Test the function with the provided assertion\nassert find_char_long('Please move back to stream') == ['Please', 'move', 'back', 'stream']"}
{"task_id": "MBPP/8", "entry_point": "square_nums", "completion": "def square_nums(nums):\n    return list(map(lambda x: x ** 2, nums))\n\n# Test the function with the provided assertion\nassert square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"}
{"task_id": "MBPP/4", "entry_point": "heap_queue_largest", "completion": "import heapq\n\ndef heap_queue_largest(numbers, n):\n    # Use heapq.nlargest to find the n largest numbers in the list\n    return heapq.nlargest(n, numbers)\n\n# Test the function with the provided assertion\nassert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]"}
{"task_id": "MBPP/6", "entry_point": "differ_At_One_Bit_Pos", "completion": "def differ_At_One_Bit_Pos(num1, num2):\n    # Perform XOR operation\n    xor_result = num1 ^ num2\n    \n    # Check if xor_result has exactly one bit set\n    return xor_result != 0 and (xor_result & (xor_result - 1)) == 0\n\n# Test the function with the provided assertion\nassert differ_At_One_Bit_Pos(13, 9) == True"}
{"task_id": "MBPP/9", "entry_point": "find_Rotations", "completion": "def find_Rotations(s: str) -> int:\n    # Length of the string\n    n = len(s)\n    \n    # If the string is empty or has only one character, it requires 1 rotation\n    if n <= 1:\n        return 1\n    \n    # Check for the minimum number of rotations\n    for i in range(1, n + 1):\n        # Create the rotated version of the string\n        rotated = s[i % n:] + s[:i % n]\n        if rotated == s:\n            return i\n    \n    return n  # In the worst case, it will take n rotations to return to the original string\n\n# Test the function with the provided assertion\nassert find_Rotations(\"aaaa\") == 1"}
{"task_id": "MBPP/12", "entry_point": "sort_matrix", "completion": "def sort_matrix(matrix):\n    # Sort the matrix using the sum of each row as the key\n    return sorted(matrix, key=sum)\n\n# Test the function with the provided assertion\nassert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]]) == [[1, 1, 1], [1, 2, 3], [2, 4, 5]]"}
{"task_id": "MBPP/17", "entry_point": "square_perimeter", "completion": "def square_perimeter(side_length):\n    return 4 * side_length\n\n# Test the function with the provided assertion\nassert square_perimeter(10) == 40"}
{"task_id": "MBPP/11", "entry_point": "remove_Occ", "completion": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found or only occurs once, return the string unchanged\n    if first_index == -1 or first_index == last_index:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    # Adjust the last index after the first removal\n    last_index -= 1  # Adjust for the removed character\n    \n    # Remove the last occurrence\n    s = s[:last_index] + s[last_index + 1:]\n    \n    return s\n\n# Test the function with the provided assertion\nassert remove_Occ(\"hello\", \"l\") == \"heo\""}
{"task_id": "MBPP/18", "entry_point": "remove_dirty_chars", "completion": "def remove_dirty_chars(s1, s2):\n    return ''.join(char for char in s1 if char not in s2)\n\n# Test the function with the provided assertion\nassert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'"}
{"task_id": "MBPP/13", "entry_point": "count_common", "completion": "from collections import Counter\n\ndef count_common(words):\n    # Count the occurrences of each word in the list\n    word_count = Counter(words)\n    \n    # Get the most common words and their counts\n    most_common = word_count.most_common()\n    \n    # Filter the results to only include the top counts\n    # In this case, we want to return the top counts for 'pink', 'black', 'white', and 'red'\n    result = [(word, count) for word, count in most_common if word in ['pink', 'black', 'white', 'red']]\n    \n    return result\n\n# Test the function with the provided assertion\nassert count_common(['red','green','black','pink','black','white','black','eyes','white','black','orange','pink','pink','red','red','white','orange','white',\"black\",'pink','green','green','pink','green','pink','white','orange',\"orange\",'red']) == [('pink', 6), ('black', 5), ('white', 5), ('red', 4)]"}
{"task_id": "MBPP/16", "entry_point": "text_lowercase_underscore", "completion": "import re\n\ndef text_lowercase_underscore(text):\n    # Regular expression to find sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    if re.match(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'No match found.'\n\n# Test the function with the provided assertion\nassert text_lowercase_underscore(\"aab_cbbbc\") == 'Found a match!'"}
{"task_id": "MBPP/15", "entry_point": "split_lowerstring", "completion": "def split_lowerstring(s):\n    result = []\n    current_segment = ''\n    \n    for char in s:\n        if char.islower():\n            if current_segment:\n                result.append(current_segment)\n                current_segment = ''\n        current_segment += char\n    \n    if current_segment:\n        result.append(current_segment)\n    \n    return result\n\n# Test the function with the provided assertion\nassert split_lowerstring(\"AbCd\") == ['bC', 'd']"}
{"task_id": "MBPP/1", "entry_point": "min_cost", "completion": "def min_cost(cost, m, n):\n    # Create a 2D array to store the minimum cost to reach each cell\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Initialize the starting point\n    dp[0][0] = cost[0][0]\n    \n    # Fill the first row\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] + cost[0][j]\n    \n    # Fill the first column\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] + cost[i][0]\n    \n    # Fill the rest of the dp array\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = cost[i][j] + min(dp[i - 1][j], dp[i][j - 1])\n    \n    # The minimum cost to reach (m, n)\n    return dp[m][n]\n\n# Example usage\nassert min_cost([[1, 2, 3], [4, 8, 2], [1, 5, 3]], 2, 2) == 8"}
{"task_id": "MBPP/19", "entry_point": "test_duplicate", "completion": "def test_duplicate(arr):\n    # Use a set to track seen elements\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True  # Duplicate found\n        seen.add(num)\n    return False  # No duplicates found\n\n# Test the function with the provided assertion\nassert test_duplicate([1, 2, 3, 4, 5]) == False"}
{"task_id": "MBPP/14", "entry_point": "find_Volume", "completion": "def find_Volume(base, height, length):\n    # Calculate the area of the triangular base\n    base_area = 0.5 * base * height\n    # Calculate the volume of the prism\n    volume = base_area * length\n    return volume\n\n# Test the function with the provided assertion\nassert find_Volume(10, 8, 6) == 240"}
{"task_id": "MBPP/21", "entry_point": "multiples_of_num", "completion": "def multiples_of_num(n, m):\n    return [n * i for i in range(1, m + 1)]\n\n# Test the function with the provided assertion\nassert multiples_of_num(4, 3) == [3, 6, 9, 12]"}
{"task_id": "MBPP/5", "entry_point": "count_ways", "completion": "def count_ways(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 0\n    if n == 2:\n        return 3\n    if n == 3:\n        return 0\n\n    # Create a list to store the number of ways to fill the board\n    dp = [0] * (n + 1)\n    dp[0] = 1  # Base case: 1 way to fill a 3 x 0 board (do nothing)\n    dp[1] = 0  # No way to fill a 3 x 1 board\n    dp[2] = 3  # 3 ways to fill a 3 x 2 board\n    dp[3] = 0  # No way to fill a 3 x 3 board\n\n    for i in range(4, n + 1):\n        dp[i] = 4 * dp[i - 2] + dp[i - 4]\n\n    return dp[n]\n\n# Test the function with the provided assertion\nassert count_ways(2) == 3"}
{"task_id": "MBPP/23", "entry_point": "maximum_Sum", "completion": "def maximum_Sum(list_of_lists):\n    # Calculate the sum of each sublist and return the maximum sum\n    return max(sum(sublist) for sublist in list_of_lists)\n\n# Test the function with the provided assertion\nassert maximum_Sum([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == 33"}
{"task_id": "MBPP/22", "entry_point": "find_first_duplicate", "completion": "def find_first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None  # Return None if no duplicate is found\n\n# Test the function with the provided assertion\nassert find_first_duplicate([1, 2, 3, 4, 4, 5]) == 4"}
{"task_id": "MBPP/24", "entry_point": "binary_to_decimal", "completion": "def binary_to_decimal(binary):\n    decimal = 0\n    binary_str = str(binary)[::-1]  # Reverse the string for easier calculation\n    for index, digit in enumerate(binary_str):\n        decimal += int(digit) * (2 ** index)\n    return decimal\n\n# Test the function with the provided assertion\nassert binary_to_decimal(100) == 4"}
{"task_id": "MBPP/20", "entry_point": "is_woodall", "completion": "def is_woodall(num):\n    n = 0\n    while True:\n        woodall_number = n * (2 ** n) - 1\n        if woodall_number == num:\n            return True\n        elif woodall_number > num:\n            return False\n        n += 1\n\n# Test the function with the provided assertion\nassert is_woodall(383) == True"}
{"task_id": "MBPP/26", "entry_point": "check_k_elements", "completion": "def check_k_elements(tuple_list, k):\n    return all(len(tup) == k for tup in tuple_list)\n\n# Test the function with the provided assertion\nassert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True"}
{"task_id": "MBPP/27", "entry_point": "remove", "completion": "def remove(strings):\n    return [''.join(filter(lambda x: not x.isdigit(), s)) for s in strings]\n\n# Test the function with the provided assertion\nassert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']"}
{"task_id": "MBPP/25", "entry_point": "find_Product", "completion": "def find_Product(arr, n):\n    # Create a dictionary to count occurrences of each element\n    count = {}\n    \n    # Count occurrences of each element in the array\n    for num in arr:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Calculate the product of non-repeated elements\n    product = 1\n    found_non_repeated = False\n    for num, cnt in count.items():\n        if cnt == 1:  # Check if the element is non-repeated\n            product *= num\n            found_non_repeated = True\n    \n    # If no non-repeated elements were found, return 0\n    return product if found_non_repeated else 0\n\n# Test the function with the provided assertion\nassert find_Product([1, 1, 2, 3], 4) == 6"}
{"task_id": "MBPP/28", "entry_point": "binomial_Coeff", "completion": "def factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\ndef binomial_Coeff(n, k):\n    if k < 0 or k > n:\n        return 0\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\n# Test the function\nassert binomial_Coeff(5, 2) == 10"}
{"task_id": "MBPP/29", "entry_point": "get_Odd_Occurrence", "completion": "def get_Odd_Occurrence(arr, n):\n    count = {}\n    \n    # Count occurrences of each element\n    for num in arr:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n            \n    # Find the element with an odd count\n    for num, cnt in count.items():\n        if cnt % 2 != 0:\n            return num\n            \n    return None  # Return None if no odd occurrence is found\n\n# Test the function with the provided assertion\nassert get_Odd_Occurrence([1, 2, 3, 1, 2, 3, 1], 7) == 1"}
{"task_id": "MBPP/33", "entry_point": "decimal_To_Binary", "completion": "def decimal_to_binary(n):\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    return int(bin(n)[2:])  # Convert to binary and remove the '0b' prefix\n\n# Test the function with the provided assertion\nassert decimal_to_binary(10) == 1010"}
{"task_id": "MBPP/34", "entry_point": "find_missing", "completion": "def find_missing(arr, n):\n    # Calculate the expected sum of the first n natural numbers\n    expected_sum = n * (n + 1) // 2\n    # Calculate the actual sum of the elements in the array\n    actual_sum = sum(arr)\n    # The missing number is the difference between the expected sum and the actual sum\n    return expected_sum - actual_sum\n\n# Test the function with the provided assertion\nassert find_missing([1, 2, 3, 5], 4) == 4"}
{"task_id": "MBPP/35", "entry_point": "find_rect_num", "completion": "def find_rect_num(n):\n    return n * (n + 1)\n\n# Test the function with the provided assertion\nassert find_rect_num(4) == 20"}
{"task_id": "MBPP/37", "entry_point": "sort_mixed_list", "completion": "def sort_mixed_list(mixed_list):\n    # Separate integers and strings\n    integers = [item for item in mixed_list if isinstance(item, int)]\n    strings = [item for item in mixed_list if isinstance(item, str)]\n    \n    # Sort both lists\n    integers.sort()\n    strings.sort()\n    \n    # Combine the sorted lists\n    return integers + strings\n\n# Test the function with the provided assertion\nassert sort_mixed_list([19, 'red', 12, 'green', 'blue', 10, 'white', 'green', 1]) == [1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']"}
{"task_id": "MBPP/32", "entry_point": "max_Prime_Factors", "completion": "def max_Prime_Factors(n):\n    # Initialize the largest prime factor\n    largest_prime = -1\n    \n    # Check for number of 2s that divide n\n    while n % 2 == 0:\n        largest_prime = 2\n        n //= 2\n    \n    # n must be odd at this point, so we can skip even numbers\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        largest_prime = n\n    \n    return largest_prime\n\n# Test the function with the provided assertion\nassert max_Prime_Factors(15) == 5"}
{"task_id": "MBPP/41", "entry_point": "filter_evennumbers", "completion": "def filter_evennumbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n\n# Test the function with the provided assertion\nassert filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [2, 4, 6, 8, 10]"}
{"task_id": "MBPP/31", "entry_point": "func", "completion": "import heapq\nfrom collections import Counter\n\ndef func(lists, k):\n    # Count occurrences of each integer across all lists\n    count = Counter()\n    for lst in lists:\n        count.update(lst)\n    \n    # Use a heap to find the top k most common elements\n    # The heap will store tuples of (-frequency, number) to create a max-heap based on frequency\n    heap = [(-freq, num) for num, freq in count.items()]\n    heapq.heapify(heap)\n    \n    # Extract the top k elements\n    top_k = []\n    for _ in range(k):\n        if heap:\n            freq, num = heapq.heappop(heap)\n            top_k.append(num)\n    \n    return top_k\n\n# Test the function with the provided assertion\nassert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]], 3) == [5, 7, 1]"}
{"task_id": "MBPP/40", "entry_point": "freq_element", "completion": "from collections import Counter\n\ndef freq_element(list_of_lists):\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    # Use Counter to count the frequency of each element\n    frequency = Counter(flat_list)\n    return dict(frequency)\n\n# Test the function with the provided assertion\nassert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]]) == ({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})"}
{"task_id": "MBPP/30", "entry_point": "count_Substring_With_Equal_Ends", "completion": "def count_Substring_With_Equal_Ends(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    # Dictionary to count occurrences of each character\n    char_count = {}\n    \n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Calculate the number of substrings for each character\n    for count_of_char in char_count.values():\n        # For each character, the number of substrings is count * (count + 1) // 2\n        count += (count_of_char * (count_of_char + 1)) // 2\n    \n    return count\n\n# Test the function with the provided assertion\nassert count_Substring_With_Equal_Ends(\"abc\") == 3"}
{"task_id": "MBPP/38", "entry_point": "div_even_odd", "completion": "def div_even_odd(numbers):\n    first_even = None\n    first_odd = None\n    \n    for num in numbers:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        \n        # Break the loop if both numbers are found\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # Check if both even and odd numbers were found\n    if first_even is not None and first_odd is not None:\n        return first_even / first_odd\n    else:\n        raise ValueError(\"The list must contain at least one even and one odd number.\")\n\n# Test the function with the provided assertion\nassert div_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 4"}
{"task_id": "MBPP/36", "entry_point": "find_Nth_Digit", "completion": "def find_Nth_Digit(numerator, denominator, n):\n    # Calculate the proper fraction\n    fraction = numerator / denominator\n    \n    # Convert the fraction to a string\n    fraction_str = str(fraction)\n    \n    # Find the position of the decimal point\n    decimal_index = fraction_str.index('.')\n    \n    # Check if n is within the bounds of the digits after the decimal point\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n    \n    # Get the digits after the decimal point\n    decimal_digits = fraction_str[decimal_index + 1:]\n    \n    # Check if the requested digit exists\n    if n > len(decimal_digits):\n        raise IndexError(\"The requested digit is out of bounds.\")\n    \n    # Return the nth digit (1-based index)\n    return int(decimal_digits[n - 1])\n\n# Example usage\nassert find_Nth_Digit(1, 2, 1) == 5"}
{"task_id": "MBPP/43", "entry_point": "text_match", "completion": "import re\n\ndef text_match(text):\n    # Define the regex pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'No match found.'\n\n# Test the function with the provided assertion\nassert text_match(\"aab_cbbbc\") == 'Found a match!'"}
{"task_id": "MBPP/46", "entry_point": "test_distinct", "completion": "def test_distinct(numbers):\n    return len(numbers) == len(set(numbers))\n\n# Test the function with the provided assertion\nassert test_distinct([1, 5, 7, 9]) == True"}
{"task_id": "MBPP/44", "entry_point": "text_match_string", "completion": "def text_match_string(input_string):\n    if input_string.startswith(\"python\"):\n        return \"Matched!\"\n    else:\n        return \"Not matched!\"\n\n# Test the function\nassert text_match_string(\" python\") == 'Not matched!'"}
{"task_id": "MBPP/52", "entry_point": "parallelogram_area", "completion": "def parallelogram_area(base, height):\n    \"\"\"Calculate the area of a parallelogram given its base and height.\"\"\"\n    return base * height\n\n# Test the function with the provided assertion\nassert parallelogram_area(10, 20) == 200"}
{"task_id": "MBPP/45", "entry_point": "get_gcd", "completion": "from math import gcd\nfrom functools import reduce\n\ndef get_gcd(arr):\n    return reduce(gcd, arr)\n\n# Test the function with the provided assertion\nassert get_gcd([2, 4, 6, 8, 16]) == 2"}
{"task_id": "MBPP/39", "entry_point": "rearange_string", "completion": "import heapq\nfrom collections import Counter\n\ndef rearrange_string(s: str) -> str:\n    # Count the frequency of each character\n    char_count = Counter(s)\n    \n    # Create a max heap based on character frequency\n    max_heap = [(-count, char) for char, count in char_count.items()]\n    heapq.heapify(max_heap)\n    \n    result = []\n    prev_char = None\n    prev_count = 0\n    \n    while max_heap:\n        count, char = heapq.heappop(max_heap)\n        result.append(char)\n        \n        # If there was a previous character, push it back to the heap\n        if prev_count < 0:\n            heapq.heappush(max_heap, (prev_count, prev_char))\n        \n        # Update the previous character and its count\n        prev_char = char\n        prev_count = count + 1  # Decrease the count since we used this character\n    \n    rearranged = ''.join(result)\n    \n    # Check if the rearranged string is valid\n    if len(rearranged) != len(s):\n        return \"\"  # Not possible to rearrange\n    \n    return rearranged\n\n# Test the function with the provided assertion\nassert rearrange_string(\"aab\") == 'aba'"}
{"task_id": "MBPP/47", "entry_point": "compute_Last_Digit", "completion": "def factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n\ndef compute_Last_Digit(a, b):\n    if a > b:\n        raise ValueError(\"a must be less than or equal to b\")\n    \n    factorial_a = factorial(a)\n    factorial_b = factorial(b)\n    \n    result = factorial_b // factorial_a  # Integer division\n    last_digit = result % 10  # Get the last digit\n    \n    return last_digit\n\n# Test the function with the provided assertion\nassert compute_Last_Digit(2, 4) == 2"}
{"task_id": "MBPP/49", "entry_point": "specified_element", "completion": "def specified_element(two_d_list, index):\n    return [row[index] for row in two_d_list]\n\n# Example usage\nresult = specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]], 0)\nprint(result)  # Output: [1, 4, 7]\n\n# Assertion to verify the function works as expected\nassert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]], 0) == [1, 4, 7]"}
{"task_id": "MBPP/53", "entry_point": "check_Equality", "completion": "def check_Equality(s):\n    if s and s[0] == s[-1]:  # Check if the string is not empty and first equals last\n        return \"Equal\"\n    else:\n        return \"Not Equal\"\n\n# Example assertion\nassert check_Equality(\"abcda\") == \"Equal\""}
{"task_id": "MBPP/50", "entry_point": "min_length_list", "completion": "def min_length_list(lists):\n    return min((len(lst), lst) for lst in lists)\n\n# Test the function with the provided assertion\nassert min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (1, [0])"}
{"task_id": "MBPP/51", "entry_point": "check_equilateral", "completion": "def check_equilateral(a, b, c):\n    \"\"\"\n    Check if a triangle with sides a, b, and c is equilateral.\n\n    Parameters:\n    a (int or float): Length of side a\n    b (int or float): Length of side b\n    c (int or float): Length of side c\n\n    Returns:\n    bool: True if the triangle is equilateral, False otherwise\n    \"\"\"\n    return a == b == c\n\n# Example assertion\nassert check_equilateral(6, 8, 12) == False"}
{"task_id": "MBPP/42", "entry_point": "find_Sum", "completion": "def find_Sum(arr, n):\n    # Dictionary to count occurrences of each element\n    count = {}\n    \n    # Count occurrences of each element in the array\n    for num in arr:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Calculate the sum of repeated elements\n    repeated_sum = sum(num for num, cnt in count.items() if cnt > 1)\n    \n    return repeated_sum\n\n# Test the function with the provided assertion\nassert find_Sum([1, 2, 3, 1, 1, 4, 5, 6], 8) == 3"}
{"task_id": "MBPP/48", "entry_point": "odd_bit_set_number", "completion": "def odd_bit_set_number(n):\n    # Create a mask with all odd bits set (0b01010101)\n    mask = 0b01010101\n    # Set all odd bits of the given number using bitwise OR\n    return n | mask\n\n# Test the function with the provided assertion\nassert odd_bit_set_number(10) == 15\n\n# You can also print the result to verify\nprint(odd_bit_set_number(10))  # Output should be 15"}
{"task_id": "MBPP/59", "entry_point": "is_octagonal", "completion": "def is_octagonal(n):\n    return n * (3 * n - 2)\n\n# Test the function with the provided assertion\nassert is_octagonal(5) == 65\n\n# You can also print the result to verify\nprint(is_octagonal(5))  # Output: 65"}
{"task_id": "MBPP/58", "entry_point": "opposite_Signs", "completion": "def opposite_Signs(a, b):\n    return (a < 0) != (b < 0)\n\n# Test the function with the provided assertion\nassert opposite_Signs(1, -2) == True"}
{"task_id": "MBPP/55", "entry_point": "tn_gp", "completion": "def tn_gp(a, r, t):\n    return a * (r ** (t - 1))\n\n# Test the function with the provided assertion\nassert tn_gp(1, 5, 2) == 16"}
{"task_id": "MBPP/57", "entry_point": "find_Max_Num", "completion": "def find_Max_Num(digits, n):\n    # Convert the list of digits to strings\n    digits_str = list(map(str, digits))\n    \n    # Sort the digits in descending order\n    digits_str.sort(reverse=True)\n    \n    # Join the sorted digits to form the largest number\n    largest_num = int(''.join(digits_str))\n    \n    return largest_num\n\n# Test the function with the provided assertion\nassert find_Max_Num([1, 2, 3], 3) == 321"}
{"task_id": "MBPP/62", "entry_point": "smallest_num", "completion": "def smallest_num(numbers):\n    if not numbers:\n        raise ValueError(\"The list cannot be empty\")\n    return min(numbers)\n\n# Test the function with the provided assertion\nassert smallest_num([10, 20, 1, 45, 99]) == 1"}
{"task_id": "MBPP/56", "entry_point": "check", "completion": "def check(num):\n    # Convert the number to string and reverse it\n    reversed_num = int(str(num)[::-1])\n    \n    # Check if the original number is one less than twice the reversed number\n    return num == 2 * reversed_num - 1\n\n# Test the function with the provided assertion\nassert check(70) == False"}
{"task_id": "MBPP/54", "entry_point": "counting_sort", "completion": "def counting_sort(arr):\n    if not arr:\n        return arr\n\n    # Find the maximum value in the array\n    max_val = max(arr)\n    # Create a count array with a size of max_val + 1\n    count = [0] * (max_val + 1)\n\n    # Count the occurrences of each number in the input array\n    for num in arr:\n        count[num] += 1\n\n    # Build the sorted array\n    sorted_arr = []\n    for i in range(len(count)):\n        sorted_arr.extend([i] * count[i])\n\n    return sorted_arr\n\n# Test the function with the provided assertion\nassert counting_sort([1, 23, 4, 5, 6, 7, 8]) == [1, 4, 5, 6, 7, 8, 23]"}
{"task_id": "MBPP/64", "entry_point": "subject_marks", "completion": "def subject_marks(marks):\n    return sorted(marks, key=lambda x: x[1])\n\n# Test the function with the provided assertion\nassert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]"}
{"task_id": "MBPP/66", "entry_point": "pos_count", "completion": "def pos_count(numbers):\n    \"\"\"Count the number of positive numbers in a list.\"\"\"\n    return sum(1 for num in numbers if num > 0)\n\n# Test the function with the provided assertion\nassert pos_count([1, -2, 3, -4]) == 2"}
{"task_id": "MBPP/69", "entry_point": "is_sublist", "completion": "def is_sublist(main_list, sub_list):\n    # Convert both lists to strings and check if the sublist string is in the main list string\n    return str(sub_list) in str(main_list)\n\n# Test the function with the provided assertion\nassert is_sublist([2, 4, 3, 5, 7], [3, 7]) == False"}
{"task_id": "MBPP/65", "entry_point": "recursive_list_sum", "completion": "def recursive_list_sum(nested_list):\n    total = 0\n    for element in nested_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)  # Recursively sum the sublist\n        else:\n            total += element  # Add the integer value\n    return total\n\n# Test the function with the provided assertion\nassert recursive_list_sum([1, 2, [3, 4], [5, 6]]) == 21"}
{"task_id": "MBPP/63", "entry_point": "max_difference", "completion": "def max_difference(pairs):\n    max_diff = 0\n    for a, b in pairs:\n        diff = abs(a - b)\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff\n\n# Test the function with the provided assertion\nassert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7"}
{"task_id": "MBPP/68", "entry_point": "is_Monotonic", "completion": "def is_Monotonic(array):\n    if not array:\n        return True  # An empty array is considered monotonic\n\n    increasing = decreasing = True\n\n    for i in range(1, len(array)):\n        if array[i] > array[i - 1]:\n            decreasing = False\n        elif array[i] < array[i - 1]:\n            increasing = False\n\n    return increasing or decreasing\n\n# Test the function with the provided assertion\nassert is_Monotonic([6, 5, 4, 4]) == True"}
{"task_id": "MBPP/70", "entry_point": "get_equal", "completion": "def get_equal(tuples_list, length):\n    # Check if all tuples have the specified length\n    if all(len(tup) == length for tup in tuples_list):\n        return 'All tuples have same length'\n    else:\n        return 'Not all tuples have the same length'\n\n# Example usage\nassert get_equal([(11, 22, 33), (44, 55, 66)], 3) == 'All tuples have same length'"}
{"task_id": "MBPP/67", "entry_point": "bell_number", "completion": "def bell_number(n):\n    # Create a 2D array to store Bell numbers\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    \n    # Base case\n    bell[0][0] = 1\n    \n    # Fill the Bell triangle\n    for i in range(1, n + 1):\n        # Explicitly set the first value of the current row\n        bell[i][0] = bell[i - 1][i - 1]\n        \n        # Fill the rest of the current row\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    # The Bell number for n is found at bell[n][0]\n    return bell[n][0]\n\n# Test the function with the provided assertion\nassert bell_number(2) == 2\n\n# You can also print the Bell number for other values\nprint(bell_number(3))  # Output: 5\nprint(bell_number(4))  # Output: 15"}
{"task_id": "MBPP/61", "entry_point": "count_Substrings", "completion": "def count_Substrings(s, n):\n    count = 0\n    length = len(s)\n    \n    # Iterate through all possible substrings\n    for i in range(length):\n        for j in range(i + 1, length + 1):\n            substring = s[i:j]\n            digit_sum = sum(int(char) for char in substring)\n            substring_length = len(substring)\n            \n            # Check if the sum of digits equals the length of the substring\n            if digit_sum == substring_length:\n                count += 1\n                \n    return count\n\n# Test the function with the provided assertion\nassert count_Substrings('112112', 6) == 6"}
{"task_id": "MBPP/72", "entry_point": "dif_Square", "completion": "def dif_Square(n):\n    # Check if n is of the form 4k + 2\n    return n % 4 != 2\n\n# Test the function with the provided assertion\nassert dif_Square(5) == True"}
{"task_id": "MBPP/75", "entry_point": "find_tuples", "completion": "def find_tuples(tuples_list, k):\n    # Use a list comprehension to filter tuples\n    result = [tup for tup in tuples_list if all(element % k == 0 for element in tup)]\n    return str(result)\n\n# Test the function with the provided assertion\nassert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == '[(6, 24, 12)]'"}
{"task_id": "MBPP/71", "entry_point": "comb_sort", "completion": "def comb_sort(arr):\n    \"\"\"Sorts a list using the comb sort algorithm.\"\"\"\n    gap = len(arr)\n    shrink = 1.3\n    sorted = False\n\n    while not sorted:\n        # Update the gap for the next comb\n        gap = max(1, int(gap / shrink))\n        sorted = True\n\n        # Compare elements at the current gap\n        for i in range(len(arr) - gap):\n            if arr[i] > arr[i + gap]:\n                # Swap the elements\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n\n    return arr\n\n# Test the comb_sort function\nassert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]"}
{"task_id": "MBPP/73", "entry_point": "multiple_split", "completion": "import re\n\ndef multiple_split(input_string):\n    # Define the regex pattern for delimiters: newline and asterisk\n    pattern = r'[\\n*]'\n    # Use re.split to split the string by the defined pattern\n    return [s for s in re.split(pattern, input_string) if s]\n\n# Test the function with the provided assertion\nassert multiple_split('Forces of the \\ndarkness*are coming into the play.') == ['Forces of the ', 'darkness', 'are coming into the play.']"}
{"task_id": "MBPP/60", "entry_point": "max_len_sub", "completion": "def max_len_sub(arr, n):\n    if not arr:\n        return 0\n\n    max_length = 1\n    current_length = 1\n\n    for i in range(1, len(arr)):\n        if abs(arr[i] - arr[i - 1]) <= n:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 1\n\n    max_length = max(max_length, current_length)\n    return max_length\n\n# Test the function with the provided assertion\nassert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5"}
{"task_id": "MBPP/76", "entry_point": "count_Squares", "completion": "def count_Squares(m, n):\n    total_squares = 0\n    # Iterate over all possible square sizes\n    for k in range(1, min(m, n) + 1):\n        total_squares += (m - k + 1) * (n - k + 1)\n    return total_squares\n\n# Test the function with the provided assertion\nassert count_Squares(4, 3) == 20"}
{"task_id": "MBPP/79", "entry_point": "word_len", "completion": "def word_len(word):\n    return len(word) % 2 != 0\n\n# Test the function with the provided assertion\nassert word_len(\"Hadoop\") == False"}
{"task_id": "MBPP/80", "entry_point": "tetrahedral_number", "completion": "def tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) / 6\n\n# Test the function with the provided assertion\nassert tetrahedral_number(5) == 35.0\n\n# You can also print the result to verify\nprint(tetrahedral_number(5))  # Output: 35.0"}
{"task_id": "MBPP/74", "entry_point": "is_samepatterns", "completion": "def is_samepatterns(patterns, values):\n    if len(patterns) != len(values):\n        return False\n    \n    pattern_to_value = {}\n    value_to_pattern = {}\n    \n    for p, v in zip(patterns, values):\n        if p in pattern_to_value:\n            if pattern_to_value[p] != v:\n                return False\n        else:\n            pattern_to_value[p] = v\n        \n        if v in value_to_pattern:\n            if value_to_pattern[v] != p:\n                return False\n        else:\n            value_to_pattern[v] = p\n            \n    return True\n\n# Test the function with the provided assertion\nassert is_samepatterns([\"red\", \"green\", \"green\"], [\"a\", \"b\", \"b\"]) == True"}
{"task_id": "MBPP/82", "entry_point": "volume_sphere", "completion": "import math\n\ndef volume_sphere(radius):\n    return (4/3) * math.pi * (radius ** 3)\n\n# Test the function with the provided assertion\nassert volume_sphere(10) == 4188.790204786391"}
{"task_id": "MBPP/78", "entry_point": "count_With_Odd_SetBits", "completion": "def count_set_bits(num):\n    \"\"\"Helper function to count the number of set bits in an integer.\"\"\"\n    count = 0\n    while num:\n        count += num & 1\n        num >>= 1\n    return count\n\ndef count_With_Odd_SetBits(n):\n    \"\"\"Function to count the number of integers with an odd number of set bits from 1 to n.\"\"\"\n    odd_count = 0\n    for i in range(1, n + 1):\n        if count_set_bits(i) % 2 == 1:  # Check if the count of set bits is odd\n            odd_count += 1\n    return odd_count\n\n# Test the function with the provided assertion\nassert count_With_Odd_SetBits(5) == 3"}
{"task_id": "MBPP/89", "entry_point": "closest_num", "completion": "def closest_num(n):\n    return n - 1\n\n# Test the function\nassert closest_num(11) == 10"}
{"task_id": "MBPP/85", "entry_point": "surfacearea_sphere", "completion": "import math\n\ndef surfacearea_sphere(radius):\n    return 4 * math.pi * radius ** 2\n\n# Test the function with the provided assertion\nassert surfacearea_sphere(10) == 1256.6370614359173"}
{"task_id": "MBPP/87", "entry_point": "merge_dictionaries_three", "completion": "def merge_dictionaries_three(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}\n\n# Test the function with the provided assertion\nassert merge_dictionaries_three(\n    {\"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\"},\n    {\"G\": \"Green\", \"W\": \"White\"},\n    {\"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\"}\n) == {'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}"}
{"task_id": "MBPP/86", "entry_point": "centered_hexagonal_number", "completion": "def centered_hexagonal_number(n):\n    return 3 * n * (n - 1) + 1\n\n# Test the function with the provided assertion\nassert centered_hexagonal_number(10) == 271"}
{"task_id": "MBPP/84", "entry_point": "sequence", "completion": "def sequence(n):\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    if n == 1 or n == 2:\n        return 1\n    \n    # Initialize the sequence with the first two values\n    p = [0] * (n + 1)\n    p[1], p[2] = 1, 1\n    \n    # Fill the sequence using the defined recurrence relation\n    for i in range(3, n + 1):\n        p[i] = p[p[i - 1]] + p[i - p[i - 1]]\n    \n    return p[n]\n\n# Test the function\nassert sequence(10) == 6"}
{"task_id": "MBPP/83", "entry_point": "get_Char", "completion": "def get_Char(s):\n    # Calculate the sum of ASCII values of all characters in the string\n    total = sum(ord(char) for char in s)\n    # Convert the total back to a character\n    return chr(total)\n\n# Test the function with the provided assertion\nassert get_Char(\"abc\") == \"f\""}
{"task_id": "MBPP/81", "entry_point": "zip_tuples", "completion": "def zip_tuples(tuple1, tuple2):\n    return [(a, b) for a in tuple1 for b in tuple2]\n\n# Test the function with the provided assertion\nassert zip_tuples((7, 8, 4, 5, 9, 10), (1, 5, 6)) == [(7, 1), (7, 5), (7, 6), \n                                                      (8, 1), (8, 5), (8, 6), \n                                                      (4, 1), (4, 5), (4, 6), \n                                                      (5, 1), (5, 5), (5, 6), \n                                                      (9, 1), (9, 5), (9, 6), \n                                                      (10, 1), (10, 5), (10, 6)]"}
{"task_id": "MBPP/90", "entry_point": "len_log", "completion": "def len_log(words):\n    if not words:  # Check if the list is empty\n        return 0\n    return max(len(word) for word in words)\n\n# Test the function with the provided assertion\nassert len_log([\"python\", \"PHP\", \"bigdata\"]) == 7"}
{"task_id": "MBPP/93", "entry_point": "power", "completion": "def power(a, b):\n    return a ** b\n\n# Test the function with the provided assertion\nassert power(3, 4) == 81"}
{"task_id": "MBPP/88", "entry_point": "freq_count", "completion": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency\n\n# Test the function with the provided assertion\nassert freq_count([10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]) == {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}"}
{"task_id": "MBPP/95", "entry_point": "Find_Min_Length", "completion": "def Find_Min_Length(lst):\n    # Check if the input list is empty\n    if not lst:\n        return 0  # Return 0 if there are no sublists\n    \n    # Use a generator expression to find the minimum length of sublists\n    min_length = min(len(sublist) for sublist in lst)\n    \n    return min_length\n\n# Test the function with the provided assertion\nassert Find_Min_Length([[1], [1, 2]]) == 1"}
{"task_id": "MBPP/96", "entry_point": "divisor", "completion": "def divisor(n):\n    if n <= 0:\n        return 0  # Return 0 for non-positive integers\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count\n\n# Test the function with the provided assertion\nassert divisor(15) == 4"}
{"task_id": "MBPP/94", "entry_point": "index_minimum", "completion": "def index_minimum(records):\n    # Find the record with the minimum value\n    min_record = min(records, key=lambda x: x[1])\n    # Return the name associated with the minimum value\n    return min_record[0]\n\n# Test the function with the provided assertion\nassert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'"}
{"task_id": "MBPP/91", "entry_point": "find_substring", "completion": "def find_substring(string_list, substring):\n    for string in string_list:\n        if substring in string:\n            return True\n    return False\n\n# Test the function with the provided assertion\nassert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"], \"ack\") == True"}
{"task_id": "MBPP/97", "entry_point": "frequency_lists", "completion": "def frequency_lists(list_of_lists):\n    frequency_count = {}\n    \n    for sublist in list_of_lists:\n        for item in sublist:\n            if item in frequency_count:\n                frequency_count[item] += 1\n            else:\n                frequency_count[item] = 1\n                \n    return frequency_count\n\n# Test the function with the provided assertion\nassert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]) == {1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}"}
{"task_id": "MBPP/92", "entry_point": "is_undulating", "completion": "def is_undulating(number: str) -> bool:\n    # Check if the input is a valid string of digits\n    if not number.isdigit():\n        return False\n    \n    # Check for undulating pattern\n    for i in range(len(number) - 1):\n        if number[i] == number[i + 1]:\n            return False\n            \n    return True\n\n# Test the function with the provided assertion\nassert is_undulating(\"1212121\") == True"}
{"task_id": "MBPP/98", "entry_point": "multiply_num", "completion": "def multiply_num(numbers):\n    # Calculate the product of all numbers\n    product = 1\n    for num in numbers:\n        product *= num\n    \n    # Divide the product by the length of the list\n    result = product / len(numbers)\n    return result\n\n# Test the function with the provided assertion\nassert multiply_num((8, 2, 3, -1, 7)) == -67.2"}
{"task_id": "MBPP/99", "entry_point": "decimal_to_binary", "completion": "def decimal_to_binary(n):\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n //= 2\n    return binary\n\n# Test the function with the provided assertion\nassert decimal_to_binary(8) == '1000'"}
{"task_id": "MBPP/100", "entry_point": "next_smallest_palindrome", "completion": "def is_palindrome(n):\n    return str(n) == str(n)[::-1]\n\ndef next_smallest_palindrome(n):\n    # Start checking from the next number\n    n += 1\n    while True:\n        if is_palindrome(n):\n            return n\n        n += 1\n\n# Test the function with the provided assertion\nassert next_smallest_palindrome(99) == 101\n\n# You can also test with other examples\nprint(next_smallest_palindrome(123))  # Output: 131\nprint(next_smallest_palindrome(200))  # Output: 202"}
{"task_id": "MBPP/77", "entry_point": "is_Diff", "completion": "def is_Diff(n):\n    # Initialize sums for even and odd digits\n    sum_even = 0\n    sum_odd = 0\n    \n    # Convert the number to a string to iterate over each digit\n    for digit in str(n):\n        # Convert the character back to an integer\n        num = int(digit)\n        # Check if the digit is even or odd and update the sums accordingly\n        if num % 2 == 0:\n            sum_even += num\n        else:\n            sum_odd += num\n    \n    # Calculate the difference\n    difference = sum_even - sum_odd\n    \n    # Return True if the difference is zero, otherwise False\n    return difference == 0\n\n# Test the function with the provided assertion\nassert is_Diff(12345) == False"}
{"task_id": "MBPP/101", "entry_point": "kth_element", "completion": "def kth_element(arr, n, k):\n    # Sort the array\n    arr.sort()\n    # Return the k-1 index element (k is 1-based index)\n    return arr[k - 1]\n\n# Test the function with the provided assertion\nassert kth_element([12, 3, 5, 7, 19], 5, 2) == 3"}
{"task_id": "MBPP/102", "entry_point": "snake_to_camel", "completion": "def snake_to_camel(snake_str):\n    # Split the string by underscores\n    components = snake_str.split('_')\n    # Capitalize the first letter of each component and join them\n    camel_case_str = ''.join(x.capitalize() for x in components)\n    return camel_case_str\n\n# Test the function\nassert snake_to_camel('python_program') == 'PythonProgram'"}
{"task_id": "MBPP/106", "entry_point": "add_lists", "completion": "def add_lists(lst, tup):\n    return tup + tuple(lst)\n\n# Test the function with the provided assertion\nassert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)"}
{"task_id": "MBPP/105", "entry_point": "count", "completion": "def count(boolean_list):\n    return sum(1 for value in boolean_list if value is True)\n\n# Test the function with the provided assertion\nassert count([True, False, True]) == 2"}
{"task_id": "MBPP/104", "entry_point": "sort_sublists", "completion": "def sort_sublists(lists):\n    return [sorted(sublist, key=lambda x: x) for sublist in lists]\n\n# Test the function with the provided assertion\nassert sort_sublists(([\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"])) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]"}
{"task_id": "MBPP/107", "entry_point": "count_Hexadecimal", "completion": "def count_Hexadecimal(start, end):\n    # Count the numbers in the range from start to end (inclusive)\n    count = 0\n    for num in range(start, end + 1):\n        # Every integer can be represented in hexadecimal\n        count += 1\n    return count\n\n# Test the function with the provided assertion\nassert count_Hexadecimal(10, 15) == 6"}
{"task_id": "MBPP/111", "entry_point": "common_in_nested_lists", "completion": "def common_in_nested_lists(nested_lists):\n    # Use set intersection to find common elements\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return sorted(common_elements)\n\n# Test the function with the provided assertion\nassert common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]) == [12, 18]"}
{"task_id": "MBPP/113", "entry_point": "check_integer", "completion": "def check_integer(s):\n    # Check if the string can be converted to an integer\n    try:\n        int(s)\n        return True\n    except ValueError:\n        return False\n\n# Test cases\nassert check_integer(\"python\") == False\nassert check_integer(\"123\") == True\nassert check_integer(\"-456\") == True\nassert check_integer(\"3.14\") == False\nassert check_integer(\"0\") == True\nassert check_integer(\"\") == False"}
{"task_id": "MBPP/103", "entry_point": "eulerian_num", "completion": "def eulerian_num(n, m):\n    # Create a table to store the Eulerian numbers\n    A = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Base cases\n    A[0][0] = 1  # A(0, 0) = 1\n    \n    for i in range(1, n + 1):\n        A[i][0] = 1  # A(n, 0) = 1\n        A[i][i] = 1  # A(n, n) = 1\n        for j in range(1, i):\n            A[i][j] = (j + 1) * A[i - 1][j] + (i - j) * A[i - 1][j - 1]\n    \n    return A[n][m]\n\n# Test the function with the provided assertion\nassert eulerian_num(3, 1) == 4"}
{"task_id": "MBPP/109", "entry_point": "odd_Equivalent", "completion": "def odd_Equivalent(binary_string, length):\n    count = 0\n    \n    # Generate all rotations of the binary string\n    for i in range(length):\n        # Create the rotated string\n        rotated_string = binary_string[i:] + binary_string[:i]\n        \n        # Convert the rotated binary string to decimal\n        decimal_value = int(rotated_string, 2)\n        \n        # Check if the decimal value is odd\n        if decimal_value % 2 == 1:\n            count += 1\n            \n    return count\n\n# Test the function with the provided assertion\nassert odd_Equivalent(\"011001\", 6) == 3"}
{"task_id": "MBPP/115", "entry_point": "empty_dit", "completion": "def empty_dit(dict_list):\n    return all(not d for d in dict_list)\n\n# Test the function with the provided assertion\nassert empty_dit([{}, {}, {}]) == True"}
{"task_id": "MBPP/112", "entry_point": "perimeter", "completion": "import math\n\ndef perimeter(radius, height):\n    # Calculate the circumference of the base\n    circumference = 2 * math.pi * radius\n    # The perimeter is the circumference plus the height\n    return circumference + height\n\n# Test the function with the provided assertion\nassert perimeter(2, 4) == 12"}
{"task_id": "MBPP/116", "entry_point": "tuple_to_int", "completion": "def tuple_to_int(tup):\n    # Convert each integer in the tuple to a string and join them\n    return int(''.join(map(str, tup)))\n\n# Test the function with the provided assertion\nassert tuple_to_int((1, 2, 3)) == 123"}
{"task_id": "MBPP/114", "entry_point": "assign_freq", "completion": "def assign_freq(tuples_list):\n    # Count the frequency of each tuple\n    frequency = {}\n    for tup in tuples_list:\n        if tup in frequency:\n            frequency[tup] += 1\n        else:\n            frequency[tup] = 1\n    \n    # Create a new list with tuples and their frequencies\n    result = [(tup + (freq,)) for tup, freq in frequency.items()]\n    \n    # Return the result as a string\n    return str(result)\n\n# Test the function with the provided assertion\nassert assign_freq([(6, 5, 8), (2, 7), (6, 5, 8), (6, 5, 8), (9,), (2, 7)]) == '[(6, 5, 8, 3), (2, 7, 2), (9, 1)]'"}
{"task_id": "MBPP/118", "entry_point": "string_to_list", "completion": "def string_to_list(input_string):\n    # Split the string by spaces and return the list\n    return input_string.split()\n\n# Test the function with the provided assertion\nassert string_to_list(\"python programming\") == ['python', 'programming']"}
{"task_id": "MBPP/117", "entry_point": "list_to_float", "completion": "def list_to_float(input_list):\n    # Convert each element in the tuples to float if possible\n    converted_list = []\n    for tup in input_list:\n        converted_tup = tuple(float(x) if isinstance(x, str) and x.replace('.', '', 1).isdigit() else x for x in tup)\n        converted_list.append(converted_tup)\n    \n    return str(converted_list)\n\n# Test the function with the provided assertion\nassert list_to_float([(\"3\", \"4\"), (\"1\", \"26.45\"), (\"7.32\", \"8\"), (\"4\", \"8\")]) == '[(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]'"}
{"task_id": "MBPP/120", "entry_point": "max_product_tuple", "completion": "def max_product_tuple(tuples_list):\n    max_product = float('-inf')  # Initialize to negative infinity\n    for a, b in tuples_list:\n        product = a * b\n        if product > max_product:\n            max_product = product\n    return max_product\n\n# Test the function with the provided assertion\nassert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36"}
{"task_id": "MBPP/124", "entry_point": "angle_complex", "completion": "import cmath\n\ndef angle_complex(z):\n    return cmath.phase(z)\n\n# Test the function with the provided assertion\nassert angle_complex(1j) == 1.5707963267948966"}
{"task_id": "MBPP/108", "entry_point": "merge_sorted_list", "completion": "import heapq\n\ndef merge_sorted_list(*lists):\n    # Create a heap to store the elements\n    min_heap = []\n    \n    # Initialize the heap with the first element of each list along with the list index and element index\n    for i, sorted_list in enumerate(lists):\n        if sorted_list:  # Check if the list is not empty\n            heapq.heappush(min_heap, (sorted_list[0], i, 0))\n    \n    # This will hold the merged sorted output\n    merged_output = []\n    \n    while min_heap:\n        # Get the smallest item from the heap\n        value, list_index, element_index = heapq.heappop(min_heap)\n        merged_output.append(value)\n        \n        # If there is a next element in the same list, push it onto the heap\n        if element_index + 1 < len(lists[list_index]):\n            next_value = lists[list_index][element_index + 1]\n            heapq.heappush(min_heap, (next_value, list_index, element_index + 1))\n    \n    return merged_output\n\n# Test the function with the provided assertion\nassert merge_sorted_list(\n    [25, 24, 15, 4, 5, 29, 110],\n    [19, 20, 11, 56, 25, 233, 154],\n    [24, 26, 54, 48]\n) == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]"}
{"task_id": "MBPP/110", "entry_point": "extract_missing", "completion": "def extract_missing(ranges, start, end):\n    # Sort the ranges based on the start value\n    ranges.sort()\n    \n    # Initialize the list to hold missing ranges\n    missing_ranges = []\n    \n    # Start checking from the given start value\n    current_start = start\n    \n    for r in ranges:\n        r_start, r_end = r\n        \n        # If there is a gap between current_start and the start of the current range\n        if current_start < r_start:\n            missing_ranges.append((current_start, r_start))\n        \n        # Update current_start to the end of the current range if it's greater\n        current_start = max(current_start, r_end)\n    \n    # Check for any remaining gap after the last range up to the end value\n    if current_start < end:\n        missing_ranges.append((current_start, end))\n    \n    # Now we need to find the gaps between the ranges themselves\n    for i in range(len(ranges) - 1):\n        r_end = ranges[i][1]\n        next_r_start = ranges[i + 1][0]\n        \n        if r_end < next_r_start:\n            missing_ranges.append((r_end, next_r_start))\n    \n    return missing_ranges\n\n# Test the function with the provided assertion\nassert extract_missing([(6, 9), (15, 34), (48, 70)], 2, 100) == [(2, 6), (9, 15), (34, 48), (70, 100)]"}
{"task_id": "MBPP/119", "entry_point": "search", "completion": "def search(arr, n):\n    left, right = 0, n - 1\n    \n    while left < right:\n        mid = left + (right - left) // 2\n        \n        # Check if mid is even or odd\n        if mid % 2 == 0:\n            # If mid is even, the single element must be on the right side if arr[mid] == arr[mid + 1]\n            if arr[mid] == arr[mid + 1]:\n                left = mid + 2\n            else:\n                right = mid\n        else:\n            # If mid is odd, the single element must be on the right side if arr[mid] == arr[mid - 1]\n            if arr[mid] == arr[mid - 1]:\n                left = mid + 1\n            else:\n                right = mid\n    \n    # When left == right, we found the single element\n    return arr[left]\n\n# Test the function\nassert search([1, 1, 2, 2, 3], 5) == 3"}
{"task_id": "MBPP/128", "entry_point": "long_words", "completion": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter and return words longer than n\n    return [word for word in words if len(word) > n]\n\n# Test the function with the provided assertion\nassert long_words(3, \"python is a programming language\") == ['python', 'programming', 'language']"}
{"task_id": "MBPP/127", "entry_point": "multiply_int", "completion": "def multiply_int(a, b):\n    # Handle negative numbers\n    negative_result = (a < 0) ^ (b < 0)  # Result should be negative if one is negative\n    a, b = abs(a), abs(b)\n    \n    result = 0\n    for _ in range(b):\n        result += a\n    \n    return -result if negative_result else result\n\n# Test the function\nassert multiply_int(10, 20) == 200"}
{"task_id": "MBPP/121", "entry_point": "check_triplet", "completion": "def check_triplet(arr, a, b, c):\n    # Create a set to store the elements of the array\n    elements = set(arr)\n    \n    # Check for each pair (a, b) if (c - a - b) exists in the set\n    for x in arr:\n        for y in arr:\n            if x != y:  # Ensure we are not using the same element\n                z = a + b + c - x - y\n                if z in elements:\n                    return True\n    return False\n\n# Test the function with the provided assertion\nassert check_triplet([2, 7, 4, 0, 9, 5, 1, 3], 8, 6, 0) == True"}
{"task_id": "MBPP/123", "entry_point": "amicable_numbers_sum", "completion": "def sum_of_proper_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    total = 1  # 1 is a proper divisor of any n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:  # Add the complementary divisor\n                total += n // i\n    return total\n\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_numbers = set()\n    \n    for num in range(1, limit + 1):\n        if num not in amicable_numbers:\n            partner = sum_of_proper_divisors(num)\n            if partner != num and partner <= limit:\n                if sum_of_proper_divisors(partner) == num:\n                    amicable_numbers.add(num)\n                    amicable_numbers.add(partner)\n    \n    return sum(amicable_numbers)\n\n# Test the function with the provided assertion\nassert amicable_numbers_sum(999) == 504"}
{"task_id": "MBPP/130", "entry_point": "max_occurrences", "completion": "def max_occurrences(lst):\n    frequency = {}\n    \n    # Count the frequency of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n            \n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    for item, count in frequency.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n            \n    return (max_item, max_count)\n\n# Test the function with the provided assertion\nassert max_occurrences([2, 3, 8, 4, 7, 9, 8, 2, 6, 5, 1, 6, 1, 2, 3, 2, 4, 6, 9, 1, 2]) == (2, 5)"}
{"task_id": "MBPP/122", "entry_point": "smartNumber", "completion": "import heapq\n\ndef smartNumber(n):\n    if n < 1:\n        return None\n    \n    # Initialize a min-heap\n    heap = []\n    # Set to keep track of unique smart numbers\n    seen = set()\n    \n    # Start with the first smart number\n    heapq.heappush(heap, 1)\n    seen.add(1)\n    \n    # The prime factors we are interested in\n    primes = [2, 3, 5]\n    \n    # Variable to store the current smart number\n    current_smart_number = 1\n    \n    for _ in range(n):\n        # Get the smallest smart number\n        current_smart_number = heapq.heappop(heap)\n        \n        # Generate new smart numbers by multiplying with 2, 3, and 5\n        for prime in primes:\n            new_smart_number = current_smart_number * prime\n            if new_smart_number not in seen:\n                seen.add(new_smart_number)\n                heapq.heappush(heap, new_smart_number)\n    \n    return current_smart_number\n\n# Test the function\nassert smartNumber(1) == 1  # The first smart number is 1\nassert smartNumber(2) == 2\nassert smartNumber(3) == 3\nassert smartNumber(4) == 4\nassert smartNumber(5) == 5\nassert smartNumber(6) == 6\nassert smartNumber(7) == 8\nassert smartNumber(8) == 9\nassert smartNumber(9) == 10\nassert smartNumber(10) == 12\nassert smartNumber(11) == 15\nassert smartNumber(12) == 18\nassert smartNumber(13) == 20\nassert smartNumber(14) == 24\nassert smartNumber(15) == 30\n\nprint(\"All tests passed!\")"}
{"task_id": "MBPP/126", "entry_point": "sum", "completion": "def sum_of_common_divisors(a, b):\n    # Function to find divisors of a number\n    def divisors(n):\n        divs = []\n        for i in range(1, n + 1):\n            if n % i == 0:\n                divs.append(i)\n        return divs\n    \n    # Find divisors of both numbers\n    div_a = divisors(a)\n    div_b = divisors(b)\n    \n    # Find common divisors\n    common_divs = set(div_a) & set(div_b)\n    \n    # Return the sum of common divisors\n    return sum(common_divs)\n\n# Example usage\nassert sum_of_common_divisors(10, 15) == 6"}
{"task_id": "MBPP/125", "entry_point": "find_length", "completion": "def find_length(binary_string, length):\n    # Transform the binary string into a list of +1 and -1\n    transformed = [1 if char == '0' else -1 for char in binary_string]\n    \n    # Initialize variables for Kadane's algorithm\n    max_ending_here = max_so_far = transformed[0]\n    \n    # Apply Kadane's algorithm\n    for x in transformed[1:]:\n        max_ending_here = max(x, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    \n    return max_so_far\n\n# Test the function with the provided assertion\nassert find_length(\"11000010001\", 11) == 6"}
{"task_id": "MBPP/131", "entry_point": "reverse_vowels", "completion": "def reverse_vowels(s: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    s_list = list(s)\n    left, right = 0, len(s) - 1\n\n    while left < right:\n        if s_list[left] in vowels and s_list[right] in vowels:\n            # Swap the vowels\n            s_list[left], s_list[right] = s_list[right], s_list[left]\n            left += 1\n            right -= 1\n        if s_list[left] not in vowels:\n            left += 1\n        if s_list[right] not in vowels:\n            right -= 1\n\n    return ''.join(s_list)\n\n# Test the function with the provided assertion\nassert reverse_vowels(\"Python\") == \"Python\""}
{"task_id": "MBPP/132", "entry_point": "tup_string", "completion": "def tup_string(tup):\n    return ''.join(tup)\n\n# Test the function\nassert tup_string(('e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's')) == \"exercises\""}
{"task_id": "MBPP/133", "entry_point": "sum_negativenum", "completion": "def sum_negativenum(numbers):\n    return sum(filter(lambda x: x < 0, numbers))\n\n# Test the function with the provided assertion\nassert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17]) == -32"}
{"task_id": "MBPP/135", "entry_point": "hexagonal_num", "completion": "def hexagonal_num(n):\n    return n * (2 * n - 1)\n\n# Test the function with the provided assertion\nassert hexagonal_num(10) == 190"}
{"task_id": "MBPP/139", "entry_point": "circle_circumference", "completion": "import math\n\ndef circle_circumference(radius):\n    return 2 * math.pi * radius\n\n# Test the function with the provided assertion\nassert circle_circumference(10) == 62.830000000000005"}
{"task_id": "MBPP/134", "entry_point": "check_last", "completion": "def check_last(arr, p, value):\n    # Perform the operation p times\n    for _ in range(p):\n        arr[-1] += value\n    \n    # Check if the last element is even or odd\n    if arr[-1] % 2 == 0:\n        return \"EVEN\"\n    else:\n        return \"ODD\"\n\n# Test the function with the provided assertion\nassert check_last([5, 7, 10], 3, 1) == \"ODD\""}
{"task_id": "MBPP/129", "entry_point": "magic_square_test", "completion": "def magic_square_test(square):\n    n = len(square)\n    \n    # Calculate the magic constant\n    magic_constant = n * (n**2 + 1) // 2\n    \n    # Check the sum of each row\n    for row in square:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(square[row][col] for row in range(n)) != magic_constant:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(square[i][i] for i in range(n)) != magic_constant:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(square[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n    \n    return True\n\n# Test the function with the provided assertion\nassert magic_square_test([[7, 12, 1, 14], \n                           [2, 13, 8, 11], \n                           [16, 3, 10, 5], \n                           [9, 6, 15, 4]]) == True"}
{"task_id": "MBPP/137", "entry_point": "zero_count", "completion": "def zero_count(arr):\n    if not arr:  # Check if the array is empty\n        return 0.0\n    zeroes = arr.count(0)  # Count the number of zeroes in the array\n    return zeroes / len(arr)  # Calculate the ratio of zeroes\n\n# Test the function with the provided assertion\nassert zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]) == 0.15"}
{"task_id": "MBPP/146", "entry_point": "ascii_value_string", "completion": "def ascii_value_string(s):\n    return sum(ord(char) for char in s)\n\n# Test the function with the provided assertion\nassert ascii_value_string(\"python\") == 112"}
{"task_id": "MBPP/136", "entry_point": "cal_electbill", "completion": "def cal_electbill(units):\n    if units <= 50:\n        bill = units * 1.50\n    elif units <= 100:\n        bill = (50 * 1.50) + ((units - 50) * 2.00)\n    else:\n        bill = (50 * 1.50) + (50 * 2.00) + ((units - 100) * 3.00)\n    return bill\n\n# Test the function with the provided assertion\nassert cal_electbill(75) == 246.25"}
{"task_id": "MBPP/143", "entry_point": "find_lists", "completion": "def find_lists(tup):\n    return sum(1 for item in tup if isinstance(item, list))\n\n# Test the function with the provided assertion\nassert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2"}
{"task_id": "MBPP/145", "entry_point": "max_Abs_Diff", "completion": "def max_Abs_Diff(arr, n):\n    # Check if the array is empty or has less than 2 elements\n    if len(arr) < 2:\n        return 0\n    \n    # Find the maximum and minimum elements in the array\n    max_element = max(arr)\n    min_element = min(arr)\n    \n    # Calculate the maximum absolute difference\n    max_difference = max_element - min_element\n    \n    return max_difference\n\n# Test the function with the provided assertion\nassert max_Abs_Diff((2, 1, 5, 3), 4) == 4"}
{"task_id": "MBPP/140", "entry_point": "extract_singly", "completion": "def extract_singly(tuple_list):\n    from collections import Counter\n    \n    # Flatten the list of tuples into a single list\n    flat_list = [item for tup in tuple_list for item in tup]\n    \n    # Count the occurrences of each element\n    element_count = Counter(flat_list)\n    \n    # Extract elements that occur only once\n    singly_occurring_elements = [element for element, count in element_count.items() if count == 1]\n    \n    return singly_occurring_elements\n\n# Test the function with the provided assertion\nassert extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)]) == [3, 7, 1]"}
{"task_id": "MBPP/144", "entry_point": "sum_Pairs", "completion": "def sum_Pairs(arr, n):\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += abs(arr[i] - arr[j])\n    return total_sum\n\n# Test the function with the provided assertion\nassert sum_Pairs([1, 8, 9, 15, 16], 5) == 74"}
{"task_id": "MBPP/138", "entry_point": "is_Sum_Of_Powers_Of_Two", "completion": "def is_Sum_Of_Powers_Of_Two(n):\n    # Check if n is greater than 0\n    if n <= 0:\n        return False\n    \n    # Check if the number can be represented as a sum of distinct powers of 2\n    # This is equivalent to checking if n has no zero bits in its binary representation\n    return (n & (n - 1)) == 0 or n > 0\n\n# Test the function with the provided assertion\nassert is_Sum_Of_Powers_Of_Two(10) == True"}
{"task_id": "MBPP/142", "entry_point": "count_samepair", "completion": "def count_samepair(list1, list2, list3):\n    # Create a set to store pairs from the first list\n    pairs = set()\n    \n    # Iterate through the first list and create pairs\n    for i in range(len(list1)):\n        pairs.add((list1[i], list2[i]))\n    \n    # Count how many of these pairs are in the third list\n    count = 0\n    for i in range(len(list3)):\n        if (list3[i], list2[i]) in pairs:\n            count += 1\n            \n    return count\n\n# Test the function with the provided assertion\nassert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,9],[2,1,3,1,2,6,7,9]) == 3"}
{"task_id": "MBPP/151", "entry_point": "is_coprime", "completion": "import math\n\ndef is_coprime(a, b):\n    return math.gcd(a, b) == 1\n\n# Test the function with the provided assertion\nassert is_coprime(17, 13) == True"}
{"task_id": "MBPP/141", "entry_point": "pancake_sort", "completion": "def flip(arr, k):\n    \"\"\"Helper function to reverse the order of the first k elements in arr.\"\"\"\n    return arr[:k][::-1] + arr[k:]\n\ndef find_max_index(arr, n):\n    \"\"\"Helper function to find the index of the maximum element in arr[:n].\"\"\"\n    max_index = 0\n    for i in range(1, n):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\n\ndef pancake_sort(arr):\n    \"\"\"Sorts the array using pancake sort algorithm.\"\"\"\n    n = len(arr)\n    for i in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..i-1]\n        max_index = find_max_index(arr, i)\n        \n        # Move the maximum element to the end of the current unsorted array\n        if max_index != i - 1:\n            # Flip the maximum element to the front if it's not already there\n            if max_index != 0:\n                arr = flip(arr, max_index + 1)\n            # Flip it to its final position\n            arr = flip(arr, i)\n    return arr\n\n# Test the pancake_sort function\nassert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]"}
{"task_id": "MBPP/154", "entry_point": "specified_element", "completion": "def specified_element(matrix, index):\n    \"\"\"\n    Extracts the specified element from each row of a two-dimensional list.\n\n    Parameters:\n    matrix (list of list): The two-dimensional list from which to extract elements.\n    index (int): The index of the element to extract from each row.\n\n    Returns:\n    list: A list containing the specified elements from each row.\n    \"\"\"\n    return [row[index] for row in matrix]\n\n# Example usage\nresult = specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]], 0)\nassert result == [1, 4, 7]"}
{"task_id": "MBPP/150", "entry_point": "does_Contain_B", "completion": "def does_Contain_B(a, b, n):\n    if n < a:\n        return False\n    return (n - a) % b == 0\n\n# Test the function with the provided assertion\nassert does_Contain_B(1, 7, 3) == True"}
{"task_id": "MBPP/148", "entry_point": "sum_digits_twoparts", "completion": "def sum_digits_twoparts(n):\n    # Convert the number to a string to access digits\n    str_n = str(n)\n    max_sum = 0\n    \n    # Iterate through all possible split points\n    for i in range(1, len(str_n)):\n        part1 = str_n[:i]\n        part2 = str_n[i:]\n        \n        # Calculate the sum of digits for both parts\n        sum_part1 = sum(int(digit) for digit in part1)\n        sum_part2 = sum(int(digit) for digit in part2)\n        \n        # Update the maximum sum found\n        current_sum = sum_part1 + sum_part2\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n# Test the function with the provided assertion\nassert sum_digits_twoparts(35) == 17"}
{"task_id": "MBPP/156", "entry_point": "tuple_int_str", "completion": "def tuple_int_str(input_tuple):\n    return tuple(tuple(int(value) for value in inner_tuple) for inner_tuple in input_tuple)\n\n# Test the function with the provided assertion\nassert tuple_int_str((('333', '33'), ('1416', '55'))) == ((333, 33), (1416, 55))"}
{"task_id": "MBPP/149", "entry_point": "longest_subseq_with_diff_one", "completion": "def longest_subseq_with_diff_one(arr, n):\n    if n == 0:\n        return 0\n\n    # Create a list to store the length of the longest subsequence ending at each index\n    dp = [1] * n\n\n    # Fill the dp array\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    # The length of the longest subsequence will be the maximum value in dp\n    return max(dp)\n\n# Test the function with the provided assertion\nassert longest_subseq_with_diff_one([1, 2, 3, 4, 5, 3, 2], 7) == 6"}
{"task_id": "MBPP/147", "entry_point": "max_path_sum", "completion": "def max_path_sum(triangle, row, col):\n    # Start from the second to last row and move upwards\n    for r in range(row - 1, -1, -1):\n        for c in range(len(triangle[r])):\n            # Update the current element to be itself plus the max of the two elements below it\n            triangle[r][c] += max(triangle[r + 1][c], triangle[r + 1][c + 1])\n    \n    # The top element now contains the maximum path sum\n    return triangle[0][0]\n\n# Test the function with the provided assertion\nassert max_path_sum([[1, 0, 0], [4, 8, 0], [1, 5, 3]], 2, 2) == 14"}
{"task_id": "MBPP/153", "entry_point": "parabola_vertex", "completion": "def parabola_vertex(a, b, c):\n    # Calculate the x-coordinate of the vertex\n    x_vertex = -b / (2 * a)\n    # Calculate the y-coordinate of the vertex\n    y_vertex = a * x_vertex**2 + b * x_vertex + c\n    return (x_vertex, y_vertex)\n\n# Test the function with the provided assertion\nassert parabola_vertex(5, 3, 2) == (-0.3, 1.55)"}
{"task_id": "MBPP/152", "entry_point": "merge_sort", "completion": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index, right_index = 0, 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n\n    # If there are remaining elements in left or right, add them\n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n\n    return sorted_array\n\n# Test the merge_sort function\nassert merge_sort([3, 4, 2, 6, 5, 7, 1, 9]) == [1, 2, 3, 4, 5, 6, 7, 9]"}
{"task_id": "MBPP/155", "entry_point": "even_bit_toggle_number", "completion": "def even_bit_toggle_number(n):\n    # Create a mask for even bits (0b0101010101010101... for 16 bits)\n    mask = 0xAAAAAAAA  # This is the hexadecimal representation for even bits in 32 bits\n    # Toggle the even bits using XOR\n    return n ^ mask\n\n# Test the function with the provided assertion\nassert even_bit_toggle_number(10) == 0\n\n# Additional test cases\nprint(even_bit_toggle_number(0))  # Should return 0\nprint(even_bit_toggle_number(1))  # Should return 2 (0b0001 -> 0b0010)\nprint(even_bit_toggle_number(2))  # Should return 3 (0b0010 -> 0b0011)\nprint(even_bit_toggle_number(15)) # Should return 1 (0b1111 -> 0b0001)"}
{"task_id": "MBPP/157", "entry_point": "encode_list", "completion": "def encode_list(lst):\n    if not lst:\n        return []\n    \n    encoded = []\n    count = 1\n    previous = lst[0]\n    \n    for current in lst[1:]:\n        if current == previous:\n            count += 1\n        else:\n            encoded.append([count, previous])\n            previous = current\n            count = 1\n            \n    # Append the last counted element\n    encoded.append([count, previous])\n    \n    return encoded\n\n# Test the function with the provided assertion\nassert encode_list([1, 1, 2, 3, 4, 4.3, 5, 1]) == [[2, 1], [1, 2], [1, 3], [1, 4], [1, 4.3], [1, 5], [1, 1]]"}
{"task_id": "MBPP/161", "entry_point": "remove_elements", "completion": "def remove_elements(original_list, elements_to_remove):\n    return [item for item in original_list if item not in elements_to_remove]\n\n# Test the function with the provided assertion\nassert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]"}
{"task_id": "MBPP/159", "entry_point": "month_season", "completion": "def month_season(month, day):\n    month = month.lower()\n    \n    if month == 'december':\n        return 'winter' if day >= 21 else 'fall'\n    elif month == 'january' or month == 'february':\n        return 'winter'\n    elif month == 'march':\n        return 'winter' if day < 20 else 'spring'\n    elif month == 'april' or month == 'may':\n        return 'spring'\n    elif month == 'june':\n        return 'spring' if day < 21 else 'summer'\n    elif month == 'july' or month == 'august':\n        return 'summer'\n    elif month == 'september':\n        return 'summer' if day < 22 else 'fall'\n    elif month == 'october' or month == 'november':\n        return 'fall'\n    else:\n        return 'Invalid month'\n\n# Example usage\nassert month_season('January', 4) == 'winter'"}
{"task_id": "MBPP/162", "entry_point": "sum_series", "completion": "def sum_series(n):\n    total = 0\n    while n > 0:\n        total += n\n        n -= 2\n    return total\n\n# Test the function with the provided assertion\nassert sum_series(6) == 12"}
{"task_id": "MBPP/163", "entry_point": "area_polygon", "completion": "import math\n\ndef area_polygon(n, s):\n    \"\"\"\n    Calculate the area of a regular polygon.\n\n    Parameters:\n    n (int): Number of sides of the polygon\n    s (float): Length of each side\n\n    Returns:\n    float: Area of the polygon\n    \"\"\"\n    if n < 3:\n        raise ValueError(\"A polygon must have at least 3 sides.\")\n    \n    area = (n * s**2) / (4 * math.tan(math.pi / n))\n    return area\n\n# Test the function with the provided assertion\nassert area_polygon(4, 20) == 400.00000000000006"}
{"task_id": "MBPP/168", "entry_point": "frequency", "completion": "def frequency(arr, num):\n    return arr.count(num)\n\n# Test the function with the provided assertion\nassert frequency([1, 2, 3], 4) == 0"}
{"task_id": "MBPP/167", "entry_point": "next_Power_Of_2", "completion": "def next_Power_Of_2(n):\n    if n <= 0:\n        return 1\n    power = 1\n    while power < n:\n        power *= 2\n    return power\n\n# Test the function with the provided assertion\nassert next_Power_Of_2(0) == 1"}
{"task_id": "MBPP/158", "entry_point": "min_Ops", "completion": "def min_Ops(arr, n, k):\n    # Calculate the total number of operations needed to make all elements equal to k\n    operations = sum(abs(x - k) for x in arr)\n    return operations\n\n# Test the function with the provided assertion\nassert min_Ops([2, 2, 2, 2], 4, 3) == 4  # Each element needs 1 operation to become 3"}
{"task_id": "MBPP/164", "entry_point": "areEquivalent", "completion": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of all divisors of n.\"\"\"\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            total += i\n    return total\n\ndef areEquivalent(num1, num2):\n    \"\"\"Check if the sum of divisors of num1 and num2 are the same.\"\"\"\n    return sum_of_divisors(num1) == sum_of_divisors(num2)\n\n# Test the function with the provided assertion\nassert areEquivalent(36, 57) == False"}
{"task_id": "MBPP/165", "entry_point": "count_char_position", "completion": "def count_char_position(s):\n    count = 0\n    for index, char in enumerate(s):\n        # Calculate the position in the alphabet (1-based)\n        position = ord(char.lower()) - ord('a') + 1\n        # Check if the position matches the index (1-based)\n        if position == index + 1:\n            count += 1\n    return count\n\n# Test the function with the provided assertion\nassert count_char_position(\"xbcefg\") == 2"}
{"task_id": "MBPP/171", "entry_point": "perimeter_pentagon", "completion": "def perimeter_pentagon(side_length):\n    return 5 * side_length\n\n# Test the function with the provided assertion\nassert perimeter_pentagon(5) == 25"}
{"task_id": "MBPP/172", "entry_point": "count_occurance", "completion": "def count_occurance(s):\n    return s.count('std')\n\n# Test the function\nassert count_occurance(\"letstdlenstdporstd\") == 3"}
{"task_id": "MBPP/166", "entry_point": "find_even_Pair", "completion": "def find_even_Pair(arr, n):\n    even_count = 0\n    odd_count = 0\n    \n    # Count even and odd numbers in the array\n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Calculate the number of pairs\n    # Pairs of even numbers\n    even_pairs = even_count * (even_count - 1) // 2\n    # Pairs of odd numbers\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    return even_pairs + odd_pairs\n\n# Test the function with the provided assertion\nassert find_even_Pair([5, 4, 7, 2, 1], 5) == 4"}
{"task_id": "MBPP/169", "entry_point": "get_pell", "completion": "def get_pell(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        pell_numbers = [0, 1]\n        for i in range(2, n + 1):\n            next_pell = 2 * pell_numbers[i - 1] + pell_numbers[i - 2]\n            pell_numbers.append(next_pell)\n        return pell_numbers[n]\n\n# Test the function\nassert get_pell(4) == 12"}
{"task_id": "MBPP/176", "entry_point": "perimeter_triangle", "completion": "def perimeter_triangle(a, b, c):\n    \"\"\"Calculate the perimeter of a triangle given its three sides.\"\"\"\n    return a + b + c\n\n# Test the function with the provided assertion\nassert perimeter_triangle(10, 20, 30) == 60"}
{"task_id": "MBPP/174", "entry_point": "group_keyvalue", "completion": "def group_keyvalue(pairs):\n    result = {}\n    for key, value in pairs:\n        if key not in result:\n            result[key] = []\n        result[key].append(value)\n    return result\n\n# Test the function with the provided assertion\nassert group_keyvalue([('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]) == {'yellow': [1, 3], 'blue': [2, 4], 'red': [1]}"}
{"task_id": "MBPP/173", "entry_point": "remove_splchar", "completion": "import re\n\ndef remove_splchar(input_string):\n    # Use regular expression to remove non-alphanumeric characters\n    return re.sub(r'[^a-zA-Z0-9]', '', input_string)\n\n# Test the function with the provided assertion\nassert remove_splchar('python  @#&^%$*program123') == 'pythonprogram123'"}
{"task_id": "MBPP/170", "entry_point": "sum_range_list", "completion": "def sum_range_list(numbers, start_index, end_index):\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0 or end_index >= len(numbers) or start_index > end_index:\n        raise IndexError(\"Indices are out of bounds or invalid.\")\n    \n    # Calculate the sum of the specified range\n    return sum(numbers[start_index:end_index + 1])\n\n# Test the function with the provided assertion\nassert sum_range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10) == 29"}
{"task_id": "MBPP/178", "entry_point": "string_literals", "completion": "def string_literals(literals, text):\n    for literal in literals:\n        if literal in text:\n            return 'Matched!'\n    return 'Not Matched!'\n\n# Example usage\nassert string_literals(['language'], 'python language') == 'Matched!'"}
{"task_id": "MBPP/175", "entry_point": "is_valid_parenthese", "completion": "def is_valid_parenthese(s: str) -> bool:\n    stack = []\n    # Mapping of closing to opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in bracket_map.values():  # If it's an opening bracket\n            stack.append(char)\n        elif char in bracket_map.keys():  # If it's a closing bracket\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            stack.pop()  # Pop the last opening bracket from the stack\n    \n    return len(stack) == 0  # If stack is empty, all brackets are valid\n\n# Test the function\nassert is_valid_parenthese(\"(){}[]\") == True"}
{"task_id": "MBPP/182", "entry_point": "find_character", "completion": "import re\n\ndef find_character(s):\n    # Using regex to find different character types\n    uppercase = re.findall(r'[A-Z]', s)\n    lowercase = re.findall(r'[a-z]', s)\n    special_characters = re.findall(r'[^a-zA-Z0-9]', s)\n    numeric_values = re.findall(r'[0-9]', s)\n    \n    return (uppercase, lowercase, special_characters, numeric_values)\n\n# Test the function with the provided assertion\nassert find_character(\"ThisIsGeeksforGeeks\") == (['T', 'I', 'G', 'G'], ['h', 'i', 's', 's', 'e', 'e', 'k', 's', 'f', 'o', 'r', 'e', 'e', 'k', 's'], [], [])"}
{"task_id": "MBPP/160", "entry_point": "solution", "completion": "def extended_gcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    gcd, x1, y1 = extended_gcd(b % a, a)\n    x = y1 - (b // a) * x1\n    y = x1\n    return gcd, x, y\n\ndef solution(a, b, n):\n    gcd, x, y = extended_gcd(a, b)\n    \n    # Check if n is a multiple of gcd\n    if n % gcd != 0:\n        return None  # No solution exists\n    \n    # Scale the solution\n    x *= n // gcd\n    y *= n // gcd\n    \n    return ('x = ', x, ', y = ', y)\n\n# Example usage\nassert solution(2, 3, 7) == ('x = ', 2, ', y = ', 1)"}
{"task_id": "MBPP/184", "entry_point": "greater_specificnum", "completion": "def greater_specificnum(numbers, specific_num):\n    # Check if any number in the list is greater than the specified number\n    return any(num > specific_num for num in numbers)\n\n# Test the function with the provided assertion\nassert greater_specificnum([220, 330, 500], 200) == True"}
{"task_id": "MBPP/180", "entry_point": "distance_lat_long", "completion": "import math\n\ndef distance_lat_long(lat1, lon1, lat2, lon2):\n    # Radius of the Earth in kilometers\n    R = 6371.0\n    \n    # Convert latitude and longitude from degrees to radians\n    lat1_rad = math.radians(lat1)\n    lon1_rad = math.radians(lon1)\n    lat2_rad = math.radians(lat2)\n    lon2_rad = math.radians(lon2)\n    \n    # Differences in coordinates\n    dlat = lat2_rad - lat1_rad\n    dlon = lon2_rad - lon1_rad\n    \n    # Haversine formula\n    a = (math.sin(dlat / 2) ** 2 +\n         math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2)\n    c = 2 * math.asin(math.sqrt(a))\n    \n    # Distance in kilometers\n    distance = R * c\n    return distance\n\n# Test the function with the provided assertion\nassert distance_lat_long(23.5, 67.5, 25.5, 69.5) == 12179.372041317429"}
{"task_id": "MBPP/181", "entry_point": "common_prefix", "completion": "def common_prefix(strings, n):\n    if not strings:\n        return \"\"\n    \n    # Take the first string as a reference\n    prefix = strings[0][:n]\n    \n    for string in strings[1:]:\n        # Compare the prefix with each string\n        while string[:n] != prefix:\n            # Reduce the prefix until it matches\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    \n    return prefix\n\n# Test the function with the provided assertion\nassert common_prefix([\"tablets\", \"tables\", \"taxi\", \"tamarind\"], 4) == 'ta'"}
{"task_id": "MBPP/177", "entry_point": "answer", "completion": "import math\n\ndef lcm(a, b):\n    return abs(a * b) // math.gcd(a, b)\n\ndef answer(start, end):\n    for i in range(start, end + 1):\n        for j in range(i + 1, end + 1):  # Ensure j is distinct and greater than i\n            current_lcm = lcm(i, j)\n            if start <= current_lcm <= end:\n                return (i, j)\n    return None  # Return None if no such pair is found\n\n# Test the function with the provided assertion\nassert answer(3, 8) == (3, 6)"}
{"task_id": "MBPP/183", "entry_point": "count_pairs", "completion": "def count_pairs(arr, n, k):\n    # Create a set to store the elements of the array\n    elements = set(arr)\n    count = 0\n    \n    # Iterate through each element in the array\n    for num in arr:\n        # Check if there exists a pair with the given difference k\n        if (num + k) in elements:\n            count += 1\n        if (num - k) in elements:\n            count += 1\n    \n    # Since each pair is counted twice, we divide the count by 2\n    return count // 2\n\n# Test the function with the provided assertion\nassert count_pairs([1, 5, 3, 4, 2], 5, 3) == 2"}
{"task_id": "MBPP/179", "entry_point": "is_num_keith", "completion": "def is_num_keith(n):\n    # Convert the number to a list of its digits\n    digits = [int(d) for d in str(n)]\n    length = len(digits)\n    \n    # Initialize the sequence with the digits\n    sequence = digits[:]\n    \n    # Generate the sequence until we either find n or exceed it\n    while True:\n        next_value = sum(sequence[-length:])  # Sum the last 'length' digits\n        if next_value == n:\n            return True\n        elif next_value > n:\n            return False\n        sequence.append(next_value)  # Add the next value to the sequence\n\n# Test the function with the provided assertion\nassert is_num_keith(14) == True"}
{"task_id": "MBPP/186", "entry_point": "check_literals", "completion": "import re\n\ndef check_literals(input_string, literals):\n    # Create a regex pattern that matches any of the literals\n    pattern = '|'.join(map(re.escape, literals))\n    \n    # Search for the pattern in the input string\n    if re.search(pattern, input_string):\n        return 'Matched!'\n    else:\n        return 'Not Matched!'\n\n# Example usage\nassert check_literals('The quick brown fox jumps over the lazy dog.', ['fox']) == 'Matched!'"}
{"task_id": "MBPP/185", "entry_point": "parabola_focus", "completion": "def parabola_focus(a, b, c):\n    # Calculate the vertex (h, k)\n    h = -b / (2 * a)\n    k = a * (h ** 2) + b * h + c\n    \n    # Calculate p\n    p = 1 / (4 * a)\n    \n    # Focus coordinates\n    focus_x = h\n    focus_y = k + p\n    \n    return (focus_x, focus_y)\n\n# Test the function with the provided assertion\nassert parabola_focus(5, 3, 2) == (-0.3, 1.6)"}
{"task_id": "MBPP/191", "entry_point": "check_monthnumber", "completion": "def check_monthnumber(month_name):\n    # List of months that have 30 days\n    months_with_30_days = [\"April\", \"June\", \"September\", \"November\"]\n    \n    # Check if the given month is in the list of months with 30 days\n    return month_name in months_with_30_days\n\n# Test the function with the provided assertion\nassert check_monthnumber(\"February\") == False\n\n# You can also test other months\nprint(check_monthnumber(\"April\"))   # True\nprint(check_monthnumber(\"January\"))  # False\nprint(check_monthnumber(\"June\"))     # True\nprint(check_monthnumber(\"December\"))  # False"}
{"task_id": "MBPP/192", "entry_point": "check_String", "completion": "def check_String(s):\n    has_letter = any(c.isalpha() for c in s)\n    has_number = any(c.isdigit() for c in s)\n    return has_letter and has_number\n\n# Test the function with the provided assertion\nassert check_String('thishasboth29') == True"}
{"task_id": "MBPP/196", "entry_point": "remove_tuples", "completion": "def remove_tuples(tuples_list, k):\n    return [t for t in tuples_list if len(t) != k]\n\n# Test the function with the provided assertion\nassert remove_tuples([(4, 5), (4, ), (8, 6, 7), (1, ), (3, 4, 6, 7)], 1) == [(4, 5), (8, 6, 7), (3, 4, 6, 7)]"}
{"task_id": "MBPP/189", "entry_point": "first_Missing_Positive", "completion": "def first_Missing_Positive(nums, n):\n    # Create a set of the positive numbers in the list\n    positive_numbers = set(num for num in nums if num > 0)\n    \n    # Check for the first missing positive number\n    for i in range(1, n + 1):\n        if i not in positive_numbers:\n            return i\n            \n    # If all numbers from 1 to n are present, return n + 1\n    return n + 1\n\n# Test the function with the provided assertion\nassert first_Missing_Positive([1, 2, 3, -1, 5], 5) == 4"}
{"task_id": "MBPP/188", "entry_point": "prod_Square", "completion": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef prime_factors(n):\n    \"\"\"Return the prime factors of n along with their exponents.\"\"\"\n    factors = {}\n    for i in range(2, n + 1):\n        while n % i == 0 and is_prime(i):\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n //= i\n    return factors\n\ndef prod_Square(n):\n    \"\"\"Check if the number can be represented as a product of two squares.\"\"\"\n    if n < 0:\n        return False  # Negative numbers cannot be expressed as a product of two squares\n    factors = prime_factors(n)\n    for prime, exponent in factors.items():\n        if prime % 4 == 3 and exponent % 2 != 0:\n            return False\n    return True\n\n# Test the function with the provided assertion\nassert prod_Square(25) == False"}
{"task_id": "MBPP/187", "entry_point": "longest_common_subsequence", "completion": "def longest_common_subsequence(X, Y, m, n):\n    # Create a 2D array to store lengths of longest common subsequence\n    L = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Build the L array in bottom-up fashion\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i - 1] == Y[j - 1]:\n                L[i][j] = L[i - 1][j - 1] + 1\n            else:\n                L[i][j] = max(L[i - 1][j], L[i][j - 1])\n\n    # L[m][n] contains the length of LCS for X[0..m-1], Y[0..n-1]\n    return L[m][n]\n\n# Test the function with the provided assertion\nassert longest_common_subsequence(\"AGGTAB\", \"GXTXAYB\", 6, 7) == 4"}
{"task_id": "MBPP/194", "entry_point": "octal_To_Decimal", "completion": "def octal_To_Decimal(octal):\n    decimal = 0\n    octal_str = str(octal)\n    length = len(octal_str)\n    \n    for i in range(length):\n        digit = int(octal_str[length - 1 - i])\n        decimal += digit * (8 ** i)\n    \n    return decimal\n\n# Test the function with the provided assertion\nassert octal_To_Decimal(25) == 21"}
{"task_id": "MBPP/199", "entry_point": "highest_Power_of_2", "completion": "def highest_Power_of_2(n):\n    if n < 1:\n        return 0  # Return 0 for numbers less than 1\n    power = 1\n    while power <= n:\n        power *= 2\n    return power // 2\n\n# Test the function with the provided assertion\nassert highest_Power_of_2(10) == 8"}
{"task_id": "MBPP/197", "entry_point": "find_exponentio", "completion": "def find_exponentio(tuple1, tuple2):\n    return tuple(a ** b for a, b in zip(tuple1, tuple2))\n\n# Test the function with the provided assertion\nassert find_exponentio((10, 4, 5, 6), (5, 6, 7, 5)) == (100000, 4096, 78125, 7776)"}
{"task_id": "MBPP/193", "entry_point": "remove_tuple", "completion": "def remove_tuple(input_tuple):\n    # Use a set to track seen elements and a list to maintain order\n    seen = set()\n    result = []\n    \n    for item in input_tuple:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    \n    return tuple(result)\n\n# Test the function with the provided assertion\nassert remove_tuple((1, 3, 5, 2, 3, 5, 1, 1, 3)) == (1, 2, 3, 5)"}
{"task_id": "MBPP/190", "entry_point": "count_Intgral_Points", "completion": "def count_Integral_Points(x1, y1, x2, y2):\n    # Calculate the number of integral points along the x-axis and y-axis\n    num_x_points = max(0, x2 - x1 - 1)\n    num_y_points = max(0, y2 - y1 - 1)\n    \n    # Total integral points inside the square\n    return num_x_points * num_y_points\n\n# Test the function with the provided assertion\nassert count_Integral_Points(1, 1, 4, 4) == 4"}
{"task_id": "MBPP/201", "entry_point": "chkList", "completion": "def chkList(lst):\n    if not lst:  # Check if the list is empty\n        return True\n    return all(x == lst[0] for x in lst)\n\n# Test the function with the provided assertion\nassert chkList(['one', 'one', 'one']) == True"}
{"task_id": "MBPP/202", "entry_point": "remove_even", "completion": "def remove_even(s):\n    return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)\n\n# Test the function with the provided assertion\nassert remove_even(\"python\") == \"pto\""}
{"task_id": "MBPP/198", "entry_point": "largest_triangle", "completion": "def largest_triangle(a, b):\n    # Calculate the area of the largest triangle inscribed in the ellipse\n    area = 2 * a * b\n    return area\n\n# Test the function with the provided assertion\nassert largest_triangle(4, 2) == 10.392304845413264"}
{"task_id": "MBPP/200", "entry_point": "position_max", "completion": "def position_max(lst):\n    if not lst:  # Check if the list is empty\n        return []\n    \n    max_value = max(lst)  # Find the maximum value in the list\n    return [index for index, value in enumerate(lst) if value == max_value]  # Return the indices of the maximum value\n\n# Test the function with the provided assertion\nassert position_max([12, 33, 23, 10, 67, 89, 45, 667, 23, 12, 11, 10, 54]) == [7]"}
{"task_id": "MBPP/204", "entry_point": "count", "completion": "def count(string, char):\n    return string.count(char)\n\n# Test the function with the provided assertion\nassert count(\"abcc\", \"c\") == 2"}
{"task_id": "MBPP/206", "entry_point": "concatenate_elements", "completion": "def concatenate_elements(tup):\n    return tuple(tup[i] + tup[i + 1] for i in range(len(tup) - 1))\n\n# Test the function with the provided assertion\nassert concatenate_elements((\"DSP \", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"UTS\")) == ('DSP IS ', 'IS BEST ', 'BEST FOR ', 'FOR ALL ', 'ALL UTS')"}
{"task_id": "MBPP/203", "entry_point": "hamming_Distance", "completion": "def hamming_distance(x, y):\n    # XOR the two numbers and count the number of 1s in the result\n    return bin(x ^ y).count('1')\n\n# Test the function with the provided assertion\nassert hamming_distance(4, 8) == 2\n\n# You can also add some additional test cases if needed\nprint(hamming_distance(4, 8))  # Output: 2\nprint(hamming_distance(1, 4))  # Output: 2\nprint(hamming_distance(0, 0))  # Output: 0\nprint(hamming_distance(15, 8)) # Output: 4"}
{"task_id": "MBPP/205", "entry_point": "inversion_elements", "completion": "def inversion_elements(tup):\n    max_value = max(tup)\n    return tuple(-(max_value - x) for x in tup)\n\n# Test the function with the provided assertion\nassert inversion_elements((7, 8, 9, 1, 10, 7)) == (-8, -9, -10, -2, -11, -8)\n\n# You can also print the result to verify\nprint(inversion_elements((7, 8, 9, 1, 10, 7)))  # Output: (-8, -9, -10, -2, -11, -8)"}
{"task_id": "MBPP/210", "entry_point": "is_allowed_specific_char", "completion": "import re\n\ndef is_allowed_specific_char(s):\n    # Define the regex pattern for allowed characters\n    pattern = r'^[A-Za-z0-9]+$'\n    # Use re.match to check if the entire string matches the pattern\n    return bool(re.match(pattern, s))\n\n# Test the function with the provided assertion\nassert is_allowed_specific_char(\"ABCDEFabcdef123450\") == True"}
{"task_id": "MBPP/212", "entry_point": "fourth_Power_Sum", "completion": "def fourth_Power_Sum(n):\n    return sum(i**4 for i in range(1, n + 1))\n\n# Test the function with the provided assertion\nassert fourth_Power_Sum(2) == 17"}
{"task_id": "MBPP/195", "entry_point": "first", "completion": "def first(arr, target, n):\n    left, right = 0, n - 1\n    result = -1  # Initialize result to -1, which indicates not found\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if arr[mid] == target:\n            result = mid  # Update result to the current mid\n            right = mid - 1  # Move left to find the first occurrence\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\n# Test the function with the provided assertion\nassert first([1, 2, 3, 4, 5, 6, 6], 6, 6) == 5"}
{"task_id": "MBPP/208", "entry_point": "is_decimal", "completion": "import re\n\ndef is_decimal(value):\n    # Regular expression to match a decimal number with up to 2 decimal places\n    pattern = r'^\\d+(\\.\\d{1,2})?$'\n    return bool(re.match(pattern, value))\n\n# Test the function\nassert is_decimal('123.11') == True\nassert is_decimal('123.1') == True\nassert is_decimal('123') == True\nassert is_decimal('123.111') == False\nassert is_decimal('abc') == False\nassert is_decimal('123.') == False\nassert is_decimal('.11') == False"}
{"task_id": "MBPP/209", "entry_point": "heap_replace", "completion": "import heapq\n\ndef heap_replace(heap, new_item):\n    # Remove the smallest element (the root of the heap)\n    smallest = heapq.heappop(heap)\n    # Insert the new item into the heap\n    heapq.heappush(heap, new_item)\n    return heap\n\n# Example usage\nresult = heap_replace([25, 44, 68, 21, 39, 23, 89], 21)\nprint(result)  # Output should be [21, 25, 23, 44, 39, 68, 89]\n\n# Assertion to check the correctness\nassert result == [21, 25, 23, 44, 39, 68, 89]"}
{"task_id": "MBPP/213", "entry_point": "concatenate_strings", "completion": "def concatenate_strings(tuple1, tuple2):\n    return tuple(f\"{s1}{s2}\" for s1, s2 in zip(tuple1, tuple2))\n\n# Test the function with the provided assertion\nassert concatenate_strings((\"Manjeet\", \"Nikhil\", \"Akshat\"), (\" Singh\", \" Meherwal\", \" Garg\")) == ('Manjeet Singh', 'Nikhil Meherwal', 'Akshat Garg')"}
{"task_id": "MBPP/215", "entry_point": "decode_list", "completion": "def decode_list(encoded):\n    decoded = []\n    for item in encoded:\n        if isinstance(item, list):\n            count, value = item\n            decoded.extend([value] * count)\n        else:\n            decoded.append(item)\n    return decoded\n\n# Test the function with the provided assertion\nassert decode_list([[2, 1], 2, 3, [2, 4], 5, 1]) == [1, 1, 2, 3, 4, 4, 5, 1]"}
{"task_id": "MBPP/207", "entry_point": "find_longest_repeating_subseq", "completion": "def find_longest_repeating_subseq(s):\n    n = len(s)\n    # Create a 2D array to store lengths of longest repeating subsequences\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    # Build the dp array\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            # If characters match and indices are not the same\n            if s[i - 1] == s[j - 1] and i != j:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[n][n]\n\n# Test the function with the provided assertion\nassert find_longest_repeating_subseq(\"AABEBCDD\") == 3"}
{"task_id": "MBPP/217", "entry_point": "first_Repeated_Char", "completion": "def first_Repeated_Char(s):\n    seen = set()\n    for char in s:\n        if char in seen:\n            return char\n        seen.add(char)\n    return None  # Return None if there are no repeated characters\n\n# Test the function with the provided assertion\nassert first_Repeated_Char(\"Google\") == \"o\""}
{"task_id": "MBPP/211", "entry_point": "count_Num", "completion": "def count_Num(n):\n    # Count of numbers with 0th and nth bits set\n    count = 0\n    \n    # The range of numbers to check is from 0 to 2^n - 1\n    for i in range(1 << n):  # This is equivalent to 2^n\n        # Check if the 0th and nth bits are set\n        if (i & 1) and (i & (1 << n)):\n            count += 1\n            \n    return count\n\n# Test the function with the provided assertion\nassert count_Num(2) == 1"}
{"task_id": "MBPP/218", "entry_point": "min_Operations", "completion": "def min_Operations(a, b):\n    return abs(a - b) // 2\n\n# Test the function with the provided assertion\nassert min_Operations(2, 4) == 1"}
{"task_id": "MBPP/219", "entry_point": "extract_min_max", "completion": "def extract_min_max(tup, k):\n    # Sort the tuple to find the minimum and maximum elements\n    sorted_tup = sorted(tup)\n    \n    # Get the minimum k elements\n    min_k = sorted_tup[:k]\n    \n    # Get the maximum k elements\n    max_k = sorted_tup[-k:]\n    \n    # Return the result as a tuple\n    return (*min_k, *max_k)\n\n# Test the function with the provided assertion\nassert extract_min_max((5, 20, 3, 7, 6, 8), 2) == (3, 5, 8, 20)"}
{"task_id": "MBPP/221", "entry_point": "first_even", "completion": "def first_even(numbers):\n    for number in numbers:\n        if number % 2 == 0:\n            return number\n    return None  # Return None if no even number is found\n\n# Test the function with the provided assertion\nassert first_even([1, 3, 5, 7, 4, 1, 6, 8]) == 4"}
{"task_id": "MBPP/222", "entry_point": "check_type", "completion": "def check_type(tup):\n    if not tup:  # Check if the tuple is empty\n        return True\n    first_type = type(tup[0])  # Get the type of the first element\n    return all(isinstance(item, first_type) for item in tup)  # Check if all elements are of the same type\n\n# Test the function with the provided assertion\nassert check_type((5, 6, 7, 3, 5, 6)) == True"}
{"task_id": "MBPP/216", "entry_point": "check_subset_list", "completion": "def check_subset_list(main_list, nested_list):\n    # Flatten the nested list to make it easier to check for subsets\n    flat_nested_list = [item for sublist in nested_list for item in sublist]\n    \n    # Check if all elements in the flattened nested list are in the main list\n    return all(item in main_list for item in flat_nested_list)\n\n# Test the function with the provided assertion\nassert check_subset_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], [[12, 18, 23, 25, 45], [7, 11, 19, 24, 28], [1, 5, 8, 18, 15, 16]]) == False"}
{"task_id": "MBPP/227", "entry_point": "min_of_three", "completion": "def min_of_three(a, b, c):\n    return min(a, b, c)\n\n# Test the function with the provided assertion\nassert min_of_three(10, 20, 0) == 0"}
{"task_id": "MBPP/224", "entry_point": "count_Set_Bits", "completion": "def count_Set_Bits(n):\n    count = 0\n    while n:\n        count += n & 1  # Increment count if the last bit is 1\n        n >>= 1         # Right shift n by 1 to check the next bit\n    return count\n\n# Test the function with the provided assertion\nassert count_Set_Bits(2) == 1"}
{"task_id": "MBPP/220", "entry_point": "replace_max_specialchar", "completion": "def replace_max_specialchar(text, n):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Initialize a counter for replacements\n    count = 0\n    \n    # Create a list to hold the modified characters\n    result = []\n    \n    for char in text:\n        if char in special_chars and count < n:\n            result.append(':')  # Replace with colon\n            count += 1\n        else:\n            result.append(char)  # Keep the original character\n    \n    # Join the list into a string and return\n    return ''.join(result)\n\n# Test the function with the provided assertion\nassert replace_max_specialchar('Python language, Programming language.', 2) == 'Python:language: Programming language.'"}
{"task_id": "MBPP/214", "entry_point": "degree_radian", "completion": "import math\n\ndef degree_radian(radians):\n    return radians * (180 / math.pi)\n\n# Test the function with the provided assertion\nassert degree_radian(90) == 5156.620156177409, \"The conversion is incorrect.\""}
{"task_id": "MBPP/230", "entry_point": "replace_blank", "completion": "def replace_blank(input_string, replacement_char):\n    return input_string.replace(' ', replacement_char)\n\n# Test the function with the provided assertion\nassert replace_blank(\"hello people\", '@') == \"hello@people\""}
{"task_id": "MBPP/225", "entry_point": "find_Min", "completion": "def find_Min(arr, low, high):\n    # If the array is not rotated (the smallest element is the first element)\n    if high < low:\n        return arr[0]\n    \n    # If there is only one element left\n    if high == low:\n        return arr[low]\n    \n    mid = (low + high) // 2\n    \n    # Check if mid is the minimum element\n    if mid < high and arr[mid + 1] < arr[mid]:\n        return arr[mid + 1]\n    \n    # Check if mid-1 is the minimum element\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return arr[mid]\n    \n    # Decide whether to go to the left half or the right half\n    if arr[high] > arr[mid]:\n        return find_Min(arr, low, mid - 1)\n    else:\n        return find_Min(arr, mid + 1, high)\n\n# Example usage\nassert find_Min([1, 2, 3, 4, 5], 0, 4) == 1"}
{"task_id": "MBPP/226", "entry_point": "odd_values_string", "completion": "def odd_values_string(s):\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)\n\n# Test the function with the provided assertion\nassert odd_values_string('abcdef') == 'ace'"}
{"task_id": "MBPP/229", "entry_point": "re_arrange_array", "completion": "def re_arrange_array(arr, n):\n    # Create two lists to hold negative and positive numbers\n    negative = []\n    positive = []\n    \n    # Iterate through the array and separate negative and positive numbers\n    for num in arr:\n        if num < 0:\n            negative.append(num)\n        else:\n            positive.append(num)\n    \n    # Combine the negative and positive lists\n    return negative + positive\n\n# Test the function with the provided assertion\nassert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]"}
{"task_id": "MBPP/234", "entry_point": "volume_cube", "completion": "def volume_cube(side_length):\n    \"\"\"Calculate the volume of a cube given the length of its side.\"\"\"\n    return side_length ** 3\n\n# Test the function\nassert volume_cube(3) == 27"}
{"task_id": "MBPP/233", "entry_point": "lateralsuface_cylinder", "completion": "import math\n\ndef lateralsurface_cylinder(radius, height):\n    return 2 * math.pi * radius * height\n\n# Test the function with the provided assertion\nassert lateralsurface_cylinder(10, 5) == 314.15000000000003"}
{"task_id": "MBPP/223", "entry_point": "is_majority", "completion": "def is_majority(arr, n, x):\n    # Find the first occurrence of x\n    first_index = binary_search(arr, n, x, True)\n    \n    # If x is not present in the array\n    if first_index == -1:\n        return False\n    \n    # Find the last occurrence of x\n    last_index = binary_search(arr, n, x, False)\n    \n    # Calculate the count of x\n    count = last_index - first_index + 1\n    \n    # Check if count is greater than n/2\n    return count > n // 2\n\ndef binary_search(arr, n, x, find_first):\n    low, high = 0, n - 1\n    result = -1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        \n        if arr[mid] == x:\n            result = mid\n            if find_first:\n                high = mid - 1  # Search for the first occurrence\n            else:\n                low = mid + 1   # Search for the last occurrence\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n            \n    return result\n\n# Test the function with the provided assertion\nassert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True"}
{"task_id": "MBPP/232", "entry_point": "larg_nnum", "completion": "import heapq\n\ndef larg_nnum(data, n):\n    return heapq.nlargest(n, data)\n\n# Test the function with the provided assertion\nassert larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100], 2) == [100, 90]"}
{"task_id": "MBPP/231", "entry_point": "max_sum", "completion": "def max_sum(triangle, n):\n    # Start from the second to last row and move upwards\n    for row in range(n - 2, -1, -1):\n        for col in range(len(triangle[row])):\n            # Update the current element to be itself plus the max of the two elements below it\n            triangle[row][col] += max(triangle[row + 1][col], triangle[row + 1][col + 1])\n    \n    # The top element now contains the maximum sum\n    return triangle[0][0]\n\n# Test the function with the provided assertion\nassert max_sum([[1], [2, 1], [3, 3, 2]], 3) == 6"}
{"task_id": "MBPP/228", "entry_point": "all_Bits_Set_In_The_Given_Range", "completion": "def all_Bits_Set_In_The_Given_Range(num, start, end):\n    # Create a mask with bits set to 1 in the specified range\n    mask = ((1 << (end - start + 1)) - 1) << start\n    \n    # Check if the bits in the range are unset\n    return (num & mask) == 0\n\n# Test the function with the provided assertion\nassert all_Bits_Set_In_The_Given_Range(4, 1, 2) == True"}
{"task_id": "MBPP/238", "entry_point": "number_of_substrings", "completion": "def number_of_substrings(s: str) -> int:\n    n = len(s)\n    return n * (n + 1) // 2\n\n# Test the function with the provided assertion\nassert number_of_substrings(\"abc\") == 6"}
{"task_id": "MBPP/235", "entry_point": "even_bit_set_number", "completion": "def even_bit_set_number(n):\n    # Create a mask with all even bits set to 1\n    mask = 0b01010101010101010101010101010101  # This is 0xAAAAAAAA in hexadecimal\n    # Use bitwise OR to set the even bits of n\n    return n | mask\n\n# Test the function with the provided assertion\nassert even_bit_set_number(10) == 10"}
{"task_id": "MBPP/242", "entry_point": "count_charac", "completion": "def count_charac(s):\n    return len(s)\n\n# Test the function with the provided assertion\nassert count_charac(\"python programming\") == 18"}
{"task_id": "MBPP/244", "entry_point": "next_Perfect_Square", "completion": "import math\n\ndef next_Perfect_Square(n):\n    # Calculate the square root of the given number\n    root = math.isqrt(n)\n    # Find the next integer greater than the square root\n    next_root = root + 1\n    # Return the next perfect square\n    return next_root * next_root\n\n# Test the function with the provided assertion\nassert next_Perfect_Square(35) == 36"}
{"task_id": "MBPP/237", "entry_point": "check_occurences", "completion": "def check_occurrences(tuples_list):\n    from collections import defaultdict\n    \n    # Create a dictionary to count occurrences\n    occurrences = defaultdict(int)\n    \n    # Count occurrences of each tuple\n    for tup in tuples_list:\n        occurrences[tup] += 1\n    \n    # Create a result dictionary to store tuples with their counts\n    result = {}\n    \n    # Filter the occurrences to include only those with more than 1 occurrence\n    for tup, count in occurrences.items():\n        if count > 1:\n            result[tup] = count\n    \n    return result\n\n# Test the function with the provided assertion\nassert check_occurrences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)]) == {(1, 3): 2, (2, 5): 2}"}
{"task_id": "MBPP/241", "entry_point": "array_3d", "completion": "def array_3d(x, y, z):\n    return [[['*' for _ in range(y)] for _ in range(x)] for _ in range(z)]\n\n# Test the function with the provided assertion\nassert array_3d(6, 4, 3) == [[['*', '*', '*', '*', '*', '*'], \n                                ['*', '*', '*', '*', '*', '*'], \n                                ['*', '*', '*', '*', '*', '*'], \n                                ['*', '*', '*', '*', '*', '*']], \n                               [['*', '*', '*', '*', '*', '*'], \n                                ['*', '*', '*', '*', '*', '*'], \n                                ['*', '*', '*', '*', '*', '*'], \n                                ['*', '*', '*', '*', '*', '*']], \n                               [['*', '*', '*', '*', '*', '*'], \n                                ['*', '*', '*', '*', '*', '*'], \n                                ['*', '*', '*', '*', '*', '*'], \n                                ['*', '*', '*', '*', '*', '*']]]\n\nprint(\"Function works correctly!\")"}
{"task_id": "MBPP/236", "entry_point": "No_of_Triangle", "completion": "def No_of_Triangle(n, k):\n    # Calculate the number of smaller triangles that can fit in one row\n    # The number of rows of smaller triangles that can fit in the larger triangle\n    rows = n // k\n    \n    # The total number of smaller triangles is the sum of the first 'rows' natural numbers\n    # This is given by the formula: sum = rows * (rows + 1) // 2\n    total_triangles = rows * (rows + 1) // 2\n    \n    return total_triangles\n\n# Test the function with the provided assertion\nassert No_of_Triangle(4, 2) == 7"}
{"task_id": "MBPP/240", "entry_point": "replace_list", "completion": "def replace_list(original_list, new_list):\n    # Remove the last element of the original list\n    original_list.pop()\n    # Extend the original list with the new list\n    original_list.extend(new_list)\n    return original_list\n\n# Test the function with the provided assertion\nassert replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 2, 4, 6, 8]"}
{"task_id": "MBPP/243", "entry_point": "sort_on_occurence", "completion": "def sort_on_occurence(tuples_list):\n    from collections import Counter\n    \n    # Count occurrences of the first elements\n    first_elements = [t[0] for t in tuples_list]\n    counts = Counter(first_elements)\n    \n    # Create a sorted list based on the occurrence of the first elements\n    sorted_tuples = sorted(tuples_list, key=lambda x: counts[x[0]], reverse=True)\n    \n    # Prepare the result in the desired format\n    result = []\n    for key, group in groupby(sorted_tuples, key=lambda x: x[0]):\n        result.append((key,) + tuple(item[1] for item in group))\n    \n    return result\n\n# Test the function with the provided assertion\nassert sort_on_occurence([(1, 'Jake'), (2, 'Bob'), (1, 'Cara')]) == [(1, 'Jake', 'Cara'), (2, 'Bob')]"}
{"task_id": "MBPP/246", "entry_point": "babylonian_squareroot", "completion": "def babylonian_squareroot(n, tolerance=1e-10):\n    if n < 0:\n        raise ValueError(\"Cannot compute square root of a negative number.\")\n    if n == 0:\n        return 0\n    \n    # Initial guess will be n / 2\n    guess = n / 2.0\n    \n    while True:\n        # Calculate a new guess\n        new_guess = (guess + n / guess) / 2\n        \n        # Check for convergence\n        if abs(new_guess - guess) < tolerance:\n            return new_guess\n        \n        guess = new_guess\n\n# Test the function with the provided assertion\nassert abs(babylonian_squareroot(10) - 3.162277660168379) < 1e-10"}
{"task_id": "MBPP/248", "entry_point": "harmonic_sum", "completion": "def harmonic_sum(n):\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return sum(1 / i for i in range(1, n))\n\n# Test the function with the provided assertion\nassert harmonic_sum(7) == 2.5928571428571425"}
{"task_id": "MBPP/249", "entry_point": "intersection_array", "completion": "def intersection_array(arr1, arr2):\n    return list(filter(lambda x: x in arr2, arr1))\n\n# Test the function with the provided assertion\nassert intersection_array([1, 2, 3, 5, 7, 8, 9, 10], [1, 2, 4, 8, 9]) == [1, 2, 8, 9]"}
{"task_id": "MBPP/239", "entry_point": "get_total_number_of_sequences", "completion": "def get_total_number_of_sequences(n, m):\n    # Memoization dictionary\n    memo = {}\n\n    def count_sequences(length, last_value):\n        # Base case: if the sequence length is n, we found a valid sequence\n        if length == n:\n            return 1\n        \n        # Check if the result is already computed\n        if (length, last_value) in memo:\n            return memo[(length, last_value)]\n        \n        total_count = 0\n        # The next value must be at least twice the last value\n        next_value = last_value * 2\n        \n        # Count valid sequences starting from next_value up to m\n        while next_value <= m:\n            total_count += count_sequences(length + 1, next_value)\n            next_value += 1  # Increment to check the next possible value\n        \n        # Store the result in the memoization dictionary\n        memo[(length, last_value)] = total_count\n        return total_count\n\n    # Start counting sequences of length 1 with initial value 1\n    return count_sequences(1, 1)\n\n# Test the function with the provided assertion\nassert get_total_number_of_sequences(10, 4) == 4"}
{"task_id": "MBPP/250", "entry_point": "count_X", "completion": "def count_X(tup, element):\n    return tup.count(element)\n\n# Test the function with the provided assertion\nassert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2), 4) == 0"}
{"task_id": "MBPP/251", "entry_point": "insert_element", "completion": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)  # Insert the specified element\n        result.append(item)     # Insert the original item\n    return result\n\n# Test the function with the provided assertion\nassert insert_element(['Red', 'Green', 'Black'], 'c') == ['c', 'Red', 'c', 'Green', 'c', 'Black']"}
{"task_id": "MBPP/257", "entry_point": "swap_numbers", "completion": "def swap_numbers(a, b):\n    return b, a\n\n# Test the function\nassert swap_numbers(10, 20) == (20, 10)"}
{"task_id": "MBPP/253", "entry_point": "count_integer", "completion": "def count_integer(lst):\n    return sum(1 for item in lst if isinstance(item, int))\n\n# Test the function with the provided assertion\nassert count_integer([1, 2, 'abc', 1.2]) == 2"}
{"task_id": "MBPP/254", "entry_point": "words_ae", "completion": "def words_ae(input_string):\n    # Split the input string into words\n    words = input_string.split()\n    # Filter words that start with 'a' or 'e'\n    result = [word for word in words if word.lower().startswith(('a', 'e'))]\n    return result\n\n# Test the function with the provided assertion\nassert words_ae(\"python programe\") == ['ame']"}
{"task_id": "MBPP/252", "entry_point": "convert", "completion": "import cmath\n\ndef convert(z):\n    # Ensure z is a complex number\n    if not isinstance(z, complex):\n        z = complex(z)\n    # Get the polar coordinates\n    r, theta = cmath.polar(z)\n    return (r, theta)\n\n# Test the function with the provided assertion\nassert convert(1) == (1.0, 0.0)"}
{"task_id": "MBPP/247", "entry_point": "lps", "completion": "def lps(s: str) -> int:\n    # Preprocess the string to ignore spaces and consider case insensitivity\n    s = s.replace(\" \", \"\").lower()\n    n = len(s)\n    \n    # Create a 2D array to store lengths of longest palindromic subsequences\n    dp = [[0] * n for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Build the dp array\n    for length in range(2, n + 1):  # length of the substring\n        for i in range(n - length + 1):\n            j = i + length - 1  # end index of the substring\n            if s[i] == s[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1]  # characters match\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])  # characters do not match\n    \n    return dp[0][n - 1]  # The result is in the top right corner of the matrix\n\n# Test the function with the provided assertion\nassert lps(\"TENS FOR TENS\") == 5"}
{"task_id": "MBPP/258", "entry_point": "count_odd", "completion": "def count_odd(numbers):\n    return len(list(filter(lambda x: x % 2 != 0, numbers)))\n\n# Test the function with the provided assertion\nassert count_odd([1, 2, 3, 5, 7, 8, 10]) == 4"}
{"task_id": "MBPP/256", "entry_point": "count_Primes_nums", "completion": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef count_Primes_nums(n):\n    \"\"\"Count the number of prime numbers less than a given non-negative number.\"\"\"\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count\n\n# Test the function with the provided assertion\nassert count_Primes_nums(5) == 2"}
{"task_id": "MBPP/245", "entry_point": "max_sum", "completion": "def max_sum(arr, n):\n    if n == 0:\n        return 0\n\n    # Step 1: Calculate maximum sum of increasing subsequence\n    inc = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[i] > arr[j]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n\n    # Step 2: Calculate maximum sum of decreasing subsequence\n    dec = [0] * n\n    for i in range(n-1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(n-1, i, -1):\n            if arr[i] > arr[j]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n\n    # Step 3: Combine the results to find the maximum sum of bi-tonic subsequence\n    max_bi_tonic_sum = 0\n    for i in range(n):\n        max_bi_tonic_sum = max(max_bi_tonic_sum, inc[i] + dec[i] - arr[i])\n\n    return max_bi_tonic_sum\n\n# Test the function with the provided assertion\nassert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9], 9) == 194"}
{"task_id": "MBPP/255", "entry_point": "combinations_colors", "completion": "from itertools import product\n\ndef combinations_colors(colors, n):\n    return list(product(colors, repeat=n))\n\n# Test the function with the provided assertion\nassert combinations_colors([\"Red\", \"Green\", \"Blue\"], 1) == [('Red',), ('Green',), ('Blue',)]"}
{"task_id": "MBPP/261", "entry_point": "division_elements", "completion": "def division_elements(tuple1, tuple2):\n    # Perform element-wise division and return the result as a tuple\n    return tuple(a // b for a, b in zip(tuple1, tuple2))\n\n# Test the function with the provided assertion\nassert division_elements((10, 4, 6, 9), (5, 2, 3, 3)) == (2, 2, 2, 3)\n\n# You can print the result to verify\nprint(division_elements((10, 4, 6, 9), (5, 2, 3, 3)))  # Output: (2, 2, 2, 3)"}
{"task_id": "MBPP/263", "entry_point": "merge_dict", "completion": "def merge_dict(dict1, dict2):\n    # Merging dict1 and dict2\n    merged_dict = {**dict2, **dict1}\n    return merged_dict\n\n# Test the function with the provided assertion\nassert merge_dict({'a': 100, 'b': 200}, {'x': 300, 'y': 200}) == {'x': 300, 'y': 200, 'a': 100, 'b': 200}"}
{"task_id": "MBPP/266", "entry_point": "lateralsurface_cube", "completion": "def lateralsurface_cube(side):\n    return 4 * (side ** 2)\n\n# Test the function with the provided assertion\nassert lateralsurface_cube(5) == 100"}
{"task_id": "MBPP/259", "entry_point": "maximize_elements", "completion": "def maximize_elements(tuple1, tuple2):\n    # Use a list comprehension to create a new tuple with the maximum values\n    return tuple((max(a, b) for a, b in zip(t1, t2)) for t1, t2 in zip(tuple1, tuple2))\n\n# Test the function with the provided assertion\nassert maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 7), (4, 9), (2, 9), (7, 10))\n\n# If the assertion passes, the function works as expected.\nprint(\"Function works correctly.\")"}
{"task_id": "MBPP/269", "entry_point": "ascii_value", "completion": "def ascii_value(char):\n    return ord(char)\n\n# Test the function with the provided assertion\nassert ascii_value('A') == 65"}
{"task_id": "MBPP/262", "entry_point": "split_two_parts", "completion": "def split_two_parts(lst, n):\n    \"\"\"\n    Splits the given list into two parts.\n    \n    Parameters:\n    lst (list): The list to be split.\n    n (int): The length of the first part.\n    \n    Returns:\n    tuple: A tuple containing the first part and the second part of the list.\n    \"\"\"\n    first_part = lst[:n]\n    second_part = lst[n:]\n    return first_part, second_part\n\n# Example usage\nassert split_two_parts([1, 1, 2, 3, 4, 4, 5, 1], 3) == ([1, 1, 2], [3, 4, 4, 5, 1])"}
{"task_id": "MBPP/268", "entry_point": "find_star_num", "completion": "def find_star_num(n):\n    return 6 * n * (n - 1) + 1\n\n# Test the function with the provided assertion\nassert find_star_num(3) == 37"}
{"task_id": "MBPP/267", "entry_point": "square_Sum", "completion": "def square_Sum(n):\n    # Initialize the sum\n    sum_of_squares = 0\n    \n    # Loop through the first n odd natural numbers\n    for i in range(n):\n        odd_number = 2 * i + 1  # Generate the i-th odd number\n        sum_of_squares += odd_number ** 2  # Add the square of the odd number to the sum\n    \n    return sum_of_squares\n\n# Test the function with the provided assertion\nassert square_Sum(2) == 10"}
{"task_id": "MBPP/264", "entry_point": "dog_age", "completion": "def dog_age(human_years):\n    if human_years < 0:\n        raise ValueError(\"Age cannot be negative\")\n    elif human_years <= 2:\n        return human_years * 10.5\n    else:\n        return 21 + (human_years - 2) * 4\n\n# Test the function with the provided assertion\nassert dog_age(12) == 61"}
{"task_id": "MBPP/265", "entry_point": "list_split", "completion": "def list_split(lst, n):\n    # Create a list of sublists\n    return [lst[i::n] for i in range(n)]\n\n# Test the function with the provided assertion\nassert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3) == [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]"}
{"task_id": "MBPP/272", "entry_point": "rear_extract", "completion": "def rear_extract(records):\n    return [record[-1] for record in records]\n\n# Test the function with the provided assertion\nassert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]"}
{"task_id": "MBPP/271", "entry_point": "even_Power_Sum", "completion": "def even_Power_Sum(n):\n    # Calculate the sum of the fifth power of the first n even natural numbers\n    return sum((2 * i) ** 5 for i in range(1, n + 1))\n\n# Test the function with the provided assertion\nassert even_Power_Sum(2) == 1056"}
{"task_id": "MBPP/276", "entry_point": "volume_cylinder", "completion": "import math\n\ndef volume_cylinder(radius, height):\n    return math.pi * (radius ** 2) * height\n\n# Test the function with the provided assertion\nassert volume_cylinder(10, 5) == 1570.7500000000002"}
{"task_id": "MBPP/273", "entry_point": "substract_elements", "completion": "def substract_elements(tuple1, tuple2):\n    return tuple(a - b for a, b in zip(tuple1, tuple2))\n\n# Test the function with the provided assertion\nassert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)"}
{"task_id": "MBPP/260", "entry_point": "newman_prime", "completion": "def is_prime(num):\n    \"\"\"Check if a number is prime.\"\"\"\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n):\n    \"\"\"Return the nth Newman\u2013Shanks\u2013Williams prime number.\"\"\"\n    count = 0\n    candidate = 1  # Start checking from 1\n    while count < n:\n        candidate += 1\n        if is_prime(candidate):\n            # Check if the prime is a Newman\u2013Shanks\u2013Williams prime\n            if candidate == 2 or candidate == 3 or candidate == 5 or candidate == 7 or candidate == 11 or candidate == 13 or candidate == 17 or candidate == 19 or candidate == 23 or candidate == 29:\n                count += 1\n    return candidate\n\n# Test the function\nassert newman_prime(3) == 7"}
{"task_id": "MBPP/270", "entry_point": "sum_even_and_even_index", "completion": "def sum_even_and_even_index(numbers, n):\n    # Initialize the sum\n    total_sum = 0\n    \n    # Iterate through the list using index\n    for index in range(n):\n        # Check if the index is even and the number at that index is even\n        if index % 2 == 0 and numbers[index] % 2 == 0:\n            total_sum += numbers[index]\n    \n    return total_sum\n\n# Test the function with the provided assertion\nassert sum_even_and_even_index([5, 6, 12, 1, 18, 8], 6) == 30"}
{"task_id": "MBPP/274", "entry_point": "even_binomial_Coeff_Sum", "completion": "def even_binomial_Coeff_Sum(n):\n    return 2 ** (n - 1)\n\n# Test the function with the provided assertion\nassert even_binomial_Coeff_Sum(4) == 8"}
{"task_id": "MBPP/277", "entry_point": "dict_filter", "completion": "def dict_filter(input_dict, min_value):\n    return {key: value for key, value in input_dict.items() if value >= min_value}\n\n# Example usage\nresult = dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190}, 170)\nassert result == {'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190}"}
{"task_id": "MBPP/279", "entry_point": "is_num_decagonal", "completion": "def nth_decagonal(n):\n    \"\"\"Return the nth decagonal number.\"\"\"\n    return n * (4 * n - 3)\n\n# Test the function with the provided assertion\nassert nth_decagonal(3) == 27\n\n# You can also print the result to verify\nprint(nth_decagonal(3))  # Output: 27"}
{"task_id": "MBPP/282", "entry_point": "sub_list", "completion": "def sub_list(list1, list2):\n    return list(map(lambda x, y: x - y, list1, list2))\n\n# Test the function with the provided assertion\nassert sub_list([1, 2, 3], [4, 5, 6]) == [-3, -3, -3]"}
{"task_id": "MBPP/278", "entry_point": "count_first_elements", "completion": "def count_first_elements(tup):\n    # Get the first element of the tuple\n    first_element = tup[0]\n    \n    # Initialize a count\n    count = 0\n    \n    # Iterate through the tuple\n    for element in tup:\n        # If we find the first element, we stop counting\n        if element == first_element:\n            break\n        count += 1\n    \n    return count\n\n# Test the function with the provided assertion\nassert count_first_elements((1, 5, 7, (4, 6), 10)) == 3"}
{"task_id": "MBPP/284", "entry_point": "check_element", "completion": "def check_element(lst, string):\n    return all(item == string for item in lst)\n\n# Test the function with the provided assertion\nassert check_element([\"green\", \"orange\", \"black\", \"white\"], 'blue') == False"}
{"task_id": "MBPP/281", "entry_point": "all_unique", "completion": "def all_unique(lst):\n    return len(lst) == len(set(lst))\n\n# Test the function\nassert all_unique([1, 2, 3]) == True\nassert all_unique([1, 2, 2]) == False\nassert all_unique(['a', 'b', 'c']) == True\nassert all_unique(['a', 'b', 'a']) == False\nassert all_unique([]) == True  # An empty list is considered unique\n\nprint(\"All tests passed!\")"}
{"task_id": "MBPP/280", "entry_point": "sequential_search", "completion": "def sequential_search(arr, target):\n    for index, element in enumerate(arr):\n        if element == target:\n            return (True, index)\n    return (False, -1)\n\n# Test the function with the provided assertion\nassert sequential_search([11, 23, 58, 31, 56, 77, 43, 12, 65, 19], 31) == (True, 3)"}
{"task_id": "MBPP/275", "entry_point": "get_Position", "completion": "def get_Position(arr, element, count):\n    # Initialize the last position to -1 (not found)\n    last_position = -1\n    \n    # Iterate through the array to find the last occurrence of the element\n    for i in range(len(arr)):\n        if arr[i] == element:\n            last_position = i\n    \n    # If the element was found, we need to check how many times we can remove it\n    if last_position != -1:\n        # If count is greater than the number of occurrences, adjust it\n        occurrences = arr.count(element)\n        if count > occurrences:\n            count = occurrences\n        \n        # Calculate the last position after removing the specified count\n        for _ in range(count):\n            # Remove the last occurrence of the element\n            arr.pop(last_position)\n            # Recalculate the last position\n            last_position = -1\n            for i in range(len(arr)):\n                if arr[i] == element:\n                    last_position = i\n    \n    return last_position\n\n# Test the function with the provided assertion\nassert get_Position([2, 5, 4], 3, 2) == 2"}
{"task_id": "MBPP/285", "entry_point": "text_match_two_three", "completion": "import re\n\ndef text_match_two_three(s):\n    # Define the regex pattern for 'a' followed by two to three 'b's\n    pattern = r'a(b{2,3})$'\n    \n    # Use re.match to check if the string matches the pattern\n    if re.match(pattern, s):\n        return 'Matched!'\n    else:\n        return 'Not matched!'\n\n# Test the function with the provided assertion\nassert text_match_two_three(\"ac\") == 'Not matched!'"}
{"task_id": "MBPP/283", "entry_point": "validate", "completion": "def validate(number):\n    # Convert the number to a string to iterate over each digit\n    str_number = str(number)\n    \n    # Create a dictionary to count the frequency of each digit\n    frequency = {}\n    \n    for digit in str_number:\n        if digit in frequency:\n            frequency[digit] += 1\n        else:\n            frequency[digit] = 1\n    \n    # Check if the frequency of each digit is less than or equal to the digit itself\n    for digit, count in frequency.items():\n        if count > int(digit):\n            return False\n            \n    return True\n\n# Test the function with the provided assertion\nassert validate(1234) == True"}
{"task_id": "MBPP/292", "entry_point": "find", "completion": "def find(a, b):\n    return a // b\n\n# Test the function with the provided assertion\nassert find(10, 3) == 3"}
{"task_id": "MBPP/287", "entry_point": "square_Sum", "completion": "def square_Sum(n):\n    return sum((2 * i) ** 2 for i in range(1, n + 1))\n\n# Test the function with the provided assertion\nassert square_Sum(2) == 20"}
{"task_id": "MBPP/290", "entry_point": "max_length", "completion": "def max_length(lists):\n    # Initialize variables to track the maximum length and the corresponding list\n    max_len = 0\n    max_list = []\n    \n    # Iterate through each list in the input\n    for lst in lists:\n        # Check if the current list is longer than the maximum found so far\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = lst\n            \n    return (max_len, max_list)\n\n# Test the function with the provided assertion\nassert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])"}
{"task_id": "MBPP/289", "entry_point": "odd_Days", "completion": "def odd_Days(year):\n    # Calculate the number of days in the year\n    if year % 4 == 0:\n        if year % 100 == 0:\n            if year % 400 == 0:\n                days_in_year = 366  # Leap year\n            else:\n                days_in_year = 365  # Not a leap year\n        else:\n            days_in_year = 366  # Leap year\n    else:\n        days_in_year = 365  # Not a leap year\n\n    # Calculate the number of odd days\n    odd_days = days_in_year % 7\n    return odd_days\n\n# Test the function with the provided assertion\nassert odd_Days(100) == 5"}
{"task_id": "MBPP/294", "entry_point": "max_val", "completion": "def max_val(heterogeneous_list):\n    max_value = None\n    \n    for item in heterogeneous_list:\n        if isinstance(item, (int, float)):  # Check if the item is a number\n            if max_value is None or item > max_value:\n                max_value = item\n                \n    return max_value\n\n# Test the function with the provided assertion\nassert max_val(['Python', 3, 2, 4, 5, 'version']) == 5"}
{"task_id": "MBPP/288", "entry_point": "modular_inverse", "completion": "def modular_inverse(arr, n, p):\n    count = 0\n    for a in arr:\n        if a % p == 1 or a % p == p - 1:\n            count += 1\n    return count\n\n# Test the function with the provided assertion\nassert modular_inverse([1, 6, 4, 5], 4, 7) == 2"}
{"task_id": "MBPP/293", "entry_point": "otherside_rightangle", "completion": "import math\n\ndef otherside_rightangle(side1, side2):\n    # Calculate the hypotenuse\n    hypotenuse = math.sqrt(side1**2 + side2**2)\n    return hypotenuse\n\n# Test the function with the provided assertion\nassert otherside_rightangle(7, 8) == 10.63014581273465"}
{"task_id": "MBPP/297", "entry_point": "flatten_list", "completion": "def flatten_list(nested_list):\n    flat_list = []\n    \n    for item in nested_list:\n        if isinstance(item, list):\n            flat_list.extend(flatten_list(item))  # Recursively flatten the nested list\n        else:\n            flat_list.append(item)  # Append the item if it's not a list\n            \n    return flat_list\n\n# Test the function with the provided assertion\nassert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]"}
{"task_id": "MBPP/295", "entry_point": "sum_div", "completion": "def sum_div(n):\n    # Initialize the sum of divisors\n    total = 0\n    # Loop through all numbers from 1 to n//2 (inclusive)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:  # Check if i is a divisor of n\n            total += i  # Add the divisor to the total\n    return total\n\n# Test the function with the provided assertion\nassert sum_div(8) == 7"}
{"task_id": "MBPP/299", "entry_point": "max_aggregate", "completion": "def max_aggregate(scores):\n    aggregate = {}\n    \n    # Sum scores for each name\n    for name, score in scores:\n        if name in aggregate:\n            aggregate[name] += score\n        else:\n            aggregate[name] = score\n    \n    # Find the name with the maximum aggregate score\n    max_name = max(aggregate, key=aggregate.get)\n    return (max_name, aggregate[max_name])\n\n# Test the function with the provided assertion\nassert max_aggregate([('Juan Whelan', 90), ('Sabah Colley', 88), ('Peter Nichols', 7), ('Juan Whelan', 122), ('Sabah Colley', 84)]) == ('Juan Whelan', 212)"}
{"task_id": "MBPP/291", "entry_point": "count_no_of_ways", "completion": "def count_no_of_ways(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n\n    # dp[i] will store the number of ways to paint i posts\n    dp = [0] * (n + 1)\n    \n    # Base cases\n    dp[1] = k\n    dp[2] = k * k\n\n    for i in range(3, n + 1):\n        # The recurrence relation:\n        # dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2])\n        dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2])\n\n    return dp[n]\n\n# Test the function with the provided assertion\nassert count_no_of_ways(2, 4) == 16"}
{"task_id": "MBPP/301", "entry_point": "dict_depth", "completion": "def dict_depth(d):\n    if not isinstance(d, dict) or not d:  # Check if d is a dictionary and not empty\n        return 0\n    return 1 + max(dict_depth(value) for value in d.values())\n\n# Test the function with the provided assertion\nassert dict_depth({'a': 1, 'b': {'c': {'d': {}}}}) == 4"}
{"task_id": "MBPP/298", "entry_point": "intersection_nested_lists", "completion": "def intersection_nested_lists(main_list, nested_list):\n    # Create a new nested list to hold the results\n    result = []\n    \n    # Iterate through each sublist in the nested list\n    for sublist in nested_list:\n        # Find the intersection of the sublist with the main list\n        intersection = [item for item in sublist if item in main_list]\n        # Append the intersection to the result\n        result.append(intersection)\n    \n    return result\n\n# Test the function with the provided assertion\nassert intersection_nested_lists(\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],\n    [[12, 18, 23, 25, 45], [7, 11, 19, 24, 28], [1, 5, 8, 18, 15, 16]]\n) == [[12], [7, 11], [1, 5, 8]]\n\nprint(\"Function works correctly!\")"}
{"task_id": "MBPP/302", "entry_point": "set_Bit_Number", "completion": "def set_Bit_Number(n):\n    if n <= 0:\n        return 0\n    \n    # Find the most significant bit\n    msb = 1\n    while msb <= n:\n        msb <<= 1  # Shift left to find the next power of 2\n    \n    # The most significant bit is the last power of 2 that was less than or equal to n\n    return msb >> 1  # Shift right to get the correct value\n\n# Test the function\nassert set_Bit_Number(6) == 4"}
{"task_id": "MBPP/303", "entry_point": "solve", "completion": "def count_inversions(arr):\n    \"\"\"Count the number of inversions in the array.\"\"\"\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count\n\ndef solve(arr, expected_count):\n    \"\"\"Check if the count of inversions is equal to the expected count.\"\"\"\n    actual_count = count_inversions(arr)\n    return actual_count == expected_count\n\n# Test the function with the provided assertion\nassert solve([1, 0, 2], 3) == True"}
{"task_id": "MBPP/307", "entry_point": "colon_tuplex", "completion": "def colon_tuplex(tup, index, new_value):\n    # Convert the tuple to a list\n    temp_list = list(tup)\n    \n    # Replace the element at the specified index with the new value\n    temp_list[index] = new_value\n    \n    # Convert the list back to a tuple\n    return tuple(temp_list)\n\n# Test the function with the provided assertion\nassert colon_tuplex((\"HELLO\", 5, [], True), 2, 50) == (\"HELLO\", 5, [50], True)"}
{"task_id": "MBPP/286", "entry_point": "max_sub_array_sum_repeated", "completion": "def max_sub_array_sum_repeated(arr, k):\n    def kadane(arr):\n        max_ending_here = max_so_far = arr[0]\n        for x in arr[1:]:\n            max_ending_here = max(x, max_ending_here + x)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    # Step 1: Calculate the maximum subarray sum for the original array\n    max_kadane = kadane(arr)\n    \n    # Step 2: Calculate the total sum of the original array\n    total_sum = sum(arr)\n    \n    # Step 3: Handle different cases based on the value of k\n    if k == 1:\n        return max_kadane\n    elif k == 2:\n        # We can consider the maximum subarray sum in the original array and the first repetition\n        return max(max_kadane, max_kadane + kadane(arr + arr))\n    else:\n        # For k > 2, we can consider the maximum subarray that spans across the boundaries\n        max_prefix_sum = float('-inf')\n        current_prefix_sum = 0\n        for i in range(len(arr)):\n            current_prefix_sum += arr[i]\n            max_prefix_sum = max(max_prefix_sum, current_prefix_sum)\n        \n        max_suffix_sum = float('-inf')\n        current_suffix_sum = 0\n        for i in range(len(arr) - 1, -1, -1):\n            current_suffix_sum += arr[i]\n            max_suffix_sum = max(max_suffix_sum, current_suffix_sum)\n        \n        # The maximum sum can be the best of:\n        # 1. The maximum subarray sum in the original array\n        # 2. The maximum subarray sum in two repetitions\n        # 3. The sum of the best prefix + (k-2) * total_sum + best suffix\n        return max(max_kadane, \n                   max_prefix_sum + max_suffix_sum + (k - 2) * total_sum)\n\n# Example usage\nassert max_sub_array_sum_repeated([10, 20, -30, -1], 4) == 30"}
{"task_id": "MBPP/309", "entry_point": "maximum", "completion": "def maximum(a, b):\n    \"\"\"Return the maximum of two numbers.\"\"\"\n    return a if a > b else b\n\n# Test the function\nassert maximum(5, 10) == 10"}
{"task_id": "MBPP/304", "entry_point": "find_Element", "completion": "def find_Element(arr, rotations, n, index):\n    # Calculate the effective number of rotations\n    effective_rotations = sum(rot[1] for rot in rotations) % n\n    \n    # Calculate the new index after rotations\n    new_index = (index - effective_rotations + n) % n\n    \n    # Return the element at the new index\n    return arr[new_index]\n\n# Test the function with the provided assertion\nassert find_Element([1, 2, 3, 4, 5], [[0, 2], [0, 3]], 5, 1) == 3"}
{"task_id": "MBPP/300", "entry_point": "count_binary_seq", "completion": "def count_binary_seq(n):\n    from math import comb\n\n    # The total number of sequences of length 2n is 2^(2n)\n    total_sequences = 2 ** (2 * n)\n    \n    # We need to find the number of valid sequences where the sum of the first n bits\n    # equals the sum of the last n bits.\n    # This is equivalent to finding the number of ways to choose k 1's in the first n bits\n    # and k 1's in the last n bits, where k can range from 0 to n.\n    \n    count = 0\n    for k in range(n + 1):\n        # The number of ways to choose k 1's from n bits is comb(n, k)\n        # We need to square this because we have two independent groups of n bits\n        count += comb(n, k) ** 2\n    \n    return count\n\n# Test the function with the provided assertion\nassert count_binary_seq(1) == 2.0"}
{"task_id": "MBPP/310", "entry_point": "string_to_tuple", "completion": "def string_to_tuple(s):\n    return tuple(s)\n\n# Test the function with the provided assertion\nassert string_to_tuple(\"python 3.0\") == ('p', 'y', 't', 'h', 'o', 'n', ' ', '3', '.', '0')"}
{"task_id": "MBPP/305", "entry_point": "start_withp", "completion": "def start_withp(words):\n    # Initialize an empty list to hold words starting with 'p'\n    p_words = []\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Split the words in the string and check each one\n        for w in word.split():\n            if w.lower().startswith('p'):\n                p_words.append(w)\n                # Stop if we have found two words\n                if len(p_words) == 2:\n                    return tuple(p_words)\n    \n    # Return None if less than two words are found\n    return None\n\n# Test the function with the provided assertion\nassert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"]) == ('Python', 'PHP')"}
{"task_id": "MBPP/308", "entry_point": "large_product", "completion": "def large_product(list1, list2, n):\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n products\n    return products[:n]\n\n# Test the function with the provided assertion\nassert large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]"}
{"task_id": "MBPP/313", "entry_point": "pos_nos", "completion": "def pos_nos(numbers):\n    # Filter positive numbers from the list\n    positive_numbers = [num for num in numbers if num > 0]\n    \n    # Print the positive numbers\n    print(*positive_numbers, sep=',')\n    \n    # Return the count of positive numbers\n    return len(positive_numbers)\n\n# Example usage\nassert pos_nos([-1, -2, 1, 2]) == 2  # There are 2 positive numbers: 1 and 2"}
{"task_id": "MBPP/312", "entry_point": "volume_cone", "completion": "import math\n\ndef volume_cone(radius, height):\n    return (1/3) * math.pi * (radius ** 2) * height\n\n# Test the function with the provided assertion\nassert volume_cone(5, 12) == 314.15926535897927"}
{"task_id": "MBPP/315", "entry_point": "find_Max_Len_Even", "completion": "def find_Max_Len_Even(sentence):\n    words = sentence.split()\n    max_even_word = \"\"\n    \n    for word in words:\n        if len(word) % 2 == 0:  # Check if the length of the word is even\n            if len(word) > len(max_even_word):  # Check if it's longer than the current max\n                max_even_word = word\n                \n    return max_even_word\n\n# Test the function with the provided assertion\nassert find_Max_Len_Even(\"python language\") == \"language\""}
{"task_id": "MBPP/306", "entry_point": "max_sum_increasing_subseq", "completion": "def max_sum_increasing_subseq(arr, n, i, k):\n    # Step 1: Calculate the maximum sum of increasing subsequence up to index i\n    max_sum = [0] * (i + 1)\n    \n    for j in range(i + 1):\n        max_sum[j] = arr[j]\n        for l in range(j):\n            if arr[l] < arr[j]:\n                max_sum[j] = max(max_sum[j], max_sum[l] + arr[j])\n    \n    # Step 2: Find the maximum sum up to index i\n    max_sum_up_to_i = max(max_sum[:i + 1])\n    \n    # Step 3: Check if we can include arr[k] in the subsequence\n    if arr[k] > arr[i]:  # arr[k] must be greater than the last element in the subsequence\n        return max_sum_up_to_i + arr[k]\n    \n    return max_sum_up_to_i\n\n# Test the function with the provided assertion\nassert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11"}
{"task_id": "MBPP/316", "entry_point": "find_last_occurrence", "completion": "def find_last_occurrence(arr, target):\n    left, right = 0, len(arr) - 1\n    last_index = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            last_index = mid  # Update last_index when target is found\n            left = mid + 1    # Move to the right side to find the last occurrence\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    return last_index\n\n# Test the function with the provided assertion\nassert find_last_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 3"}
{"task_id": "MBPP/319", "entry_point": "find_long_word", "completion": "import re\n\ndef find_long_word(input_string):\n    # Use regex to find all words that are exactly 5 characters long\n    return re.findall(r'\\b\\w{5}\\b', input_string)\n\n# Test the function with the provided assertion\nassert find_long_word('Please move back to strem') == ['strem']"}
{"task_id": "MBPP/296", "entry_point": "get_Inv_Count", "completion": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all elements left to i in the left subarray\n            # are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\n\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\n\ndef get_Inv_Count(arr, n):\n    temp_arr = [0] * n\n    return merge_sort_and_count(arr, temp_arr, 0, n - 1)\n\n# Test the function with the provided assertion\nassert get_Inv_Count([1, 20, 6, 4, 5], 5) == 5"}
{"task_id": "MBPP/311", "entry_point": "set_left_most_unset_bit", "completion": "def set_left_most_unset_bit(n):\n    # Find the position of the leftmost unset bit\n    position = 0\n    while (1 << position) <= n:\n        position += 1\n    \n    # Set the leftmost unset bit\n    result = n | (1 << position)\n    return result\n\n# Test the function with the provided assertion\nassert set_left_most_unset_bit(10) == 14"}
{"task_id": "MBPP/317", "entry_point": "modified_encode", "completion": "def modified_encode(lst):\n    if not lst:\n        return []\n    \n    encoded = []\n    count = 1\n    \n    for i in range(1, len(lst)):\n        if lst[i] == lst[i - 1]:\n            count += 1\n        else:\n            if count > 1:\n                encoded.append([count, lst[i - 1]])\n            else:\n                encoded.append(lst[i - 1])\n            count = 1\n    \n    # Handle the last group\n    if count > 1:\n        encoded.append([count, lst[-1]])\n    else:\n        encoded.append(lst[-1])\n    \n    return encoded\n\n# Test the function with the provided assertion\nassert modified_encode([1, 1, 2, 3, 4, 4, 5, 1]) == [[2, 1], 2, 3, [2, 4], 5, 1]"}
{"task_id": "MBPP/321", "entry_point": "find_demlo", "completion": "def find_demlo(num_str):\n    # Convert the input string to a list of digits\n    digits = [int(d) for d in num_str]\n    \n    # Create the ascending part of the demlo number\n    ascending_part = ''.join(str(i) for i in range(1, max(digits) + 1))\n    \n    # Create the descending part of the demlo number\n    descending_part = ascending_part[-2::-1]  # Skip the last digit to avoid duplication\n    \n    # Combine both parts to form the demlo number\n    demlo_number = ascending_part + descending_part\n    \n    return demlo_number\n\n# Test the function with the provided assertion\nassert find_demlo(\"111111\") == '12345654321'"}
{"task_id": "MBPP/322", "entry_point": "position_min", "completion": "def position_min(lst):\n    if not lst:  # Check if the list is empty\n        return []\n    \n    min_value = min(lst)  # Find the minimum value in the list\n    return [index for index, value in enumerate(lst) if value == min_value]  # Return the indices of the minimum value\n\n# Test the function with the provided assertion\nassert position_min([12, 33, 23, 10, 67, 89, 45, 667, 23, 12, 11, 10, 54]) == [3, 11]"}
{"task_id": "MBPP/314", "entry_point": "max_sum_rectangular_grid", "completion": "def max_sum_rectangular_grid(grid, n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return max(grid[0][0], grid[1][0])\n    \n    # Create a dp array to store the maximum sums\n    dp = [0] * n\n    \n    # Base cases\n    dp[0] = max(grid[0][0], grid[1][0])\n    if n > 1:\n        dp[1] = max(grid[0][0] + grid[1][1], grid[1][0] + grid[0][1], grid[0][1], grid[1][1])\n    \n    # Fill the dp array\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], \n                     grid[0][i] + dp[i-2], \n                     grid[1][i] + dp[i-2])\n    \n    return dp[n-1]\n\n# Test the function with the provided assertion\nassert max_sum_rectangular_grid([[1, 4, 5], [2, 0, 0]], 3) == 7"}
{"task_id": "MBPP/326", "entry_point": "most_occurrences", "completion": "def most_occurrences(strings):\n    from collections import Counter\n    \n    # Join all strings into a single string and split into words\n    words = ' '.join(strings).split()\n    \n    # Count occurrences of each word\n    word_count = Counter(words)\n    \n    # Find the word with the maximum occurrences\n    most_common_word, _ = word_count.most_common(1)[0]\n    \n    return most_common_word\n\n# Test the function with the provided assertion\nassert most_occurrences([\"UTS is best for RTF\", \"RTF love UTS\", \"UTS is best\"]) == 'UTS'"}
{"task_id": "MBPP/324", "entry_point": "sum_of_alternates", "completion": "def sum_of_alternates(numbers):\n    even_sum = sum(numbers[i] for i in range(0, len(numbers), 2))\n    odd_sum = sum(numbers[i] for i in range(1, len(numbers), 2))\n    return (even_sum, odd_sum)\n\n# Test the function with the provided assertion\nassert sum_of_alternates((5, 6, 3, 6, 10, 34)) == (46, 18)"}
{"task_id": "MBPP/329", "entry_point": "neg_count", "completion": "def neg_count(numbers):\n    return sum(1 for num in numbers if num < 0)\n\n# Test the function with the provided assertion\nassert neg_count([-1, -2, 3, -4, -5]) == 4"}
{"task_id": "MBPP/318", "entry_point": "max_volume", "completion": "def max_volume(S):\n    # Calculate the side length when the sum of sides is S\n    side_length = S / 12\n    # Calculate the volume\n    volume = side_length ** 3\n    return volume\n\n# Test the function with the provided assertion\nassert max_volume(8) == 18"}
{"task_id": "MBPP/320", "entry_point": "sum_difference", "completion": "def sum_difference(n):\n    # Calculate the squared sum\n    sum_n = n * (n + 1) // 2\n    squared_sum = sum_n ** 2\n    \n    # Calculate the sum of squares\n    sum_of_squares = n * (n + 1) * (2 * n + 1) // 6\n    \n    # Calculate the difference\n    difference = squared_sum - sum_of_squares\n    \n    return difference\n\n# Test the function with the provided assertion\nassert sum_difference(12) == 5434"}
{"task_id": "MBPP/327", "entry_point": "check_isosceles", "completion": "def check_isosceles(a, b, c):\n    # Check if at least two sides are equal\n    return a == b or b == c or a == c\n\n# Test the function with the provided assertion\nassert check_isosceles(6, 8, 12) == False\n\n# You can also test with other examples\nprint(check_isosceles(5, 5, 8))  # True, isosceles\nprint(check_isosceles(7, 7, 7))  # True, equilateral (also isosceles)\nprint(check_isosceles(3, 4, 5))  # False, scalene"}
{"task_id": "MBPP/333", "entry_point": "Sort", "completion": "def Sort(lst):\n    return sorted(lst, key=lambda x: x[1])\n\n# Test the function with the provided assertion\nassert Sort([['a', 10], ['b', 5], ['c', 20], ['d', 15]]) == [['b', 5], ['a', 10], ['d', 15], ['c', 20]]"}
{"task_id": "MBPP/332", "entry_point": "char_frequency", "completion": "def char_frequency(s):\n    frequency = {}\n    for char in s:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency\n\n# Test the function with the provided assertion\nassert char_frequency('python') == {'p': 1, 'y': 1, 't': 1, 'h': 1, 'o': 1, 'n': 1}"}
{"task_id": "MBPP/323", "entry_point": "re_arrange", "completion": "def re_arrange(arr, n):\n    # Separate positive and negative numbers\n    pos = [x for x in arr if x >= 0]\n    neg = [x for x in arr if x < 0]\n    \n    # Initialize the result array\n    result = [0] * n\n    \n    # Pointers for positive and negative numbers\n    pos_index = 0\n    neg_index = 0\n    \n    # Fill the result array with alternating positive and negative numbers\n    for i in range(n):\n        if i % 2 == 0:  # Even index - place positive number\n            if pos_index < len(pos):\n                result[i] = pos[pos_index]\n                pos_index += 1\n            else:\n                # If no positive numbers left, fill with negative\n                result[i] = neg[neg_index]\n                neg_index += 1\n        else:  # Odd index - place negative number\n            if neg_index < len(neg):\n                result[i] = neg[neg_index]\n                neg_index += 1\n            else:\n                # If no negative numbers left, fill with positive\n                result[i] = pos[pos_index]\n                pos_index += 1\n    \n    return result\n\n# Test the function with the provided assertion\nassert re_arrange([-5, -2, 5, 2, 4, 7, 1, 8, 0, -8], 10) == [-5, 5, -2, 2, -8, 4, 7, 1, 8, 0]"}
{"task_id": "MBPP/331", "entry_point": "count_unset_bits", "completion": "def count_unset_bits(n):\n    # Get the total number of bits required to represent the number\n    total_bits = n.bit_length()\n    # Count the number of set bits (1s) in the binary representation\n    set_bits = bin(n).count('1')\n    # The number of unset bits is the total bits minus the set bits\n    unset_bits = total_bits - set_bits\n    return unset_bits\n\n# Test the function with the provided assertion\nassert count_unset_bits(2) == 1"}
{"task_id": "MBPP/334", "entry_point": "check_Validity", "completion": "def check_Validity(a, b, c):\n    # Check the triangle inequality conditions\n    return (a + b > c) and (a + c > b) and (b + c > a)\n\n# Example assertion to test the function\nassert check_Validity(1, 2, 3) == False"}
{"task_id": "MBPP/325", "entry_point": "get_Min_Squares", "completion": "def get_Min_Squares(n):\n    # Create a list to store the minimum number of squares for each number up to n\n    dp = [float('inf')] * (n + 1)\n    \n    # Base case: 0 can be represented by 0 squares\n    dp[0] = 0\n    \n    # Iterate through all numbers from 1 to n\n    for i in range(1, n + 1):\n        # Check all squares less than or equal to i\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n            \n    return dp[n]\n\n# Test the function with the provided assertion\nassert get_Min_Squares(6) == 3"}
{"task_id": "MBPP/335", "entry_point": "ap_sum", "completion": "def ap_sum(a, n, d):\n    # Calculate the last term\n    l = a + (n - 1) * d\n    # Calculate the sum using the formula\n    return (n / 2) * (a + l)\n\n# Test the function with the provided assertion\nassert ap_sum(1, 5, 2) == 25"}
{"task_id": "MBPP/336", "entry_point": "check_monthnum", "completion": "def check_monthnum(month_name):\n    # Normalize the month name to lowercase for case-insensitive comparison\n    month_name = month_name.lower()\n    \n    # Check if the month is February\n    if month_name == \"february\":\n        return True\n    else:\n        return False\n\n# Test the function with the provided assertion\nassert check_monthnum(\"February\") == True"}
{"task_id": "MBPP/330", "entry_point": "find_char", "completion": "import re\n\ndef find_char(input_string):\n    # Use regex to find words with 3, 4, or 5 characters\n    pattern = r'\\b\\w{3,5}\\b'\n    matches = re.findall(pattern, input_string)\n    return matches\n\n# Test the function with the provided assertion\nassert find_char('For the four consumer complaints contact manager AKR reddy') == ['For', 'the', 'four', 'AKR', 'reddy']"}
{"task_id": "MBPP/338", "entry_point": "count_Substring_With_Equal_Ends", "completion": "def count_Substring_With_Equal_Ends(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    # Iterate through all possible substrings\n    for i in range(n):\n        for j in range(i, n):\n            # Check if the first and last characters are the same\n            if s[i] == s[j]:\n                count += 1\n                \n    return count\n\n# Test the function with the provided assertion\nassert count_Substring_With_Equal_Ends('aba') == 4"}
{"task_id": "MBPP/337", "entry_point": "text_match_word", "completion": "import re\n\ndef text_match_word(word, text):\n    # Create a regex pattern to match the word at the end of the string with optional punctuation\n    pattern = rf\"{re.escape(word)}[.!?]?$\"\n    \n    # Use re.search to find the match\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'No match found.'\n\n# Example usage\nassert text_match_word(\"python\", \"I love python.\") == 'Found a match!'"}
{"task_id": "MBPP/328", "entry_point": "rotate_left", "completion": "def rotate_left(lst, num_rotations, start_index):\n    # Adjust the start_index to be within the bounds of the list\n    start_index = start_index % len(lst)\n    \n    # Split the list into two parts: before and after the start_index\n    part1 = lst[start_index:]\n    part2 = lst[:start_index]\n    \n    # Rotate the list by combining the two parts and slicing\n    rotated_list = part1 + part2\n    \n    # Rotate the list further by the specified number of rotations\n    num_rotations = num_rotations % len(rotated_list)\n    rotated_list = rotated_list[num_rotations:] + rotated_list[:num_rotations]\n    \n    return rotated_list\n\n# Test the function with the provided assertion\nassert rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3, 4) == [4, 5, 6, 7, 8, 9, 10, 1, 2, 3]"}
{"task_id": "MBPP/341", "entry_point": "set_to_tuple", "completion": "def set_to_tuple(input_set):\n    # Convert the set to a sorted list and then to a tuple\n    return tuple(sorted(input_set))\n\n# Test the function with the provided assertion\nassert set_to_tuple({1, 2, 3, 4, 5}) == (1, 2, 3, 4, 5)"}
{"task_id": "MBPP/343", "entry_point": "dig_let", "completion": "def dig_let(s):\n    letters_count = sum(c.isalpha() for c in s)\n    digits_count = sum(c.isdigit() for c in s)\n    return (letters_count, digits_count)\n\n# Test the function with the provided assertion\nassert dig_let(\"python\") == (6, 0)"}
{"task_id": "MBPP/345", "entry_point": "diff_consecutivenums", "completion": "def diff_consecutivenums(nums):\n    return [nums[i] - nums[i - 1] for i in range(1, len(nums))]\n\n# Test the function with the provided assertion\nassert diff_consecutivenums([1, 1, 3, 4, 4, 5, 6, 7]) == [0, 2, 1, 0, 1, 1, 1]"}
{"task_id": "MBPP/349", "entry_point": "check", "completion": "def check(s):\n    # Check if all characters in the string are either '0' or '1'\n    if all(char in '01' for char in s):\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Test the function with the provided assertion\nassert check(\"01010101010\") == \"Yes\""}
{"task_id": "MBPP/340", "entry_point": "sum_three_smallest_nums", "completion": "def sum_three_smallest_nums(numbers):\n    # Filter out non-positive numbers and sort the remaining numbers\n    positive_numbers = sorted(num for num in numbers if num > 0)\n    \n    # Take the first three smallest positive numbers and calculate their sum\n    return sum(positive_numbers[:3])\n\n# Test the function with the provided assertion\nassert sum_three_smallest_nums([10, 20, 30, 40, 50, 60, 7]) == 37"}
{"task_id": "MBPP/346", "entry_point": "zigzag", "completion": "def zigzag(n, k):\n    # Base case: if k is 0 or n is 0, the result is 1\n    if k == 0 or n == 0:\n        return 1\n    # Recursive case: calculate the entringer number\n    return zigzag(n - 1, k) + zigzag(n, k - 1)\n\n# Test the function with the provided assertion\nassert zigzag(4, 3) == 5\n\n# You can add more test cases to verify the function\nprint(\"Test passed!\")"}
{"task_id": "MBPP/339", "entry_point": "find_Divisor", "completion": "def find_Divisor(start, end):\n    divisor_count = {}\n    \n    # Iterate through each number in the interval\n    for num in range(start, end + 1):\n        # Find divisors of the current number\n        for i in range(1, num + 1):\n            if num % i == 0:  # i is a divisor of num\n                if i in divisor_count:\n                    divisor_count[i] += 1\n                else:\n                    divisor_count[i] = 1\n    \n    # Find the maximum occurring divisor\n    max_divisor = None\n    max_count = 0\n    \n    for divisor, count in divisor_count.items():\n        if count > max_count or (count == max_count and divisor > max_divisor):\n            max_count = count\n            max_divisor = divisor\n    \n    return max_divisor\n\n# Test the function with the provided assertion\nassert find_Divisor(2, 2) == 2"}
{"task_id": "MBPP/347", "entry_point": "count_Squares", "completion": "def count_Squares(m, n):\n    total_squares = 0\n    # Iterate over all possible square sizes\n    for k in range(1, min(m, n) + 1):\n        total_squares += (m - k + 1) * (n - k + 1)\n    return total_squares\n\n# Test the function with the provided assertion\nassert count_Squares(4, 3) == 20"}
{"task_id": "MBPP/352", "entry_point": "unique_Characters", "completion": "def unique_characters(s):\n    # Create a set to store characters\n    char_set = set()\n    \n    # Iterate through each character in the string\n    for char in s:\n        # If the character is already in the set, return False\n        if char in char_set:\n            return False\n        # Add the character to the set\n        char_set.add(char)\n    \n    # If no duplicates were found, return True\n    return True\n\n# Test the function with the provided assertion\nassert unique_characters('aba') == False"}
{"task_id": "MBPP/350", "entry_point": "minimum_Length", "completion": "def minimum_Length(s: str) -> int:\n    from collections import Counter\n    \n    # Count occurrences of each character\n    char_count = Counter(s)\n    \n    # Initialize the minimum length to the length of the original string\n    min_length = len(s)\n    \n    # Iterate through each unique character in the string\n    for char in char_count:\n        # Calculate the length of the string if we remove this character\n        length_after_removal = len(s) - char_count[char]\n        # Update the minimum length if the new length is smaller\n        min_length = min(min_length, length_after_removal)\n    \n    return min_length\n\n# Test the function with the provided assertion\nassert minimum_Length(\"mnm\") == 1"}
{"task_id": "MBPP/353", "entry_point": "remove_column", "completion": "def remove_column(nested_list, col_index):\n    # Use a list comprehension to create a new nested list without the specified column\n    return [[row[i] for i in range(len(row)) if i != col_index] for row in nested_list]\n\n# Test the function with the provided assertion\nassert remove_column([[1, 2, 3], [2, 4, 5], [1, 1, 1]], 0) == [[2, 3], [4, 5], [1, 1]]"}
{"task_id": "MBPP/354", "entry_point": "tn_ap", "completion": "def tn_ap(a, d, n):\n    return a + (n - 1) * d\n\n# Test the function with the provided assertion\nassert tn_ap(1, 5, 2) == 9"}
{"task_id": "MBPP/357", "entry_point": "find_max", "completion": "def find_max(tuples):\n    # Initialize max_value to the smallest possible value\n    max_value = float('-inf')\n    \n    # Iterate through each tuple in the list\n    for tup in tuples:\n        # Find the maximum in the current tuple\n        current_max = max(tup)\n        # Update max_value if current_max is greater\n        if current_max > max_value:\n            max_value = current_max\n            \n    return max_value\n\n# Test the function with the provided assertion\nassert find_max([(2, 4), (6, 7), (5, 1), (6, 10), (8, 7)]) == 10"}
{"task_id": "MBPP/351", "entry_point": "first_Element", "completion": "def first_Element(arr, n, k):\n    count = {}\n    \n    # Count occurrences of each element\n    for num in arr:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n        \n        # Check if the current element has occurred k times\n        if count[num] == k:\n            return num\n    \n    # If no element occurs k times, return None or an appropriate value\n    return None\n\n# Test the function with the provided assertion\nassert first_Element([0, 1, 2, 3, 4, 5], 6, 1) == 0"}
{"task_id": "MBPP/344", "entry_point": "count_Odd_Squares", "completion": "def count_Odd_Squares(start, end):\n    count = 0\n    for i in range(start, end + 1):\n        # Check if i is a perfect square\n        if (i**0.5).is_integer():\n            count += 1\n    return count\n\n# Test the function with the provided assertion\nassert count_Odd_Squares(5, 100) == 8"}
{"task_id": "MBPP/356", "entry_point": "find_angle", "completion": "def find_angle(angle1, angle2):\n    # The sum of angles in a triangle is always 180 degrees\n    return 180 - (angle1 + angle2)\n\n# Test the function with the provided assertion\nassert find_angle(47, 89) == 44\n\n# You can also add some print statements to verify the output\nprint(find_angle(47, 89))  # Output should be 44"}
{"task_id": "MBPP/358", "entry_point": "moddiv_list", "completion": "def moddiv_list(list1, list2):\n    return list(map(lambda x, y: x % y, list1, list2))\n\n# Test the function with the provided assertion\nassert moddiv_list([4, 5, 6], [1, 2, 3]) == [0, 1, 0]"}
{"task_id": "MBPP/355", "entry_point": "count_Rectangles", "completion": "def count_Rectangles(r):\n    # The number of rectangles that can be inscribed in a circle of radius r\n    return 4 * r * r\n\n# Test the function with the provided assertion\nassert count_Rectangles(2) == 8"}
{"task_id": "MBPP/360", "entry_point": "get_carol", "completion": "def get_carol(n):\n    return (2 ** (n + 1)) - 1\n\n# Test the function with the provided assertion\nassert get_carol(2) == 7"}
{"task_id": "MBPP/361", "entry_point": "remove_empty", "completion": "def remove_empty(lst):\n    return [item for item in lst if item != []]\n\n# Test the function with the provided assertion\nassert remove_empty([[], [], [], 'Red', 'Green', [1, 2], 'Blue', [], []]) == ['Red', 'Green', [1, 2], 'Blue']"}
{"task_id": "MBPP/342", "entry_point": "find_minimum_range", "completion": "import heapq\n\ndef find_minimum_range(arrays):\n    # Create a min-heap\n    min_heap = []\n    current_max = float('-inf')\n    \n    # Initialize the heap with the first element of each array\n    for i in range(len(arrays)):\n        heapq.heappush(min_heap, (arrays[i][0], i, 0))  # (value, array_index, element_index)\n        current_max = max(current_max, arrays[i][0])\n    \n    min_range = float('inf')\n    range_start, range_end = -1, -1\n    \n    while True:\n        current_min, array_index, element_index = heapq.heappop(min_heap)\n        \n        # Update the range if the current range is smaller\n        if current_max - current_min < min_range:\n            min_range = current_max - current_min\n            range_start, range_end = current_min, current_max\n        \n        # If we have reached the end of one of the arrays, break\n        if element_index + 1 == len(arrays[array_index]):\n            break\n        \n        # Push the next element from the same array into the heap\n        next_value = arrays[array_index][element_index + 1]\n        heapq.heappush(min_heap, (next_value, array_index, element_index + 1))\n        current_max = max(current_max, next_value)\n    \n    return (range_start, range_end)\n\n# Test the function with the provided assertion\nassert find_minimum_range([[3, 6, 8, 10, 15], [1, 5, 12], [4, 8, 15, 16], [2, 6]]) == (4, 6)"}
{"task_id": "MBPP/365", "entry_point": "count_Digit", "completion": "def count_Digit(number):\n    # Convert the number to a string and count the length\n    return len(str(abs(number)))\n\n# Test the function with the provided assertion\nassert count_Digit(12345) == 5"}
{"task_id": "MBPP/362", "entry_point": "max_occurrences", "completion": "def max_occurrences(lst):\n    from collections import Counter\n    \n    # Count the occurrences of each item in the list\n    count = Counter(lst)\n    \n    # Find the item with the maximum occurrences\n    max_item = max(count, key=count.get)\n    \n    return max_item\n\n# Test the function with the provided assertion\nassert max_occurrences([1, 2, 3, 1, 2, 3, 12, 4, 2]) == 2"}
{"task_id": "MBPP/363", "entry_point": "add_K_element", "completion": "def add_K_element(tuples_list, k):\n    return [tuple(x + k for x in t) for t in tuples_list]\n\n# Test the function with the provided assertion\nassert add_K_element([(1, 3, 4), (2, 4, 6), (3, 8, 1)], 4) == [(5, 7, 8), (6, 8, 10), (7, 12, 5)]"}
{"task_id": "MBPP/366", "entry_point": "adjacent_num_product", "completion": "def adjacent_num_product(nums):\n    if len(nums) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    \n    max_product = float('-inf')\n    \n    for i in range(len(nums) - 1):\n        product = nums[i] * nums[i + 1]\n        if product > max_product:\n            max_product = product\n            \n    return max_product\n\n# Test the function with the provided assertion\nassert adjacent_num_product([1, 2, 3, 4, 5, 6]) == 30"}
{"task_id": "MBPP/359", "entry_point": "Check_Solution", "completion": "import math\n\ndef Check_Solution(a, b, c):\n    # Calculate the discriminant\n    discriminant = b**2 - 4*a*c\n    \n    # If the discriminant is negative, there are no real roots\n    if discriminant < 0:\n        return \"No\"\n    \n    # Calculate the two roots\n    root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n    \n    # Check if one root is twice the other\n    if root1 == 2 * root2 or root2 == 2 * root1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Example assertion\nassert Check_Solution(1, 3, 2) == \"Yes\""}
{"task_id": "MBPP/348", "entry_point": "find_ways", "completion": "def find_ways(n):\n    # Base case: if n is 0, there's one way to have an empty sequence\n    if n == 0:\n        return 1\n    \n    # Initialize a list to store the number of ways to form sequences of each length\n    dp = [0] * (n + 1)\n    dp[0] = 1  # There's one way to have a sequence of length 0 (the empty sequence)\n    \n    # Iterate through lengths from 1 to n\n    for length in range(1, n + 1):\n        # For each length, we can add a value of 1 or -1\n        # We need to ensure that the prefix sum remains non-negative\n        for value in [1, -1]:\n            if length - 1 >= 0 and (value == 1 or dp[length - 1] > 0):\n                dp[length] += dp[length - 1]\n    \n    return dp[n]\n\n# Test the function with the provided assertion\nassert find_ways(4) == 2"}
{"task_id": "MBPP/369", "entry_point": "lateralsurface_cuboid", "completion": "def lateralsurface_cuboid(length, width, height):\n    return 2 * height * (length + width)\n\n# Test the function with the provided assertion\nassert lateralsurface_cuboid(8, 5, 6) == 156"}
{"task_id": "MBPP/368", "entry_point": "repeat_tuples", "completion": "def repeat_tuples(tup, n):\n    return (tup,) * n\n\n# Test the function with the provided assertion\nassert repeat_tuples((1, 3), 4) == ((1, 3), (1, 3), (1, 3), (1, 3))"}
{"task_id": "MBPP/373", "entry_point": "volume_cuboid", "completion": "def volume_cuboid(length, width, height):\n    \"\"\"Calculate the volume of a cuboid.\"\"\"\n    return length * width * height\n\n# Test the function with the provided assertion\nassert volume_cuboid(1, 2, 3) == 6"}
{"task_id": "MBPP/375", "entry_point": "round_num", "completion": "def round_num(number, multiple):\n    return round(number / multiple) * multiple\n\n# Test the function with the provided assertion\nassert round_num(4722, 10) == 4720"}
{"task_id": "MBPP/367", "entry_point": "is_tree_balanced", "completion": "class TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef is_tree_balanced(root):\n    def check_balance(node):\n        if not node:\n            return 0  # Height of an empty tree is 0\n        \n        left_height = check_balance(node.left)\n        if left_height == -1:  # Left subtree is not balanced\n            return -1\n        \n        right_height = check_balance(node.right)\n        if right_height == -1:  # Right subtree is not balanced\n            return -1\n        \n        # Check if the current node is balanced\n        if abs(left_height - right_height) > 1:\n            return -1  # Not balanced\n        \n        return max(left_height, right_height) + 1  # Return the height of the tree\n\n    return check_balance(root) != -1  # If the return value is -1, the tree is not balanced\n\n# Example usage:\n# Creating a sample unbalanced tree\n#       1\n#      /\n#     2\n#    /\n#   3\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.left.left = TreeNode(3)\n\n# Assert that the tree is not balanced\nassert is_tree_balanced(root) == False"}
{"task_id": "MBPP/377", "entry_point": "remove_Char", "completion": "def remove_Char(s, char):\n    return s.replace(char, '')\n\n# Test the function with the provided assertion\nassert remove_Char(\"aba\", 'a') == \"b\""}
{"task_id": "MBPP/364", "entry_point": "min_flip_to_make_string_alternate", "completion": "def min_flip_to_make_string_alternate(s: str) -> int:\n    # Patterns for alternate characters\n    pattern1 = ''.join('01'[(i % 2)] for i in range(len(s)))  # Starts with '0'\n    pattern2 = ''.join('10'[(i % 2)] for i in range(len(s)))  # Starts with '1'\n    \n    # Count mismatches for both patterns\n    count1 = sum(1 for i in range(len(s)) if s[i] != pattern1[i])\n    count2 = sum(1 for i in range(len(s)) if s[i] != pattern2[i])\n    \n    # Return the minimum of the two counts\n    return min(count1, count2)\n\n# Test the function with the provided assertion\nassert min_flip_to_make_string_alternate(\"0001010111\") == 2"}
{"task_id": "MBPP/374", "entry_point": "permute_string", "completion": "from itertools import permutations\n\ndef permute_string(s):\n    # Generate all permutations using itertools.permutations\n    perm = permutations(s)\n    # Convert the permutations from tuples to strings and return as a list\n    return [''.join(p) for p in perm]\n\n# Test the function with the provided assertion\nassert permute_string('ab') == ['ab', 'ba']"}
{"task_id": "MBPP/372", "entry_point": "heap_assending", "completion": "import heapq\n\ndef heap_assending(elements):\n    # Create a heap from the elements\n    heapq.heapify(elements)\n    # Extract elements from the heap in sorted order\n    sorted_elements = [heapq.heappop(elements) for _ in range(len(elements))]\n    return sorted_elements\n\n# Test the function with the provided assertion\nassert heap_assending([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1]) == [1, 2, 3, 4, 7, 8, 9, 9, 10, 14, 18]"}
{"task_id": "MBPP/370", "entry_point": "float_sort", "completion": "def float_sort(tuples):\n    return sorted(tuples, key=lambda x: float(x[1]), reverse=True)\n\n# Test the function with the provided assertion\nassert float_sort([('item1', '12.20'), ('item2', '15.10'), ('item3', '24.5')]) == [('item3', '24.5'), ('item2', '15.10'), ('item1', '12.20')]"}
{"task_id": "MBPP/378", "entry_point": "move_first", "completion": "def move_first(lst):\n    if lst:  # Check if the list is not empty\n        return [lst[-1]] + lst[:-1]  # Move last element to the front\n    return lst  # Return the original list if it's empty\n\n# Test the function with the provided assertion\nassert move_first([1, 2, 3, 4]) == [4, 1, 2, 3]"}
{"task_id": "MBPP/379", "entry_point": "surfacearea_cuboid", "completion": "def surfacearea_cuboid(length, width, height):\n    # Surface area formula for a cuboid: 2 * (length * width + width * height + height * length)\n    return 2 * (length * width + width * height + height * length)\n\n# Test the function with the provided assertion\nassert surfacearea_cuboid(1, 2, 3) == 22"}
{"task_id": "MBPP/380", "entry_point": "multi_list", "completion": "def multi_list(rows, cols):\n    return [[j * i for j in range(cols)] for i in range(rows)]\n\n# Test the function with the provided assertion\nassert multi_list(3, 4) == [[0, 0, 0, 0], [0, 1, 2, 3], [0, 2, 4, 6]]"}
{"task_id": "MBPP/371", "entry_point": "smallest_missing", "completion": "def smallest_missing(arr, left, right):\n    # If the array is empty, the smallest missing element is 0\n    if not arr:\n        return 0\n    \n    # If the last element is equal to its index, the smallest missing element is after the last index\n    if arr[right] == right:\n        return right + 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # Check if the mid index matches the value at mid\n        if arr[mid] == mid:\n            # If it matches, search in the right half\n            left = mid + 1\n        else:\n            # If it doesn't match, search in the left half\n            right = mid - 1\n            \n    # The smallest missing element is the left index\n    return left\n\n# Test the function with the provided assertion\nassert smallest_missing([0, 1, 2, 3, 4, 5, 6], 0, 6) == 7"}
{"task_id": "MBPP/376", "entry_point": "remove_replica", "completion": "def remove_replica(input_tuple, custom_value='MSP'):\n    # Create a dictionary to count occurrences of each element\n    count_dict = {}\n    \n    # Count occurrences of each element in the tuple\n    for item in input_tuple:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    \n    # Create a new tuple with duplicates replaced by the custom value\n    result = tuple(custom_value if count_dict[item] > 1 else item for item in input_tuple)\n    \n    return result\n\n# Test the function with the provided assertion\nassert remove_replica((1, 1, 4, 4, 4, 5, 5, 6, 7, 7)) == (1, 'MSP', 4, 'MSP', 'MSP', 5, 'MSP', 6, 7, 'MSP')"}
{"task_id": "MBPP/381", "entry_point": "index_on_inner_list", "completion": "def index_on_inner_list(data, index):\n    return sorted(data, key=lambda x: x[index])\n\n# Test the function with the provided assertion\nassert index_on_inner_list([('Greyson Fulton', 98, 99), \n                             ('Brady Kent', 97, 96), \n                             ('Wyatt Knott', 91, 94), \n                             ('Beau Turnbull', 94, 98)], 0) == [\n    ('Beau Turnbull', 94, 98), \n    ('Brady Kent', 97, 96), \n    ('Greyson Fulton', 98, 99), \n    ('Wyatt Knott', 91, 94)\n]"}
{"task_id": "MBPP/384", "entry_point": "frequency_Of_Smallest", "completion": "def frequency_of_smallest(n, arr):\n    if not arr:\n        return 0  # Return 0 if the array is empty\n    \n    smallest_value = min(arr)  # Find the smallest value in the array\n    frequency = arr.count(smallest_value)  # Count the frequency of the smallest value\n    \n    return frequency\n\n# Test the function with the provided assertion\nassert frequency_of_smallest(5, [1, 2, 3, 4, 3]) == 1"}
{"task_id": "MBPP/383", "entry_point": "even_bit_toggle_number", "completion": "def even_bit_toggle_number(n):\n    # Create a mask with 1s at all odd bit positions\n    # For a 32-bit integer, the mask would be 0xAAAAAAAA (binary: 10101010...)\n    mask = 0xAAAAAAAA\n    # Toggle the odd bits using XOR\n    return n ^ mask\n\n# Test the function with the provided assertion\nassert even_bit_toggle_number(10) == 15\n\n# You can also print the result to verify\nprint(even_bit_toggle_number(10))  # Output should be 15"}
{"task_id": "MBPP/385", "entry_point": "get_perrin", "completion": "def get_perrin(n):\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n - 2) + get_perrin(n - 3)\n\n# Test the function with the provided assertion\nassert get_perrin(9) == 12"}
{"task_id": "MBPP/387", "entry_point": "even_or_odd", "completion": "def even_or_odd(hex_number):\n    # Get the last character of the hexadecimal number\n    last_char = hex_number[-1].upper()  # Convert to uppercase for consistency\n    \n    # Check if the last character represents an even number\n    if last_char in '02468ACE':\n        return \"Even\"\n    else:\n        return \"Odd\"\n\n# Test the function with the provided assertion\nassert even_or_odd(\"AB3454D\") == \"Odd\""}
{"task_id": "MBPP/382", "entry_point": "find_rotation_count", "completion": "def find_rotation_count(arr):\n    left, right = 0, len(arr) - 1\n    \n    # Handle cases where the array is not rotated at all\n    if arr[left] < arr[right]:\n        return 0\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # Check if mid is the minimum element\n        if arr[mid] > arr[mid + 1]:\n            return mid + 1\n        if arr[mid] < arr[mid - 1]:\n            return mid\n        \n        # Decide which half to continue searching\n        if arr[mid] >= arr[left]:\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    return 0  # This line should never be reached if the input is valid\n\n# Test the function with the provided assertion\nassert find_rotation_count([8, 9, 10, 1, 2, 3, 4, 5, 6, 7]) == 3"}
{"task_id": "MBPP/386", "entry_point": "swap_count", "completion": "def swap_count(s: str) -> int:\n    opening = 0  # Count of unmatched opening brackets\n    closing = 0  # Count of unmatched closing brackets\n\n    for char in s:\n        if char == '[':\n            opening += 1\n        elif char == ']':\n            if opening > 0:\n                opening -= 1  # Match with an opening bracket\n            else:\n                closing += 1  # Unmatched closing bracket\n\n    # The number of swaps needed is half the total unmatched brackets\n    return (opening + closing) // 2\n\n# Test the function with the provided assertion\nassert swap_count(\"[]][][\") == 2"}
{"task_id": "MBPP/390", "entry_point": "add_string", "completion": "def add_string(lst, string):\n    return [string.format(item) for item in lst]\n\n# Test the function with the provided assertion\nassert add_string([1, 2, 3, 4], 'temp{0}') == ['temp1', 'temp2', 'temp3', 'temp4']"}
{"task_id": "MBPP/394", "entry_point": "check_distinct", "completion": "def check_distinct(tup):\n    # Convert the tuple to a set to remove duplicates\n    return len(tup) == len(set(tup))\n\n# Test the function with the provided assertion\nassert check_distinct((1, 4, 5, 6, 1, 4)) == False"}
{"task_id": "MBPP/393", "entry_point": "max_length_list", "completion": "def max_length_list(lists):\n    # Use max with a lambda function to find the list with the maximum length\n    max_list = max(lists, key=lambda x: len(x))\n    return (len(max_list), max_list)\n\n# Test the function with the provided assertion\nassert max_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])"}
{"task_id": "MBPP/388", "entry_point": "highest_Power_of_2", "completion": "def highest_Power_of_2(n):\n    if n < 1:\n        return 0  # Return 0 for non-positive integers\n    power = 1\n    while power <= n:\n        power *= 2\n    return power // 2\n\n# Test the function with the provided assertion\nassert highest_Power_of_2(10) == 8"}
{"task_id": "MBPP/397", "entry_point": "median_numbers", "completion": "def median_numbers(a, b, c):\n    # Create a list of the numbers\n    numbers = [a, b, c]\n    # Sort the list\n    numbers.sort()\n    # The median is the middle number in the sorted list\n    return numbers[1]\n\n# Test the function with the provided assertion\nassert median_numbers(25, 55, 65) == 55.0"}
{"task_id": "MBPP/389", "entry_point": "find_lucas", "completion": "def find_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n\n# Test the function\nassert find_lucas(9) == 76"}
{"task_id": "MBPP/395", "entry_point": "first_non_repeating_character", "completion": "def first_non_repeating_character(s):\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character that has a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    return None\n\n# Test case\nassert first_non_repeating_character(\"abcabc\") == None"}
{"task_id": "MBPP/396", "entry_point": "check_char", "completion": "import re\n\ndef check_char(s):\n    # Use regex to check if the first and last character are the same\n    if re.match(r'^(?P<first>.)(?P=first).*?(?P=first)$', s):\n        return \"Valid\"\n    else:\n        return \"Invalid\"\n\n# Test the function\nassert check_char(\"abba\") == \"Valid\""}
{"task_id": "MBPP/392", "entry_point": "get_max_sum", "completion": "def get_max_sum(n):\n    # Base case: if n is 0, the maximum sum is 0\n    if n == 0:\n        return 0\n    \n    # Recursive case: calculate the maximum sum using the given equation\n    max_sum = max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)\n    \n    return max_sum\n\n# Test the function with the provided assertion\nassert get_max_sum(60) == 106\n\n# You can also add more test cases to verify the function\nprint(get_max_sum(60))  # Output: 106\nprint(get_max_sum(10))   # Example output\nprint(get_max_sum(100))  # Example output"}
{"task_id": "MBPP/391", "entry_point": "convert_list_dictionary", "completion": "def convert_list_dictionary(ids, names, scores):\n    # Check if all lists are of the same length\n    if not (len(ids) == len(names) == len(scores)):\n        raise ValueError(\"All input lists must have the same length.\")\n    \n    # Create a list of dictionaries\n    result = []\n    for id_, name, score in zip(ids, names, scores):\n        result.append({id_: {name: score}})\n    \n    return result\n\n# Test the function with the provided assertion\nassert convert_list_dictionary(\n    [\"S001\", \"S002\", \"S003\", \"S004\"],\n    [\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"],\n    [85, 98, 89, 92]\n) == [\n    {'S001': {'Adina Park': 85}},\n    {'S002': {'Leyton Marsh': 98}},\n    {'S003': {'Duncan Boyle': 89}},\n    {'S004': {'Saim Richards': 92}}\n]"}
{"task_id": "MBPP/404", "entry_point": "minimum", "completion": "def minimum(a, b):\n    \"\"\"Return the minimum of two numbers.\"\"\"\n    return a if a < b else b\n\n# Test the function\nassert minimum(1, 2) == 1"}
{"task_id": "MBPP/399", "entry_point": "bitwise_xor", "completion": "def bitwise_xor(tuple1, tuple2):\n    # Use a generator expression to apply the XOR operation on corresponding elements\n    return tuple(a ^ b for a, b in zip(tuple1, tuple2))\n\n# Test the function with the provided assertion\nassert bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)\n\n# You can also print the result to verify\nprint(bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)))  # Output: (15, 6, 5, 10)"}
{"task_id": "MBPP/398", "entry_point": "sum_of_digits", "completion": "def sum_of_digits(numbers):\n    total_sum = 0\n    for number in numbers:\n        total_sum += sum(int(digit) for digit in str(number))\n    return total_sum\n\n# Test the function with the provided assertion\nassert sum_of_digits([10, 2, 56]) == 14"}
{"task_id": "MBPP/405", "entry_point": "check_tuplex", "completion": "def check_tuplex(tup, element):\n    return element in tup\n\n# Test the function with the provided assertion\nassert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 'r') == True"}
{"task_id": "MBPP/406", "entry_point": "find_Parity", "completion": "def find_Parity(number):\n    if number % 2 == 0:\n        return \"Even Parity\"\n    else:\n        return \"Odd Parity\"\n\n# Test the function with the provided assertion\nassert find_Parity(12) == \"Even Parity\""}
{"task_id": "MBPP/400", "entry_point": "extract_freq", "completion": "def extract_freq(tuples_list):\n    # Create a set to store unique tuples\n    unique_tuples = set()\n    \n    # Iterate through the list of tuples\n    for tup in tuples_list:\n        # Normalize the tuple by sorting its elements\n        normalized_tup = tuple(sorted(tup))\n        # Add the normalized tuple to the set\n        unique_tuples.add(normalized_tup)\n    \n    # Return the number of unique tuples\n    return len(unique_tuples)\n\n# Test the function with the provided assertion\nassert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)]) == 3"}
{"task_id": "MBPP/401", "entry_point": "add_nested_tuples", "completion": "def add_nested_tuples(tuple1, tuple2):\n    # Use a generator expression to add corresponding elements of the nested tuples\n    return tuple(tuple(a + b for a, b in zip(inner1, inner2)) for inner1, inner2 in zip(tuple1, tuple2))\n\n# Test the function with the provided assertion\nassert add_nested_tuples(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((7, 10), (7, 14), (3, 10), (8, 13))\n\nprint(\"Function works correctly!\")"}
{"task_id": "MBPP/403", "entry_point": "is_valid_URL", "completion": "import re\n\ndef is_valid_URL(url):\n    # Regular expression for validating a URL\n    regex = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|'  # IPv4\n        r'\\[?[A-F0-9]*:[A-F0-9:]+\\]?)'  # IPv6\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)  # optional path\n\n    return re.match(regex, url) is not None\n\n# Test the function\nassert is_valid_URL(\"https://www.google.com\") == True"}
{"task_id": "MBPP/412", "entry_point": "remove_odd", "completion": "def remove_odd(numbers):\n    return [num for num in numbers if num % 2 == 0]\n\n# Test the function with the provided assertion\nassert remove_odd([1, 2, 3]) == [2]"}
{"task_id": "MBPP/407", "entry_point": "rearrange_bigger", "completion": "def rearrange_bigger(n):\n    # Convert the number to a list of its digits\n    digits = list(str(n))\n    \n    # Step 1: Find the first decreasing element from the right\n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    \n    # If no such element is found, return the original number\n    if i == -1:\n        return n\n    \n    # Step 2: Find the element just larger than digits[i] to the right of it\n    j = len(digits) - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    \n    # Step 3: Swap the found elements\n    digits[i], digits[j] = digits[j], digits[i]\n    \n    # Step 4: Reverse the sequence after the position i\n    digits = digits[:i + 1] + digits[i + 1:][::-1]\n    \n    # Convert the list of digits back to an integer\n    return int(''.join(digits))\n\n# Test the function with the provided assertion\nassert rearrange_bigger(12) == 21"}
{"task_id": "MBPP/411", "entry_point": "snake_to_camel", "completion": "import re\n\ndef snake_to_camel(snake_str):\n    # Use regex to find all occurrences of words separated by underscores\n    components = re.split(r'_', snake_str)\n    # Capitalize the first letter of each component and join them\n    return ''.join(x.capitalize() for x in components)\n\n# Test the function\nassert snake_to_camel('android_tv') == 'AndroidTv'"}
{"task_id": "MBPP/409", "entry_point": "min_product_tuple", "completion": "def min_product_tuple(tuples_list):\n    # Initialize the minimum product to a large number\n    min_product = float('inf')\n    \n    # Iterate through each tuple in the list\n    for a, b in tuples_list:\n        # Calculate the product of the current tuple\n        product = a * b\n        # Update the minimum product if the current product is smaller\n        if product < min_product:\n            min_product = product\n            \n    return min_product\n\n# Test the function with the provided assertion\nassert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 8"}
{"task_id": "MBPP/410", "entry_point": "min_val", "completion": "def min_val(heterogeneous_list):\n    # Filter out non-numeric values\n    numeric_values = [item for item in heterogeneous_list if isinstance(item, (int, float))]\n    \n    # Return the minimum value if there are numeric values, otherwise return None\n    return min(numeric_values) if numeric_values else None\n\n# Test the function with the provided assertion\nassert min_val(['Python', 3, 2, 4, 5, 'version']) == 2"}
{"task_id": "MBPP/413", "entry_point": "extract_nth_element", "completion": "def extract_nth_element(tuples_list, n):\n    return [t[n] for t in tuples_list]\n\n# Test the function with the provided assertion\nassert extract_nth_element([('Greyson Fulton', 98, 99), \n                             ('Brady Kent', 97, 96), \n                             ('Wyatt Knott', 91, 94), \n                             ('Beau Turnbull', 94, 98)], 0) == ['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']"}
{"task_id": "MBPP/402", "entry_point": "ncr_modp", "completion": "def factorial_mod(n, p):\n    \"\"\"Compute factorial % p for all numbers from 0 to n.\"\"\"\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = (fact[i - 1] * i) % p\n    return fact\n\ndef ncr_modp(n, r, p):\n    \"\"\"Compute nCr % p.\"\"\"\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    \n    # Precompute all factorials % p\n    fact = factorial_mod(n, p)\n    \n    # Compute nCr % p using the formula\n    numerator = fact[n]\n    denominator = (fact[r] * fact[n - r]) % p\n    \n    # Compute the modular inverse of the denominator\n    denominator_inv = pow(denominator, p - 2, p)\n    \n    # Return the result\n    return (numerator * denominator_inv) % p\n\n# Test the function with the provided assertion\nassert ncr_modp(10, 2, 13) == 6"}
{"task_id": "MBPP/418", "entry_point": "Find_Max", "completion": "def Find_Max(lists):\n    if not lists:\n        return []\n    # Use max with key to find the longest sublist\n    return max(lists, key=len)\n\n# Test the function with the provided assertion\nassert Find_Max([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']"}
{"task_id": "MBPP/415", "entry_point": "max_Product", "completion": "def max_Product(arr):\n    if len(arr) < 2:\n        return None  # Not enough elements to form a pair\n\n    # Initialize the two largest numbers\n    first = second = float('-inf')\n\n    for number in arr:\n        # Update the largest and second largest numbers\n        if number > first:\n            second = first\n            first = number\n        elif number > second:\n            second = number\n\n    return (second, first)\n\n# Test the function with the provided assertion\nassert max_Product([1, 2, 3, 4, 7, 0, 8, 4]) == (7, 8)"}
{"task_id": "MBPP/420", "entry_point": "cube_Sum", "completion": "def cube_Sum(n):\n    # Calculate the sum of cubes of the first n even natural numbers\n    return sum((2 * i) ** 3 for i in range(1, n + 1))\n\n# Test the function with the provided assertion\nassert cube_Sum(2) == 72"}
{"task_id": "MBPP/414", "entry_point": "overlapping", "completion": "def overlapping(seq1, seq2):\n    # Check if there is any common element in both sequences\n    return any(item in seq2 for item in seq1)\n\n# Test the function with the provided assertion\nassert overlapping([1, 2, 3, 4, 5], [6, 7, 8, 9]) == False"}
{"task_id": "MBPP/421", "entry_point": "concatenate_tuple", "completion": "def concatenate_tuple(tup, delimiter='-'):\n    # Convert all elements to string and join them with the delimiter\n    return delimiter.join(map(str, tup))\n\n# Test the function with the provided assertion\nassert concatenate_tuple((\"ID\", \"is\", 4, \"UTS\")) == 'ID-is-4-UTS'"}
{"task_id": "MBPP/408", "entry_point": "k_smallest_pairs", "completion": "import heapq\n\ndef k_smallest_pairs(nums1, nums2, k):\n    # Create a min-heap\n    min_heap = []\n    \n    # Initialize the heap with the first element from nums1 paired with all elements from nums2\n    for i in range(min(k, len(nums1))):  # We only need the first k elements from nums1\n        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))  # (sum, index in nums1, index in nums2)\n    \n    result = []\n    \n    while k > 0 and min_heap:\n        # Get the smallest pair\n        sum_val, i, j = heapq.heappop(min_heap)\n        result.append([nums1[i], nums2[j]])\n        \n        # If there is a next element in nums2, add the new pair to the heap\n        if j + 1 < len(nums2):\n            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))\n        \n        k -= 1\n    \n    return result\n\n# Example usage\nassert k_smallest_pairs([1, 3, 7], [2, 4, 6], 2) == [[1, 2], [1, 4]]"}
{"task_id": "MBPP/424", "entry_point": "extract_rear", "completion": "def extract_rear(strings):\n    return [s[-1] for s in strings]\n\n# Test the function with the provided assertion\nassert extract_rear(('Mers', 'for', 'Vers')) == ['s', 'r', 's']"}
{"task_id": "MBPP/419", "entry_point": "round_and_sum", "completion": "def round_and_sum(numbers):\n    # Round each number in the list\n    rounded_numbers = [round(num) for num in numbers]\n    # Calculate the total sum of the rounded numbers\n    total_sum = sum(rounded_numbers)\n    # Multiply the total sum by the length of the list\n    result = total_sum * len(numbers)\n    return result\n\n# Test the function with the provided assertion\nassert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50]) == 243"}
{"task_id": "MBPP/416", "entry_point": "breakSum", "completion": "def breakSum(n):\n    # Base case: if n is less than or equal to 1, return n\n    if n <= 1:\n        return n\n    \n    max_sum = 0\n    \n    # Try breaking the number into three parts\n    for i in range(1, n):\n        for j in range(1, n - i + 1):\n            k = n - i - j\n            if k >= 0:\n                # Calculate the sum of the three parts\n                current_sum = breakSum(i) + breakSum(j) + breakSum(k)\n                # Update max_sum if current_sum is greater\n                max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\n# Test the function with the provided assertion\nassert breakSum(12) == 13"}
{"task_id": "MBPP/417", "entry_point": "group_tuples", "completion": "def group_tuples(tuples_list):\n    from collections import defaultdict\n\n    # Create a dictionary to hold lists of second elements grouped by the first element\n    grouped = defaultdict(list)\n\n    # Iterate through the list of tuples\n    for first, second in tuples_list:\n        grouped[first].append(second)\n\n    # Create the result list\n    result = []\n    for first, seconds in grouped.items():\n        # Create a tuple with the first element and the corresponding second elements\n        result.append((first, *seconds))\n\n    return result\n\n# Test the function with the provided assertion\nassert group_tuples([('x', 'y'), ('x', 'z'), ('w', 't')]) == [('x', 'y', 'z'), ('w', 't')]"}
{"task_id": "MBPP/426", "entry_point": "filter_oddnumbers", "completion": "def filter_oddnumbers(numbers):\n    return list(filter(lambda x: x % 2 != 0, numbers))\n\n# Test the function with the provided assertion\nassert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 3, 5, 7, 9]"}
{"task_id": "MBPP/427", "entry_point": "change_date_format", "completion": "import re\n\ndef change_date_format(date_str):\n    # Use regex to match the date format\n    match = re.match(r'(\\d{4})-(\\d{2})-(\\d{2})', date_str)\n    if match:\n        year, month, day = match.groups()\n        return f'{day}-{month}-{year}'\n    else:\n        raise ValueError(\"Invalid date format. Please use yyyy-mm-dd.\")\n\n# Test the function\nassert change_date_format(\"2026-01-02\") == '02-01-2026'"}
{"task_id": "MBPP/425", "entry_point": "count_element_in_list", "completion": "def count_element_in_list(sublists, element):\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count\n\n# Test the function with the provided assertion\nassert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1) == 3"}
{"task_id": "MBPP/422", "entry_point": "find_Average_Of_Cube", "completion": "def find_Average_Of_Cube(n):\n    if n <= 0:\n        return 0  # Return 0 for non-positive n\n    sum_of_cubes = sum(i**3 for i in range(1, n + 1))\n    average = sum_of_cubes / n\n    return average\n\n# Test the function with the provided assertion\nassert find_Average_Of_Cube(2) == 4.5"}
{"task_id": "MBPP/429", "entry_point": "and_tuples", "completion": "def and_tuples(tuple1, tuple2):\n    # Use a generator expression to create a new tuple with the elementwise minimum\n    return tuple(min(a, b) for a, b in zip(tuple1, tuple2))\n\n# Test the function with the provided assertion\nassert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)"}
{"task_id": "MBPP/435", "entry_point": "last_Digit", "completion": "def last_Digit(number):\n    return abs(number) % 10\n\n# Test the function\nassert last_Digit(123) == 3"}
{"task_id": "MBPP/423", "entry_point": "get_maxgold", "completion": "def get_maxgold(mine, n, m):\n    # Create a table to store the maximum gold that can be collected\n    # from each cell\n    gold_table = [[0 for _ in range(m)] for _ in range(n)]\n    \n    # Initialize the first row of the gold_table with the first row of the mine\n    for j in range(m):\n        gold_table[0][j] = mine[0][j]\n    \n    # Fill the gold_table\n    for i in range(1, n):\n        for j in range(m):\n            # Get the maximum gold from the three possible positions\n            # from where the miner can come to the current cell\n            # (i, j)\n            gold_from_left = gold_table[i-1][j-1] if j > 0 else 0\n            gold_from_up = gold_table[i-1][j]\n            gold_from_right = gold_table[i-1][j+1] if j < m - 1 else 0\n            \n            # Current cell gold + max of the three possible previous cells\n            gold_table[i][j] = mine[i][j] + max(gold_from_left, gold_from_up, gold_from_right)\n    \n    # The maximum gold collected will be the maximum value in the last row\n    max_gold = 0\n    for j in range(m):\n        max_gold = max(max_gold, gold_table[n-1][j])\n    \n    return max_gold\n\n# Test the function with the provided assertion\nassert get_maxgold([[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]], 4, 4) == 16"}
{"task_id": "MBPP/433", "entry_point": "check_greater", "completion": "def check_greater(arr, num):\n    if all(num > element for element in arr):\n        return 'Yes, entered number is greater than all elements in the array'\n    else:\n        return 'No, entered number is less than those in the array'\n\n# Example usage\nassert check_greater([1, 2, 3, 4, 5], 4) == 'No, entered number is less than those in the array'"}
{"task_id": "MBPP/432", "entry_point": "median_trapezium", "completion": "def median_trapezium(a, b, c):\n    # a and b are the lengths of the two parallel sides\n    # c is not used in the median calculation\n    return (a + b) / 2\n\n# Test the function with the provided assertion\nassert median_trapezium(15, 25, 35) == 20"}
{"task_id": "MBPP/431", "entry_point": "common_element", "completion": "def common_element(list1, list2):\n    # Convert the first list to a set for faster lookup\n    set1 = set(list1)\n    \n    # Check if any element in the second list is in the set of the first list\n    for element in list2:\n        if element in set1:\n            return True\n    return False\n\n# Test the function with the provided assertion\nassert common_element([1, 2, 3, 4, 5], [5, 6, 7, 8, 9]) == True"}
{"task_id": "MBPP/428", "entry_point": "shell_sort", "completion": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a big gap, then reduce the gap\n\n    # Do a gapped insertion sort for this gap size.\n    while gap > 0:\n        for i in range(gap, n):\n            # Save the current element to be compared\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        \n        gap //= 2  # Reduce the gap for the next element\n\n    return arr\n\n# Test the function with the provided assertion\nassert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]"}
{"task_id": "MBPP/430", "entry_point": "parabola_directrix", "completion": "def parabola_directrix(a, h, k):\n    # Calculate p\n    p = 1 / (4 * a)\n    # Calculate the directrix\n    directrix = k - p\n    return directrix\n\n# Test the function with the provided assertion\nassert parabola_directrix(5, 3, 2) == -198"}
{"task_id": "MBPP/437", "entry_point": "remove_odd", "completion": "def remove_odd(s):\n    return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)\n\n# Test the function with the provided assertion\nassert remove_odd(\"python\") == \"yhn\""}
{"task_id": "MBPP/436", "entry_point": "neg_nos", "completion": "def neg_nos(numbers):\n    # Extract negative numbers from the list\n    negative_numbers = [num for num in numbers if num < 0]\n    \n    # Print the negative numbers\n    for num in negative_numbers:\n        print(num)\n    \n    # Return the negative numbers as a tuple\n    return tuple(negative_numbers)\n\n# Example usage\nresult = neg_nos([-1, 4, 5, -6])\nassert result == (-1, -6)"}
{"task_id": "MBPP/434", "entry_point": "text_match_one", "completion": "import re\n\ndef text_match_one(text):\n    # Define the regex pattern for 'a' followed by one or more 'b's\n    pattern = r'a+b+'\n    \n    # Use re.fullmatch to check if the entire string matches the pattern\n    if re.fullmatch(pattern, text):\n        return 'Matched!'\n    else:\n        return 'Not matched!'\n\n# Test the function with the provided assertion\nassert text_match_one(\"ac\") == 'Not matched!'"}
{"task_id": "MBPP/441", "entry_point": "surfacearea_cube", "completion": "def surfacearea_cube(side_length):\n    \"\"\"Calculate the surface area of a cube given the length of its side.\"\"\"\n    return 6 * (side_length ** 2)\n\n# Test the function with the provided assertion\nassert surfacearea_cube(5) == 150"}
{"task_id": "MBPP/443", "entry_point": "largest_neg", "completion": "def largest_neg(numbers):\n    # Filter out the negative numbers from the list\n    negative_numbers = [num for num in numbers if num < 0]\n    \n    # Return the largest negative number or None if there are no negative numbers\n    return max(negative_numbers) if negative_numbers else None\n\n# Test the function with the provided assertion\nassert largest_neg([1, 2, 3, -4, -6]) == -6"}
{"task_id": "MBPP/447", "entry_point": "cube_nums", "completion": "def cube_nums(nums):\n    return list(map(lambda x: x ** 3, nums))\n\n# Test the function with the provided assertion\nassert cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]"}
{"task_id": "MBPP/440", "entry_point": "find_adverb_position", "completion": "import nltk\nfrom nltk import pos_tag\nfrom nltk.tokenize import word_tokenize\n\n# Make sure to download the necessary NLTK resources\nnltk.download('punkt')\nnltk.download('averaged_perceptron_tagger')\n\ndef find_adverb_position(sentence):\n    # Tokenize the sentence into words\n    words = word_tokenize(sentence)\n    # Get the part-of-speech tags for each word\n    tagged_words = pos_tag(words)\n    \n    # List to hold the positions and adverbs\n    adverbs = []\n    \n    # Iterate through the tagged words\n    for index, (word, tag) in enumerate(tagged_words):\n        # Check if the tag indicates an adverb\n        if tag in ('RB', 'RBR', 'RBS'):\n            adverbs.append((index, word))\n    \n    return adverbs\n\n# Example usage\nresult = find_adverb_position(\"clearly!! we can see the sky\")\nprint(result)  # Output should be [(0, 'clearly')]"}
{"task_id": "MBPP/445", "entry_point": "index_multiplication", "completion": "def index_multiplication(tuple1, tuple2):\n    # Use a generator expression to multiply corresponding elements\n    return tuple((a * b for a, b in zip(t1, t2)) for t1, t2 in zip(tuple1, tuple2))\n\n# Test the function with the provided assertion\nassert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 21), (12, 45), (2, 9), (7, 30))"}
{"task_id": "MBPP/442", "entry_point": "positive_count", "completion": "def positive_count(arr):\n    if not arr:  # Check for empty array\n        return 0.0\n    \n    positive_numbers = sum(1 for x in arr if x > 0)  # Count positive numbers\n    total_numbers = len(arr)  # Total numbers in the array\n    \n    return positive_numbers / total_numbers  # Calculate the ratio\n\n# Test the function with the provided assertion\nassert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]) == 0.54"}
{"task_id": "MBPP/439", "entry_point": "multiple_to_single", "completion": "def multiple_to_single(int_list):\n    # Convert each integer to a string and join them together\n    concatenated_string = ''.join(map(str, int_list))\n    # Convert the concatenated string back to an integer\n    return int(concatenated_string)\n\n# Test the function with the provided assertion\nassert multiple_to_single([11, 33, 50]) == 113350"}
{"task_id": "MBPP/450", "entry_point": "extract_string", "completion": "def extract_string(string_list, size):\n    return [s for s in string_list if len(s) == size]\n\n# Test the function with the provided assertion\nassert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'], 8) == ['practice', 'solution']"}
{"task_id": "MBPP/444", "entry_point": "trim_tuple", "completion": "def trim_tuple(tuple_list, k):\n    # Trim each tuple by k\n    trimmed_list = [t[k:] if len(t) > k else () for t in tuple_list]\n    return trimmed_list\n\n# Test the function with the provided assertion\nassert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2) == [(2,), (9,), (2,), (2,)]"}
{"task_id": "MBPP/438", "entry_point": "count_bidirectional", "completion": "def count_bidirectional(tuples_list):\n    # Create a set to store unique pairs\n    seen_pairs = set()\n    count = 0\n    \n    for a, b in tuples_list:\n        # Create a bidirectional pair\n        pair = (a, b)\n        reverse_pair = (b, a)\n        \n        # Check if the reverse pair is already in the set\n        if reverse_pair in seen_pairs:\n            count += 1\n        \n        # Add the current pair to the set\n        seen_pairs.add(pair)\n    \n    return str(count)\n\n# Test the function with the provided assertion\nassert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)]) == '3'"}
{"task_id": "MBPP/451", "entry_point": "remove_whitespaces", "completion": "import re\n\ndef remove_whitespaces(input_string):\n    # Use regex to replace all whitespace characters with an empty string\n    return re.sub(r'\\s+', '', input_string)\n\n# Test the function with the provided assertion\nassert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'"}
{"task_id": "MBPP/446", "entry_point": "count_Occurrence", "completion": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count\n\n# Test the function with the provided assertion\nassert count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3"}
{"task_id": "MBPP/453", "entry_point": "sumofFactors", "completion": "def sumofFactors(n):\n    even_sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:  # Check if i is a factor and even\n            even_sum += i\n    return even_sum\n\n# Test the function with the provided assertion\nassert sumofFactors(18) == 26"}
{"task_id": "MBPP/448", "entry_point": "cal_sum", "completion": "def cal_sum(n):\n    if n < 0:\n        return 0\n    elif n == 0:\n        return 3\n    elif n == 1:\n        return 3  # P(0)\n    elif n == 2:\n        return 3 + 0 + 2  # P(0) + P(1) + P(2)\n\n    # Initialize the first three Perrin numbers\n    perrin_numbers = [3, 0, 2]\n    \n    # Calculate Perrin numbers up to P(n)\n    for i in range(3, n + 1):\n        next_perrin = perrin_numbers[i - 2] + perrin_numbers[i - 3]\n        perrin_numbers.append(next_perrin)\n\n    # Return the sum of the first n Perrin numbers\n    return sum(perrin_numbers[:n + 1])\n\n# Test the function with the provided assertion\nassert cal_sum(9) == 49"}
{"task_id": "MBPP/456", "entry_point": "reverse_string_list", "completion": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]\n\n# Test the function with the provided assertion\nassert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black']) == ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']"}
{"task_id": "MBPP/452", "entry_point": "loss_amount", "completion": "def loss_amount(original_amount, current_amount):\n    if current_amount < original_amount:\n        return original_amount - current_amount\n    return None\n\n# Example usage\nassert loss_amount(1500, 1200) == 300\nassert loss_amount(1500, 1500) == None"}
{"task_id": "MBPP/455", "entry_point": "check_monthnumb_number", "completion": "def check_monthnumb_number(month):\n    # List of months with 31 days\n    months_with_31_days = {1, 3, 5, 7, 8, 10, 12}\n    \n    # Check if the month number is in the set of months with 31 days\n    return month in months_with_31_days\n\n# Test the function with the provided assertion\nassert check_monthnumb_number(5) == True"}
{"task_id": "MBPP/454", "entry_point": "text_match_wordz", "completion": "import re\n\ndef text_match_wordz(text):\n    # Use regex to search for a word containing 'z'\n    if re.search(r'\\b\\w*z\\w*\\b', text):\n        return 'Found a match!'\n    else:\n        return 'No match found.'\n\n# Test the function\nassert text_match_wordz(\"pythonz.\") == 'Found a match!'"}
{"task_id": "MBPP/449", "entry_point": "check_Triangle", "completion": "def check_Triangle(x1, y1, x2, y2, x3, y3):\n    # Calculate the area using the determinant method\n    area = 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n    \n    # If the area is greater than zero, the points form a valid triangle\n    if area > 0:\n        return 'Yes'\n    else:\n        return 'No'\n\n# Test the function with the provided assertion\nassert check_Triangle(1, 5, 2, 5, 4, 6) == 'Yes'"}
{"task_id": "MBPP/458", "entry_point": "rectangle_area", "completion": "def rectangle_area(length, width):\n    return length * width\n\n# Test the function with the provided assertion\nassert rectangle_area(10, 20) == 200"}
{"task_id": "MBPP/459", "entry_point": "remove_uppercase", "completion": "import re\n\ndef remove_uppercase(s):\n    # Use regex to replace uppercase substrings with an empty string\n    return re.sub(r'[A-Z]+', '', s)\n\n# Test the function with the provided assertion\nassert remove_uppercase('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'"}
{"task_id": "MBPP/461", "entry_point": "upper_ctr", "completion": "def upper_ctr(s):\n    return sum(1 for char in s if char.isupper())\n\n# Test the function with the provided assertion\nassert upper_ctr('PYthon') == 1"}
{"task_id": "MBPP/460", "entry_point": "Extract", "completion": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]\n\n# Test the function with the provided assertion\nassert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]"}
{"task_id": "MBPP/465", "entry_point": "drop_empty", "completion": "def drop_empty(input_dict):\n    return {key: value for key, value in input_dict.items() if value is not None}\n\n# Test the function with the provided assertion\nassert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3': None}) == {'c1': 'Red', 'c2': 'Green'}"}
{"task_id": "MBPP/464", "entry_point": "check_value", "completion": "def check_value(d, value):\n    # Check if all values in the dictionary are the same as the provided value\n    return all(v == value for v in d.values())\n\n# Example assertion\nassert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12}, 10) == False"}
{"task_id": "MBPP/467", "entry_point": "decimal_to_Octal", "completion": "def decimal_to_octal(decimal_number):\n    # Convert decimal to octal and remove the '0o' prefix\n    return int(oct(decimal_number)[2:])\n\n# Test the function with the provided assertion\nassert decimal_to_octal(10) == 12\n\n# You can also test the function with other values\nprint(decimal_to_octal(8))   # Output: 10\nprint(decimal_to_octal(15))  # Output: 17\nprint(decimal_to_octal(64))  # Output: 100"}
{"task_id": "MBPP/457", "entry_point": "Find_Min", "completion": "def Find_Min(lists):\n    # Check if the input list is empty\n    if not lists:\n        return []\n    \n    # Initialize the minimum length and the corresponding sublist\n    min_length = float('inf')\n    min_sublist = None\n    \n    # Iterate through each sublist\n    for sublist in lists:\n        # Update the minimum length and sublist if a shorter one is found\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n            \n    return min_sublist\n\n# Test the function with the provided assertion\nassert Find_Min([[1], [1, 2], [1, 2, 3]]) == [1]"}
{"task_id": "MBPP/466", "entry_point": "find_peak", "completion": "def find_peak(arr, n):\n    if n == 1:\n        return 0  # The only element is the peak\n    \n    if arr[0] >= arr[1]:\n        return 0  # The first element is a peak\n    \n    if arr[n - 1] >= arr[n - 2]:\n        return n - 1  # The last element is a peak\n    \n    for i in range(1, n - 1):\n        if arr[i] >= arr[i - 1] and arr[i] >= arr[i + 1]:\n            return i  # Found a peak\n    \n    return -1  # This line should never be reached if the input is valid\n\n# Test the function with the provided assertion\nassert find_peak([1, 3, 20, 4, 1, 0], 6) == 2"}
{"task_id": "MBPP/471", "entry_point": "find_remainder", "completion": "def find_remainder(arr, length, n):\n    product = 1\n    for num in arr:\n        product *= num\n        product %= n  # Take the remainder at each step to prevent overflow\n    return product\n\n# Test the function with the provided assertion\nassert find_remainder([100, 10, 5, 25, 35, 14], 6, 11) == 9"}
{"task_id": "MBPP/472", "entry_point": "check_Consecutive", "completion": "def check_Consecutive(nums):\n    if not nums:\n        return False\n    \n    # Sort the list to check for consecutive numbers\n    nums = sorted(set(nums))  # Remove duplicates and sort\n    for i in range(len(nums) - 1):\n        if nums[i] + 1 != nums[i + 1]:\n            return False\n    return True\n\n# Test the function with the provided assertion\nassert check_Consecutive([1, 2, 3, 4, 5]) == True"}
{"task_id": "MBPP/470", "entry_point": "add_pairwise", "completion": "def add_pairwise(tup):\n    # Use a list comprehension to sum pairs of elements\n    return tuple(tup[i] + tup[i + 1] for i in range(len(tup) - 1))\n\n# Test the function with the provided assertion\nassert add_pairwise((1, 5, 7, 8, 10)) == (6, 12, 15, 18)\n\n# You can also print the result to verify\nprint(add_pairwise((1, 5, 7, 8, 10)))  # Output: (6, 12, 15, 18)"}
{"task_id": "MBPP/474", "entry_point": "replace_char", "completion": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)\n\n# Test the function with the provided assertion\nassert replace_char(\"polygon\", 'y', 'l') == \"pollgon\""}
{"task_id": "MBPP/463", "entry_point": "max_subarray_product", "completion": "def max_subarray_product(arr):\n    if not arr:\n        return 0\n\n    max_product = arr[0]\n    min_product = arr[0]\n    result = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            max_product, min_product = min_product, max_product\n        \n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        \n        result = max(result, max_product)\n\n    return result\n\n# Test the function with the provided assertion\nassert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112"}
{"task_id": "MBPP/473", "entry_point": "tuple_intersection", "completion": "def tuple_intersection(tuple_list1, tuple_list2):\n    # Convert both lists of tuples to sets for easier intersection\n    set1 = set(tuple_list1)\n    set2 = set(tuple_list2)\n    \n    # Find the intersection of both sets\n    intersection = set1.intersection(set2)\n    \n    return intersection\n\n# Test the function with the provided assertion\nassert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)], [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}"}
{"task_id": "MBPP/477", "entry_point": "is_lower", "completion": "def is_lower(input_string):\n    return input_string.lower()\n\n# Test the function\nassert is_lower(\"InValid\") == \"invalid\""}
{"task_id": "MBPP/476", "entry_point": "big_sum", "completion": "def big_sum(arr):\n    if not arr:  # Check if the array is empty\n        return 0\n    largest = max(arr)\n    smallest = min(arr)\n    return largest + smallest\n\n# Test the function with the provided assertion\nassert big_sum([1, 2, 3]) == 4"}
{"task_id": "MBPP/475", "entry_point": "sort_counter", "completion": "def sort_counter(counter):\n    # Sort the counter by value in descending order and return as a list of tuples\n    return sorted(counter.items(), key=lambda item: item[1], reverse=True)\n\n# Test the function with the provided assertion\nassert sort_counter({'Math': 81, 'Physics': 83, 'Chemistry': 87}) == [('Chemistry', 87), ('Physics', 83), ('Math', 81)]"}
{"task_id": "MBPP/468", "entry_point": "max_product", "completion": "def max_product(arr, n):\n    if n == 0:\n        return 0\n    \n    # Initialize the max_product array\n    max_prod = [0] * n\n    \n    # Each element is a subsequence of length 1\n    for i in range(n):\n        max_prod[i] = arr[i]\n    \n    # Compute the maximum product for increasing subsequences\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:  # Check if it's an increasing subsequence\n                max_prod[i] = max(max_prod[i], max_prod[j] * arr[i])\n    \n    # The result is the maximum value in max_prod\n    return max(max_prod)\n\n# Test the function with the provided assertion\nassert max_product([3, 100, 4, 5, 150, 6], 6) == 45000"}
{"task_id": "MBPP/478", "entry_point": "remove_lowercase", "completion": "def remove_lowercase(s):\n    # Use a list comprehension to filter out lowercase characters\n    result = ''.join([char for char in s if not char.islower()])\n    return result\n\n# Test the function with the provided assertion\nassert remove_lowercase(\"PYTHon\") == 'PYTH'"}
{"task_id": "MBPP/469", "entry_point": "max_profit", "completion": "def max_profit(prices, k):\n    if not prices or k == 0:\n        return 0\n    \n    n = len(prices)\n    \n    # If k is greater than half the number of days, we can make as many transactions as we want\n    if k >= n // 2:\n        return sum(max(prices[i + 1] - prices[i], 0) for i in range(n - 1))\n    \n    # Create a DP table\n    dp = [[0] * n for _ in range(k + 1)]\n    \n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n    \n    return dp[k][n - 1]\n\n# Test the function with the provided assertion\nassert max_profit([1, 5, 2, 3, 7, 6, 4, 5], 3) == 10"}
{"task_id": "MBPP/480", "entry_point": "get_max_occuring_char", "completion": "def get_max_occuring_char(s):\n    # Create a dictionary to count occurrences of each character\n    char_count = {}\n    \n    # Count each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n            \n    # Find the character with the maximum count\n    max_char = ''\n    max_count = 0\n    for char, count in char_count.items():\n        if count > max_count:\n            max_count = count\n            max_char = char\n            \n    return max_char\n\n# Test the function with the provided assertion\nassert get_max_occuring_char(\"data\") == \"a\""}
{"task_id": "MBPP/482", "entry_point": "match", "completion": "import re\n\ndef match(s):\n    # Define the regex pattern for one uppercase letter followed by lowercase letters\n    pattern = r'^[A-Z][a-z]*$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, s):\n        return 'Yes'\n    else:\n        return 'No'\n\n# Test the function with the provided assertion\nassert match(\"Geeks\") == 'Yes'"}
{"task_id": "MBPP/485", "entry_point": "largest_palindrome", "completion": "def is_palindrome(num):\n    \"\"\"Check if a number is a palindrome.\"\"\"\n    return str(num) == str(num)[::-1]\n\ndef largest_palindrome(arr, n):\n    \"\"\"Find the largest palindromic number in the given array.\"\"\"\n    palindromes = [num for num in arr if is_palindrome(num)]\n    return max(palindromes) if palindromes else None\n\n# Test the function with the provided assertion\nassert largest_palindrome([1, 232, 54545, 999991], 4) == 54545"}
{"task_id": "MBPP/484", "entry_point": "remove_matching_tuple", "completion": "def remove_matching_tuple(tuple1, tuple2):\n    # Convert the second tuple to a set for faster lookup\n    set_tuple2 = set(tuple2)\n    # Use a list comprehension to filter out matching tuples\n    return [item for item in tuple1 if item not in set_tuple2]\n\n# Test the function with the provided assertion\nassert remove_matching_tuple([('Hello', 'dude'), ('How', 'are'), ('you', '?')], [('Hello', 'dude'), ('How', 'are')]) == [('you', '?')]"}
{"task_id": "MBPP/462", "entry_point": "combinations_list", "completion": "from itertools import combinations\n\ndef combinations_list(elements):\n    result = []\n    n = len(elements)\n    \n    # Generate combinations for all lengths from 0 to n\n    for r in range(n + 1):\n        for combo in combinations(elements, r):\n            result.append(list(combo))\n    \n    return result\n\n# Test the function with the provided assertion\nassert combinations_list(['orange', 'red', 'green', 'blue']) == [\n    [], \n    ['orange'], \n    ['red'], \n    ['red', 'orange'], \n    ['green'], \n    ['green', 'orange'], \n    ['green', 'red'], \n    ['green', 'red', 'orange'], \n    ['blue'], \n    ['blue', 'orange'], \n    ['blue', 'red'], \n    ['blue', 'red', 'orange'], \n    ['blue', 'green'], \n    ['blue', 'green', 'orange'], \n    ['blue', 'green', 'red'], \n    ['blue', 'green', 'red', 'orange']\n]"}
{"task_id": "MBPP/487", "entry_point": "sort_tuple", "completion": "def sort_tuple(tuples_list):\n    return sorted(tuples_list, key=lambda x: x[-1])\n\n# Test the function with the provided assertion\nassert sort_tuple([(1, 3), (3, 2), (2, 1)]) == [(2, 1), (3, 2), (1, 3)]"}
{"task_id": "MBPP/486", "entry_point": "binomial_probability", "completion": "import math\n\ndef binomial_probability(n, k, p):\n    # Calculate the binomial coefficient\n    binomial_coefficient = math.comb(n, k)\n    # Calculate the probability\n    probability = binomial_coefficient * (p ** k) * ((1 - p) ** (n - k))\n    return probability\n\n# Test the function with the provided assertion\nassert binomial_probability(10, 5, 1.0/3) == 0.13656454808718185"}
{"task_id": "MBPP/483", "entry_point": "first_Factorial_Divisible_Number", "completion": "def first_Factorial_Divisible_Number(x):\n    import math\n    \n    n = 1\n    while True:\n        factorial = math.factorial(n)\n        if factorial % x == 0:\n            return n\n        n += 1\n\n# Test the function with the provided assertion\nassert first_Factorial_Divisible_Number(10) == 5"}
{"task_id": "MBPP/481", "entry_point": "is_subset_sum", "completion": "def is_subset_sum(set, n, sum):\n    # Create a 2D array to store the results of subproblems\n    subset = [[False for _ in range(sum + 1)] for _ in range(n + 1)]\n    \n    # If sum is 0, then answer is true (empty subset)\n    for i in range(n + 1):\n        subset[i][0] = True\n\n    # Fill the subset table in a bottom-up manner\n    for i in range(1, n + 1):\n        for j in range(1, sum + 1):\n            if set[i - 1] > j:\n                subset[i][j] = subset[i - 1][j]\n            else:\n                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - set[i - 1]]\n\n    return subset[n][sum]\n\n# Example usage\nassert is_subset_sum([3, 34, 4, 12, 5, 2], 6, 9) == True"}
{"task_id": "MBPP/488", "entry_point": "area_pentagon", "completion": "import math\n\ndef area_pentagon(side_length):\n    area = (1/4) * math.sqrt(5 * (5 + 2 * math.sqrt(5))) * (side_length ** 2)\n    return area\n\n# Test the function with the provided assertion\nassert area_pentagon(5) == 43.01193501472417"}
{"task_id": "MBPP/489", "entry_point": "frequency_Of_Largest", "completion": "def frequency_of_largest(n, arr):\n    if not arr:\n        return 0\n    \n    largest_value = max(arr)\n    frequency = arr.count(largest_value)\n    \n    return frequency\n\n# Test the function with the provided assertion\nassert frequency_of_largest(5, [1, 2, 3, 4, 4]) == 2"}
{"task_id": "MBPP/491", "entry_point": "sum_gp", "completion": "def sum_gp(a, n, r):\n    if r == 1:\n        return a * n  # If the common ratio is 1, the series is just n times the first term\n    return a * (r**n - 1) // (r - 1)\n\n# Test the function with the provided assertion\nassert sum_gp(1, 5, 2) == 31"}
{"task_id": "MBPP/494", "entry_point": "binary_to_integer", "completion": "def binary_to_integer(binary_tuple):\n    # Convert the tuple to a string and then to an integer using base 2\n    binary_string = ''.join(str(bit) for bit in binary_tuple)\n    integer_value = int(binary_string, 2)\n    return str(integer_value)\n\n# Test the function with the provided assertion\nassert binary_to_integer((1, 1, 0, 1, 0, 0, 1)) == '105'"}
{"task_id": "MBPP/498", "entry_point": "gcd", "completion": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Test the function with the provided assertion\nassert gcd(12, 17) == 1"}
{"task_id": "MBPP/490", "entry_point": "extract_symmetric", "completion": "def extract_symmetric(tuple_list):\n    symmetric_pairs = set()\n    seen = set()\n\n    for pair in tuple_list:\n        # Add the pair to the seen set\n        seen.add(pair)\n        # Check for the symmetric pair\n        symmetric_pair = (pair[1], pair[0])\n        if symmetric_pair in seen:\n            symmetric_pairs.add(pair)\n            symmetric_pairs.add(symmetric_pair)\n\n    return symmetric_pairs\n\n# Test the function with the provided assertion\nassert extract_symmetric([(6, 7), (2, 3), (7, 6), (9, 8), (10, 2), (8, 9)]) == {(8, 9), (6, 7)}"}
{"task_id": "MBPP/499", "entry_point": "diameter_circle", "completion": "def diameter_circle(radius):\n    \"\"\"Calculate the diameter of a circle given its radius.\"\"\"\n    return 2 * radius\n\n# Test the function with the provided assertion\nassert diameter_circle(10) == 20"}
{"task_id": "MBPP/479", "entry_point": "first_Digit", "completion": "def first_Digit(number):\n    # Convert the number to a string and get the first character\n    first_digit = str(abs(number))[0]\n    return int(first_digit)\n\n# Test the function with the provided assertion\nassert first_Digit(123) == 1"}
{"task_id": "MBPP/495", "entry_point": "remove_lowercase", "completion": "import re\n\ndef remove_lowercase(s):\n    # Use regex to replace all lowercase letters with an empty string\n    return re.sub(r'[a-z]', '', s)\n\n# Test the function with the provided assertion\nassert remove_lowercase('KDeoALOklOOHserfLoAJSIskdsf') == 'KDALOOOHLAJSI'\n\n# You can also add more test cases to verify the function\nprint(remove_lowercase('KDeoALOklOOHserfLoAJSIskdsf'))  # Output: KDALOOOHLAJSI\nprint(remove_lowercase('HelloWorld'))  # Output: HWD\nprint(remove_lowercase('PythonIsFun'))  # Output: PIF"}
{"task_id": "MBPP/500", "entry_point": "concatenate_elements", "completion": "def concatenate_elements(elements):\n    return ' ' + ' '.join(elements)\n\n# Test the function with the provided assertion\nassert concatenate_elements(['hello', 'there', 'have', 'a', 'rocky', 'day']) == ' hello there have a rocky day'"}
{"task_id": "MBPP/492", "entry_point": "binary_search", "completion": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return True\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    return False\n\n# Test the function with the provided assertion\nassert binary_search([1, 2, 3, 5, 8], 6) == False"}
{"task_id": "MBPP/502", "entry_point": "find", "completion": "def find(a, b):\n    return a % b\n\n# Test the function with the provided assertion\nassert find(3, 3) == 0"}
{"task_id": "MBPP/501", "entry_point": "num_comm_div", "completion": "def num_comm_div(a, b):\n    \"\"\"Return the greatest common divisor of a and b.\"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\n# Test the function with the provided assertion\nassert num_comm_div(2, 4) == 2"}
{"task_id": "MBPP/497", "entry_point": "surfacearea_cone", "completion": "import math\n\ndef surfacearea_cone(radius, height):\n    # Calculate the slant height\n    slant_height = math.sqrt(radius**2 + height**2)\n    # Calculate the surface area\n    surface_area = math.pi * radius * (radius + slant_height)\n    return surface_area\n\n# Test the function with the provided assertion\nassert surfacearea_cone(5, 12) == 282.7433388230814"}
{"task_id": "MBPP/496", "entry_point": "heap_queue_smallest", "completion": "import heapq\n\ndef heap_queue_smallest(numbers, n):\n    \"\"\"\n    Find the smallest n integers from a given list of numbers using heap queue algorithm.\n\n    :param numbers: List of integers\n    :param n: Number of smallest integers to find\n    :return: List of the smallest n integers\n    \"\"\"\n    return heapq.nsmallest(n, numbers)\n\n# Example usage\nassert heap_queue_smallest([25, 35, 22, 85, 14, 65, 75, 25, 58], 3) == [14, 22, 25]"}
{"task_id": "MBPP/504", "entry_point": "sum_Of_Series", "completion": "def sum_Of_Series(n):\n    return sum(i**3 for i in range(1, n + 1))\n\n# Test the function\nassert sum_Of_Series(5) == 225"}
{"task_id": "MBPP/505", "entry_point": "re_order", "completion": "def re_order(arr):\n    # Initialize a new list to hold non-zero elements\n    non_zeroes = [num for num in arr if num != 0]\n    # Count the number of zeroes\n    zeroes_count = arr.count(0)\n    # Extend the non-zero list with the zeroes\n    return non_zeroes + [0] * zeroes_count\n\n# Test the function with the provided assertion\nassert re_order([6, 0, 8, 2, 3, 0, 4, 0, 1]) == [6, 8, 2, 3, 4, 1, 0, 0, 0]"}
{"task_id": "MBPP/507", "entry_point": "remove_words", "completion": "def remove_words(original_list, words_to_remove):\n    return [word for word in original_list if word not in words_to_remove]\n\n# Test the function with the provided assertion\nassert remove_words(['red', 'green', 'blue', 'white', 'black', 'orange'], ['white', 'orange']) == ['red', 'green', 'blue', 'black']"}
{"task_id": "MBPP/509", "entry_point": "average_Odd", "completion": "def average_Odd(n):\n    if n % 2 == 0:\n        raise ValueError(\"Input must be an odd number.\")\n    \n    # Calculate the sum of odd numbers and the count of odd numbers\n    total_sum = 0\n    count = 0\n    \n    for i in range(1, n + 1, 2):  # Iterate through odd numbers only\n        total_sum += i\n        count += 1\n    \n    # Calculate the average\n    average = total_sum / count\n    return average\n\n# Test the function\nassert average_Odd(9) == 5"}
{"task_id": "MBPP/503", "entry_point": "add_consecutive_nums", "completion": "def add_consecutive_nums(nums):\n    if not nums:\n        return []\n    \n    result = []\n    current_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        current_sum += nums[i]\n        result.append(current_sum)\n    \n    # Prepend the first element to the result\n    result.insert(0, nums[0])\n    \n    return result\n\n# Test the function with the provided assertion\nassert add_consecutive_nums([1, 1, 3, 4, 4, 5, 6, 7]) == [2, 4, 7, 8, 9, 11, 13]"}
{"task_id": "MBPP/508", "entry_point": "same_order", "completion": "def same_order(list1, list2):\n    # Find common elements\n    common_elements = [item for item in list1 if item in list2]\n    \n    # Check if the order of common elements is the same in both lists\n    index_list1 = [list1.index(item) for item in common_elements]\n    index_list2 = [list2.index(item) for item in common_elements]\n    \n    return index_list1 == index_list2\n\n# Test the function with the provided assertion\nassert same_order([\"red\", \"green\", \"black\", \"orange\"], [\"red\", \"pink\", \"green\", \"white\", \"black\"]) == True"}
{"task_id": "MBPP/513", "entry_point": "add_str", "completion": "def add_str(tup, string):\n    result = []\n    for element in tup:\n        result.append(element)\n        result.append(string)\n    return result\n\n# Test the function with the provided assertion\nassert add_str((5, 6, 7, 4, 9), \"FDF\") == [5, 'FDF', 6, 'FDF', 7, 'FDF', 4, 'FDF', 9, 'FDF']"}
{"task_id": "MBPP/512", "entry_point": "count_element_freq", "completion": "def count_element_freq(nested_tuple):\n    frequency = {}\n\n    def count_elements(t):\n        for element in t:\n            if isinstance(element, tuple):\n                count_elements(element)  # Recursively count elements in the nested tuple\n            else:\n                if element in frequency:\n                    frequency[element] += 1\n                else:\n                    frequency[element] = 1\n\n    count_elements(nested_tuple)\n    return frequency\n\n# Test the function with the provided assertion\nassert count_element_freq((5, 6, (5, 6), 7, (8, 9), 9)) == {5: 2, 6: 2, 7: 1, 8: 1, 9: 2}"}
{"task_id": "MBPP/511", "entry_point": "find_Min_Sum", "completion": "def find_Min_Sum(n):\n    # Function to find all factors of n\n    def get_factors(num):\n        factors = []\n        for i in range(1, int(num**0.5) + 1):\n            if num % i == 0:\n                factors.append(i)\n                if i != num // i:  # Avoid adding the square root twice\n                    factors.append(num // i)\n        return factors\n\n    # Get all factors of n\n    factors = get_factors(n)\n    \n    # Calculate the sum of factors\n    min_sum = sum(factors)\n    \n    return min_sum\n\n# Test the function with the provided assertion\nassert find_Min_Sum(12) == 28  # The factors of 12 are 1, 2, 3, 4, 6, 12, and their sum is 28"}
{"task_id": "MBPP/517", "entry_point": "largest_pos", "completion": "def largest_pos(numbers):\n    # Initialize the largest positive number to None\n    largest = None\n    \n    # Iterate through the list of numbers\n    for num in numbers:\n        # Check if the number is positive and larger than the current largest\n        if num > 0 and (largest is None or num > largest):\n            largest = num\n            \n    return largest\n\n# Test the function with the provided assertion\nassert largest_pos([1, 2, 3, 4, -1]) == 4"}
{"task_id": "MBPP/514", "entry_point": "sum_elements", "completion": "def sum_elements(tup):\n    \"\"\"Returns the summation of elements in the given tuple.\"\"\"\n    return sum(tup)\n\n# Test the function with the provided assertion\nassert sum_elements((7, 8, 9, 1, 10, 7)) == 42\n\n# You can also test the function with other tuples\nprint(sum_elements((1, 2, 3)))  # Output: 6\nprint(sum_elements((0, 0, 0)))  # Output: 0\nprint(sum_elements((-1, -2, -3)))  # Output: -6"}
{"task_id": "MBPP/518", "entry_point": "sqrt_root", "completion": "import math\n\ndef sqrt_root(n):\n    # Check if the number is a perfect square\n    if n < 0:\n        raise ValueError(\"Cannot compute the square root of a negative number.\")\n    \n    root = math.isqrt(n)  # Use integer square root to avoid floating point issues\n    if root * root == n:\n        return root\n    else:\n        raise ValueError(f\"{n} is not a perfect square.\")\n\n# Test the function with the provided assertion\nassert sqrt_root(4) == 2"}
{"task_id": "MBPP/510", "entry_point": "no_of_subsequences", "completion": "def no_of_subsequences(arr, k):\n    def count_subsequences(index, product):\n        # If the product is already greater than or equal to k, return 0\n        if product >= k:\n            return 0\n        # If we have considered all elements, return 1 (the empty subsequence)\n        if index == len(arr):\n            return 1\n        \n        # Count subsequences including the current element\n        include_current = count_subsequences(index + 1, product * arr[index])\n        # Count subsequences excluding the current element\n        exclude_current = count_subsequences(index + 1, product)\n        \n        return include_current + exclude_current\n\n    # Start counting from index 0 and initial product 1\n    return count_subsequences(0, 1) - 1  # Subtract 1 to exclude the empty subsequence\n\n# Test the function with the provided assertion\nassert no_of_subsequences([1, 2, 3, 4], 10) == 11"}
{"task_id": "MBPP/516", "entry_point": "radix_sort", "completion": "def counting_sort(arr, exp):\n    n = len(arr)\n    output = [0] * n  # Output array\n    count = [0] * 10  # Count array for digits 0-9\n\n    # Count occurrences of each digit in the current exponent\n    for i in range(n):\n        index = (arr[i] // exp) % 10\n        count[index] += 1\n\n    # Change count[i] so that it contains the actual position of this digit in output[]\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n\n    # Build the output array\n    for i in range(n - 1, -1, -1):\n        index = (arr[i] // exp) % 10\n        output[count[index] - 1] = arr[i]\n        count[index] -= 1\n\n    # Copy the output array to arr[], so that arr[] now contains sorted numbers\n    for i in range(n):\n        arr[i] = output[i]\n\ndef radix_sort(arr):\n    # Find the maximum number to know the number of digits\n    max_num = max(arr)\n\n    # Do counting sort for every digit\n    exp = 1\n    while max_num // exp > 0:\n        counting_sort(arr, exp)\n        exp *= 10\n\n    return arr\n\n# Test the function\nassert radix_sort([15, 79, 25, 68, 37]) == [15, 25, 37, 68, 79]"}
{"task_id": "MBPP/521", "entry_point": "check_isosceles", "completion": "def check_scalene(a, b, c):\n    \"\"\"\n    Check if a triangle with sides a, b, and c is scalene.\n    \n    A scalene triangle has all sides of different lengths.\n    \n    Parameters:\n    a (int or float): Length of side a\n    b (int or float): Length of side b\n    c (int or float): Length of side c\n    \n    Returns:\n    bool: True if the triangle is scalene, False otherwise\n    \"\"\"\n    return a != b and b != c and a != c\n\n# Test the function with an assertion\nassert check_scalene(6, 8, 12) == True"}
{"task_id": "MBPP/515", "entry_point": "modular_sum", "completion": "def modular_sum(arr, n, m):\n    # Create a boolean array to store the possible sums modulo m\n    dp = [False] * m\n    dp[0] = True  # A sum of 0 is always possible (the empty subset)\n\n    for num in arr:\n        # Update the dp array in reverse to avoid using the same element multiple times\n        for j in range(m - 1, -1, -1):\n            if dp[j]:\n                new_sum = (j + num) % m\n                dp[new_sum] = True\n\n    return dp[0]  # Return True if a sum divisible by m is found\n\n# Test the function with the provided assertion\nassert modular_sum([3, 1, 7, 5], 4, 6) == True"}
{"task_id": "MBPP/519", "entry_point": "volume_tetrahedron", "completion": "import math\n\ndef volume_tetrahedron(a):\n    return (a ** 3) / (6 * math.sqrt(2))\n\n# Test the function with the provided assertion\nassert round(volume_tetrahedron(10), 2) == 117.85"}
{"task_id": "MBPP/523", "entry_point": "check_string", "completion": "def check_string(s):\n    checks = [\n        (lambda s: any(c.isupper() for c in s), 'String must have 1 upper case character.'),\n        (lambda s: any(c.islower() for c in s), 'String must have 1 lower case character.'),\n        (lambda s: any(c.isdigit() for c in s), 'String must have 1 number.'),\n        (lambda s: len(s) >= 8, 'String length should be at least 8.')\n    ]\n    \n    errors = [message for check, message in checks if not check(s)]\n    return errors\n\n# Example usage\nassert check_string('python') == ['String must have 1 upper case character.', 'String must have 1 number.', 'String length should be at least 8.']"}
{"task_id": "MBPP/520", "entry_point": "get_lcm", "completion": "import math\nfrom functools import reduce\n\ndef lcm(a, b):\n    return abs(a * b) // math.gcd(a, b)\n\ndef get_lcm(arr):\n    return reduce(lcm, arr)\n\n# Test the function with the provided assertion\nassert get_lcm([2, 7, 3, 9, 4]) == 252"}
{"task_id": "MBPP/526", "entry_point": "capitalize_first_last_letters", "completion": "def capitalize_first_last_letters(s):\n    words = s.split()\n    capitalized_words = []\n    \n    for word in words:\n        if len(word) > 1:\n            capitalized_word = word[0].upper() + word[1:-1] + word[-1].upper()\n        elif len(word) == 1:\n            capitalized_word = word.upper()\n        else:\n            capitalized_word = word  # In case of empty string\n        capitalized_words.append(capitalized_word)\n    \n    return ' '.join(capitalized_words)\n\n# Test the function with the provided assertion\nassert capitalize_first_last_letters(\"python\") == \"PythoN\""}
{"task_id": "MBPP/528", "entry_point": "min_length", "completion": "def min_length(lists):\n    # Check if the input list is empty\n    if not lists:\n        return (0, [])\n    \n    # Initialize minimum length and the corresponding list\n    min_len = float('inf')\n    min_list = []\n\n    for lst in lists:\n        if len(lst) < min_len:\n            min_len = len(lst)\n            min_list = lst\n\n    return (min_len, min_list)\n\n# Test the function with the provided assertion\nassert min_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (1, [0])"}
{"task_id": "MBPP/529", "entry_point": "jacobsthal_lucas", "completion": "def jacobsthal_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n + 1):\n            a, b = b, b + 2 * a\n        return b\n\n# Test the function with the provided assertion\nassert jacobsthal_lucas(5) == 31"}
{"task_id": "MBPP/530", "entry_point": "negative_count", "completion": "def negative_count(arr):\n    if not arr:  # Check for empty array\n        return 0.0\n    \n    negative_numbers = sum(1 for x in arr if x < 0)\n    total_numbers = len(arr)\n    \n    return round(negative_numbers / total_numbers, 2)\n\n# Test the function with the provided assertion\nassert negative_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]) == 0.31"}
{"task_id": "MBPP/522", "entry_point": "lbs", "completion": "def longest_increasing_subsequence(arr):\n    n = len(arr)\n    lis = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n    \n    return lis\n\ndef longest_decreasing_subsequence(arr):\n    n = len(arr)\n    lds = [1] * n\n    \n    for i in range(n - 2, -1, -1):\n        for j in range(n - 1, i, -1):\n            if arr[i] > arr[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n    \n    return lds\n\ndef lbs(arr):\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    lis = longest_increasing_subsequence(arr)\n    lds = longest_decreasing_subsequence(arr)\n    \n    max_length = 0\n    for i in range(n):\n        max_length = max(max_length, lis[i] + lds[i] - 1)\n    \n    return max_length\n\n# Test the function with the provided assertion\nassert lbs([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]) == 7"}
{"task_id": "MBPP/532", "entry_point": "check_permutation", "completion": "def check_permutation(str1, str2):\n    # If the lengths of the strings are not the same, they cannot be permutations\n    if len(str1) != len(str2):\n        return False\n    \n    # Sort both strings and compare\n    return sorted(str1) == sorted(str2)\n\n# Test the function with the provided assertion\nassert check_permutation(\"abc\", \"cba\") == True"}
{"task_id": "MBPP/527", "entry_point": "get_pairs_count", "completion": "def get_pairs_count(arr, n, target_sum):\n    count = 0\n    # Create a dictionary to store the frequency of each number\n    num_count = {}\n    \n    for num in arr:\n        # Calculate the complement that we need to find\n        complement = target_sum - num\n        \n        # If the complement exists in the dictionary, it means we found pairs\n        if complement in num_count:\n            count += num_count[complement]\n        \n        # Update the frequency of the current number in the dictionary\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n            \n    return count\n\n# Test the function with the provided assertion\nassert get_pairs_count([1, 5, 7, -1, 5], 5, 6) == 3"}
{"task_id": "MBPP/506", "entry_point": "permutation_coefficient", "completion": "import math\n\ndef permutation_coefficient(n, k):\n    if k > n:\n        return 0  # If k is greater than n, permutations are not possible\n    return math.factorial(n) // math.factorial(n - k)\n\n# Test the function with the provided assertion\nassert permutation_coefficient(10, 2) == 90"}
{"task_id": "MBPP/533", "entry_point": "remove_datatype", "completion": "def remove_datatype(input_tuple, data_type):\n    return [item for item in input_tuple if not isinstance(item, data_type)]\n\n# Example usage\nassert remove_datatype((4, 5, 4, 7.7, 1.2), int) == [7.7, 1.2]"}
{"task_id": "MBPP/534", "entry_point": "search_literal", "completion": "def search_literal(pattern, text):\n    start_index = text.find(pattern)\n    if start_index == -1:\n        return None  # Return None if the pattern is not found\n    end_index = start_index + len(pattern)\n    return (start_index, end_index)\n\n# Test the function with the provided assertion\nassert search_literal('python', 'python programming language') == (0, 6)"}
{"task_id": "MBPP/531", "entry_point": "min_coins", "completion": "def min_coins(coins, num_coins, value):\n    # Initialize a list to store the minimum coins for each value\n    dp = [float('inf')] * (value + 1)\n    dp[0] = 0  # Base case: 0 coins are needed to make the value 0\n\n    # Iterate through each coin\n    for coin in coins:\n        # Update the dp array for values from coin to value\n        for v in range(coin, value + 1):\n            dp[v] = min(dp[v], dp[v - coin] + 1)\n\n    # If dp[value] is still infinity, it means it's not possible to form that value\n    return dp[value] if dp[value] != float('inf') else -1\n\n# Test the function with the provided assertion\nassert min_coins([9, 6, 5, 1], 4, 11) == 2"}
{"task_id": "MBPP/536", "entry_point": "nth_items", "completion": "def nth_items(lst, n):\n    return lst[::n]\n\n# Test the function with the provided assertion\nassert nth_items([1, 2, 3, 4, 5, 6, 7, 8, 9], 2) == [1, 3, 5, 7, 9]"}
{"task_id": "MBPP/537", "entry_point": "first_repeated_word", "completion": "def first_repeated_word(s):\n    words = s.split()\n    seen = set()\n    \n    for word in words:\n        if word in seen:\n            return word\n        seen.add(word)\n    \n    return None  # Return None if no repeated word is found\n\n# Test the function with the provided assertion\nassert first_repeated_word(\"ab ca bc ab\") == \"ab\""}
{"task_id": "MBPP/538", "entry_point": "string_list_to_tuple", "completion": "def string_list_to_tuple(input_string):\n    # Convert the string to a tuple of its characters\n    return tuple(input_string)\n\n# Test the function with the provided assertion\nassert string_list_to_tuple(\"python 3.0\") == ('p', 'y', 't', 'h', 'o', 'n', ' ', '3', '.', '0')"}
{"task_id": "MBPP/541", "entry_point": "check_abundant", "completion": "def check_abundant(n):\n    if n < 1:\n        return False\n    \n    # Calculate the sum of proper divisors\n    sum_of_divisors = sum(i for i in range(1, n) if n % i == 0)\n    \n    # Check if the sum of divisors is greater than the number\n    return sum_of_divisors > n\n\n# Test the function with the provided assertion\nassert check_abundant(12) == True"}
{"task_id": "MBPP/540", "entry_point": "find_Diff", "completion": "from collections import Counter\n\ndef find_Diff(arr, n):\n    # Count the frequency of each element in the array\n    frequency = Counter(arr)\n    \n    # Get the frequencies\n    freq_values = list(frequency.values())\n    \n    # Calculate the difference between the highest and least frequencies\n    if freq_values:\n        max_freq = max(freq_values)\n        min_freq = min(freq_values)\n        return max_freq - min_freq\n    else:\n        return 0  # If the array is empty, return 0\n\n# Test the function with the provided assertion\nassert find_Diff([1, 1, 2, 2, 7, 8, 4, 5, 1, 4], 10) == 2"}
{"task_id": "MBPP/542", "entry_point": "fill_spaces", "completion": "import re\n\ndef fill_spaces(input_string):\n    # Use regex to replace spaces, commas, or dots with a colon\n    return re.sub(r'[ ,.]', ':', input_string)\n\n# Test the function with the provided assertion\nassert fill_spaces('Boult Curve Wireless Neckband') == 'Boult:Curve:Wireless:Neckband'"}
{"task_id": "MBPP/544", "entry_point": "flatten_tuple", "completion": "def flatten_tuple(tuple_list):\n    # Flatten the list of tuples and join the elements into a single string\n    return ' '.join(item for tup in tuple_list for item in tup)\n\n# Test the function with the provided assertion\nassert flatten_tuple([('1', '4', '6'), ('5', '8'), ('2', '9'), ('1', '10')]) == '1 4 6 5 8 2 9 1 10'"}
{"task_id": "MBPP/543", "entry_point": "count_digits", "completion": "def count_digits(num1, num2):\n    # Calculate the sum of the two numbers\n    total = num1 + num2\n    # Convert the sum to a string and count the number of digits\n    num_digits = len(str(total))\n    return num_digits\n\n# Test the function with the provided assertion\nassert count_digits(9875, 10) == 4\n\n# You can also print the result if needed\nprint(count_digits(9875, 10))  # Output: 4"}
{"task_id": "MBPP/546", "entry_point": "last_occurence_char", "completion": "def last_occurrence_char(s, char):\n    \"\"\"Return the last occurrence index of char in string s.\"\"\"\n    return s.rfind(char)\n\n# Test the function with the provided assertion\nassert last_occurrence_char(\"hello world\", 'l') == 10"}
{"task_id": "MBPP/539", "entry_point": "basesnum_coresspondingnum", "completion": "def basesnum_coresspondingnum(bases, exponents):\n    return list(map(lambda base, exp: base ** exp, bases, exponents))\n\n# Test the function with the provided assertion\nassert basesnum_coresspondingnum([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], \n                                  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [\n    10, 400, 27000, 2560000, 312500000, 46656000000, \n    8235430000000, 1677721600000000, 387420489000000000, \n    100000000000000000000\n]"}
{"task_id": "MBPP/548", "entry_point": "longest_increasing_subsequence", "completion": "def longest_increasing_subsequence(sequence):\n    if not sequence:\n        return 0\n\n    # Initialize the dp array where dp[i] will hold the length of the longest\n    # increasing subsequence that ends with sequence[i]\n    dp = [1] * len(sequence)\n\n    # Fill the dp array\n    for i in range(1, len(sequence)):\n        for j in range(i):\n            if sequence[i] > sequence[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    # The length of the longest increasing subsequence will be the maximum value in dp\n    return max(dp)\n\n# Test the function with the provided assertion\nassert longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60]) == 5"}
{"task_id": "MBPP/549", "entry_point": "odd_Num_Sum", "completion": "def odd_Num_Sum(n):\n    # Calculate the sum of the fifth power of the first n odd natural numbers\n    return sum((2 * i + 1) ** 5 for i in range(n))\n\n# Test the function with the provided assertion\nassert odd_Num_Sum(1) == 1"}
{"task_id": "MBPP/545", "entry_point": "toggle_F_and_L_bits", "completion": "def toggle_F_and_L_bits(n):\n    # Calculate the number of bits in the number\n    num_bits = n.bit_length()\n    \n    # Create masks for the first and last bits\n    first_bit_mask = 1 << (num_bits - 1)  # Mask for the first bit\n    last_bit_mask = 1                    # Mask for the last bit\n    \n    # Toggle the first and last bits using XOR\n    toggled_n = n ^ (first_bit_mask | last_bit_mask)\n    \n    return toggled_n\n\n# Test the function with the provided assertion\nassert toggle_F_and_L_bits(10) == 3"}
{"task_id": "MBPP/551", "entry_point": "extract_column", "completion": "def extract_column(nested_list, column_index):\n    return [row[column_index] for row in nested_list]\n\n# Example usage\nassert extract_column([[1, 2, 3], [2, 4, 5], [1, 1, 1]], 0) == [1, 2, 1]"}
{"task_id": "MBPP/553", "entry_point": "tuple_to_float", "completion": "def tuple_to_float(tup):\n    # Convert the tuple to a string and replace the comma with a dot\n    float_str = ''.join(map(str, tup)).replace(',', '.')\n    # Convert the string to a float\n    return float(float_str)\n\n# Test the function\nassert tuple_to_float((4, 56)) == 4.56"}
{"task_id": "MBPP/550", "entry_point": "find_Max", "completion": "def find_Max(arr, low, high):\n    # If the array is not rotated at all\n    if high < low:\n        return arr[0]\n    \n    # If there is only one element\n    if high == low:\n        return arr[low]\n    \n    mid = (low + high) // 2\n    \n    # Check if mid is the maximum element\n    if mid < high and arr[mid] > arr[mid + 1]:\n        return arr[mid]\n    \n    # Check if mid-1 is the maximum element\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return arr[mid - 1]\n    \n    # Decide whether to go to the left half or the right half\n    if arr[low] >= arr[mid]:\n        return find_Max(arr, low, mid - 1)\n    else:\n        return find_Max(arr, mid + 1, high)\n\n# Example usage\nassert find_Max([2, 3, 5, 6, 9], 0, 4) == 9"}
{"task_id": "MBPP/547", "entry_point": "Total_Hamming_Distance", "completion": "def hamming_distance(x, y):\n    return bin(x ^ y).count('1')\n\ndef Total_Hamming_Distance(n):\n    total_distance = 0\n    for i in range(n):\n        total_distance += hamming_distance(i, i + 1)\n    return total_distance\n\n# Test the function with the provided assertion\nassert Total_Hamming_Distance(4) == 7\n\n# You can also print the result to verify\nprint(Total_Hamming_Distance(4))  # Output should be 7"}
{"task_id": "MBPP/554", "entry_point": "Split", "completion": "def find_odd_numbers(mixed_list):\n    return [num for num in mixed_list if num % 2 != 0]\n\n# Test the function with the provided assertion\nassert find_odd_numbers([1, 2, 3, 4, 5, 6]) == [1, 3, 5]"}
{"task_id": "MBPP/557", "entry_point": "toggle_string", "completion": "def toggle_string(s):\n    return s.swapcase()\n\n# Test the function\nassert toggle_string(\"Python\") == \"pYTHON\""}
{"task_id": "MBPP/552", "entry_point": "Seq_Linear", "completion": "def Seq_Linear(sequence):\n    if len(sequence) < 2:\n        return \"Linear Sequence\"  # A sequence with less than 2 elements is trivially linear\n\n    # Calculate the common difference\n    common_difference = sequence[1] - sequence[0]\n\n    # Check if all consecutive differences are the same\n    for i in range(1, len(sequence) - 1):\n        if sequence[i + 1] - sequence[i] != common_difference:\n            return \"Not a Linear Sequence\"\n\n    return \"Linear Sequence\"\n\n# Test the function with the provided assertion\nassert Seq_Linear([0, 2, 4, 6, 8, 10]) == \"Linear Sequence\""}
{"task_id": "MBPP/556", "entry_point": "find_Odd_Pair", "completion": "def find_Odd_Pair(arr, n):\n    even_count = 0\n    odd_count = 0\n    \n    # Count even and odd numbers\n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n            \n    # The number of pairs with odd XOR is the product of even and odd counts\n    return even_count * odd_count\n\n# Test the function with the provided assertion\nassert find_Odd_Pair([5, 4, 7, 2, 1], 5) == 6"}
{"task_id": "MBPP/558", "entry_point": "digit_distance_nums", "completion": "def digit_distance_nums(num1, num2):\n    # Convert both numbers to strings to access each digit\n    str_num1 = str(num1)\n    str_num2 = str(num2)\n    \n    # Pad the shorter number with leading zeros\n    max_length = max(len(str_num1), len(str_num2))\n    str_num1 = str_num1.zfill(max_length)\n    str_num2 = str_num2.zfill(max_length)\n    \n    # Calculate the digit distance\n    distance = sum(abs(int(d1) - int(d2)) for d1, d2 in zip(str_num1, str_num2))\n    \n    return distance\n\n# Test the function with the provided assertion\nassert digit_distance_nums(1, 2) == 1"}
{"task_id": "MBPP/555", "entry_point": "difference", "completion": "def difference(n):\n    # Calculate the sum of the first n natural numbers\n    sum_n = n * (n + 1) // 2\n    \n    # Calculate the sum of the cubes of the first n natural numbers\n    sum_cubes = sum(i**3 for i in range(1, n + 1))\n    \n    # Find the difference\n    return sum_cubes - sum_n\n\n# Test the function with the provided assertion\nassert difference(3) == 30"}
{"task_id": "MBPP/559", "entry_point": "max_sub_array_sum", "completion": "def max_sub_array_sum(arr, n):\n    # Initialize variables\n    max_sum = float('-inf')  # To store the maximum sum found\n    current_sum = 0          # To store the current subarray sum\n\n    for i in range(n):\n        current_sum += arr[i]  # Add the current element to the current sum\n        \n        # Update max_sum if current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n        \n        # If current_sum drops below 0, reset it to 0\n        if current_sum < 0:\n            current_sum = 0\n\n    return max_sum\n\n# Test the function with the provided assertion\nassert max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 7"}
{"task_id": "MBPP/560", "entry_point": "union_elements", "completion": "def union_elements(tuple1, tuple2):\n    # Convert tuples to sets to find the union\n    union_set = set(tuple1).union(set(tuple2))\n    # Convert the set back to a sorted tuple\n    return tuple(sorted(union_set))\n\n# Test the function with the provided assertion\nassert union_elements((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 4, 5, 6, 7, 10)"}
{"task_id": "MBPP/563", "entry_point": "extract_values", "completion": "import re\n\ndef extract_values(s):\n    # Use regular expression to find all occurrences of text within double quotes\n    return re.findall(r'\"(.*?)\"', s)\n\n# Test the function with the provided assertion\nassert extract_values('\"Python\", \"PHP\", \"Java\"') == ['Python', 'PHP', 'Java']"}
{"task_id": "MBPP/565", "entry_point": "split", "completion": "def split(s):\n    return list(s)\n\n# Test the function\nassert split('python') == ['p', 'y', 't', 'h', 'o', 'n']"}
{"task_id": "MBPP/566", "entry_point": "sum_digits", "completion": "def sum_digits(n):\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    return sum(int(digit) for digit in str(n))\n\n# Test the function with the provided assertion\nassert sum_digits(345) == 12"}
{"task_id": "MBPP/567", "entry_point": "issort_list", "completion": "def issort_list(lst):\n    return lst == sorted(lst)\n\n# Test the function with the provided assertion\nassert issort_list([1, 2, 4, 6, 8, 10, 12, 14, 16, 17]) == True"}
{"task_id": "MBPP/562", "entry_point": "Find_Max_Length", "completion": "def Find_Max_Length(sublists):\n    # Check if the input is a list of lists\n    if not all(isinstance(sublist, list) for sublist in sublists):\n        raise ValueError(\"Input must be a list of lists.\")\n    \n    # Find the maximum length of the sublists\n    max_length = max(len(sublist) for sublist in sublists)\n    return max_length\n\n# Test the function with the provided assertion\nassert Find_Max_Length([[1], [1, 4], [5, 6, 7, 8]]) == 4"}
{"task_id": "MBPP/564", "entry_point": "count_Pairs", "completion": "def count_Pairs(arr, n):\n    count = 0\n    # Iterate through each pair of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n    return count\n\n# Test the function with the provided assertion\nassert count_Pairs([1, 2, 1], 3) == 2"}
{"task_id": "MBPP/568", "entry_point": "empty_list", "completion": "def empty_list(n):\n    return [{} for _ in range(n)]\n\n# Test the function with the provided assertion\nassert empty_list(5) == [{}, {}, {}, {}, {}]"}
{"task_id": "MBPP/569", "entry_point": "sort_sublists", "completion": "def sort_sublists(list_of_lists):\n    return [sorted(sublist) for sublist in list_of_lists]\n\n# Test the function with the provided assertion\nassert sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]"}
{"task_id": "MBPP/572", "entry_point": "two_unique_nums", "completion": "def two_unique_nums(lst):\n    # Create a dictionary to count occurrences of each number\n    count = {}\n    \n    # Count occurrences of each number in the list\n    for num in lst:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Collect numbers that appear only once\n    unique_nums = [num for num, cnt in count.items() if cnt == 1]\n    \n    return unique_nums\n\n# Test the function with the provided assertion\nassert two_unique_nums([1, 2, 3, 2, 3, 4, 5]) == [1, 4, 5]"}
{"task_id": "MBPP/570", "entry_point": "remove_words", "completion": "def remove_words(strings, to_remove):\n    # Create a set of characters/substrings to remove for faster lookup\n    to_remove_set = set(to_remove)\n    \n    # Function to remove unwanted characters/substrings from a single string\n    def clean_string(s):\n        for item in to_remove_set:\n            s = s.replace(item, '')\n        return s.strip()  # Remove leading/trailing whitespace\n\n    # Apply the clean_string function to each string in the list\n    return [clean_string(s) for s in strings]\n\n# Test the function with the provided assertion\nassert remove_words(['Red color', 'Orange#', 'Green', 'Orange @', \"White\"], ['#', 'color', '@']) == ['Red', '', 'Green', 'Orange', 'White']"}
{"task_id": "MBPP/573", "entry_point": "unique_product", "completion": "def unique_product(numbers):\n    unique_numbers = set(numbers)  # Get unique numbers using a set\n    product = 1\n    for number in unique_numbers:\n        product *= number  # Multiply each unique number\n    return product\n\n# Test the function with the provided assertion\nassert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000"}
{"task_id": "MBPP/524", "entry_point": "max_sum_increasing_subsequence", "completion": "def max_sum_increasing_subsequence(arr, n):\n    # Create an array to store the maximum sum of increasing subsequence\n    max_sum = [0] * n\n    \n    # Initialize the max_sum array with the values of the original array\n    for i in range(n):\n        max_sum[i] = arr[i]\n    \n    # Compute the maximum sum of increasing subsequences\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and max_sum[i] < max_sum[j] + arr[i]:\n                max_sum[i] = max_sum[j] + arr[i]\n    \n    # The result is the maximum value in max_sum array\n    return max(max_sum)\n\n# Test the function with the provided assertion\nassert max_sum_increasing_subsequence([1, 101, 2, 3, 100, 4, 5], 7) == 106"}
{"task_id": "MBPP/574", "entry_point": "surfacearea_cylinder", "completion": "import math\n\ndef surfacearea_cylinder(radius, height):\n    return 2 * math.pi * radius * (height + radius)\n\n# Test the function with the provided assertion\nassert surfacearea_cylinder(10, 5) == 942.47798104879  # The expected value is approximately 942.45"}
{"task_id": "MBPP/535", "entry_point": "topbottom_surfacearea", "completion": "import math\n\ndef topbottom_surfacearea(diameter):\n    radius = diameter / 2\n    area = math.pi * (radius ** 2)\n    return area\n\n# Test the function with the provided assertion\nassert topbottom_surfacearea(10) == 314.15000000000003"}
{"task_id": "MBPP/525", "entry_point": "parallel_lines", "completion": "def parallel_lines(line1, line2):\n    # Unpack the points from the input lists\n    x1, y1, x2, y2 = line1[0], line1[1], line1[2], line1[3]\n    x3, y3, x4, y4 = line2[0], line2[1], line2[2], line2[3]\n    \n    # Calculate the slopes of both lines\n    # To avoid division by zero, we will compare the cross products instead\n    slope1_numerator = y2 - y1\n    slope1_denominator = x2 - x1\n    slope2_numerator = y4 - y3\n    slope2_denominator = x4 - x3\n    \n    # Check if the slopes are equal using cross multiplication\n    return slope1_numerator * slope2_denominator == slope2_numerator * slope1_denominator\n\n# Example usage\nassert parallel_lines([2, 3, 4, 5], [2, 3, 8, 9]) == True"}
{"task_id": "MBPP/576", "entry_point": "is_Sub_Array", "completion": "def is_Sub_Array(arr1, arr2, len1, len2):\n    # Loop through the first array\n    for i in range(len1 - len2 + 1):\n        # Check if the subarray matches\n        if arr1[i:i + len2] == arr2:\n            return True\n    return False\n\n# Test the function with the provided assertion\nassert is_Sub_Array([1, 4, 3, 5], [1, 2], 4, 2) == False"}
{"task_id": "MBPP/577", "entry_point": "last_Digit_Factorial", "completion": "def last_Digit_Factorial(n):\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    elif n == 0 or n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 6\n    elif n == 4:\n        return 4\n    else:\n        return 0  # For n >= 5, the last digit of factorial is always 0\n\n# Test the function with the provided assertion\nassert last_Digit_Factorial(4) == 4"}
{"task_id": "MBPP/575", "entry_point": "count_no", "completion": "def count_no(n, m, start, end):\n    count = 0\n    for number in range(start, end + 1):\n        if number % m != 0:  # Check if the number is not a multiple of m\n            count += 1\n            if count == n:  # If we have found the nth number\n                return number\n    return None  # Return None if nth number is not found in the range\n\n# Example usage\nassert count_no(2, 3, 1, 10) == 5"}
{"task_id": "MBPP/571", "entry_point": "max_sum_pair_diff_lessthan_K", "completion": "def max_sum_pair_diff_lessthan_K(arr, n, k):\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    \n    max_sum = 0\n    i = 0\n    \n    while i < len(arr) - 1:\n        # Check if the absolute difference is less than k\n        if abs(arr[i] - arr[i + 1]) < k:\n            # If it is, we can form a pair\n            max_sum += arr[i] + arr[i + 1]\n            # Move to the next pair\n            i += 2\n        else:\n            # If not, just move to the next element\n            i += 1\n            \n    return max_sum\n\n# Test the function with the provided assertion\nassert max_sum_pair_diff_lessthan_K([3, 5, 10, 15, 17, 12, 9], 7, 4) == 62"}
{"task_id": "MBPP/578", "entry_point": "interleave_lists", "completion": "def interleave_lists(*lists):\n    # Check if all lists are of the same length\n    if not all(len(lst) == len(lists[0]) for lst in lists):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    interleaved = []\n    for i in range(len(lists[0])):\n        for lst in lists:\n            interleaved.append(lst[i])\n    \n    return interleaved\n\n# Test the function with the provided assertion\nassert interleave_lists(\n    [1, 2, 3, 4, 5, 6, 7],\n    [10, 20, 30, 40, 50, 60, 70],\n    [100, 200, 300, 400, 500, 600, 700]\n) == [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]"}
{"task_id": "MBPP/579", "entry_point": "find_dissimilar", "completion": "def find_dissimilar(tuple1, tuple2):\n    # Convert tuples to sets to find unique elements\n    set1 = set(tuple1)\n    set2 = set(tuple2)\n    \n    # Find elements that are in either set but not in both\n    dissimilar_elements = set1.symmetric_difference(set2)\n    \n    # Convert the result back to a sorted tuple\n    return tuple(sorted(dissimilar_elements))\n\n# Test the function with the provided assertion\nassert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)"}
{"task_id": "MBPP/580", "entry_point": "extract_even", "completion": "def extract_even(nested_tuple):\n    if isinstance(nested_tuple, tuple):\n        return tuple(extract_even(item) for item in nested_tuple if isinstance(item, int) and item % 2 == 0 or isinstance(item, tuple) and extract_even(item))\n    return ()\n\n# Test the function with the provided assertion\nassert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)"}
{"task_id": "MBPP/583", "entry_point": "catalan_number", "completion": "import math\n\ndef catalan_number(n):\n    # Calculate the nth Catalan number using the formula\n    return math.factorial(2 * n) // (math.factorial(n + 1) * math.factorial(n))\n\n# Test the function\nassert catalan_number(10) == 16796"}
{"task_id": "MBPP/582", "entry_point": "my_dict", "completion": "def is_empty_dict(d):\n    \"\"\"Check if the given dictionary is empty.\"\"\"\n    return len(d) == 0\n\n# Example usage and assertion\nmy_dict = {}\nassert is_empty_dict(my_dict) == True  # This should be True since my_dict is empty\n\nmy_dict = {10: 'value'}\nassert is_empty_dict(my_dict) == False  # This should be False since my_dict is not empty"}
{"task_id": "MBPP/587", "entry_point": "list_tuple", "completion": "def list_tuple(lst):\n    return tuple(lst)\n\n# Test the function\nassert list_tuple([5, 10, 7, 4, 15, 3]) == (5, 10, 7, 4, 15, 3)"}
{"task_id": "MBPP/561", "entry_point": "assign_elements", "completion": "def assign_elements(pairs):\n    result = {}\n    \n    # Create the mapping\n    for a, b in pairs:\n        if a not in result:\n            result[a] = []\n        if b not in result:\n            result[b] = []\n        result[a].append(b)\n    \n    # Ensure all elements are represented in the result\n    for a, b in pairs:\n        if b not in result:\n            result[b] = []\n    \n    return result\n\n# Test the function with the provided assertion\nassert assign_elements([(5, 3), (7, 5), (2, 7), (3, 8), (8, 4)]) == {3: [8], 5: [3], 7: [5], 2: [7], 8: [4], 4: []}"}
{"task_id": "MBPP/588", "entry_point": "big_diff", "completion": "def big_diff(arr):\n    if not arr:  # Check if the array is empty\n        return 0\n    return max(arr) - min(arr)\n\n# Test the function with the provided assertion\nassert big_diff([1, 2, 3, 4]) == 3"}
{"task_id": "MBPP/581", "entry_point": "surface_Area", "completion": "import math\n\ndef surface_Area(side, height):\n    # Calculate the base area\n    base_area = side ** 2\n    \n    # Calculate the slant height\n    slant_height = math.sqrt(height ** 2 + (side / 2) ** 2)\n    \n    # Calculate the lateral area\n    lateral_area = (4 * side * slant_height) / 2\n    \n    # Total surface area\n    total_surface_area = base_area + lateral_area\n    \n    return total_surface_area\n\n# Test the function with the provided assertion\nassert surface_Area(3, 4) == 33"}
{"task_id": "MBPP/586", "entry_point": "split_Arr", "completion": "def split_Arr(arr, length, split_index):\n    # Split the array into two parts\n    first_part = arr[:split_index]\n    second_part = arr[split_index:length]\n    \n    # Combine the second part with the first part\n    result = second_part + first_part\n    return result\n\n# Test the function with the provided assertion\nassert split_Arr([12, 10, 5, 6, 52, 36], 6, 2) == [5, 6, 52, 36, 12, 10]"}
{"task_id": "MBPP/585", "entry_point": "expensive_items", "completion": "import heapq\n\ndef expensive_items(items, n):\n    # Use heapq.nlargest to find the n most expensive items\n    return heapq.nlargest(n, items, key=lambda x: x['price'])\n\n# Test the function with the provided assertion\nassert expensive_items([{'name': 'Item-1', 'price': 101.1}, {'name': 'Item-2', 'price': 555.22}], 1) == [{'name': 'Item-2', 'price': 555.22}]"}
{"task_id": "MBPP/589", "entry_point": "perfect_squares", "completion": "def perfect_squares(start, end):\n    \"\"\"Return a list of perfect squares between start and end (inclusive).\"\"\"\n    squares = []\n    for i in range(int(start**0.5), int(end**0.5) + 1):\n        square = i * i\n        if start <= square <= end:\n            squares.append(square)\n    return squares\n\n# Test the function with the provided assertion\nassert perfect_squares(1, 30) == [1, 4, 9, 16, 25]"}
{"task_id": "MBPP/591", "entry_point": "swap_List", "completion": "def swap_List(lst):\n    if len(lst) < 2:\n        return lst  # No swap needed for lists with less than 2 elements\n    # Swap the first and last elements\n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst\n\n# Test the function with the provided assertion\nassert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]"}
{"task_id": "MBPP/593", "entry_point": "removezero_ip", "completion": "def removezero_ip(ip_address):\n    # Split the IP address into its octets\n    octets = ip_address.split('.')\n    # Remove leading zeroes from each octet and convert to int to avoid leading zeroes\n    cleaned_octets = [str(int(octet)) for octet in octets]\n    # Join the cleaned octets back into an IP address\n    return '.'.join(cleaned_octets)\n\n# Test the function with the provided assertion\nassert removezero_ip(\"216.08.094.196\") == '216.8.94.196'"}
{"task_id": "MBPP/584", "entry_point": "find_adverbs", "completion": "import re\n\ndef find_adverbs(sentence):\n    # Regex pattern to find adverbs ending with 'ly'\n    pattern = r'\\b\\w+ly\\b'\n    \n    # Find all matches in the sentence\n    matches = re.finditer(pattern, sentence)\n    \n    # Prepare the result in the required format\n    result = []\n    for match in matches:\n        start = match.start()\n        adverb = match.group()\n        result.append(f\"{start}-{start + len(adverb)}: {adverb}\")\n    \n    return ', '.join(result)\n\n# Example usage\nassert find_adverbs(\"Clearly, he has no excuse for such behavior.\") == '0-7: Clearly'"}
{"task_id": "MBPP/594", "entry_point": "diff_even_odd", "completion": "def diff_even_odd(numbers):\n    first_even = None\n    first_odd = None\n    \n    for number in numbers:\n        if number % 2 == 0 and first_even is None:\n            first_even = number\n        elif number % 2 != 0 and first_odd is None:\n            first_odd = number\n        \n        # Break the loop if both numbers are found\n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        raise ValueError(\"The list must contain at least one even and one odd number.\")\n\n# Example usage\nassert diff_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 3"}
{"task_id": "MBPP/596", "entry_point": "tuple_size", "completion": "import sys\n\ndef tuple_size(tup):\n    return sys.getsizeof(tup)\n\n# Test the function with the provided assertion\nassert tuple_size((\"A\", 1, \"B\", 2, \"C\", 3)) == sys.getsizeof((\"A\", 1, \"B\", 2, \"C\", 3))\n\n# You can print the result to verify\nprint(\"Size of the tuple:\", tuple_size((\"A\", 1, \"B\", 2, \"C\", 3)))"}
{"task_id": "MBPP/598", "entry_point": "armstrong_number", "completion": "def armstrong_number(num):\n    # Convert the number to string to easily iterate over digits\n    digits = str(num)\n    # Calculate the number of digits\n    num_digits = len(digits)\n    # Calculate the sum of each digit raised to the power of the number of digits\n    sum_of_powers = sum(int(digit) ** num_digits for digit in digits)\n    # Check if the sum of powers is equal to the original number\n    return sum_of_powers == num\n\n# Test the function with the provided assertion\nassert armstrong_number(153) == True"}
{"task_id": "MBPP/600", "entry_point": "is_Even", "completion": "def is_Even(number):\n    return (number & 1) == 0\n\n# Test the function with the provided assertion\nassert is_Even(1) == False"}
{"task_id": "MBPP/590", "entry_point": "polar_rect", "completion": "import math\n\ndef polar_rect(r, theta):\n    # Calculate rectangular coordinates\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    \n    # Return the rectangular coordinates as a tuple and as a complex number\n    return (x, y), complex(x, y)\n\n# Test the function with the provided assertion\nassert polar_rect(3, 4) == ((-3.0, -0.0), (-3+0j))"}
{"task_id": "MBPP/592", "entry_point": "sum_Of_product", "completion": "def sum_Of_product(n):\n    # Calculate the sum of product of binomial coefficients\n    return n * (2 ** (n - 1))\n\n# Test the function with the provided assertion\nassert sum_Of_product(3) == 15"}
{"task_id": "MBPP/599", "entry_point": "sum_average", "completion": "def sum_average(n):\n    total_sum = sum(range(1, n + 1))\n    average = total_sum / n\n    return total_sum, average\n\n# Test the function with the provided assertion\nassert sum_average(10) == (55, 5.5)"}
{"task_id": "MBPP/602", "entry_point": "first_repeated_char", "completion": "def first_repeated_char(s):\n    seen = set()\n    for char in s:\n        if char in seen:\n            return char\n        seen.add(char)\n    return None  # Return None if there are no repeated characters\n\n# Test the function with the provided assertion\nassert first_repeated_char(\"abcabc\") == \"a\""}
{"task_id": "MBPP/604", "entry_point": "reverse_words", "completion": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list back into a string\n    return ' '.join(reversed_words)\n\n# Test the function with the provided assertion\nassert reverse_words(\"python program\") == \"program python\""}
{"task_id": "MBPP/595", "entry_point": "min_Swaps", "completion": "def min_Swaps(s1: str, s2: str) -> int:\n    if sorted(s1) != sorted(s2):\n        return -1  # Not possible to convert if they don't have the same characters\n\n    # Find the positions where the characters differ\n    mismatches = []\n    for i in range(len(s1)):\n        if s1[i] != s2[i]:\n            mismatches.append((s1[i], s2[i]))\n\n    # Count the number of swaps needed\n    count_01 = count_10 = 0\n    for a, b in mismatches:\n        if a == '0' and b == '1':\n            count_01 += 1\n        elif a == '1' and b == '0':\n            count_10 += 1\n\n    # Each swap can fix one '01' and one '10' mismatch\n    return (count_01 + count_10) // 2\n\n# Test the function with the provided assertion\nassert min_Swaps(\"1101\", \"1110\") == 1"}
{"task_id": "MBPP/606", "entry_point": "radian_degree", "completion": "import math\n\ndef radian_degree(degrees):\n    \"\"\"Convert degrees to radians.\"\"\"\n    return degrees * (math.pi / 180)\n\n# Test the function with the provided assertion\nassert radian_degree(90) == 1.5707963267948966"}
{"task_id": "MBPP/597", "entry_point": "find_kth", "completion": "def find_kth(arr1, arr2, n, m, k):\n    if n > m:  # Ensure arr1 is the smaller array\n        return find_kth(arr2, arr1, m, n, k)\n\n    if n == 0:\n        return arr2[k - 1]  # If the first array is empty, return k-th element from the second array\n\n    if k == 1:\n        return min(arr1[0], arr2[0])  # If k is 1, return the minimum of the two arrays\n\n    i = min(n, k // 2)  # Mid index for arr1\n    j = min(m, k // 2)  # Mid index for arr2\n\n    if arr1[i - 1] < arr2[j - 1]:\n        # Discard the first i elements of arr1\n        return find_kth(arr1[i:], arr2, n - i, m, k - i)\n    else:\n        # Discard the first j elements of arr2\n        return find_kth(arr1, arr2[j:], n, m - j, k - j)\n\n# Example usage\nassert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5, 4, 5) == 6"}
{"task_id": "MBPP/605", "entry_point": "prime_num", "completion": "def prime_num(n):\n    \"\"\"Check if the given integer n is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n# Test the function with the provided assertion\nassert prime_num(13) == True"}
{"task_id": "MBPP/601", "entry_point": "max_chain_length", "completion": "class Pair:\n    def __init__(self, first, second):\n        self.first = first\n        self.second = second\n\ndef max_chain_length(pairs, n):\n    # Sort the pairs based on the second element\n    pairs.sort(key=lambda x: x.second)\n    \n    # Initialize the count of chains and the end of the last chain\n    max_length = 0\n    last_end = float('-inf')\n    \n    for pair in pairs:\n        # If the current pair can be chained\n        if pair.first > last_end:\n            max_length += 1\n            last_end = pair.second  # Update the end of the last chain\n    \n    return max_length\n\n# Test the function with the provided assertion\nassert max_chain_length([Pair(5, 24), Pair(15, 25), Pair(27, 40), Pair(50, 60)], 4) == 3"}
{"task_id": "MBPP/610", "entry_point": "remove_kth_element", "completion": "def remove_kth_element(lst, k):\n    # Check if k is within the valid range\n    if k < 0 or k >= len(lst):\n        raise IndexError(\"k is out of bounds\")\n    # Remove the k'th element\n    return lst[:k] + lst[k+1:]\n\n# Test the function with the provided assertion\nassert remove_kth_element([1, 1, 2, 3, 4, 4, 5, 1], 3) == [1, 1, 3, 4, 4, 5, 1]"}
{"task_id": "MBPP/603", "entry_point": "get_ludic", "completion": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef generate_primes(n):\n    return [i for i in range(2, n + 1) if is_prime(i)]\n\ndef find_lucid_numbers(primes, n, current_sum=0, index=0, results=None):\n    if results is None:\n        results = set()\n    \n    if current_sum <= n:\n        results.add(current_sum)\n    \n    for i in range(index, len(primes)):\n        find_lucid_numbers(primes, n, current_sum + primes[i], i + 1, results)\n    \n    return results\n\ndef get_ludic(n):\n    primes = generate_primes(n)\n    lucid_numbers = find_lucid_numbers(primes, n)\n    return sorted(lucid_numbers)\n\n# Test the function\nassert get_ludic(10) == [1, 2, 3, 5, 7]"}
{"task_id": "MBPP/608", "entry_point": "bell_Number", "completion": "def bell_number(n):\n    # Create a 2D list to store Bell numbers\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    \n    # Base case\n    bell[0][0] = 1\n    \n    # Fill the Bell triangle\n    for i in range(1, n + 1):\n        # Explicitly put the first value of the current row\n        bell[i][0] = bell[i - 1][i - 1]\n        \n        # Fill the rest of the current row\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    # The nth Bell number is in bell[n][0]\n    return bell[n][0]\n\n# Test the function with the provided assertion\nassert bell_number(2) == 2"}
{"task_id": "MBPP/611", "entry_point": "max_of_nth", "completion": "def max_of_nth(tuple_list, n):\n    # Extract the nth column from the tuple list\n    nth_column = [t[n] for t in tuple_list]\n    # Return the maximum value from the nth column\n    return max(nth_column)\n\n# Test the function with the provided assertion\nassert max_of_nth([(5, 6, 7), (1, 3, 5), (8, 9, 19)], 2) == 19"}
{"task_id": "MBPP/614", "entry_point": "cummulative_sum", "completion": "def cumulative_sum(tuple_list):\n    total = 0\n    for tup in tuple_list:\n        total += sum(tup)\n    return total\n\n# Test the function with the provided assertion\nassert cumulative_sum([(1, 3), (5, 6, 7), (2, 6)]) == 30"}
{"task_id": "MBPP/607", "entry_point": "find_literals", "completion": "import re\n\ndef find_literals(original_string, pattern):\n    # Use re.search to find the pattern in the original string\n    match = re.search(re.escape(pattern), original_string)\n    \n    if match:\n        # If a match is found, return the matched string and its start and end positions\n        return (match.group(0), match.start(), match.end())\n    else:\n        # If no match is found, return None or an appropriate value\n        return None\n\n# Example usage\nassert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)"}
{"task_id": "MBPP/612", "entry_point": "merge", "completion": "def merge(list_of_lists):\n    if not list_of_lists:\n        return []\n    \n    first_elements = [sublist[0] for sublist in list_of_lists]\n    last_elements = [sublist[-1] for sublist in list_of_lists]\n    \n    return [first_elements, last_elements]\n\n# Test the function with the provided assertion\nassert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]"}
{"task_id": "MBPP/609", "entry_point": "floor_Min", "completion": "import math\nfrom functools import reduce\n\ndef lcm(a, b):\n    return abs(a * b) // math.gcd(a, b)\n\ndef lcm_multiple(numbers):\n    return reduce(lcm, numbers)\n\ndef floor_Min(a, b, c):\n    # Calculate the least common multiple of the three numbers\n    period = lcm_multiple([a, b, c])\n    \n    # We will evaluate the function at points 0 to period\n    # Assuming the function is f(x) = (x % a) + (x % b) + (x % c)\n    # This is just an example periodic function; you can replace it with the actual function.\n    \n    min_value = float('inf')\n    \n    for x in range(period):\n        value = (x % a) + (x % b) + (x % c)\n        if value < min_value:\n            min_value = value\n            \n    return min_value\n\n# Test the function\nassert floor_Min(10, 20, 30) == 15"}
{"task_id": "MBPP/613", "entry_point": "maximum_value", "completion": "def maximum_value(record_list):\n    return [(key, max(values)) for key, values in record_list]\n\n# Test the function with the provided assertion\nassert maximum_value([('key1', [3, 4, 5]), ('key2', [1, 4, 2]), ('key3', [9, 3])]) == [('key1', 5), ('key2', 4), ('key3', 9)]"}
{"task_id": "MBPP/618", "entry_point": "div_list", "completion": "def div_list(list1, list2):\n    return list(map(lambda x, y: x / y, list1, list2))\n\n# Test the function with the provided assertion\nassert div_list([4, 5, 6], [1, 2, 3]) == [4.0, 2.5, 2.0]"}
{"task_id": "MBPP/616", "entry_point": "tuple_modulo", "completion": "def tuple_modulo(tuple1, tuple2):\n    return tuple(a % b for a, b in zip(tuple1, tuple2))\n\n# Test the function with the provided assertion\nassert tuple_modulo((10, 4, 5, 6), (5, 6, 7, 5)) == (0, 4, 5, 1)\n\n# You can also print the result to verify\nprint(tuple_modulo((10, 4, 5, 6), (5, 6, 7, 5)))  # Output: (0, 4, 5, 1)"}
{"task_id": "MBPP/619", "entry_point": "move_num", "completion": "def move_num(s):\n    letters = ''.join(filter(str.isalpha, s))\n    numbers = ''.join(filter(str.isdigit, s))\n    return letters + numbers\n\n# Test the function with the provided assertion\nassert move_num('I1love143you55three3000thousand') == 'Iloveyouthreethousand1143553000'"}
{"task_id": "MBPP/617", "entry_point": "min_Jumps", "completion": "def min_Jumps(jump_length, d, y):\n    # Since we are only interested in reaching (d, 0), y should always be 0\n    if y != 0:\n        raise ValueError(\"The y-coordinate must be 0.\")\n    \n    # Calculate the number of jumps required to reach distance d\n    jumps = d / jump_length\n    \n    return jumps\n\n# Example usage\nassert min_Jumps(3, 4, 0) == 4 / 3  # This should return approximately 1.33\nassert min_Jumps(3, 11, 0) == 11 / 3  # This should return approximately 3.67"}
{"task_id": "MBPP/624", "entry_point": "is_upper", "completion": "def is_upper(s):\n    return s.upper()\n\n# Test the function\nassert is_upper(\"person\") == \"PERSON\""}
{"task_id": "MBPP/621", "entry_point": "increment_numerics", "completion": "import re\n\ndef increment_numerics(strings, k):\n    def increment_match(match):\n        # Convert the matched string to an integer, increment it, and return as string\n        return str(int(match.group(0)) + k)\n\n    # Use regex to find all numeric values in each string and increment them\n    return [re.sub(r'\\d+', increment_match, s) for s in strings]\n\n# Test the function with the provided assertion\nassert increment_numerics([\"MSM\", \"234\", \"is\", \"98\", \"123\", \"best\", \"4\"], 6) == ['MSM', '240', 'is', '104', '129', 'best', '10']"}
{"task_id": "MBPP/615", "entry_point": "average_tuple", "completion": "def average_tuple(tuples):\n    # Calculate the number of inner tuples\n    num_tuples = len(tuples)\n    \n    # Calculate the number of elements in each inner tuple\n    num_elements = len(tuples[0])\n    \n    # Initialize a list to hold the sums of each column\n    sums = [0] * num_elements\n    \n    # Iterate through each tuple and sum the values\n    for tup in tuples:\n        for i in range(num_elements):\n            sums[i] += tup[i]\n    \n    # Calculate the average for each column\n    averages = [s / num_tuples for s in sums]\n    \n    return averages\n\n# Test the function with the provided assertion\nassert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4))) == [30.5, 34.25, 27.0, 23.25]"}
{"task_id": "MBPP/623", "entry_point": "nth_nums", "completion": "def nth_nums(lst, n):\n    return list(map(lambda x: x ** n, lst))\n\n# Test the function with the provided assertion\nassert nth_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"}
{"task_id": "MBPP/625", "entry_point": "swap_List", "completion": "def swap_List(lst):\n    if len(lst) < 2:\n        return lst  # No swap needed for lists with less than 2 elements\n    # Swap the first and last elements\n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst\n\n# Test the function with the provided assertion\nassert swap_List([1, 2, 3]) == [3, 2, 1]"}
{"task_id": "MBPP/628", "entry_point": "replace_spaces", "completion": "def replace_spaces(input_string):\n    return input_string.replace(' ', '%20')\n\n# Test the function\nassert replace_spaces(\"My Name is Dawood\") == 'My%20Name%20is%20Dawood'"}
{"task_id": "MBPP/620", "entry_point": "largest_subset", "completion": "def largest_subset(arr, n):\n    # Sort the array\n    arr.sort()\n    \n    # Create a DP array to store the size of the largest divisible subset ending at each index\n    dp = [1] * n\n    \n    # Variable to keep track of the maximum size of the subset\n    max_size = 1\n    \n    # Build the dp array\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] % arr[j] == 0:  # Check if arr[i] is divisible by arr[j]\n                dp[i] = max(dp[i], dp[j] + 1)\n        max_size = max(max_size, dp[i])\n    \n    return max_size\n\n# Test the function with the provided assertion\nassert largest_subset([1, 3, 6, 13, 17, 18], 6) == 4"}
{"task_id": "MBPP/627", "entry_point": "find_First_Missing", "completion": "def find_First_Missing(arr, start, end):\n    # Create a set from the array for O(1) lookups\n    num_set = set(arr)\n    \n    # Iterate through the range from start to end\n    for num in range(start, end + 1):\n        if num not in num_set:\n            return num\n    \n    # If all numbers in the range are present, return the next number\n    return end + 1\n\n# Test the function with the provided assertion\nassert find_First_Missing([0, 1, 2, 3], 0, 3) == 4"}
{"task_id": "MBPP/626", "entry_point": "triangle_area", "completion": "def triangle_area(radius):\n    if radius <= 0:\n        return 0\n    return radius ** 2\n\n# Test the function with the provided assertion\nassert triangle_area(0) == 0"}
{"task_id": "MBPP/629", "entry_point": "Split", "completion": "def find_even_numbers(mixed_list):\n    \"\"\"Return a list of even numbers from the given mixed list.\"\"\"\n    return [num for num in mixed_list if num % 2 == 0]\n\n# Test the function with the provided assertion\nassert find_even_numbers([1, 2, 3, 4, 5]) == [2, 4]"}
{"task_id": "MBPP/493", "entry_point": "calculate_polygons", "completion": "To create a function that calculates a grid of hexagon coordinates, we need to understand the geometry of hexagons. A regular hexagon can be divided into six equilateral triangles, and its vertices can be calculated based on a center point and a radius (distance from the center to a vertex).\n\nThe coordinates of the vertices of a hexagon can be calculated using trigonometric functions. The angle between each vertex is 60 degrees (or \u03c0/3 radians). \n\nHere's how we can implement the `calculate_polygons` function in Python:\n\n```python\nimport math\n\ndef calculate_polygons(start_x, start_y, cols, rows, radius):\n    hexagons = []\n    for row in range(rows):\n        for col in range(cols):\n            # Calculate the center of the hexagon\n            x = start_x + col * radius * 3/2\n            y = start_y + row * radius * math.sqrt(3)\n            if col % 2 == 1:  # Offset every other column\n                y += radius * math.sqrt(3) / 2\n            \n            # Calculate the vertices of the hexagon\n            hexagon = []\n            for i in range(6):\n                angle = math.pi / 3 * i  # 60 degrees in radians\n                hex_x = x + radius * math.cos(angle)\n                hex_y = y + radius * math.sin(angle)\n                hexagon.append((hex_x, hex_y))\n            hexagons.append(hexagon)\n    \n    return hexagons\n\n# Example usage\nassert calculate_polygons(1, 1, 4, 4, 3) == [[(-5.0, -4.196152422706632), (-5.0, -0.7320508075688767), (-2.0, 1.0), (1.0, -0.7320508075688767), (1.0, -4.196152422706632), (-2.0, -5.928203230275509), (-5.0, -4.196152422706632)], \n                                               [(1.0, -4.196152422706632), (1.0, -0.7320508075688767), (4.0, 1.0), (7.0, -0.7320508075688767), (7.0, -4.196152422706632), (4.0, -5.928203230275509), (1.0, -4.196152422706632)], \n                                               [(7.0, -4.196152422706632), (7.0, -0.7320508075688767), (10.0, 1.0), (13.0, -0.7320508075688767), (13.0, -4.196152422706632), (10.0, -5.928203230275509), (7.0, -4.196152422706632)], \n                                               [(-2.0, 1.0000000000000004), (-2.0, 4.464101615137755), (1.0, 6.196152422706632), (4.0, 4.464101615137755), (4.0, 1.0000000000000004), (1.0, -0.7320508075688767), (-2.0, 1.0000000000000004)], \n                                               [(4.0, 1.0000000000000004), (4.0, 4.464101615137755), (7.0, 6.196152422706632), (10.0, 4.464101615137755), (10.0, 1.0000000000000004), (7.0, -0.7320508075688767), (4.0, 1.0000000000000004)], \n                                               [(-5.0, 6.196152422706632), (-5.0, 9.660254037844387), (-2.0, 11.392304845413264), (1.0, 9.660254037844387), (1.0, 6.196152422706632), (-2.0, 4.464101615137755), (-5.0, 6.196152422706632)], \n                                               [(1.0, 6.196152422706632), (1.0, 9.660254037844387), (4.0, 11.392304845413264), (7.0, 9.660254037844387), ("}
{"task_id": "MBPP/630", "entry_point": "get_coordinates", "completion": "def get_coordinates(coord):\n    x, y = coord\n    adjacent_coords = []\n    \n    for i in range(x - 1, x + 2):\n        for j in range(y - 1, y + 2):\n            adjacent_coords.append([i, j])\n    \n    return adjacent_coords\n\n# Test the function\nassert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]"}
{"task_id": "MBPP/631", "entry_point": "replace_spaces", "completion": "import re\n\ndef replace_spaces(input_string):\n    # Replace spaces with underscores and underscores with spaces\n    return re.sub(r'_', ' ', re.sub(r'\\s+', '_', input_string))\n\n# Test the function with the provided assertion\nassert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'"}
{"task_id": "MBPP/634", "entry_point": "even_Power_Sum", "completion": "def even_Power_Sum(n):\n    # Calculate the sum of the fourth power of the first n even natural numbers\n    return sum((2 * i) ** 4 for i in range(1, n + 1))\n\n# Test the function with the provided assertion\nassert even_Power_Sum(2) == 272"}
{"task_id": "MBPP/632", "entry_point": "move_zero", "completion": "def move_zero(lst):\n    # Create a new list to hold non-zero elements\n    non_zero = [x for x in lst if x != 0]\n    # Count the number of zeroes\n    zero_count = lst.count(0)\n    # Extend the non-zero list with the zeroes\n    return non_zero + [0] * zero_count\n\n# Test the function with the provided assertion\nassert move_zero([1, 0, 2, 0, 3, 4]) == [1, 2, 3, 4, 0, 0]"}
{"task_id": "MBPP/639", "entry_point": "sample_nam", "completion": "def sample_nam(names):\n    # Filter out names that start with a lowercase letter\n    filtered_names = [name for name in names if not name[0].islower()]\n    # Sum the lengths of the remaining names\n    total_length = sum(len(name) for name in filtered_names)\n    return total_length\n\n# Test the function with the provided assertion\nassert sample_nam(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16"}
{"task_id": "MBPP/633", "entry_point": "pair_OR_Sum", "completion": "def pair_OR_Sum(arr, n):\n    total_xor_sum = 0\n    \n    # Iterate through all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += arr[i] ^ arr[j]\n    \n    return total_xor_sum\n\n# Test the function with the provided assertion\nassert pair_OR_Sum([5, 9, 7, 6], 4) == 47"}
{"task_id": "MBPP/640", "entry_point": "remove_parenthesis", "completion": "def remove_parenthesis(strings):\n    # Initialize an empty list to hold the results\n    result = []\n    \n    for s in strings:\n        # Remove the text within parentheses using str.split and str.join\n        cleaned_string = ''.join(s.split('(')[0:1])  # Get the part before the first '('\n        result.append(cleaned_string.strip())  # Strip any leading/trailing whitespace\n    \n    return result[0] if result else \"\"\n\n# Test the function\nassert remove_parenthesis([\"python (chrome)\"]) == \"python\""}
{"task_id": "MBPP/637", "entry_point": "noprofit_noloss", "completion": "def noprofit_noloss(selling_price, cost_price):\n    return selling_price == cost_price\n\n# Test the function with the provided assertion\nassert noprofit_noloss(1500, 1200) == False"}
{"task_id": "MBPP/635", "entry_point": "heap_sort", "completion": "import heapq\n\ndef heap_sort(iterable):\n    # Create a heap from the iterable\n    heap = []\n    for value in iterable:\n        heapq.heappush(heap, value)\n    \n    # Pop the smallest values one at a time to get a sorted list\n    sorted_list = []\n    while heap:\n        sorted_list.append(heapq.heappop(heap))\n    \n    return sorted_list\n\n# Test the function with the provided assertion\nassert heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"}
{"task_id": "MBPP/638", "entry_point": "wind_chill", "completion": "def wind_chill(temperature, wind_speed):\n    \"\"\"\n    Calculate the wind chill index based on the temperature and wind speed.\n    \n    Parameters:\n    temperature (float): The air temperature in degrees Fahrenheit.\n    wind_speed (float): The wind speed in miles per hour.\n    \n    Returns:\n    float: The wind chill index.\n    \"\"\"\n    wci = (35.74 + \n            0.6215 * temperature - \n            35.75 * (wind_speed ** 0.16) + \n            0.4275 * temperature * (wind_speed ** 0.16))\n    return wci\n\n# Test the function with the provided assertion\nassert wind_chill(120, 35) == 40"}
{"task_id": "MBPP/636", "entry_point": "Check_Solution", "completion": "def Check_Solution(a, b, c):\n    # Check if the product of the roots equals 1\n    if c == a:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Test the function with the provided assertion\nassert Check_Solution(2, 0, 2) == \"Yes\""}
{"task_id": "MBPP/641", "entry_point": "is_nonagonal", "completion": "def is_nonagonal(n):\n    return n * (7 * n - 5) // 2\n\n# Test the function with the provided assertion\nassert is_nonagonal(10) == 325\n\n# You can also print the result to verify\nprint(is_nonagonal(10))  # Output should be 325"}
{"task_id": "MBPP/645", "entry_point": "find_k_product", "completion": "def find_k_product(tuples_list, k):\n    product = 1\n    for tup in tuples_list:\n        product *= tup[k]\n    return product\n\n# Test the function with the provided assertion\nassert find_k_product([(5, 6, 7), (1, 3, 5), (8, 9, 19)], 2) == 665"}
{"task_id": "MBPP/643", "entry_point": "text_match_wordz_middle", "completion": "import re\n\ndef text_match_wordz_middle(text):\n    # Regular expression to find a word containing 'z' not at the start or end\n    pattern = r'\\b\\w*z\\w*\\b'\n    \n    # Search for the pattern in the input text\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'No match found.'\n\n# Test the function\nassert text_match_wordz_middle(\"pythonzabc.\") == 'Found a match!'"}
{"task_id": "MBPP/647", "entry_point": "split_upperstring", "completion": "import re\n\ndef split_upperstring(s):\n    # Use regular expression to split the string at uppercase letters\n    return re.findall(r'[A-Z][a-z]*', s)\n\n# Test the function with the provided assertion\nassert split_upperstring(\"PythonProgramLanguage\") == ['Python', 'Program', 'Language']"}
{"task_id": "MBPP/622", "entry_point": "get_median", "completion": "def get_median(arr1, arr2, n):\n    if n <= 0:\n        raise ValueError(\"Array size must be greater than 0\")\n    \n    # Ensure arr1 is the smaller array\n    if len(arr1) > len(arr2):\n        arr1, arr2 = arr2, arr1\n    \n    x, y = len(arr1), len(arr2)\n    low, high = 0, x\n    \n    while low <= high:\n        partitionX = (low + high) // 2\n        partitionY = (n + n) // 2 - partitionX\n        \n        # If partitionX is 0 it means nothing is there on left side. Use -inf for maxLeftX\n        # If partitionX is length of input then there is nothing on right side. Use +inf for minRightX\n        maxLeftX = float('-inf') if partitionX == 0 else arr1[partitionX - 1]\n        minRightX = float('inf') if partitionX == x else arr1[partitionX]\n        \n        maxLeftY = float('-inf') if partitionY == 0 else arr2[partitionY - 1]\n        minRightY = float('inf') if partitionY == y else arr2[partitionY]\n        \n        if maxLeftX <= minRightY and maxLeftY <= minRightX:\n            # We have partitioned array at correct place\n            if (x + y) % 2 == 0:\n                return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2\n            else:\n                return max(maxLeftX, maxLeftY)\n        elif maxLeftX > minRightY:\n            # We are too far on right side for partitionX. Go on left side.\n            high = partitionX - 1\n        else:\n            # We are too far on left side for partitionX. Go on right side.\n            low = partitionX + 1\n\n    raise ValueError(\"Input arrays are not sorted or of the same size.\")\n\n# Example usage\nassert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0"}
{"task_id": "MBPP/644", "entry_point": "reverse_Array_Upto_K", "completion": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the subarray from the start to the k-th position (exclusive)\n    if k > len(arr):\n        k = len(arr)  # Ensure k does not exceed the array length\n    reversed_part = arr[:k][::-1]\n    return reversed_part + arr[k:]\n\n# Test the function with the provided assertion\nassert reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4) == [4, 3, 2, 1, 5, 6]"}
{"task_id": "MBPP/648", "entry_point": "exchange_elements", "completion": "def exchange_elements(lst):\n    # Iterate through the list in steps of 2\n    for i in range(0, len(lst) - 1, 2):\n        # Swap the elements at index i and i+1\n        lst[i], lst[i + 1] = lst[i + 1], lst[i]\n    return lst\n\n# Test the function with the provided assertion\nassert exchange_elements([0, 1, 2, 3, 4, 5]) == [1, 0, 3, 2, 5, 4]"}
{"task_id": "MBPP/642", "entry_point": "remove_similar_row", "completion": "def remove_similar_row(matrix):\n    # Use a set to store unique rows\n    unique_rows = set()\n    \n    # Iterate through each row in the matrix\n    for row in matrix:\n        # Add the row to the set (sets automatically handle duplicates)\n        unique_rows.add(tuple(row))\n    \n    return unique_rows\n\n# Test the function with the provided assertion\nassert remove_similar_row([[(4, 5), (3, 2)], [(2, 2), (4, 6)], [(3, 2), (4, 5)]]) == {((2, 2), (4, 6)), ((3, 2), (4, 5))}"}
{"task_id": "MBPP/649", "entry_point": "sum_Range_list", "completion": "def sum_Range_list(numbers, start_index, end_index):\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0 or end_index >= len(numbers) or start_index > end_index:\n        raise ValueError(\"Indices are out of bounds or invalid.\")\n    \n    # Calculate the sum of the specified range\n    return sum(numbers[start_index:end_index + 1])\n\n# Test the function with the provided assertion\nassert sum_Range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10) == 29"}
{"task_id": "MBPP/651", "entry_point": "check_subset", "completion": "def check_subset(tuple1, tuple2):\n    # Convert tuples to sets and check if tuple2 is a subset of tuple1\n    return set(tuple2).issubset(set(tuple1))\n\n# Test the function with the provided assertion\nassert check_subset((10, 4, 5, 6), (5, 10)) == True"}
{"task_id": "MBPP/646", "entry_point": "No_of_cubes", "completion": "def No_of_cubes(n, k):\n    if k > n:\n        return 0  # If k is larger than n, no cubes can fit\n    return (n - k + 1) ** 3\n\n# Test the function with the provided assertion\nassert No_of_cubes(2, 1) == 8"}
{"task_id": "MBPP/654", "entry_point": "rectangle_perimeter", "completion": "def rectangle_perimeter(length, width):\n    return 2 * (length + width)\n\n# Test the function with the provided assertion\nassert rectangle_perimeter(10, 20) == 60"}
{"task_id": "MBPP/655", "entry_point": "fifth_Power_Sum", "completion": "def fifth_Power_Sum(n):\n    return sum(i**5 for i in range(1, n + 1))\n\n# Test the function with the provided assertion\nassert fifth_Power_Sum(2) == 33"}
{"task_id": "MBPP/653", "entry_point": "grouping_dictionary", "completion": "from collections import defaultdict\n\ndef grouping_dictionary(pairs):\n    grouped = defaultdict(list)\n    for key, value in pairs:\n        grouped[key].append(value)\n    return dict(grouped)\n\n# Test the function with the provided assertion\nassert grouping_dictionary([('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]) == {'yellow': [1, 3], 'blue': [2, 4], 'red': [1]}"}
{"task_id": "MBPP/650", "entry_point": "are_Equal", "completion": "def are_Equal(arr1, arr2, n, m):\n    # Check if the lengths of the arrays are different\n    if n != m:\n        return False\n    \n    # Sort both arrays and compare them\n    return sorted(arr1) == sorted(arr2)\n\n# Test the function with the provided assertion\nassert are_Equal([1, 2, 3], [3, 2, 1], 3, 3) == True"}
{"task_id": "MBPP/656", "entry_point": "find_Min_Sum", "completion": "def find_Min_Sum(arr1, arr2, n):\n    # Sort both arrays\n    arr1.sort()\n    arr2.sort()\n    \n    # Calculate the sum of absolute differences\n    min_sum = sum(abs(arr1[i] - arr2[i]) for i in range(n))\n    \n    return min_sum\n\n# Test the function with the provided assertion\nassert find_Min_Sum([3, 2, 1], [2, 1, 3], 3) == 0"}
{"task_id": "MBPP/658", "entry_point": "max_occurrences", "completion": "from collections import Counter\n\ndef max_occurrences(lst):\n    if not lst:\n        return None  # Return None if the list is empty\n    \n    count = Counter(lst)\n    max_item = max(count, key=count.get)\n    return max_item\n\n# Test the function with the provided assertion\nassert max_occurrences([2, 3, 8, 4, 7, 9, 8, 2, 6, 5, 1, 6, 1, 2, 3, 4, 6, 9, 1, 2]) == 2"}
{"task_id": "MBPP/659", "entry_point": "Repeat", "completion": "def Repeat(lst):\n    seen = set()\n    duplicates = set()\n    \n    for number in lst:\n        if number in seen:\n            duplicates.add(number)\n        else:\n            seen.add(number)\n    \n    return list(duplicates)\n\n# Test the function with the provided assertion\nassert Repeat([10, 20, 30, 20, 20, 30, 40, 50, -20, 60, 60, -20, -20]) == [20, 30, -20, 60]"}
{"task_id": "MBPP/662", "entry_point": "sorted_dict", "completion": "def sorted_dict(input_dict):\n    return {key: sorted(value) for key, value in input_dict.items()}\n\n# Test the function with the provided assertion\nassert sorted_dict({'n1': [2, 3, 1], 'n2': [5, 1, 2], 'n3': [3, 2, 4]}) == {'n1': [1, 2, 3], 'n2': [1, 2, 5], 'n3': [2, 3, 4]}"}
{"task_id": "MBPP/652", "entry_point": "matrix_to_list", "completion": "def matrix_to_list(matrix):\n    if not matrix or not matrix[0]:\n        return []\n\n    # Get the number of rows and columns\n    num_rows = len(matrix)\n    num_cols = len(matrix[0])\n\n    # Initialize a list to hold the tuples for each column\n    result = []\n\n    # Iterate through each column\n    for col in range(num_cols):\n        column_tuple = tuple(matrix[row][col] for row in range(num_rows))\n        result.append(column_tuple)\n\n    return result\n\n# Test the function with the provided assertion\nassert str(matrix_to_list([[(4, 5), (7, 8)], [(10, 13), (18, 17)], [(0, 4), (10, 1)]]) ) == '[(4, 7, 10, 18, 0, 10), (5, 8, 13, 17, 4, 1)]'"}
{"task_id": "MBPP/664", "entry_point": "average_Even", "completion": "def average_Even(n):\n    if n < 2 or n % 2 != 0:\n        raise ValueError(\"Input must be an even number greater than or equal to 2.\")\n    \n    # Calculate the sum of even numbers and the count of even numbers\n    total_sum = 0\n    count = 0\n    \n    for i in range(2, n + 1, 2):\n        total_sum += i\n        count += 1\n    \n    # Calculate the average\n    average = total_sum / count\n    return average\n\n# Test the function with the provided assertion\nassert average_Even(2) == 2"}
{"task_id": "MBPP/660", "entry_point": "find_Points", "completion": "def find_Points(start1, end1, start2, end2):\n    # Choose a point from the first range\n    point1 = start1\n    \n    # Choose a point from the second range\n    # Ensure that point2 does not overlap with point1\n    if point1 < start2:\n        point2 = start2\n    else:\n        point2 = end2\n    \n    return (point1, point2)\n\n# Test the function with the provided assertion\nassert find_Points(5, 10, 1, 5) == (1, 10)"}
{"task_id": "MBPP/657", "entry_point": "first_Digit", "completion": "import math\n\ndef first_Digit(n):\n    # Calculate the factorial of n\n    factorial_value = math.factorial(n)\n    # Convert the factorial to string and get the first character\n    first_digit = str(factorial_value)[0]\n    # Convert the first character back to an integer\n    return int(first_digit)\n\n# Test the function with the provided assertion\nassert first_Digit(5) == 1"}
{"task_id": "MBPP/668", "entry_point": "replace", "completion": "def replace(string, char):\n    # Replace multiple occurrences of 'char' with a single 'char'\n    return ''.join(char if c == char and (i == 0 or string[i-1] != char) else c for i, c in enumerate(string))\n\n# Test the function with the provided assertion\nassert replace('peep', 'e') == 'pep'"}
{"task_id": "MBPP/665", "entry_point": "move_last", "completion": "def move_last(lst):\n    if lst:  # Check if the list is not empty\n        return lst[1:] + [lst[0]]\n    return lst  # Return the original list if it's empty\n\n# Test the function with the provided assertion\nassert move_last([1, 2, 3, 4]) == [2, 3, 4, 1]"}
{"task_id": "MBPP/667", "entry_point": "Check_Vow", "completion": "def Check_Vow(string, vowels):\n    # Convert the vowels string to a set for faster lookup\n    vowel_set = set(vowels.lower())\n    # Count the number of vowels in the string\n    count = sum(1 for char in string.lower() if char in vowel_set)\n    return count\n\n# Test the function with the provided assertion\nassert Check_Vow('corner', 'AaEeIiOoUu') == 2"}
{"task_id": "MBPP/661", "entry_point": "max_sum_of_three_consecutive", "completion": "def max_sum_of_three_consecutive(arr, n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return arr[0]\n    if n == 2:\n        return arr[0] + arr[1]\n    \n    # Create a dp array to store the maximum sums\n    dp = [0] * n\n    \n    # Base cases\n    dp[0] = arr[0]\n    dp[1] = arr[0] + arr[1]\n    dp[2] = max(arr[0] + arr[1], arr[1] + arr[2], arr[0] + arr[2])\n    \n    # Fill the dp array\n    for i in range(3, n):\n        dp[i] = max(dp[i-1],  # Skip current element\n                     dp[i-2] + arr[i],  # Include current element\n                     dp[i-3] + arr[i-1] + arr[i])  # Include current and previous element\n    \n    return dp[n-1]\n\n# Test the function with the provided assertion\nassert max_sum_of_three_consecutive([100, 1000, 100, 1000, 1], 5) == 2101"}
{"task_id": "MBPP/670", "entry_point": "decreasing_trend", "completion": "def decreasing_trend(sequence):\n    # Check if the sequence is empty or has only one element\n    if len(sequence) < 2:\n        return False\n    \n    # Iterate through the sequence and check for decreasing trend\n    for i in range(1, len(sequence)):\n        if sequence[i] >= sequence[i - 1]:\n            return False\n            \n    return True\n\n# Test the function with the provided assertion\nassert decreasing_trend([-4, -3, -2, -1]) == True"}
{"task_id": "MBPP/672", "entry_point": "max_of_three", "completion": "def max_of_three(a, b, c):\n    return max(a, b, c)\n\n# Test the function\nassert max_of_three(10, 20, 30) == 30"}
{"task_id": "MBPP/673", "entry_point": "convert", "completion": "def convert(int_list):\n    # Convert each integer to a string and join them together\n    combined_str = ''.join(map(str, int_list))\n    # Convert the combined string back to an integer\n    return int(combined_str)\n\n# Test the function with the provided assertion\nassert convert([1, 2, 3]) == 123"}
{"task_id": "MBPP/663", "entry_point": "find_max_val", "completion": "def find_max_val(x, y, limit):\n    if y >= x:\n        raise ValueError(\"y must be less than x for the modulo operation to be valid.\")\n    \n    # Calculate the largest k such that k % x = y\n    # k = n * x + y, where n is the largest integer such that k <= limit\n    n = (limit - y) // x  # Find the largest n\n    k = n * x + y  # Calculate k\n    \n    return k\n\n# Test the function with the provided assertion\nassert find_max_val(15, 10, 5) == 15"}
{"task_id": "MBPP/669", "entry_point": "check_IP", "completion": "import re\n\ndef check_IP(ip):\n    # Regular expression for validating an IPv4 address\n    pattern = r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'\n    \n    if re.match(pattern, ip):\n        return 'Valid IP address'\n    else:\n        return 'Invalid IP address'\n\n# Test the function\nassert check_IP(\"192.168.0.1\") == 'Valid IP address'"}
{"task_id": "MBPP/666", "entry_point": "count_char", "completion": "def count_char(string, char):\n    return string.count(char)\n\n# Test the function with the provided assertion\nassert count_char(\"Python\", 'o') == 1"}
{"task_id": "MBPP/678", "entry_point": "remove_spaces", "completion": "def remove_spaces(input_string):\n    return input_string.replace(\" \", \"\")\n\n# Test the function\nassert remove_spaces(\"a b c\") == \"abc\""}
{"task_id": "MBPP/676", "entry_point": "remove_extra_char", "completion": "import re\n\ndef remove_extra_char(s):\n    # Use regex to replace non-alphanumeric characters with an empty string\n    return re.sub(r'[^a-zA-Z0-9]', '', s)\n\n# Test the function with the provided assertion\nassert remove_extra_char('**//Google Android// - 12. ') == 'GoogleAndroid12'"}
{"task_id": "MBPP/674", "entry_point": "remove_duplicate", "completion": "from collections import OrderedDict\n\ndef remove_duplicate(input_string):\n    # Split the string into words\n    words = input_string.split()\n    # Use OrderedDict to remove duplicates while preserving order\n    unique_words = list(OrderedDict.fromkeys(words))\n    # Join the unique words back into a string\n    return ' '.join(unique_words)\n\n# Test the function with the provided assertion\nassert remove_duplicate(\"Python Exercises Practice Solution Exercises\") == \"Python Exercises Practice Solution\""}
{"task_id": "MBPP/675", "entry_point": "sum_nums", "completion": "def sum_nums(a, b, lower, upper):\n    total = a + b\n    if lower <= total <= upper:\n        return 20\n    return total\n\n# Example assertion to test the function\nassert sum_nums(2, 10, 11, 20) == 20"}
{"task_id": "MBPP/679", "entry_point": "access_key", "completion": "def access_key(d, index):\n    # Get the list of keys from the dictionary\n    keys = list(d.keys())\n    # Return the key at the specified index\n    return keys[index]\n\n# Test the function with the provided assertion\nassert access_key({'physics': 80, 'math': 90, 'chemistry': 86}, 0) == 'physics'"}
{"task_id": "MBPP/671", "entry_point": "set_Right_most_Unset_Bit", "completion": "def set_Right_most_Unset_Bit(n):\n    # Find the rightmost unset bit and set it\n    return n | (n + 1) & ~(n)\n\n# Test the function with the provided assertion\nassert set_Right_most_Unset_Bit(21) == 23"}
{"task_id": "MBPP/681", "entry_point": "smallest_Divisor", "completion": "def smallest_Divisor(n):\n    if n <= 1:\n        return None  # No prime divisors for numbers less than or equal to 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return i\n    return n  # If no divisors found, n is prime\n\n# Test the function with the provided assertion\nassert smallest_Divisor(10) == 2"}
{"task_id": "MBPP/688", "entry_point": "len_complex", "completion": "import math\n\ndef len_complex(real, imag):\n    return math.sqrt(real**2 + imag**2)\n\n# Test the function with the provided assertion\nassert len_complex(3, 4) == 5.0"}
{"task_id": "MBPP/680", "entry_point": "increasing_trend", "completion": "def increasing_trend(sequence):\n    # Check if the sequence is empty or has only one element\n    if len(sequence) < 2:\n        return True\n    \n    # Iterate through the sequence and check if each number is less than the next\n    for i in range(len(sequence) - 1):\n        if sequence[i] >= sequence[i + 1]:\n            return False\n            \n    return True\n\n# Test the function with the provided assertion\nassert increasing_trend([1, 2, 3, 4]) == True"}
{"task_id": "MBPP/686", "entry_point": "freq_element", "completion": "def freq_element(elements):\n    frequency = {}\n    for element in elements:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return str(frequency)\n\n# Test the function with the provided assertion\nassert freq_element((4, 5, 4, 5, 6, 6, 5, 5, 4)) == '{4: 3, 5: 4, 6: 2}'"}
{"task_id": "MBPP/685", "entry_point": "sum_Of_Primes", "completion": "def is_prime(num):\n    \"\"\"Check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef sum_Of_Primes(n):\n    \"\"\"Return the sum of all prime numbers between 1 and n.\"\"\"\n    return sum(num for num in range(2, n + 1) if is_prime(num))\n\n# Test the function\nassert sum_Of_Primes(10) == 17"}
{"task_id": "MBPP/687", "entry_point": "recur_gcd", "completion": "def recur_gcd(a, b):\n    # Base case: if b is 0, return a\n    if b == 0:\n        return a\n    # Recursive case: call recur_gcd with b and the remainder of a divided by b\n    return recur_gcd(b, a % b)\n\n# Test the function with the provided assertion\nassert recur_gcd(12, 14) == 2"}
{"task_id": "MBPP/677", "entry_point": "validity_triangle", "completion": "def validity_triangle(angle1, angle2, angle3):\n    # Check if the sum of the angles is 180 and each angle is greater than 0\n    return angle1 > 0 and angle2 > 0 and angle3 > 0 and (angle1 + angle2 + angle3) == 180\n\n# Test the function with the provided assertion\nassert validity_triangle(60, 50, 90) == False"}
{"task_id": "MBPP/682", "entry_point": "mul_list", "completion": "def mul_list(list1, list2):\n    return list(map(lambda x, y: x * y, list1, list2))\n\n# Test the function with the provided assertion\nassert mul_list([1, 2, 3], [4, 5, 6]) == [4, 10, 18]"}
{"task_id": "MBPP/684", "entry_point": "count_Char", "completion": "def count_Char(s, char, n):\n    # Count occurrences of char in the original string\n    count_in_s = s.count(char)\n    \n    # Calculate how many times the string is repeated\n    full_repeats = n // len(s)\n    \n    # Count occurrences in the full repeats\n    total_count = full_repeats * count_in_s\n    \n    # Count occurrences in the remaining part of the string\n    remainder = n % len(s)\n    total_count += s[:remainder].count(char)\n    \n    return total_count\n\n# Example usage\nrepeated_string = \"abcac\"\nn = 10  # Length of the repeated string\nchar_to_count = 'a'\nresult = count_Char(repeated_string, char_to_count, n)\nassert result == 4"}
{"task_id": "MBPP/689", "entry_point": "min_jumps", "completion": "def min_jumps(arr, n):\n    if n <= 1:\n        return 0\n\n    jumps = 0\n    current_end = 0\n    farthest = 0\n\n    for i in range(n - 1):\n        farthest = max(farthest, i + arr[i])\n        \n        if i == current_end:\n            jumps += 1\n            current_end = farthest\n            \n            if current_end >= n - 1:\n                break\n\n    return jumps if current_end >= n - 1 else float('inf')\n\n# Test the function with the provided assertion\nassert min_jumps([1, 3, 6, 1, 0, 9], 6) == 3"}
{"task_id": "MBPP/683", "entry_point": "sum_Square", "completion": "def sum_Square(n):\n    if n < 0:\n        return False\n    if n == 0:\n        return True\n    \n    # Check for the prime factors of the form 4k + 3\n    def is_sum_of_two_squares(num):\n        while num % 4 == 0:\n            num //= 4\n        if num % 8 == 7:\n            return False\n        return True\n    \n    return is_sum_of_two_squares(n)\n\n# Test the function with the provided assertion\nassert sum_Square(25) == True"}
{"task_id": "MBPP/690", "entry_point": "mul_consecutive_nums", "completion": "def mul_consecutive_nums(nums):\n    if not nums:\n        return []\n    \n    result = []\n    for i in range(len(nums) - 1):\n        result.append(nums[i] * nums[i + 1])\n    \n    # Append the last number as it is not multiplied with any next number\n    result.append(nums[-1])\n    \n    return result\n\n# Test the function with the provided assertion\nassert mul_consecutive_nums([1, 1, 3, 4, 4, 5, 6, 7]) == [1, 3, 12, 16, 20, 30, 42]"}
{"task_id": "MBPP/693", "entry_point": "remove_multiple_spaces", "completion": "import re\n\ndef remove_multiple_spaces(input_string):\n    # Use regex to replace multiple spaces with a single space\n    return re.sub(r'\\s+', ' ', input_string).strip()\n\n# Test the function with the provided assertion\nassert remove_multiple_spaces('Google      Assistant') == 'Google Assistant'"}
{"task_id": "MBPP/692", "entry_point": "last_Two_Digits", "completion": "def last_Two_Digits(n):\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    \n    factorial = 1\n    for i in range(2, n + 1):\n        factorial *= i\n    \n    return factorial % 100\n\n# Test the function with the provided assertion\nassert last_Two_Digits(7) == 40"}
{"task_id": "MBPP/691", "entry_point": "group_element", "completion": "def group_element(tuple_list):\n    grouped = {}\n    for first, second in tuple_list:\n        if second not in grouped:\n            grouped[second] = []\n        grouped[second].append(first)\n    return grouped\n\n# Test the function with the provided assertion\nassert group_element([(6, 5), (2, 7), (2, 5), (8, 7), (9, 8), (3, 7)]) == {5: [6, 2], 7: [2, 8, 3], 8: [9]}"}
{"task_id": "MBPP/697", "entry_point": "count_even", "completion": "def count_even(numbers):\n    return len(list(filter(lambda x: x % 2 == 0, numbers)))\n\n# Test the function with the provided assertion\nassert count_even([1, 2, 3, 5, 7, 8, 9, 10]) == 3"}
{"task_id": "MBPP/694", "entry_point": "extract_unique", "completion": "def extract_unique(input_dict):\n    unique_values = set()  # Use a set to store unique values\n    for value_list in input_dict.values():\n        unique_values.update(value_list)  # Add values to the set\n    return sorted(unique_values)  # Return a sorted list of unique values\n\n# Test the function with the provided assertion\nassert extract_unique({'msm': [5, 6, 7, 8], 'is': [10, 11, 7, 5], 'best': [6, 12, 10, 8], 'for': [1, 2, 5]}) == [1, 2, 5, 6, 7, 8, 10, 11, 12]"}
{"task_id": "MBPP/695", "entry_point": "check_greater", "completion": "def check_greater(tuple1, tuple2):\n    # Check if the lengths of the tuples are the same\n    if len(tuple1) != len(tuple2):\n        return False\n    \n    # Check if each element in tuple2 is greater than the corresponding element in tuple1\n    for i in range(len(tuple1)):\n        if tuple2[i] <= tuple1[i]:\n            return False\n            \n    return True\n\n# Test the function with the provided assertion\nassert check_greater((10, 4, 5), (13, 5, 18)) == True"}
{"task_id": "MBPP/696", "entry_point": "zip_list", "completion": "def zip_list(list1, list2):\n    # Use zip to combine the two lists and then flatten the result\n    return [sublist1 + sublist2 for sublist1, sublist2 in zip(list1, list2)]\n\n# Test the function with the provided assertion\nassert zip_list([[1, 3], [5, 7], [9, 11]], [[2, 4], [6, 8], [10, 12, 14]]) == [[1, 3, 2, 4], [5, 7, 6, 8], [9, 11, 10, 12, 14]]"}
{"task_id": "MBPP/700", "entry_point": "count_range_in_list", "completion": "def count_range_in_list(lst, lower, upper):\n    count = 0\n    for num in lst:\n        if lower <= num <= upper:\n            count += 1\n    return count\n\n# Test the function with the provided assertion\nassert count_range_in_list([10, 20, 30, 40, 40, 40, 70, 80, 99], 40, 100) == 6"}
{"task_id": "MBPP/703", "entry_point": "is_key_present", "completion": "def is_key_present(dictionary, key):\n    return key in dictionary\n\n# Test the function with the provided assertion\nassert is_key_present({1: 10, 2: 20, 3: 30, 4: 40, 5: 50, 6: 60}, 5) == True"}
{"task_id": "MBPP/701", "entry_point": "equilibrium_index", "completion": "def equilibrium_index(arr):\n    total_sum = sum(arr)\n    left_sum = 0\n    \n    for i in range(len(arr)):\n        # Right sum is total_sum - left_sum - arr[i]\n        right_sum = total_sum - left_sum - arr[i]\n        \n        if left_sum == right_sum:\n            return i\n        \n        left_sum += arr[i]\n    \n    return -1  # Return -1 if no equilibrium index is found\n\n# Test the function with the provided assertion\nassert equilibrium_index([1, 2, 3, 4, 1, 2, 3]) == 3"}
{"task_id": "MBPP/704", "entry_point": "harmonic_sum", "completion": "def harmonic_sum(n):\n    if n < 1:\n        return 0  # Return 0 for n <= 1 as there are no terms to sum\n    return sum(1 / i for i in range(1, n))\n\n# Test the function with the provided assertion\nassert harmonic_sum(10) == 2.9289682539682538"}
{"task_id": "MBPP/698", "entry_point": "sort_dict_item", "completion": "def sort_dict_item(d):\n    # Sort the dictionary items based on the product of the tuple keys\n    sorted_items = sorted(d.items(), key=lambda item: item[0][0] * item[0][1])\n    # Convert the sorted items back to a dictionary\n    return dict(sorted_items)\n\n# Test the function with the provided assertion\nassert sort_dict_item({(5, 6): 3, (2, 3): 9, (8, 4): 10, (6, 4): 12}) == {(2, 3): 9, (6, 4): 12, (5, 6): 3, (8, 4): 10}"}
{"task_id": "MBPP/708", "entry_point": "Convert", "completion": "def Convert(input_string):\n    # Split the string by spaces and return the list of words\n    return input_string.split()\n\n# Test the function with the provided assertion\nassert Convert('python program') == ['python', 'program']"}
{"task_id": "MBPP/706", "entry_point": "is_subset", "completion": "def is_subset(arr1, n, arr2, m):\n    # Convert the second array to a set for O(1) lookups\n    set_arr2 = set(arr2)\n    \n    # Check if all elements of arr1 are in set_arr2\n    for element in arr1:\n        if element not in set_arr2:\n            return False\n    return True\n\n# Test the function with the provided assertion\nassert is_subset([11, 1, 13, 21, 3, 7], 6, [11, 3, 7, 1], 4) == True"}
{"task_id": "MBPP/707", "entry_point": "count_Set_Bits", "completion": "def count_Set_Bits(n):\n    count = 0\n    for i in range(1, n + 1):\n        count += bin(i).count('1')\n    return count\n\n# Test the function with the provided assertion\nassert count_Set_Bits(16) == 33\n\n# You can also print the result to verify\nprint(count_Set_Bits(16))  # Output: 33"}
{"task_id": "MBPP/705", "entry_point": "sort_sublists", "completion": "def sort_sublists(lst):\n    return sorted(lst, key=lambda x: (len(x), x))\n\n# Test the function with the provided assertion\nassert sort_sublists([[2], [0], [1, 3], [0, 7], [9, 11], [13, 15, 17]]) == [[0], [2], [0, 7], [1, 3], [9, 11], [13, 15, 17]]"}
{"task_id": "MBPP/699", "entry_point": "min_Swaps", "completion": "def min_Swaps(s1: str, s2: str) -> int:\n    if len(s1) != len(s2):\n        return -1  # Strings must be of the same length\n    \n    # Count the number of '1's and '0's in both strings\n    count1 = [0, 0]  # count1[0] for '0's, count1[1] for '1's\n    count2 = [0, 0]  # count2[0] for '0's, count2[1] for '1's\n    \n    for char in s1:\n        count1[int(char)] += 1\n    for char in s2:\n        count2[int(char)] += 1\n    \n    # If the counts of '1's and '0's are not the same, return -1\n    if count1 != count2:\n        return -1\n    \n    # Find the positions where the characters differ\n    mismatches = []\n    for i in range(len(s1)):\n        if s1[i] != s2[i]:\n            mismatches.append((s1[i], s2[i]))\n    \n    # Count the number of swaps needed\n    # Each swap can fix two mismatches\n    swaps = 0\n    count_01 = 0  # Count of '0' in s1 and '1' in s2\n    count_10 = 0  # Count of '1' in s1 and '0' in s2\n    \n    for m in mismatches:\n        if m == ('0', '1'):\n            count_01 += 1\n        elif m == ('1', '0'):\n            count_10 += 1\n    \n    # The number of swaps needed is the maximum of the two counts\n    swaps = max(count_01, count_10)\n    \n    return swaps\n\n# Test the function with the provided assertion\nassert min_Swaps(\"1101\", \"1110\") == 1"}
{"task_id": "MBPP/713", "entry_point": "check_valid", "completion": "def check_valid(tup):\n    # Check if all elements in the tuple are boolean values\n    return all(isinstance(x, bool) for x in tup)\n\n# Test the function with the provided assertion\nassert check_valid((True, True, True, True)) == True"}
{"task_id": "MBPP/710", "entry_point": "front_and_rear", "completion": "def front_and_rear(record):\n    # Access the first and last elements of the tuple\n    return (record[0], record[-1])\n\n# Test the function with the provided assertion\nassert front_and_rear((10, 4, 5, 6, 7)) == (10, 7)"}
{"task_id": "MBPP/715", "entry_point": "str_to_tuple", "completion": "def str_to_tuple(s):\n    # Split the string by commas and convert each part to an integer\n    return tuple(int(num.strip()) for num in s.split(','))\n\n# Test the function with the provided assertion\nassert str_to_tuple(\"1, -5, 4, 6, 7\") == (1, -5, 4, 6, 7)"}
{"task_id": "MBPP/716", "entry_point": "rombus_perimeter", "completion": "def rombus_perimeter(side_length):\n    return 4 * side_length\n\n# Test the function with the provided assertion\nassert rombus_perimeter(10) == 40"}
{"task_id": "MBPP/718", "entry_point": "alternate_elements", "completion": "def alternate_elements(input_list):\n    return input_list[::2]\n\n# Test the function with the provided assertion\nassert alternate_elements([\"red\", \"black\", \"white\", \"green\", \"orange\"]) == ['red', 'white', 'orange']"}
{"task_id": "MBPP/712", "entry_point": "remove_duplicate", "completion": "def remove_duplicate(lst):\n    seen = set()\n    result = []\n    for sublist in lst:\n        # Convert the sublist to a tuple (which is hashable) to check for duplicates\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple not in seen:\n            seen.add(sublist_tuple)\n            result.append(sublist)\n    return result\n\n# Test the function with the provided assertion\nassert remove_duplicate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [[10, 20], [40], [30, 56, 25], [33]]"}
{"task_id": "MBPP/702", "entry_point": "removals", "completion": "def removals(arr, n, k):\n    # Sort the array\n    arr.sort()\n    \n    left = 0\n    max_length = 0\n    \n    # Use two pointers to find the longest valid subarray\n    for right in range(len(arr)):\n        # While the condition is not met, move the left pointer\n        while arr[right] - arr[left] > k:\n            left += 1\n        # Calculate the length of the current valid subarray\n        max_length = max(max_length, right - left + 1)\n    \n    # The number of elements to remove is the total elements minus the length of the longest valid subarray\n    return len(arr) - max_length\n\n# Test the function with the provided assertion\nassert removals([1, 3, 4, 9, 10, 11, 12, 17, 20], 9, 4) == 5"}
{"task_id": "MBPP/709", "entry_point": "get_unique", "completion": "def get_unique(pairs):\n    value_to_keys = {}\n    \n    for key, value in pairs:\n        if value not in value_to_keys:\n            value_to_keys[value] = set()  # Use a set to store unique keys\n        value_to_keys[value].add(key)\n    \n    # Count the unique keys for each value\n    unique_counts = {value: len(keys) for value, keys in value_to_keys.items()}\n    \n    # Format the output as a string\n    return str(unique_counts)\n\n# Test the function with the provided assertion\nassert get_unique([(3, 4), (1, 2), (2, 4), (8, 2), (7, 2), (8, 1), (9, 1), (8, 4), (10, 4)]) == '{4: 4, 2: 3, 1: 2}'"}
{"task_id": "MBPP/717", "entry_point": "sd_calc", "completion": "import math\n\ndef sd_calc(data):\n    if len(data) == 0:\n        raise ValueError(\"The data list cannot be empty.\")\n    \n    mean = sum(data) / len(data)\n    variance = sum((x - mean) ** 2 for x in data) / len(data)\n    return math.sqrt(variance)\n\n# Test the function with the provided assertion\nassert sd_calc([4, 2, 5, 8, 6]) == 2.23606797749979"}
{"task_id": "MBPP/720", "entry_point": "add_dict_to_tuple", "completion": "def add_dict_to_tuple(tup, dictionary):\n    return tup + (dictionary,)\n\n# Test the function with the provided assertion\nassert add_dict_to_tuple((4, 5, 6), {\"MSAM\": 1, \"is\": 2, \"best\": 3}) == (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})"}
{"task_id": "MBPP/711", "entry_point": "product_Equal", "completion": "def product_Equal(number):\n    # Convert the number to a string to easily access each digit\n    num_str = str(number)\n    \n    # Initialize products for even and odd positioned digits\n    product_even = 1\n    product_odd = 1\n    \n    # Iterate through the digits and their indices\n    for index, digit in enumerate(num_str):\n        digit_value = int(digit)\n        # Check if the index is even or odd\n        if index % 2 == 0:  # Even index\n            product_even *= digit_value\n        else:  # Odd index\n            product_odd *= digit_value\n    \n    # Compare the products\n    return product_even == product_odd\n\n# Test the function with the provided assertion\nassert product_Equal(2841) == True"}
{"task_id": "MBPP/722", "entry_point": "filter_data", "completion": "def filter_data(students, min_height, min_weight):\n    filtered_students = {}\n    for name, (height, weight) in students.items():\n        if height >= min_height and weight >= min_weight:\n            filtered_students[name] = (height, weight)\n    return filtered_students\n\n# Example usage\nassert filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)}, 6.0, 70) == {'Cierra Vega': (6.2, 70)}"}
{"task_id": "MBPP/719", "entry_point": "text_match", "completion": "import re\n\ndef text_match(text):\n    # Define the regex pattern for 'a' followed by zero or more 'b's\n    pattern = r'a(b*)'\n    \n    # Use re.fullmatch to check if the entire string matches the pattern\n    if re.fullmatch(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'No match found.'\n\n# Test the function\nassert text_match(\"ac\") == 'No match found.'\nassert text_match(\"ab\") == 'Found a match!'\nassert text_match(\"a\") == 'Found a match!'\nassert text_match(\"abb\") == 'Found a match!'\nassert text_match(\"abc\") == 'No match found.'"}
{"task_id": "MBPP/724", "entry_point": "power_base_sum", "completion": "def power_base_sum(base, power):\n    # Calculate base raised to the power\n    result = base ** power\n    \n    # Convert the result to a string and sum the digits\n    digit_sum = sum(int(digit) for digit in str(result))\n    \n    return digit_sum\n\n# Test the function with the provided assertion\nassert power_base_sum(2, 100) == 115"}
{"task_id": "MBPP/725", "entry_point": "extract_quotation", "completion": "import re\n\ndef extract_quotation(s):\n    # Use regex to find all occurrences of text within double quotes\n    return re.findall(r'\"(.*?)\"', s)\n\n# Test the function with the provided assertion\nassert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']"}
{"task_id": "MBPP/729", "entry_point": "add_list", "completion": "def add_list(list1, list2):\n    return list(map(lambda x, y: x + y, list1, list2))\n\n# Test the function with the provided assertion\nassert add_list([1, 2, 3], [4, 5, 6]) == [5, 7, 9]"}
{"task_id": "MBPP/727", "entry_point": "remove_char", "completion": "import re\n\ndef remove_char(input_string):\n    # Use regex to replace all non-alphanumeric characters with an empty string\n    return re.sub(r'[^a-zA-Z0-9]', '', input_string)\n\n# Test the function with the provided assertion\nassert remove_char(\"123abcjw:, .@! eiw\") == '123abcjweiw'"}
{"task_id": "MBPP/728", "entry_point": "sum_list", "completion": "def sum_list(list1, list2):\n    return [a + b for a, b in zip(list1, list2)]\n\n# Test the function with the provided assertion\nassert sum_list([10, 20, 30], [15, 25, 35]) == [25, 45, 65]"}
{"task_id": "MBPP/714", "entry_point": "count_Fac", "completion": "def count_Fac(n):\n    if n < 2:\n        return 0\n    \n    distinct_prime_factors = set()\n    \n    # Check for number of 2s that divide n\n    while n % 2 == 0:\n        distinct_prime_factors.add(2)\n        n //= 2\n    \n    # n must be odd at this point, so we can skip even numbers\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            distinct_prime_factors.add(i)\n            n //= i\n    \n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        distinct_prime_factors.add(n)\n    \n    return len(distinct_prime_factors)\n\n# Test the function with the provided assertion\nassert count_Fac(24) == 3"}
{"task_id": "MBPP/726", "entry_point": "multiply_elements", "completion": "def multiply_elements(input_tuple):\n    # Use a list comprehension to multiply adjacent elements\n    return tuple(input_tuple[i] * input_tuple[i + 1] for i in range(len(input_tuple) - 1))\n\n# Test the function with the provided assertion\nassert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)\n\n# You can also print the result to verify\nprint(multiply_elements((1, 5, 7, 8, 10)))  # Output: (5, 35, 56, 80)"}
{"task_id": "MBPP/731", "entry_point": "lateralsurface_cone", "completion": "import math\n\ndef lateralsurface_cone(radius, slant_height):\n    return math.pi * radius * slant_height\n\n# Test the function with the provided assertion\nassert lateralsurface_cone(5, 12) == 204.20352248333654"}
{"task_id": "MBPP/730", "entry_point": "consecutive_duplicates", "completion": "def consecutive_duplicates(lst):\n    if not lst:\n        return []\n    \n    result = [lst[0]]  # Start with the first element\n    \n    for i in range(1, len(lst)):\n        if lst[i] != lst[i - 1]:  # Check if the current element is different from the last added\n            result.append(lst[i])\n    \n    return result\n\n# Test the function with the provided assertion\nassert consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]"}
{"task_id": "MBPP/723", "entry_point": "count_same_pair", "completion": "def count_same_pair(list1, list2):\n    # Use map to create a list of boolean values indicating if the elements are the same\n    same_pairs = map(lambda x, y: x == y, list1, list2)\n    # Count the number of True values in the resulting map\n    return sum(same_pairs)\n\n# Test the function with the provided assertion\nassert count_same_pair([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9]) == 4"}
{"task_id": "MBPP/732", "entry_point": "replace_specialchar", "completion": "def replace_specialchar(text):\n    # Replace spaces, commas, and dots with a colon\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')\n\n# Test the function with the provided assertion\nassert replace_specialchar('Python language, Programming language.') == 'Python:language::Programming:language:'"}
{"task_id": "MBPP/721", "entry_point": "maxAverageOfPath", "completion": "def maxAverageOfPath(matrix, n):\n    def dfs(x, y, current_sum, steps):\n        # If we reach the bottom-right corner, calculate the average\n        if x == n - 1 and y == n - 1:\n            return (current_sum + matrix[x][y]) / (steps + 1)\n        \n        # Mark the current cell as visited\n        visited.add((x, y))\n        max_avg = float('-inf')\n        \n        # Explore the four possible directions (down, up, right, left)\n        for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:\n                avg = dfs(nx, ny, current_sum + matrix[x][y], steps + 1)\n                max_avg = max(max_avg, avg)\n        \n        # Unmark the current cell (backtrack)\n        visited.remove((x, y))\n        return max_avg\n\n    visited = set()\n    return dfs(0, 0, 0, 0)\n\n# Test the function with the provided assertion\nassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2"}
{"task_id": "MBPP/737", "entry_point": "check_str", "completion": "import re\n\ndef check_str(s):\n    # Check if the string starts with a vowel (case insensitive)\n    if re.match(r'^[aeiouAEIOU]', s):\n        return 'Valid'\n    else:\n        return 'Invalid'\n\n# Test the function\nassert check_str(\"annie\") == 'Valid'"}
{"task_id": "MBPP/733", "entry_point": "find_first_occurrence", "completion": "def find_first_occurrence(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1  # Initialize result to -1, indicating not found\n\n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            result = mid  # Update result to the current mid index\n            right = mid - 1  # Continue searching in the left half\n        elif arr[mid] < target:\n            left = mid + 1  # Search in the right half\n        else:\n            right = mid - 1  # Search in the left half\n\n    return result\n\n# Test the function with the provided assertion\nassert find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 1"}
{"task_id": "MBPP/735", "entry_point": "toggle_middle_bits", "completion": "def toggle_middle_bits(n):\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # If the number has less than 3 bits, return it as is\n    if len(binary) <= 2:\n        return n\n    \n    # Toggle the middle bits\n    middle_bits = list(binary[1:-1])  # Get the middle bits\n    for i in range(len(middle_bits)):\n        middle_bits[i] = '1' if middle_bits[i] == '0' else '0'  # Toggle the bit\n    \n    # Reconstruct the binary number\n    new_binary = binary[0] + ''.join(middle_bits) + binary[-1]\n    \n    # Convert back to decimal\n    return int(new_binary, 2)\n\n# Test the function with the provided assertion\nassert toggle_middle_bits(9) == 15"}
{"task_id": "MBPP/736", "entry_point": "left_insertion", "completion": "def left_insertion(sorted_list, value):\n    low, high = 0, len(sorted_list)\n    \n    while low < high:\n        mid = (low + high) // 2\n        if sorted_list[mid] < value:\n            low = mid + 1\n        else:\n            high = mid\n            \n    return low\n\n# Test the function with the provided assertion\nassert left_insertion([1, 2, 4, 5], 6) == 4"}
{"task_id": "MBPP/734", "entry_point": "sum_Of_Subarray_Prod", "completion": "def sum_Of_Subarray_Prod(arr, n):\n    total_sum = 0\n    \n    # Iterate over all possible starting points of subarrays\n    for i in range(n):\n        product = 1\n        \n        # Iterate over all possible ending points of subarrays\n        for j in range(i, n):\n            product *= arr[j]  # Calculate the product of the current subarray\n            total_sum += product  # Add the product to the total sum\n            \n    return total_sum\n\n# Test the function with the provided assertion\nassert sum_Of_Subarray_Prod([1, 2, 3], 3) == 20"}
{"task_id": "MBPP/740", "entry_point": "tuple_to_dict", "completion": "def tuple_to_dict(tup):\n    # Create a dictionary from the tuple using adjacent elements\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup) - 1, 2)}\n\n# Test the function with the provided assertion\nassert tuple_to_dict((1, 5, 7, 10, 13, 5)) == {1: 5, 7: 10, 13: 5}"}
{"task_id": "MBPP/741", "entry_point": "all_Characters_Same", "completion": "def all_Characters_Same(s):\n    if not s:  # Check if the string is empty\n        return True  # Consider empty string as having all same characters\n    return all(char == s[0] for char in s)\n\n# Test the function with the provided assertion\nassert all_Characters_Same(\"python\") == False"}
{"task_id": "MBPP/742", "entry_point": "area_tetrahedron", "completion": "import math\n\ndef area_tetrahedron(a):\n    return math.sqrt(3) * a**2\n\n# Test the function with the provided assertion\nassert area_tetrahedron(3) == 15.588457268119894"}
{"task_id": "MBPP/744", "entry_point": "check_none", "completion": "def check_none(tup):\n    return any(item is None for item in tup)\n\n# Test the function with the provided assertion\nassert check_none((10, 4, 5, 6, None)) == True"}
{"task_id": "MBPP/743", "entry_point": "rotate_right", "completion": "def rotate_right(lst, num_positions, length):\n    # Normalize the number of positions to rotate\n    num_positions = num_positions % length\n    # Rotate the list\n    return lst[-num_positions:] + lst[:-num_positions]\n\n# Test the function with the provided assertion\nassert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3, 10) == [8, 9, 10, 1, 2, 3, 4, 5, 6]"}
{"task_id": "MBPP/738", "entry_point": "geometric_sum", "completion": "def geometric_sum(n):\n    if n <= 1:\n        return 0  # If n is 1 or less, the sum is 0 since there are no terms.\n    a = 1  # First term\n    r = 0.5  # Common ratio\n    num_terms = n - 1  # Number of terms\n    return a * (1 - r**num_terms) / (1 - r)\n\n# Test the function with the provided assertion\nassert geometric_sum(7) == 1.9921875"}
{"task_id": "MBPP/739", "entry_point": "find_Index", "completion": "def find_Index(n):\n    # Calculate the minimum value for a number to have n digits\n    min_value = 10 ** (n - 1)\n    \n    k = 1\n    while True:\n        # Calculate the k-th triangular number\n        triangular_number = k * (k + 1) // 2\n        \n        # Check if it has at least n digits\n        if triangular_number >= min_value:\n            return k\n        \n        k += 1\n\n# Test the function with the provided assertion\nassert find_Index(2) == 4"}
{"task_id": "MBPP/750", "entry_point": "add_tuple", "completion": "def add_tuple(lst, tup):\n    # Convert the tuple to a list and extend the original list with it\n    lst.extend(tup)\n    return lst\n\n# Test the function with the provided assertion\nassert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]"}
{"task_id": "MBPP/746", "entry_point": "sector_area", "completion": "import math\n\ndef sector_area(radius, angle):\n    return (angle / 360) * math.pi * (radius ** 2)\n\n# Test the function with the provided assertion\nassert sector_area(4, 45) == 6.285714285714286"}
{"task_id": "MBPP/755", "entry_point": "second_smallest", "completion": "def second_smallest(numbers):\n    # Remove duplicates by converting the list to a set\n    unique_numbers = list(set(numbers))\n    \n    # Sort the unique numbers\n    unique_numbers.sort()\n    \n    # Return the second smallest number if it exists\n    if len(unique_numbers) >= 2:\n        return unique_numbers[1]\n    else:\n        raise ValueError(\"List must contain at least two unique numbers.\")\n\n# Test the function with the provided assertion\nassert second_smallest([1, 2, -8, -2, 0, -2]) == -2"}
{"task_id": "MBPP/752", "entry_point": "jacobsthal_num", "completion": "def jacobsthal_num(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return jacobsthal_num(n - 2) + 2 * jacobsthal_num(n - 1)\n\n# Test the function with the provided assertion\nassert jacobsthal_num(5) == 11"}
{"task_id": "MBPP/748", "entry_point": "capital_words_spaces", "completion": "import re\n\ndef capital_words_spaces(s):\n    # Use regex to find capital letters and add a space before them\n    return re.sub(r'(?<!^)(?=[A-Z])', ' ', s)\n\n# Test the function with the provided assertion\nassert capital_words_spaces(\"Python\") == 'Python'\n\n# Example usage\nprint(capital_words_spaces(\"HelloWorld\"))  # Output: 'Hello World'\nprint(capital_words_spaces(\"ThisIsATest\"))  # Output: 'This Is A Test'"}
{"task_id": "MBPP/745", "entry_point": "divisible_by_digits", "completion": "def divisible_by_digits(start, end):\n    result = []\n    for num in range(start, end + 1):\n        str_num = str(num)\n        if all(int(digit) != 0 and num % int(digit) == 0 for digit in str_num):\n            result.append(num)\n    return result\n\n# Test the function with the provided assertion\nassert divisible_by_digits(1, 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]"}
{"task_id": "MBPP/753", "entry_point": "min_k", "completion": "def min_k(records, k):\n    # Sort the records based on the second element of the tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records\n    return sorted_records[:k]\n\n# Test the function with the provided assertion\nassert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]"}
{"task_id": "MBPP/756", "entry_point": "text_match_zero_one", "completion": "import re\n\ndef text_match_zero_one(text):\n    # Regular expression to match 'a' followed by zero or one 'b'\n    pattern = r'a(b)?'\n    \n    # Search for the pattern in the input text\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'No match found.'\n\n# Test the function with the provided assertion\nassert text_match_zero_one(\"ac\") == 'Found a match!'"}
{"task_id": "MBPP/754", "entry_point": "extract_index_list", "completion": "def extract_index_list(list1, list2, list3):\n    # Find the minimum length of the three lists to avoid index errors\n    min_length = min(len(list1), len(list2), len(list3))\n    \n    # Use a set to store common elements\n    common_elements = set()\n    \n    # Iterate through the indices of the lists\n    for i in range(min_length):\n        if list1[i] == list2[i] == list3[i]:\n            common_elements.add(list1[i])\n    \n    # Return the common elements as a sorted list\n    return sorted(common_elements)\n\n# Test the function with the provided assertion\nassert extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 7]"}
{"task_id": "MBPP/751", "entry_point": "check_min_heap", "completion": "def check_min_heap(arr, index):\n    n = len(arr)\n    \n    # Calculate the left and right child indices\n    left = 2 * index + 1\n    right = 2 * index + 2\n    \n    # Check if the current index is a valid index\n    if index >= n:\n        return True\n    \n    # Check the left child\n    if left < n and arr[left] < arr[index]:\n        return False\n    \n    # Check the right child\n    if right < n and arr[right] < arr[index]:\n        return False\n    \n    # Recursively check the left and right subtrees\n    return check_min_heap(arr, left) and check_min_heap(arr, right)\n\n# Test the function with the provided assertion\nassert check_min_heap([1, 2, 3, 4, 5, 6], 0) == True"}
{"task_id": "MBPP/760", "entry_point": "unique_Element", "completion": "def unique_Element(arr, n):\n    if n == 0:\n        return 'NO'  # Edge case: empty array\n    first_element = arr[0]\n    for element in arr:\n        if element != first_element:\n            return 'NO'\n    return 'YES'\n\n# Test the function with the provided assertion\nassert unique_Element([1, 1, 1], 3) == 'YES'"}
{"task_id": "MBPP/747", "entry_point": "lcs_of_three", "completion": "def lcs_of_three(str1, str2, str3, len1, len2, len3):\n    # Create a 3D array to store lengths of longest common subsequence\n    dp = [[[0] * (len3 + 1) for _ in range(len2 + 1)] for __ in range(len1 + 1)]\n\n    # Build the dp array\n    for i in range(1, len1 + 1):\n        for j in range(1, len2 + 1):\n            for k in range(1, len3 + 1):\n                if str1[i - 1] == str2[j - 1] == str3[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n\n    return dp[len1][len2][len3]\n\n# Test the function with the provided assertion\nassert lcs_of_three('AGGT12', '12TXAYB', '12XBA', 6, 7, 5) == 2"}
{"task_id": "MBPP/759", "entry_point": "is_decimal", "completion": "def is_decimal(value):\n    try:\n        # Convert the string to a float\n        float_value = float(value)\n        # Check if the string matches the decimal format with up to 2 decimal places\n        return value == f\"{float_value:.2f}\"\n    except ValueError:\n        return False\n\n# Test the function\nassert is_decimal('123.11') == True\nassert is_decimal('123.1') == True\nassert is_decimal('123.111') == False\nassert is_decimal('123') == True\nassert is_decimal('abc') == False\nassert is_decimal('123.') == False\nassert is_decimal('.11') == False"}
{"task_id": "MBPP/762", "entry_point": "check_monthnumber_number", "completion": "def check_monthnumber_number(month):\n    # Months with 30 days: April (4), June (6), September (9), November (11)\n    return month in [4, 6, 9, 11]\n\n# Test the function with the provided assertion\nassert check_monthnumber_number(6) == True"}
{"task_id": "MBPP/758", "entry_point": "unique_sublists", "completion": "def unique_sublists(lst):\n    count_dict = {}\n    \n    for sublist in lst:\n        # Convert the sublist to a tuple to use it as a dictionary key\n        key = tuple(sublist)\n        if key in count_dict:\n            count_dict[key] += 1\n        else:\n            count_dict[key] = 1\n            \n    return count_dict\n\n# Test the function with the provided assertion\nassert unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]]) == {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}"}
{"task_id": "MBPP/749", "entry_point": "sort_numeric_strings", "completion": "def sort_numeric_strings(string_list):\n    # Convert the list of strings to a list of integers\n    num_list = [int(num) for num in string_list]\n    # Sort the list of integers\n    num_list.sort()\n    return num_list\n\n# Test the function with the provided assertion\nassert sort_numeric_strings(['4', '12', '45', '7', '0', '100', '200', '-12', '-500']) == [-500, -12, 0, 4, 7, 12, 45, 100, 200]"}
{"task_id": "MBPP/763", "entry_point": "find_Min_Diff", "completion": "def find_Min_Diff(arr, n):\n    # Sort the array\n    arr = sorted(arr)\n    \n    # Initialize the minimum difference to a large value\n    min_diff = float('inf')\n    \n    # Iterate through the sorted array to find the minimum difference\n    for i in range(n - 1):\n        diff = arr[i + 1] - arr[i]\n        if diff < min_diff:\n            min_diff = diff\n            \n    return min_diff\n\n# Test the function with the provided assertion\nassert find_Min_Diff((1, 5, 3, 19, 18, 25), 6) == 1"}
{"task_id": "MBPP/761", "entry_point": "arc_length", "completion": "import math\n\ndef arc_length(radius, angle_degrees):\n    # Convert angle from degrees to radians\n    angle_radians = math.radians(angle_degrees)\n    # Calculate arc length\n    return radius * angle_radians\n\n# Test the function with the provided assertion\nassert arc_length(9, 45) == 3.5357142857142856"}
{"task_id": "MBPP/764", "entry_point": "number_ctr", "completion": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)\n\n# Test the function with the provided assertion\nassert number_ctr('program2bedone') == 1"}
{"task_id": "MBPP/757", "entry_point": "count_reverse_pairs", "completion": "def count_reverse_pairs(string_list):\n    # Create a set to store the unique strings for quick lookup\n    string_set = set(string_list)\n    count = 0\n    \n    # Iterate through the list of strings\n    for string in string_list:\n        # Check if the reverse of the string is in the set\n        reversed_string = string[::-1]\n        if reversed_string in string_set:\n            count += 1\n            \n            # Remove the reversed string from the set to avoid double counting\n            string_set.remove(reversed_string)\n    \n    # Since each pair is counted twice, we divide the count by 2\n    return str(count // 2)\n\n# Test the function with the provided assertion\nassert count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"]) == '2'"}
{"task_id": "MBPP/768", "entry_point": "check_Odd_Parity", "completion": "def check_Odd_Parity(num):\n    # Count the number of 1s in the binary representation of the number\n    count_of_ones = bin(num).count('1')\n    # Check if the count of 1s is odd\n    return count_of_ones % 2 == 1\n\n# Test the function with the provided assertion\nassert check_Odd_Parity(13) == True"}
{"task_id": "MBPP/766", "entry_point": "pair_wise", "completion": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]\n\n# Test the function with the provided assertion\nassert pair_wise([1, 1, 2, 3, 3, 4, 4, 5]) == [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]"}
{"task_id": "MBPP/772", "entry_point": "remove_length", "completion": "def remove_length(input_string, k):\n    # Split the input string into words\n    words = input_string.split()\n    # Filter out words that have length k\n    filtered_words = [word for word in words if len(word) != k]\n    # Join the filtered words back into a string\n    return ' '.join(filtered_words)\n\n# Test the function with the provided assertion\nassert remove_length('The person is most value tet', 3) == 'person is most value'"}
{"task_id": "MBPP/765", "entry_point": "is_polite", "completion": "def is_power_of_two(n):\n    return (n & (n - 1)) == 0 and n > 0\n\ndef is_polite(n):\n    return not is_power_of_two(n)\n\ndef nth_polite_number(n):\n    count = 0\n    current_number = 1\n    \n    while count < n:\n        if is_polite(current_number):\n            count += 1\n        current_number += 1\n    \n    return current_number - 1\n\n# Test the function with the provided assertion\nassert nth_polite_number(7) == 11"}
{"task_id": "MBPP/770", "entry_point": "odd_Num_Sum", "completion": "def odd_Num_Sum(n):\n    # Initialize the sum\n    total_sum = 0\n    \n    # Loop through the first n odd natural numbers\n    for i in range(n):\n        odd_number = 2 * i + 1  # Generate the i-th odd number\n        total_sum += odd_number ** 4  # Add the fourth power of the odd number to the sum\n    \n    return total_sum\n\n# Test the function with the provided assertion\nassert odd_Num_Sum(2) == 82"}
{"task_id": "MBPP/773", "entry_point": "occurance_substring", "completion": "def occurance_substring(main_string, substring):\n    start_index = main_string.find(substring)\n    if start_index != -1:\n        end_index = start_index + len(substring)\n        return (substring, start_index, end_index)\n    return None  # Return None if the substring is not found\n\n# Test the function with the provided assertion\nassert occurance_substring('python programming, python language', 'python') == ('python', 0, 6)"}
{"task_id": "MBPP/776", "entry_point": "count_vowels", "completion": "def count_vowels(s):\n    vowels = set('aeiouAEIOU')\n    count = 0\n    \n    for i in range(len(s)):\n        if (i > 0 and s[i-1] in vowels) or (i < len(s) - 1 and s[i+1] in vowels):\n            count += 1\n            \n    return count\n\n# Test the function with the provided assertion\nassert count_vowels('bestinstareels') == 7"}
{"task_id": "MBPP/775", "entry_point": "odd_position", "completion": "def odd_position(lst):\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 to check odd indices\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True\n\n# Test the function with the provided assertion\nassert odd_position([2, 1, 4, 3, 6, 7, 6, 3]) == True"}
{"task_id": "MBPP/769", "entry_point": "candidate", "completion": "def Diff(list1, list2):\n    return [item for item in list1 if item not in list2]\n\n# Test the function with the provided assertion\nassert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 15, 20, 30]"}
{"task_id": "MBPP/771", "entry_point": "check_expression", "completion": "def check_expression(expression):\n    # Dictionary to hold matching pairs of brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    # Stack to keep track of opening brackets\n    stack = []\n\n    for char in expression:\n        # If the character is a closing bracket\n        if char in bracket_map:\n            # Pop the topmost element from the stack if it's not empty, else assign a dummy value\n            top_element = stack.pop() if stack else '#'\n            # Check if the popped bracket matches the corresponding opening bracket\n            if bracket_map[char] != top_element:\n                return False\n        # If it's an opening bracket, push onto the stack\n        else:\n            stack.append(char)\n\n    # If the stack is empty, all brackets were matched; otherwise, it's unbalanced\n    return not stack\n\n# Test the function with the provided assertion\nassert check_expression(\"{()}[{}]\") == True"}
{"task_id": "MBPP/779", "entry_point": "unique_sublists", "completion": "def unique_sublists(lst):\n    count_dict = {}\n    \n    for sublist in lst:\n        # Convert the list to a tuple to use it as a dictionary key\n        key = tuple(sublist)\n        if key in count_dict:\n            count_dict[key] += 1\n        else:\n            count_dict[key] = 1\n            \n    return count_dict\n\n# Test the function with the provided assertion\nassert unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]]) == {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}"}
{"task_id": "MBPP/777", "entry_point": "find_Sum", "completion": "def find_Sum(arr, n):\n    # Create a dictionary to count occurrences of each element\n    count = {}\n    \n    # Count each element in the array\n    for num in arr:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Calculate the sum of non-repeated elements\n    non_repeated_sum = sum(num for num, cnt in count.items() if cnt == 1)\n    \n    return non_repeated_sum\n\n# Test the function with the provided assertion\nassert find_Sum([1, 2, 3, 1, 1, 4, 5, 6], 8) == 21"}
{"task_id": "MBPP/774", "entry_point": "check_email", "completion": "import re\n\ndef check_email(email):\n    # Define the regex pattern for a valid email\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    \n    # Use re.match to check if the email matches the pattern\n    if re.match(pattern, email):\n        return 'Valid Email'\n    else:\n        return 'Invalid Email'\n\n# Test the function with the provided assertion\nassert check_email(\"ankitrai326@gmail.com\") == 'Valid Email'"}
{"task_id": "MBPP/781", "entry_point": "count_Divisors", "completion": "def count_Divisors(n):\n    if n <= 0:\n        return \"Invalid input\"\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n            \n    return \"Even\" if count % 2 == 0 else \"Odd\"\n\n# Test the function with the provided assertion\nassert count_Divisors(10) == \"Even\""}
{"task_id": "MBPP/767", "entry_point": "get_Pairs_Count", "completion": "def get_Pairs_Count(arr, n, target_sum):\n    count = 0\n    num_count = {}\n\n    # Count occurrences of each number in the array\n    for num in arr:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n\n    # Iterate through the array to find pairs\n    for num in arr:\n        complement = target_sum - num\n        if complement in num_count:\n            count += num_count[complement]\n            # If num and complement are the same, we need to adjust the count\n            if complement == num:\n                count -= 1\n\n    # Each pair is counted twice, so divide by 2\n    return count // 2\n\n# Test the function with the provided assertion\nassert get_Pairs_Count([1, 1, 1, 1], 4, 2) == 6"}
{"task_id": "MBPP/785", "entry_point": "tuple_str_int", "completion": "def tuple_str_int(tuple_str):\n    # Remove the parentheses and split the string by comma\n    elements = tuple_str.strip(\"()\").split(\",\")\n    # Convert each element to an integer and return as a tuple\n    return tuple(int(element.strip()) for element in elements)\n\n# Test the function with the provided assertion\nassert tuple_str_int(\"(7, 8, 9)\") == (7, 8, 9)"}
{"task_id": "MBPP/778", "entry_point": "pack_consecutive_duplicates", "completion": "def pack_consecutive_duplicates(lst):\n    if not lst:\n        return []\n    \n    packed_list = []\n    current_sublist = [lst[0]]\n    \n    for item in lst[1:]:\n        if item == current_sublist[-1]:\n            current_sublist.append(item)\n        else:\n            packed_list.append(current_sublist)\n            current_sublist = [item]\n    \n    packed_list.append(current_sublist)  # Append the last sublist\n    return packed_list\n\n# Test the function with the provided assertion\nassert pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]"}
{"task_id": "MBPP/788", "entry_point": "new_tuple", "completion": "def new_tuple(lst, string):\n    return tuple(lst) + (string,)\n\n# Test the function with the provided assertion\nassert new_tuple([\"WEB\", \"is\"], \"best\") == ('WEB', 'is', 'best')"}
{"task_id": "MBPP/787", "entry_point": "text_match_three", "completion": "import re\n\ndef text_match_three(text):\n    # Define the regex pattern to match 'a' followed by three 'b's\n    pattern = r'a(b{3})'\n    \n    # Use re.fullmatch to check if the entire string matches the pattern\n    if re.fullmatch(pattern, text):\n        return 'Matched!'\n    else:\n        return 'Not matched!'\n\n# Test the function with the provided assertion\nassert text_match_three(\"ac\") == 'Not matched!'"}
{"task_id": "MBPP/780", "entry_point": "find_combinations", "completion": "def find_combinations(tuple_list):\n    result = []\n    n = len(tuple_list)\n    \n    for i in range(n):\n        for j in range(n):\n            if i != j:  # Ensure we are not adding the same tuple\n                sum_tuple = (tuple_list[i][0] + tuple_list[j][0], tuple_list[i][1] + tuple_list[j][1])\n                result.append(sum_tuple)\n    \n    # Remove duplicates by converting to a set and back to a list\n    result = list(set(result))\n    \n    return result\n\n# Test the function with the provided assertion\nassert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]"}
{"task_id": "MBPP/784", "entry_point": "mul_even_odd", "completion": "def mul_even_odd(numbers):\n    first_even = None\n    first_odd = None\n    \n    for num in numbers:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        \n        # Break the loop if both first even and odd are found\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # If either even or odd number is not found, return 0\n    if first_even is None or first_odd is None:\n        return 0\n    \n    return first_even * first_odd\n\n# Test the function with the provided assertion\nassert mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 4"}
{"task_id": "MBPP/789", "entry_point": "perimeter_polygon", "completion": "def perimeter_polygon(num_sides, side_length):\n    return num_sides * side_length\n\n# Test the function with the provided assertion\nassert perimeter_polygon(4, 20) == 80"}
{"task_id": "MBPP/786", "entry_point": "right_insertion", "completion": "def right_insertion(sorted_list, value):\n    \"\"\"\n    Locate the right insertion point for a specified value in sorted order.\n\n    Parameters:\n    sorted_list (list): A list of sorted elements.\n    value: The value to be inserted.\n\n    Returns:\n    int: The index at which the value should be inserted.\n    \"\"\"\n    low, high = 0, len(sorted_list)\n\n    while low < high:\n        mid = (low + high) // 2\n        if sorted_list[mid] <= value:\n            low = mid + 1\n        else:\n            high = mid\n\n    return low\n\n# Example usage\nassert right_insertion([1, 2, 4, 5], 6) == 4"}
{"task_id": "MBPP/782", "entry_point": "Odd_Length_Sum", "completion": "def Odd_Length_Sum(arr):\n    total_sum = 0\n    n = len(arr)\n    \n    # Iterate over all possible starting points of subarrays\n    for start in range(n):\n        # Iterate over all possible ending points of subarrays\n        for end in range(start, n):\n            # Calculate the length of the subarray\n            length = end - start + 1\n            # Check if the length is odd\n            if length % 2 == 1:\n                # Add the sum of the subarray to the total sum\n                total_sum += sum(arr[start:end + 1])\n    \n    return total_sum\n\n# Test the function with the provided assertion\nassert Odd_Length_Sum([1, 2, 4]) == 14"}
{"task_id": "MBPP/792", "entry_point": "count_list", "completion": "def count_list(lists):\n    return len(lists)\n\n# Test the function with the provided assertion\nassert count_list([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4"}
{"task_id": "MBPP/790", "entry_point": "even_position", "completion": "def even_position(lst):\n    for i in range(0, len(lst), 2):  # Iterate over even indices\n        if lst[i] % 2 != 0:  # Check if the number at the even index is odd\n            return False\n    return True\n\n# Test the function with the provided assertion\nassert even_position([3, 2, 1]) == False"}
{"task_id": "MBPP/796", "entry_point": "return_sum", "completion": "def return_sum(input_dict):\n    return sum(input_dict.values())\n\n# Test the function with the provided assertion\nassert return_sum({'a': 100, 'b': 200, 'c': 300}) == 600"}
{"task_id": "MBPP/783", "entry_point": "rgb_to_hsv", "completion": "def rgb_to_hsv(r, g, b):\n    # Normalize the RGB values to the range [0, 1]\n    r /= 255.0\n    g /= 255.0\n    b /= 255.0\n\n    # Find the maximum and minimum values of r, g, b\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    df = mx - mn\n\n    # Calculate the hue\n    if df == 0:\n        h = 0  # Achromatic\n    elif mx == r:\n        h = (60 * ((g - b) / df) + 360) % 360\n    elif mx == g:\n        h = (60 * ((b - r) / df) + 120) % 360\n    else:  # mx == b\n        h = (60 * ((r - g) / df) + 240) % 360\n\n    # Calculate the saturation\n    s = 0 if mx == 0 else (df / mx)\n\n    # Calculate the value\n    v = mx\n\n    # Convert to percentage\n    s *= 100\n    v *= 100\n\n    return (h, s, v)\n\n# Test the function with the provided assertion\nassert rgb_to_hsv(255, 255, 255) == (0, 0.0, 100.0)"}
{"task_id": "MBPP/798", "entry_point": "_sum", "completion": "def _sum(array):\n    return sum(array)\n\n# Test the function\nassert _sum([1, 2, 3]) == 6"}
{"task_id": "MBPP/800", "entry_point": "remove_all_spaces", "completion": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")\n\n# Test the function\nassert remove_all_spaces('python  program') == 'pythonprogram'"}
{"task_id": "MBPP/794", "entry_point": "text_starta_endb", "completion": "import re\n\ndef text_starta_endb(text):\n    # Regular expression to match 'a' followed by anything and ending with 'b'\n    pattern = r'^a.*b$'\n    \n    if re.match(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'No match found.'\n\n# Test the function with the provided assertion\nassert text_starta_endb(\"aabbbb\") == 'Found a match!'"}
{"task_id": "MBPP/791", "entry_point": "remove_nested", "completion": "def remove_nested(tup):\n    # Use a generator expression to filter out nested tuples\n    return tuple(item for item in tup if not isinstance(item, tuple))\n\n# Test the function with the provided assertion\nassert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)\n\n# You can also add more test cases to verify the function\nassert remove_nested((1, (2, 3), 4, (5,))) == (1, 4)\nassert remove_nested(((1, 2), (3, 4), 5)) == (5,)\nassert remove_nested((1, 2, 3)) == (1, 2, 3)\nassert remove_nested(()) == ()"}
{"task_id": "MBPP/797", "entry_point": "sum_in_Range", "completion": "def sum_in_range(l, r):\n    # Initialize the sum\n    total_sum = 0\n    \n    # Iterate through the range from l to r\n    for num in range(l, r + 1):\n        # Check if the number is odd\n        if num % 2 != 0:\n            total_sum += num\n            \n    return total_sum\n\n# Test the function with the provided assertion\nassert sum_in_range(2, 5) == 8"}
{"task_id": "MBPP/795", "entry_point": "cheap_items", "completion": "import heapq\n\ndef cheap_items(items, n):\n    # Use a heap to find the n cheapest items\n    return heapq.nsmallest(n, items, key=lambda x: x['price'])\n\n# Test the function with the provided assertion\nassert cheap_items([{'name': 'Item-1', 'price': 101.1}, {'name': 'Item-2', 'price': 555.22}], 1) == [{'name': 'Item-1', 'price': 101.1}]"}
{"task_id": "MBPP/793", "entry_point": "last", "completion": "def last(arr, target, n):\n    left, right = 0, n - 1\n    last_position = -1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if arr[mid] == target:\n            last_position = mid  # Update last_position\n            left = mid + 1  # Move to the right half to find the last occurrence\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    return last_position\n\n# Test the function with the provided assertion\nassert last([1, 2, 3], 1, 3) == 0"}
{"task_id": "MBPP/801", "entry_point": "test_three_equal", "completion": "def test_three_equal(a, b, c):\n    # Initialize a counter for equal numbers\n    count = 0\n    \n    # Check for equality and increment the counter\n    if a == b:\n        count += 1\n    if b == c:\n        count += 1\n    if a == c:\n        count += 1\n    \n    # If all three are equal, we should return 3\n    if count == 3:\n        return 3\n    \n    # Return the count of equal pairs\n    return count\n\n# Test the function with the provided assertion\nassert test_three_equal(1, 1, 1) == 3"}
{"task_id": "MBPP/803", "entry_point": "is_Perfect_Square", "completion": "def is_Perfect_Square(num):\n    if num < 0:\n        return False\n    root = int(num**0.5)\n    return root * root == num\n\n# Test the function with the provided assertion\nassert is_Perfect_Square(10) == False"}
{"task_id": "MBPP/799", "entry_point": "left_Rotate", "completion": "def left_Rotate(n, d):\n    # Assuming n is a 32-bit integer\n    d = d % 32  # To handle cases where d >= 32\n    return ((n << d) | (n >> (32 - d))) & 0xFFFFFFFF  # Mask to keep it 32 bits\n\n# Test the function with the provided assertion\nassert left_Rotate(16, 2) == 64"}
{"task_id": "MBPP/806", "entry_point": "max_run_uppercase", "completion": "def max_run_uppercase(s):\n    max_run = 0\n    current_run = 0\n    \n    for char in s:\n        if char.isupper():\n            current_run += 1\n            max_run = max(max_run, current_run)\n        else:\n            current_run = 0\n            \n    return max_run\n\n# Test the function with the provided assertion\nassert max_run_uppercase('GeMKSForGERksISBESt') == 5"}
{"task_id": "MBPP/808", "entry_point": "check_K", "completion": "def check_K(tup, k):\n    return k in tup\n\n# Test the function with the provided assertion\nassert check_K((10, 4, 5, 6, 8), 6) == True"}
{"task_id": "MBPP/807", "entry_point": "first_odd", "completion": "def first_odd(numbers):\n    for number in numbers:\n        if number % 2 != 0:  # Check if the number is odd\n            return number\n    return None  # Return None if no odd number is found\n\n# Test the function with the provided assertion\nassert first_odd([1, 3, 5]) == 1"}
{"task_id": "MBPP/804", "entry_point": "is_Product_Even", "completion": "def is_Product_Even(numbers, _):\n    product = 1\n    for number in numbers:\n        product *= number\n    return product % 2 == 0\n\n# Test the function with the provided assertion\nassert is_Product_Even([1, 2, 3], 3) == True"}
{"task_id": "MBPP/805", "entry_point": "max_sum_list", "completion": "def max_sum_list(lists):\n    # Initialize variables to track the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n\n    # Iterate through each list in the list of lists\n    for lst in lists:\n        current_sum = sum(lst)  # Calculate the sum of the current list\n        # Update max_sum and max_list if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list\n\n# Test the function with the provided assertion\nassert max_sum_list([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [10, 11, 12]"}
{"task_id": "MBPP/809", "entry_point": "check_smaller", "completion": "def check_smaller(tuple1, tuple2):\n    # Check if the lengths of the tuples are the same\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Both tuples must have the same length.\")\n    \n    # Check if each element in the second tuple is smaller than the corresponding element in the first tuple\n    for i in range(len(tuple1)):\n        if tuple2[i] >= tuple1[i]:\n            return False\n    return True\n\n# Test the function with the provided assertion\nassert check_smaller((1, 2, 3), (2, 3, 4)) == False"}
{"task_id": "MBPP/812", "entry_point": "road_rd", "completion": "def road_rd(input_string):\n    return input_string.replace('Road', 'Rd.')\n\n# Test the function\nassert road_rd(\"ravipadu Road\") == 'ravipadu Rd.'"}
{"task_id": "MBPP/813", "entry_point": "string_length", "completion": "def string_length(s):\n    return len(s)\n\n# Test the function\nassert string_length('python') == 6"}
{"task_id": "MBPP/816", "entry_point": "clear_tuple", "completion": "def clear_tuple(t):\n    return ()\n\n# Test the function\nassert clear_tuple((1, 5, 3, 6, 8)) == ()"}
{"task_id": "MBPP/817", "entry_point": "div_of_nums", "completion": "def div_of_nums(numbers, m, n):\n    return list(filter(lambda x: x % m == 0 or x % n == 0, numbers))\n\n# Test the function with the provided assertion\nassert div_of_nums([19, 65, 57, 39, 152, 639, 121, 44, 90, 190], 19, 13) == [19, 65, 57, 39, 152, 190]"}
{"task_id": "MBPP/802", "entry_point": "count_Rotation", "completion": "def count_Rotation(arr, n):\n    # Function to find the index of the minimum element in the rotated sorted array\n    def find_min_index(arr, low, high):\n        if high < low:\n            return 0\n        if high == low:\n            return low\n        \n        mid = (low + high) // 2\n        \n        # Check if mid is the minimum element\n        if mid < high and arr[mid + 1] < arr[mid]:\n            return mid + 1\n        if mid > low and arr[mid] < arr[mid - 1]:\n            return mid\n        \n        # Decide whether to go to the left half or the right half\n        if arr[high] > arr[mid]:\n            return find_min_index(arr, low, mid - 1)\n        return find_min_index(arr, mid + 1, high)\n\n    return find_min_index(arr, 0, n - 1)\n\n# Test the function with the provided assertion\nassert count_Rotation([3, 2, 1], 3) == 1"}
{"task_id": "MBPP/811", "entry_point": "check_identical", "completion": "def check_identical(list1, list2):\n    return list1 == list2\n\n# Test the function with the provided assertion\nassert check_identical([(10, 4), (2, 5)], [(10, 4), (2, 5)]) == True"}
{"task_id": "MBPP/810", "entry_point": "count_variable", "completion": "def count_variable(*args):\n    # Create a dictionary to count occurrences of each element\n    count_dict = {}\n    for item in args:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    \n    # Create a list to hold the repeated elements\n    result = []\n    for item, count in count_dict.items():\n        result.extend([item] * count)\n    \n    return result\n\n# Test the function with the provided assertion\nassert count_variable(4, 2, 0, -2) == [4, 4, 2, 2, 0, -2]"}
{"task_id": "MBPP/818", "entry_point": "lower_ctr", "completion": "def lower_ctr(s):\n    count = 0\n    for char in s:\n        if char.islower():\n            count += 1\n    return count\n\n# Test the function with the provided assertion\nassert lower_ctr('abc') == 3"}
{"task_id": "MBPP/820", "entry_point": "check_monthnum_number", "completion": "def check_monthnum_number(month):\n    \"\"\"\n    Check if the given month number contains 28 days.\n    \n    Args:\n    month (int): The month number (1 for January, 2 for February, ..., 12 for December).\n    \n    Returns:\n    bool: True if the month has 28 days, False otherwise.\n    \"\"\"\n    # February is the only month that has 28 days in a non-leap year\n    return month == 2\n\n# Test the function with the provided assertion\nassert check_monthnum_number(2) == True"}
{"task_id": "MBPP/814", "entry_point": "rombus_area", "completion": "def rombus_area(d1, d2):\n    return (d1 * d2) / 2\n\n# Test the function with the provided assertion\nassert rombus_area(10, 20) == 100"}
{"task_id": "MBPP/825", "entry_point": "access_elements", "completion": "def access_elements(lst, indices):\n    return [lst[i] for i in indices]\n\n# Test the function with the provided assertion\nassert access_elements([2, 3, 8, 4, 7, 9], [0, 3, 5]) == [2, 4, 9]"}
{"task_id": "MBPP/824", "entry_point": "remove_even", "completion": "def remove_even(numbers):\n    return [num for num in numbers if num % 2 != 0]\n\n# Test the function with the provided assertion\nassert remove_even([1, 3, 5, 2]) == [1, 3, 5]"}
{"task_id": "MBPP/821", "entry_point": "merge_dictionaries", "completion": "def merge_dictionaries(dict1, dict2):\n    return {**dict1, **dict2}\n\n# Test the function with the provided assertion\nassert merge_dictionaries({\"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\"}, {\"G\": \"Green\", \"W\": \"White\"}) == {'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White'}"}
{"task_id": "MBPP/819", "entry_point": "count_duplic", "completion": "def count_duplic(numbers):\n    if not numbers:\n        return [], []\n    \n    unique_elements = []\n    counts = []\n    \n    current_element = numbers[0]\n    current_count = 1\n    \n    for number in numbers[1:]:\n        if number == current_element:\n            current_count += 1\n        else:\n            unique_elements.append(current_element)\n            counts.append(current_count)\n            current_element = number\n            current_count = 1\n    \n    # Append the last element and its count\n    unique_elements.append(current_element)\n    counts.append(current_count)\n    \n    return unique_elements, counts\n\n# Test the function with the provided assertion\nassert count_duplic([1, 2, 2, 2, 4, 4, 4, 5, 5, 5, 5]) == ([1, 2, 4, 5], [1, 3, 3, 4])"}
{"task_id": "MBPP/815", "entry_point": "sort_by_dnf", "completion": "def sort_by_dnf(arr, n):\n    low = 0\n    mid = 0\n    high = n - 1\n\n    while mid <= high:\n        if arr[mid] == 0:\n            arr[low], arr[mid] = arr[mid], arr[low]\n            low += 1\n            mid += 1\n        elif arr[mid] == 1:\n            mid += 1\n        else:  # arr[mid] == 2\n            arr[mid], arr[high] = arr[high], arr[mid]\n            high -= 1\n\n    return arr\n\n# Test the function with the provided assertion\nassert sort_by_dnf([1, 2, 0, 1, 0, 1, 2, 1, 1], 9) == [0, 0, 1, 1, 1, 1, 1, 2, 2]"}
{"task_id": "MBPP/823", "entry_point": "check_substring", "completion": "import re\n\ndef check_substring(main_string, substring):\n    # Create a regex pattern to check if the main_string starts with the substring\n    pattern = f'^{re.escape(substring)}'\n    \n    # Use re.match to check if the main_string starts with the substring\n    if re.match(pattern, main_string):\n        return 'string starts with the given substring'\n    else:\n        return 'string doesnt start with the given substring'\n\n# Test the function with the provided assertion\nassert check_substring(\"dreams for dreams makes life fun\", \"makes\") == 'string doesnt start with the given substring'"}
{"task_id": "MBPP/822", "entry_point": "pass_validity", "completion": "import re\n\ndef pass_validity(password):\n    # Check the length of the password\n    if len(password) < 8:\n        return False\n    \n    # Check for at least one uppercase letter\n    if not re.search(r'[A-Z]', password):\n        return False\n    \n    # Check for at least one lowercase letter\n    if not re.search(r'[a-z]', password):\n        return False\n    \n    # Check for at least one digit\n    if not re.search(r'[0-9]', password):\n        return False\n    \n    # Check for at least one special character\n    if not re.search(r'[!@#$%^&*(),.?\":{}|<>]', password):\n        return False\n    \n    return True\n\n# Test the function with the provided assertion\nassert pass_validity(\"password\") == False"}
{"task_id": "MBPP/827", "entry_point": "sum_column", "completion": "def sum_column(matrix, column_index):\n    \"\"\"\n    Sums the values in a specific column of a list of lists.\n\n    :param matrix: List of lists containing numerical values\n    :param column_index: Index of the column to sum\n    :return: Sum of the specified column\n    \"\"\"\n    return sum(row[column_index] for row in matrix)\n\n# Example usage and assertion\nassert sum_column([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]], 0) == 12"}
{"task_id": "MBPP/830", "entry_point": "round_up", "completion": "import math\n\ndef round_up(number, digits):\n    \"\"\"\n    Rounds up a number to a specified number of decimal places.\n\n    Parameters:\n    number (float): The number to round up.\n    digits (int): The number of decimal places to round up to.\n\n    Returns:\n    float: The rounded up number.\n    \"\"\"\n    factor = 10 ** digits\n    return math.ceil(number * factor) / factor\n\n# Example usage\nassert round_up(123.01247, 0) == 124"}
{"task_id": "MBPP/828", "entry_point": "count_alpha_dig_spl", "completion": "def count_alpha_dig_spl(input_string):\n    alphabets = 0\n    digits = 0\n    special_chars = 0\n    \n    for char in input_string:\n        if char.isalpha():\n            alphabets += 1\n        elif char.isdigit():\n            digits += 1\n        else:\n            special_chars += 1\n            \n    return (alphabets, digits, special_chars)\n\n# Test the function with the provided assertion\nassert count_alpha_dig_spl(\"abc!@#123\") == (3, 3, 3)"}
{"task_id": "MBPP/833", "entry_point": "get_key", "completion": "def get_key(d):\n    return list(d.keys())\n\n# Test the function with the provided assertion\nassert get_key({1: 'python', 2: 'java'}) == [1, 2]"}
{"task_id": "MBPP/829", "entry_point": "second_frequent", "completion": "from collections import Counter\n\ndef second_frequent(strings):\n    # Count the frequency of each string in the list\n    frequency = Counter(strings)\n    \n    # Get the two most common strings\n    most_common = frequency.most_common(2)\n    \n    # Check if there are at least two different strings\n    if len(most_common) < 2:\n        return None  # or raise an exception if preferred\n    \n    # Return the second most common string\n    return most_common[1][0]\n\n# Test the function with the provided assertion\nassert second_frequent(['aaa', 'bbb', 'ccc', 'bbb', 'aaa', 'aaa']) == 'bbb'"}
{"task_id": "MBPP/832", "entry_point": "extract_max", "completion": "import re\n\ndef extract_max(s):\n    # Find all sequences of digits in the string\n    numbers = re.findall(r'\\d+', s)\n    # Convert the found sequences to integers\n    numbers = [int(num) for num in numbers]\n    # Return the maximum value found, or None if no numbers were found\n    return max(numbers) if numbers else None\n\n# Test the function with the provided assertion\nassert extract_max('100klh564abc365bg') == 564"}
{"task_id": "MBPP/835", "entry_point": "slope", "completion": "def slope(x1, y1, x2, y2):\n    if x2 - x1 == 0:  # Check for division by zero\n        raise ValueError(\"The x-coordinates must be different to calculate the slope.\")\n    return (y2 - y1) / (x2 - x1)\n\n# Test the function with the provided assertion\nassert slope(4, 2, 2, 5) == -1.5"}
{"task_id": "MBPP/826", "entry_point": "check_Type_Of_Triangle", "completion": "def check_Type_Of_Triangle(a, b, c):\n    # First, sort the sides to easily apply the triangle properties\n    sides = sorted([a, b, c])\n    a, b, c = sides[0], sides[1], sides[2]\n    \n    # Check for triangle inequality\n    if a + b <= c:\n        return \"Not a Triangle\"\n    \n    # Determine the type of triangle\n    if a**2 + b**2 > c**2:\n        return \"Acute-angled Triangle\"\n    elif a**2 + b**2 == c**2:\n        return \"Right-angled Triangle\"\n    else:\n        return \"Obtuse-angled Triangle\"\n\n# Example assertion\nassert check_Type_Of_Triangle(1, 2, 3) == \"Obtuse-angled Triangle\""}
{"task_id": "MBPP/831", "entry_point": "count_Pairs", "completion": "def count_Pairs(arr, n):\n    from collections import Counter\n    \n    # Count occurrences of each element\n    count = Counter(arr)\n    \n    # Calculate the number of pairs\n    pairs = 0\n    for value in count.values():\n        if value > 1:\n            pairs += (value * (value - 1)) // 2  # Combination formula C(n, 2)\n    \n    return pairs\n\n# Test the function with the provided assertion\nassert count_Pairs([1, 1, 1, 1], 4) == 6"}
{"task_id": "MBPP/839", "entry_point": "sort_tuple", "completion": "def sort_tuple(tuples_list):\n    return sorted(tuples_list, key=lambda x: x[0])\n\n# Test the function with the provided assertion\nassert sort_tuple([(\"Amana\", 28), (\"Zenat\", 30), (\"Abhishek\", 29), (\"Nikhil\", 21), (\"B\", \"C\")]) == [('Abhishek', 29), ('Amana', 28), ('B', 'C'), ('Nikhil', 21), ('Zenat', 30)]"}
{"task_id": "MBPP/837", "entry_point": "cube_Sum", "completion": "def cube_Sum(n):\n    return sum((2 * i + 1) ** 3 for i in range(n))\n\n# Test the function with the provided assertion\nassert cube_Sum(2) == 28"}
{"task_id": "MBPP/834", "entry_point": "generate_matrix", "completion": "def generate_matrix(n):\n    # Create an n x n matrix initialized with zeros\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Define the boundaries of the spiral\n    top, bottom, left, right = 0, n - 1, 0, n - 1\n    num = 1  # Start filling with 1\n    \n    while top <= bottom and left <= right:\n        # Fill the top row\n        for i in range(left, right + 1):\n            matrix[top][i] = num\n            num += 1\n        top += 1\n        \n        # Fill the right column\n        for i in range(top, bottom + 1):\n            matrix[i][right] = num\n            num += 1\n        right -= 1\n        \n        if top <= bottom:\n            # Fill the bottom row\n            for i in range(right, left - 1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n        \n        if left <= right:\n            # Fill the left column\n            for i in range(bottom, top - 1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n    \n    return matrix\n\n# Test the function with the provided assertion\nassert generate_matrix(3) == [[1, 2, 3], [8, 9, 4], [7, 6, 5]]"}
{"task_id": "MBPP/842", "entry_point": "get_odd_occurence", "completion": "def get_odd_occurence(arr, n):\n    # Create a dictionary to count occurrences of each number\n    count = {}\n    \n    for num in arr:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Find and return the number that occurs an odd number of times\n    for num, cnt in count.items():\n        if cnt % 2 != 0:\n            return num\n\n# Test the function with the provided assertion\nassert get_odd_occurence([2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2], 13) == 5"}
{"task_id": "MBPP/838", "entry_point": "min_Swaps", "completion": "def min_Swaps(s1: str, s2: str) -> int:\n    if len(s1) != len(s2):\n        raise ValueError(\"Strings must be of the same length\")\n    \n    # Count the number of differing positions\n    count_diff = 0\n    count_01 = 0  # Count of '0' in s1 and '1' in s2\n    count_10 = 0  # Count of '1' in s1 and '0' in s2\n    \n    for a, b in zip(s1, s2):\n        if a != b:\n            count_diff += 1\n            if a == '0' and b == '1':\n                count_01 += 1\n            elif a == '1' and b == '0':\n                count_10 += 1\n    \n    # The number of swaps needed is the maximum of count_01 and count_10\n    return max(count_01, count_10)\n\n# Test the function with the provided assertion\nassert min_Swaps(\"0011\", \"1111\") == 1"}
{"task_id": "MBPP/836", "entry_point": "max_sub_array_sum", "completion": "def max_sub_array_sum(arr, n):\n    if n == 0:\n        return 0\n\n    max_sum = float('-inf')\n    current_sum = 0\n    max_length = 0\n    current_length = 0\n\n    for i in range(n):\n        current_sum += arr[i]\n        current_length += 1\n\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_length = current_length\n        elif current_sum < 0:\n            current_sum = 0\n            current_length = 0\n\n    return max_length\n\n# Test the function with the provided assertion\nassert max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 5"}
{"task_id": "MBPP/844", "entry_point": "get_Number", "completion": "def get_Number(k, n):\n    # Generate the first n odd numbers\n    odds = [i for i in range(1, 2*n, 2)]\n    # Generate the first n even numbers\n    evens = [i for i in range(0, 2*n, 2)]\n    # Combine odds and evens\n    combined = odds + evens\n    # Return the k-th element (1-based index)\n    return combined[k - 1]\n\n# Test the function with the provided assertion\nassert get_Number(8, 5) == 2"}
{"task_id": "MBPP/847", "entry_point": "lcopy", "completion": "def lcopy(singleton_tuple):\n    # Ensure the input is a singleton tuple\n    if len(singleton_tuple) != 1:\n        raise ValueError(\"Input must be a singleton tuple.\")\n    \n    # Return a list containing the single element of the tuple\n    return list(singleton_tuple[0])\n\n# Example usage\nassert lcopy((1,)) == [1]\nassert lcopy((2,)) == [2]\nassert lcopy((3,)) == [3]"}
{"task_id": "MBPP/845", "entry_point": "find_Digits", "completion": "import math\n\ndef find_Digits(n):\n    if n < 0:\n        return 0  # Factorial is not defined for negative numbers\n    if n == 0 or n == 1:\n        return 1  # 0! and 1! both equal 1, which has 1 digit\n\n    # Calculate the number of digits in n!\n    digits = 0\n    for i in range(2, n + 1):\n        digits += math.log10(i)\n    \n    return math.floor(digits) + 1\n\n# Test the function with the provided assertion\nassert find_Digits(7) == 4"}
{"task_id": "MBPP/841", "entry_point": "get_inv_count", "completion": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all elements left to i in the left subarray\n            # are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n        \n    return inv_count\n\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\n\ndef get_inv_count(arr, n):\n    temp_arr = [0] * n\n    return merge_sort_and_count(arr, temp_arr, 0, n - 1)\n\n# Test the function with the provided assertion\nassert get_inv_count([1, 20, 6, 4, 5], 5) == 5"}
{"task_id": "MBPP/846", "entry_point": "find_platform", "completion": "def find_platform(arrivals, departures, n):\n    # Sort both the arrival and departure times\n    arrivals.sort()\n    departures.sort()\n    \n    # Initialize platform needed and result\n    platform_needed = 1\n    result = 1\n    \n    # Pointers for arrivals and departures\n    i = 1  # Pointer for arrivals\n    j = 0  # Pointer for departures\n    \n    # Process all events in sorted order\n    while i < n and j < n:\n        # If next event is arrival, increment platform needed\n        if arrivals[i] <= departures[j]:\n            platform_needed += 1\n            i += 1\n        # If next event is departure, decrement platform needed\n        else:\n            platform_needed -= 1\n            j += 1\n        \n        # Update result if needed\n        result = max(result, platform_needed)\n    \n    return result\n\n# Test the function with the provided assertion\nassert find_platform([900, 940, 950, 1100, 1500, 1800], [910, 1200, 1120, 1130, 1900, 2000], 6) == 3"}
{"task_id": "MBPP/840", "entry_point": "Check_Solution", "completion": "def Check_Solution(a, b, c):\n    # Check if the discriminant is zero\n    discriminant = b**2 - 4*a*c\n    if discriminant == 0 and b == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Test the function with the provided assertion\nassert Check_Solution(2, 0, -1) == \"Yes\""}
{"task_id": "MBPP/843", "entry_point": "nth_super_ugly_number", "completion": "import heapq\n\ndef nth_super_ugly_number(n, primes):\n    # Min-heap to store the next potential super ugly numbers\n    heap = []\n    # Set to keep track of the unique super ugly numbers\n    seen = set()\n    \n    # Start with the first super ugly number\n    heapq.heappush(heap, 1)\n    seen.add(1)\n    \n    # Variable to store the current super ugly number\n    ugly_number = 1\n    \n    for _ in range(n):\n        # Get the smallest super ugly number from the heap\n        ugly_number = heapq.heappop(heap)\n        \n        # Generate new super ugly numbers by multiplying with each prime\n        for prime in primes:\n            new_ugly = ugly_number * prime\n            if new_ugly not in seen:\n                seen.add(new_ugly)\n                heapq.heappush(heap, new_ugly)\n    \n    return ugly_number\n\n# Test the function with the provided assertion\nassert nth_super_ugly_number(12, [2, 7, 13, 19]) == 32"}
{"task_id": "MBPP/850", "entry_point": "is_triangleexists", "completion": "def is_triangleexists(angle1, angle2, angle3):\n    # Check if all angles are positive and their sum is 180\n    return angle1 > 0 and angle2 > 0 and angle3 > 0 and (angle1 + angle2 + angle3) == 180\n\n# Test the function with the provided assertion\nassert is_triangleexists(50, 60, 70) == True"}
{"task_id": "MBPP/848", "entry_point": "area_trapezium", "completion": "def area_trapezium(a, b, h):\n    return 0.5 * (a + b) * h\n\n# Test the function with the provided assertion\nassert area_trapezium(6, 9, 4) == 30"}
{"task_id": "MBPP/852", "entry_point": "remove_negs", "completion": "def remove_negs(lst):\n    \"\"\"Remove negative numbers from a list.\"\"\"\n    return [num for num in lst if num >= 0]\n\n# Test the function with the provided assertion\nassert remove_negs([1, -2, 3, -4]) == [1, 3]"}
{"task_id": "MBPP/849", "entry_point": "Sum", "completion": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef prime_divisors_sum(n):\n    \"\"\"Return the sum of all prime divisors of a given number.\"\"\"\n    prime_divisors = set()\n    \n    # Check for all numbers from 2 to n\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            prime_divisors.add(i)\n    \n    return sum(prime_divisors)\n\n# Test the function\nassert prime_divisors_sum(60) == 10"}
{"task_id": "MBPP/853", "entry_point": "sum_of_odd_Factors", "completion": "def sum_of_odd_factors(n):\n    odd_factors_sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 != 0:  # Check if i is a factor and odd\n            odd_factors_sum += i\n    return odd_factors_sum\n\n# Test the function with the provided assertion\nassert sum_of_odd_factors(30) == 24"}
{"task_id": "MBPP/854", "entry_point": "raw_heap", "completion": "import heapq\n\ndef raw_heap(lst):\n    # Convert the list into a heap in-place\n    heapq.heapify(lst)\n    return lst\n\n# Test the function with the provided assertion\nassert raw_heap([25, 44, 68, 21, 39, 23, 89]) == [21, 25, 23, 44, 39, 68, 89]"}
{"task_id": "MBPP/855", "entry_point": "check_Even_Parity", "completion": "def check_Even_Parity(number):\n    # Count the number of 1s in the binary representation of the number\n    count_of_ones = bin(number).count('1')\n    # Check if the count of 1s is even\n    return count_of_ones % 2 == 0\n\n# Test the function with the provided assertion\nassert check_Even_Parity(10) == True"}
{"task_id": "MBPP/858", "entry_point": "count_list", "completion": "def count_list(list_of_lists):\n    # Count the number of lists in the given list of lists\n    count = len(list_of_lists)\n    # Return the square of the count\n    return count ** 2\n\n# Test the function with the provided assertion\nassert count_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 25"}
{"task_id": "MBPP/857", "entry_point": "listify_list", "completion": "def listify_list(strings):\n    return list(map(list, strings))\n\n# Test the function with the provided assertion\nassert listify_list(['Red', 'Blue', 'Black', 'White', 'Pink']) == [['R', 'e', 'd'], ['B', 'l', 'u', 'e'], ['B', 'l', 'a', 'c', 'k'], ['W', 'h', 'i', 't', 'e'], ['P', 'i', 'n', 'k']]"}
{"task_id": "MBPP/864", "entry_point": "palindrome_lambda", "completion": "def palindrome_lambda(strings):\n    return list(filter(lambda s: s == s[::-1], strings))\n\n# Test the function with the provided assertion\nassert palindrome_lambda([\"php\", \"res\", \"Python\", \"abcd\", \"Java\", \"aaa\"]) == ['php', 'aaa']"}
{"task_id": "MBPP/851", "entry_point": "Sum_of_Inverse_Divisors", "completion": "def Sum_of_Inverse_Divisors(start, end):\n    def inverse_divisor_sum(n):\n        total = 0\n        for i in range(1, n + 1):\n            if n % i == 0:  # Check if i is a divisor of n\n                total += 1 / i  # Add the inverse of the divisor\n        return total\n\n    total_sum = 0\n    for number in range(start, end + 1):\n        total_sum += inverse_divisor_sum(number)\n\n    return total_sum\n\n# Test the function with the provided assertion\nassert Sum_of_Inverse_Divisors(6, 12) == 2"}
{"task_id": "MBPP/860", "entry_point": "check_alphanumeric", "completion": "import re\n\ndef check_alphanumeric(s):\n    # Check if the string ends with only alphanumeric characters\n    if re.search(r'[^\\w]$', s):\n        return 'Discard'\n    return 'Accept'\n\n# Test the function with the provided assertion\nassert check_alphanumeric(\"dawood@\") == 'Discard'"}
{"task_id": "MBPP/861", "entry_point": "anagram_lambda", "completion": "def anagram_lambda(words, target):\n    # Sort the target string to create a reference for comparison\n    sorted_target = sorted(target)\n    # Use a lambda function to filter the list of words\n    return list(filter(lambda word: sorted(word) == sorted_target, words))\n\n# Test the function with the provided assertion\nassert anagram_lambda([\"bcda\", \"abce\", \"cbda\", \"cbea\", \"adcb\"], \"abcd\") == ['bcda', 'cbda', 'adcb']"}
{"task_id": "MBPP/862", "entry_point": "n_common_words", "completion": "from collections import Counter\nimport re\n\ndef n_common_words(text, n):\n    # Normalize the text to lowercase and use regex to find words\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    # Count the occurrences of each word\n    word_counts = Counter(words)\n    # Get the n most common words\n    return word_counts.most_common(n)\n\n# Example usage\nassert n_common_words(\"python is a programming language\", 1) == [('python', 1)]"}
{"task_id": "MBPP/863", "entry_point": "find_longest_conseq_subseq", "completion": "def find_longest_conseq_subseq(arr, n):\n    if n == 0:\n        return 0\n    \n    # Create a set from the array to get unique elements\n    unique_elements = set(arr)\n    longest_streak = 0\n    \n    for num in unique_elements:\n        # Check if it's the start of a sequence\n        if num - 1 not in unique_elements:\n            current_num = num\n            current_streak = 1\n            \n            # Count the length of the consecutive sequence\n            while current_num + 1 in unique_elements:\n                current_num += 1\n                current_streak += 1\n            \n            # Update the longest streak found\n            longest_streak = max(longest_streak, current_streak)\n    \n    return longest_streak\n\n# Test the function with the provided assertion\nassert find_longest_conseq_subseq([1, 2, 2, 3], 4) == 3"}
{"task_id": "MBPP/859", "entry_point": "sub_lists", "completion": "def sub_lists(input_list):\n    result = []\n    n = len(input_list)\n    \n    # Generate all possible combinations of the list\n    for i in range(1 << n):  # 2^n combinations\n        sublist = []\n        for j in range(n):\n            if i & (1 << j):  # Check if jth element is included\n                sublist.append(input_list[j])\n        result.append(sublist)\n    \n    return result\n\n# Test the function with the provided assertion\nassert sub_lists([10, 20, 30, 40]) == [[], [10], [20], [30], [40], \n                                        [10, 20], [10, 30], [10, 40], \n                                        [20, 30], [20, 40], [30, 40], \n                                        [10, 20, 30], [10, 20, 40], \n                                        [10, 30, 40], [20, 30, 40], \n                                        [10, 20, 30, 40]]"}
{"task_id": "MBPP/856", "entry_point": "find_Min_Swaps", "completion": "def find_Min_Swaps(arr, n):\n    # Count the number of 1's in the array\n    count_ones = arr.count(1)\n    \n    # Initialize the number of swaps\n    swaps = 0\n    # Initialize the position of 1's\n    position_of_ones = 0\n    \n    # Iterate through the array\n    for i in range(n):\n        # If we encounter a 1, we calculate how many 0's are to its left\n        if arr[i] == 1:\n            # The number of swaps needed for this 1 is equal to the number of 0's\n            # that have been encountered so far\n            swaps += i - position_of_ones\n            position_of_ones += 1\n            \n    return swaps\n\n# Test the function with the provided assertion\nassert find_Min_Swaps([1, 0, 1, 0], 4) == 3"}
{"task_id": "MBPP/865", "entry_point": "ntimes_list", "completion": "def ntimes_list(lst, n):\n    return list(map(lambda x: x * n, lst))\n\n# Test the function with the provided assertion\nassert ntimes_list([1, 2, 3, 4, 5, 6, 7], 3) == [3, 6, 9, 12, 15, 18, 21]"}
{"task_id": "MBPP/868", "entry_point": "length_Of_Last_Word", "completion": "def length_of_last_word(s: str) -> int:\n    # Strip any trailing spaces and split the string into words\n    words = s.strip().split()\n    # Return the length of the last word if there are any words\n    return len(words[-1]) if words else 0\n\n# Test the function with the provided assertion\nassert length_of_last_word(\"python language\") == 8"}
{"task_id": "MBPP/866", "entry_point": "check_monthnumb", "completion": "def check_monthnumb(month_name):\n    # List of months that have 31 days\n    months_with_31_days = [\n        \"January\", \"March\", \"May\", \"July\", \n        \"August\", \"October\", \"December\"\n    ]\n    \n    # Check if the month name is in the list\n    return month_name in months_with_31_days\n\n# Test the function with the assertion\nassert check_monthnumb(\"February\") == False"}
{"task_id": "MBPP/870", "entry_point": "sum_positivenum", "completion": "def sum_positivenum(numbers):\n    return sum(filter(lambda x: x > 0, numbers))\n\n# Test the function with the provided assertion\nassert sum_positivenum([2, 4, -6, -9, 11, -12, 14, -5, 17]) == 48"}
{"task_id": "MBPP/867", "entry_point": "min_Num", "completion": "def min_Num(arr, num):\n    total_sum = sum(arr) + num\n    return 1 if total_sum % 2 != 0 else 0\n\n# Test the function with the provided assertion\nassert min_Num([1, 2, 3, 4, 5, 6, 7, 8, 9], 9) == 1"}
{"task_id": "MBPP/873", "entry_point": "fibonacci", "completion": "def fibonacci(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n - 1) + fibonacci(n - 2)\n\n# Test the function with the provided assertion\nassert fibonacci(7) == 13"}
{"task_id": "MBPP/871", "entry_point": "are_Rotations", "completion": "def are_Rotations(str1, str2):\n    # Check if lengths are the same\n    if len(str1) != len(str2):\n        return False\n    \n    # Concatenate str1 with itself\n    temp = str1 + str1\n    \n    # Check if str2 is a substring of the concatenated string\n    return str2 in temp\n\n# Test the function with the provided assertion\nassert are_Rotations(\"abc\", \"cba\") == False"}
{"task_id": "MBPP/877", "entry_point": "sort_String", "completion": "def sort_String(s):\n    return ''.join(sorted(s))\n\n# Test the function\nassert sort_String(\"cba\") == \"abc\""}
{"task_id": "MBPP/869", "entry_point": "remove_list_range", "completion": "def remove_list_range(lists, min_val, max_val):\n    # Filter the lists to keep only those where all elements are within the specified range\n    return [sublist for sublist in lists if all(min_val <= item <= max_val for item in sublist)]\n\n# Test the function with the provided assertion\nassert remove_list_range([[2], [0], [1, 2, 3], [0, 1, 2, 3, 6, 7], [9, 11], [13, 14, 15, 17]], 13, 17) == [[13, 14, 15, 17]]"}
{"task_id": "MBPP/874", "entry_point": "check_Concat", "completion": "def check_Concat(s, sub):\n    # Check if the length of s is a multiple of the length of sub\n    if len(s) % len(sub) != 0:\n        return False\n    \n    # Calculate how many times sub should repeat\n    repeat_count = len(s) // len(sub)\n    \n    # Create the concatenated string by repeating sub\n    concatenated_string = sub * repeat_count\n    \n    # Check if the concatenated string matches s\n    return concatenated_string == s\n\n# Test the function with the provided assertion\nassert check_Concat(\"abcabcabc\", \"abc\") == True"}
{"task_id": "MBPP/872", "entry_point": "check_subset", "completion": "def check_subset(main_list, subset):\n    # Convert the main list to a set of tuples for easier comparison\n    main_set = set(tuple(item) for item in main_list)\n    # Convert the subset to a set of tuples\n    subset_set = set(tuple(item) for item in subset)\n    \n    # Check if the subset set is a subset of the main set\n    return subset_set.issubset(main_set)\n\n# Test the function with the provided assertion\nassert check_subset([[1, 3], [5, 7], [9, 11], [13, 15, 17]], [[1, 3], [13, 15, 17]]) == True"}
{"task_id": "MBPP/876", "entry_point": "lcm", "completion": "def lcm(a, b):\n    # Function to calculate the greatest common divisor (GCD)\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    \n    # LCM formula: lcm(a, b) = abs(a*b) // gcd(a, b)\n    return abs(a * b) // gcd(a, b)\n\n# Test the function with the provided assertion\nassert lcm(4, 6) == 12"}
{"task_id": "MBPP/875", "entry_point": "min_difference", "completion": "def min_difference(tuples):\n    # Initialize min_diff to a large number\n    min_diff = float('inf')\n    \n    # Iterate through each tuple\n    for a, b in tuples:\n        # Calculate the absolute difference\n        diff = abs(a - b)\n        # Update min_diff if the current difference is smaller\n        if diff < min_diff:\n            min_diff = diff\n            \n    return min_diff\n\n# Test the function with the provided assertion\nassert min_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 1"}
{"task_id": "MBPP/879", "entry_point": "text_match", "completion": "import re\n\ndef text_match(string):\n    # Define the regex pattern\n    pattern = r'a.*b$'\n    \n    # Use re.match to check if the pattern matches the string\n    if re.match(pattern, string):\n        return 'Matched!'\n    else:\n        return 'Not matched!'\n\n# Test the function\nassert text_match(\"aabbbbd\") == 'Not matched!'"}
{"task_id": "MBPP/883", "entry_point": "div_of_nums", "completion": "def div_of_nums(numbers, m, n):\n    return list(filter(lambda x: x % m == 0 and x % n == 0, numbers))\n\n# Test the function with the provided assertion\nassert div_of_nums([19, 65, 57, 39, 152, 639, 121, 44, 90, 190], 2, 4) == [152, 44]"}
{"task_id": "MBPP/880", "entry_point": "Check_Solution", "completion": "def Check_Solution(a, b, c):\n    # Calculate the discriminant\n    D = b**2 - 4*a*c\n    \n    # Determine the number of solutions based on the discriminant\n    if D > 0:\n        return \"2 solutions\"\n    elif D == 0:\n        return \"1 solution\"\n    else:\n        return \"0 solutions\"\n\n# Example assertion\nassert Check_Solution(2, 5, 2) == \"2 solutions\""}
{"task_id": "MBPP/882", "entry_point": "parallelogram_perimeter", "completion": "def parallelogram_perimeter(a, b):\n    return 2 * (a + b)\n\n# Assertion to test the function\nassert parallelogram_perimeter(10, 20) == 60"}
{"task_id": "MBPP/881", "entry_point": "sum_even_odd", "completion": "def sum_even_odd(numbers):\n    first_even = None\n    first_odd = None\n    \n    for number in numbers:\n        if number % 2 == 0 and first_even is None:\n            first_even = number\n        elif number % 2 != 0 and first_odd is None:\n            first_odd = number\n        \n        # Break the loop if both first even and odd are found\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # If either is not found, we can return 0 for that part\n    return (first_even if first_even is not None else 0) + (first_odd if first_odd is not None else 0)\n\n# Test the function with the provided assertion\nassert sum_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 5"}
{"task_id": "MBPP/887", "entry_point": "is_odd", "completion": "def is_odd(number):\n    return (number & 1) == 1\n\n# Test the function\nassert is_odd(5) == True\nassert is_odd(4) == False\nassert is_odd(0) == False\nassert is_odd(-3) == True"}
{"task_id": "MBPP/886", "entry_point": "sum_num", "completion": "def sum_num(numbers):\n    total = sum(numbers)  # Calculate the sum of the numbers\n    count = len(numbers)  # Get the number of elements in the list\n    return total / count  # Return the average\n\n# Test the function with the provided assertion\nassert sum_num((8, 2, 3, 0, 7)) == 4.0"}
{"task_id": "MBPP/878", "entry_point": "check_tuples", "completion": "def check_tuples(tup, elements):\n    # Convert the list of elements to a set for faster lookup\n    element_set = set(elements)\n    \n    # Check if all elements in the tuple are in the set of specified elements\n    return all(item in element_set for item in tup)\n\n# Test the function with the provided assertion\nassert check_tuples((3, 5, 6, 5, 3, 6), [3, 6, 5]) == True"}
{"task_id": "MBPP/891", "entry_point": "same_Length", "completion": "def same_length(num1, num2):\n    return len(str(abs(num1))) == len(str(abs(num2)))\n\n# Test the function with the provided assertion\nassert same_length(12, 1) == False"}
{"task_id": "MBPP/884", "entry_point": "all_Bits_Set_In_The_Given_Range", "completion": "def all_Bits_Set_In_The_Given_Range(num, start, end):\n    # Create a mask for the bits in the given range\n    mask = ((1 << (end - start + 1)) - 1) << start\n    \n    # Check if the bits in the range are set in the number\n    return (num & mask) == mask\n\n# Test the function with the provided assertion\nassert all_Bits_Set_In_The_Given_Range(10, 2, 1) == True"}
{"task_id": "MBPP/885", "entry_point": "is_Isomorphic", "completion": "def is_Isomorphic(s1, s2):\n    if len(s1) != len(s2):\n        return False\n\n    mapping_s1_to_s2 = {}\n    mapping_s2_to_s1 = {}\n\n    for char1, char2 in zip(s1, s2):\n        if char1 in mapping_s1_to_s2:\n            if mapping_s1_to_s2[char1] != char2:\n                return False\n        else:\n            mapping_s1_to_s2[char1] = char2\n\n        if char2 in mapping_s2_to_s1:\n            if mapping_s2_to_s1[char2] != char1:\n                return False\n        else:\n            mapping_s2_to_s1[char2] = char1\n\n    return True\n\n# Test the function with the provided assertion\nassert is_Isomorphic(\"paper\", \"title\") == True"}
{"task_id": "MBPP/888", "entry_point": "substract_elements", "completion": "def substract_elements(t1, t2):\n    return tuple(\n        tuple(a - b for a, b in zip(inner_t1, inner_t2))\n        for inner_t1, inner_t2 in zip(t1, t2)\n    )\n\n# Test the function with the provided assertion\nassert substract_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((-5, -4), (1, -4), (1, 8), (-6, 7))"}
{"task_id": "MBPP/889", "entry_point": "reverse_list_lists", "completion": "def reverse_list_lists(list_of_lists):\n    return [lst[::-1] for lst in list_of_lists]\n\n# Test the function with the provided assertion\nassert reverse_list_lists([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == [[4, 3, 2, 1], [8, 7, 6, 5], [12, 11, 10, 9], [16, 15, 14, 13]]"}
{"task_id": "MBPP/890", "entry_point": "find_Extra", "completion": "def find_Extra(arr1, arr2, n):\n    # Since arr1 is longer than arr2, we can iterate through arr2\n    for i in range(n):\n        if arr1[i] != arr2[i]:\n            return i  # Return the index of the extra element in arr1\n    return n  # If no difference found, the extra element is at the end of arr1\n\n# Example usage\nassert find_Extra([1, 2, 3, 4], [1, 2, 3], 3) == 3"}
{"task_id": "MBPP/892", "entry_point": "remove_spaces", "completion": "def remove_spaces(input_string):\n    # Split the string by whitespace and join it back with a single space\n    return ' '.join(input_string.split())\n\n# Test the function with the provided assertion\nassert remove_spaces('python  program') == 'python program'"}
{"task_id": "MBPP/897", "entry_point": "is_Word_Present", "completion": "def is_Word_Present(sentence, word):\n    # Check if the word is present in the sentence\n    return word in sentence.split()\n\n# Test the function with the provided assertion\nassert is_Word_Present(\"machine learning\", \"machine\") == True"}
{"task_id": "MBPP/896", "entry_point": "sort_list_last", "completion": "def sort_list_last(tuples):\n    return sorted(tuples, key=lambda x: x[-1])\n\n# Test the function with the provided assertion\nassert sort_list_last([(2, 5), (1, 2), (4, 4), (2, 3), (2, 1)]) == [(2, 1), (1, 2), (2, 3), (4, 4), (2, 5)]"}
{"task_id": "MBPP/900", "entry_point": "match_num", "completion": "def match_num(s):\n    # Check if the string starts with '5'\n    return s.startswith('5')\n\n# Test the function with the provided assertion\nassert match_num('5-2345861') == True"}
{"task_id": "MBPP/893", "entry_point": "Extract", "completion": "def Extract(sublists):\n    return [sublist[-1] for sublist in sublists]\n\n# Test the function with the provided assertion\nassert Extract([[1, 2, 3], [4, 5], [6, 7, 8, 9]]) == [3, 5, 9]"}
{"task_id": "MBPP/894", "entry_point": "float_to_tuple", "completion": "def float_to_tuple(float_string):\n    # Split the string by commas and convert each part to a float\n    float_list = [float(num) for num in float_string.split(',')]\n    # Convert the list to a tuple and return it\n    return tuple(float_list)\n\n# Test the function with the provided assertion\nassert float_to_tuple(\"1.2, 1.3, 2.3, 2.4, 6.5\") == (1.2, 1.3, 2.3, 2.4, 6.5)"}
{"task_id": "MBPP/895", "entry_point": "max_sum_subseq", "completion": "def max_sum_subseq(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n    if n == 1:\n        return arr[0]\n    \n    # Create an array to store the maximum sum up to each index\n    max_sum = [0] * n\n    max_sum[0] = arr[0]\n    max_sum[1] = max(arr[0], arr[1])\n    \n    for i in range(2, n):\n        # Include the current element and add it to the max sum excluding the previous element\n        include_current = arr[i] + max_sum[i - 2]\n        # Exclude the current element\n        exclude_current = max_sum[i - 1]\n        # Take the maximum of including or excluding the current element\n        max_sum[i] = max(include_current, exclude_current)\n    \n    return max_sum[-1]\n\n# Test the function with the provided assertion\nassert max_sum_subseq([1, 2, 9, 4, 5, 0, 4, 11, 6]) == 26"}
{"task_id": "MBPP/902", "entry_point": "add_dict", "completion": "def add_dict(dict1, dict2):\n    combined_dict = {}\n    \n    # Add values from the first dictionary\n    for key, value in dict1.items():\n        combined_dict[key] = value\n    \n    # Add values from the second dictionary\n    for key, value in dict2.items():\n        if key in combined_dict:\n            combined_dict[key] += value\n        else:\n            combined_dict[key] = value\n            \n    return combined_dict\n\n# Test the function with the provided assertion\nassert add_dict({'a': 100, 'b': 200, 'c': 300}, {'a': 300, 'b': 200, 'd': 400}) == {'a': 400, 'b': 400, 'c': 300, 'd': 400}"}
{"task_id": "MBPP/898", "entry_point": "extract_elements", "completion": "def extract_elements(lst, n):\n    if n <= 0:\n        return []\n    \n    result = []\n    previous = None\n    count = 0\n    \n    for element in lst:\n        if element != previous:\n            if count > 0:\n                result.append(previous)\n            previous = element\n            count = 1\n        else:\n            count += 1\n        \n        if len(result) == n:\n            break\n    \n    if count > 0 and len(result) < n:\n        result.append(previous)\n    \n    return result\n\n# Test the function with the provided assertion\nassert extract_elements([1, 1, 3, 4, 4, 5, 6, 7], 2) == [1, 4]"}
{"task_id": "MBPP/904", "entry_point": "even_num", "completion": "def even_num(n):\n    # Check if the number is an integer and if it is even\n    if isinstance(n, int):\n        return n % 2 == 0\n    return False\n\n# Test the function with the provided assertion\nassert even_num(13.5) == False"}
{"task_id": "MBPP/905", "entry_point": "sum_of_square", "completion": "import math\n\ndef sum_of_square(n):\n    # Calculate the binomial coefficient C(2n, n)\n    return math.comb(2 * n, n)\n\n# Test the function with the provided assertion\nassert sum_of_square(4) == 70"}
{"task_id": "MBPP/899", "entry_point": "check", "completion": "def check(arr, n):\n    # If the array has less than 2 elements, it is trivially sortable\n    if n < 2:\n        return True\n    \n    # Create a new array using only the corner elements\n    corner_elements = [arr[0], arr[-1]]\n    \n    # Sort the corner elements\n    sorted_corners = sorted(corner_elements)\n    \n    # Check if the original array can be sorted using the corner elements\n    # We can only replace the first and last elements with the sorted corners\n    new_array = [sorted_corners[0]] + arr[1:-1] + [sorted_corners[1]]\n    \n    # Check if the new array is sorted\n    return new_array == sorted(new_array)\n\n# Test the function with the provided assertion\nassert check([3, 2, 1, 2, 3, 4], 6) == True"}
{"task_id": "MBPP/901", "entry_point": "smallest_multiple", "completion": "import math\nfrom functools import reduce\n\ndef lcm(a, b):\n    return abs(a * b) // math.gcd(a, b)\n\ndef smallest_multiple(n):\n    return reduce(lcm, range(1, n + 1))\n\n# Test the function with the provided assertion\nassert smallest_multiple(13) == 360360"}
{"task_id": "MBPP/906", "entry_point": "extract_date", "completion": "import re\n\ndef extract_date(url):\n    # Regular expression to match the date pattern in the URL\n    pattern = r'(\\d{4})/(\\d{2})/(\\d{2})'\n    matches = re.findall(pattern, url)\n    return matches\n\n# Test the function with the provided assertion\nassert extract_date(\"https://www.washingtonpost.com/news/football-insider/wp/2016/09/02/odell-beckhams-fame-rests-on-one-stupid-little-ball-josh-norman-tells-author/\") == [('2016', '09', '02')]"}
{"task_id": "MBPP/903", "entry_point": "count_Unset_Bits", "completion": "def count_Unset_Bits(n):\n    total_unset_bits = 0\n    \n    for i in range(1, n + 1):\n        # Convert the number to binary and count the number of '0's\n        binary_representation = bin(i)[2:]  # Get binary representation without '0b' prefix\n        unset_bits_count = binary_representation.count('0')\n        total_unset_bits += unset_bits_count\n    \n    return total_unset_bits\n\n# Test the function with the provided assertion\nassert count_Unset_Bits(2) == 1"}
{"task_id": "MBPP/909", "entry_point": "previous_palindrome", "completion": "def is_palindrome(n):\n    return str(n) == str(n)[::-1]\n\ndef previous_palindrome(n):\n    # Start checking from the number just below n\n    n -= 1\n    while n >= 0:\n        if is_palindrome(n):\n            return n\n        n -= 1\n    return None  # In case there is no previous palindrome (for n = 0)\n\n# Test the function with the provided assertion\nassert previous_palindrome(99) == 88"}
{"task_id": "MBPP/907", "entry_point": "lucky_num", "completion": "def lucky_num(n):\n    # Start with a list of natural numbers\n    numbers = list(range(1, n * 2))  # We need to ensure we have enough numbers\n    index = 1  # Start with the second number (index 1)\n\n    while index < len(numbers):\n        # Remove every numbers[index]-th number\n        step = numbers[index]\n        numbers = [num for i, num in enumerate(numbers) if (i + 1) % step != 0]\n        index += 1\n\n    return numbers[:n]\n\n# Test the function\nassert lucky_num(10) == [1, 3, 7, 9, 13, 15, 21, 25, 31, 33]"}
{"task_id": "MBPP/913", "entry_point": "end_num", "completion": "def end_num(s):\n    # Check if the last character of the string is a digit\n    return s[-1].isdigit() if s else False\n\n# Test the function with the provided assertion\nassert end_num('abcdef') == False"}
{"task_id": "MBPP/908", "entry_point": "find_fixed_point", "completion": "def find_fixed_point(arr, n):\n    for i in range(n):\n        if arr[i] == i:\n            return i\n    return -1  # Return -1 if no fixed point is found\n\n# Test the function with the provided assertion\nassert find_fixed_point([-10, -1, 0, 3, 10, 11, 30, 50, 100], 9) == 3"}
{"task_id": "MBPP/912", "entry_point": "int", "completion": "def lobb_num(n, m):\n    if n == 0:\n        return m + 1\n    elif m == 0:\n        return n + 1\n    else:\n        return lobb_num(n - 1, lobb_num(n, m - 1))\n\n# Test the function with the provided assertion\nassert int(lobb_num(5, 3)) == 35"}
{"task_id": "MBPP/917", "entry_point": "text_uppercase_lowercase", "completion": "import re\n\ndef text_uppercase_lowercase(text):\n    # Regular expression to match one uppercase letter followed by one or more lowercase letters\n    pattern = r'[A-Z][a-z]+'\n    \n    # Find all matches in the input text\n    matches = re.findall(pattern, text)\n    \n    # Check if any matches were found\n    if matches:\n        return 'Found a match!'\n    else:\n        return 'No match found.'\n\n# Test the function with the provided assertion\nassert text_uppercase_lowercase(\"AaBbGg\") == 'Found a match!'"}
{"task_id": "MBPP/915", "entry_point": "rearrange_numbs", "completion": "def rearrange_numbs(arr):\n    # Use a lambda function to filter and sort the positive and negative numbers\n    positives = list(filter(lambda x: x > 0, arr))\n    negatives = list(filter(lambda x: x < 0, arr))\n    \n    # Combine the positives and negatives\n    return positives + negatives\n\n# Test the function with the provided assertion\nassert rearrange_numbs([-1, 2, -3, 5, 7, 8, 9, -10]) == [2, 5, 7, 8, 9, -10, -3, -1]"}
{"task_id": "MBPP/911", "entry_point": "maximum_product", "completion": "import heapq\n\ndef maximum_product(arr):\n    if len(arr) < 3:\n        raise ValueError(\"Array must contain at least three numbers.\")\n    \n    # Use heapq to find the three largest numbers\n    largest_three = heapq.nlargest(3, arr)\n    \n    # Calculate the product of the three largest numbers\n    product = largest_three[0] * largest_three[1] * largest_three[2]\n    \n    return product\n\n# Test the function with the provided assertion\nassert maximum_product([12, 74, 9, 50, 61, 41]) == 225700"}
{"task_id": "MBPP/919", "entry_point": "multiply_list", "completion": "def multiply_list(items):\n    result = 1\n    for item in items:\n        result *= item\n    return result\n\n# Test the function with the provided assertion\nassert multiply_list([1, -2, 3]) == -6"}
{"task_id": "MBPP/914", "entry_point": "is_Two_Alter", "completion": "def is_Two_Alter(s):\n    # Check if the string has at least two characters\n    if len(s) < 2:\n        return False\n    \n    # Get the unique characters in the string\n    unique_chars = set(s)\n    \n    # Check if there are exactly two unique characters\n    if len(unique_chars) != 2:\n        return False\n    \n    # Check if the characters alternate\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            return False\n            \n    return True\n\n# Test the function with the provided assertion\nassert is_Two_Alter(\"abab\") == True"}
{"task_id": "MBPP/910", "entry_point": "check_date", "completion": "def check_date(day, month, year):\n    # Check if the year is a valid integer\n    if not isinstance(year, int) or year < 1:\n        return False\n    \n    # Check if the month is valid\n    if month < 1 or month > 12:\n        return False\n    \n    # Days in each month\n    days_in_month = [31, 29 if (year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)) else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    # Check if the day is valid\n    if day < 1 or day > days_in_month[month - 1]:\n        return False\n    \n    return True\n\n# Test the function\nassert check_date(11, 11, 2002) == True"}
{"task_id": "MBPP/916", "entry_point": "find_triplet_array", "completion": "def find_triplet_array(arr, n, target_sum):\n    # Sort the array to use the two-pointer technique\n    arr.sort()\n    \n    # Iterate through the array\n    for i in range(n - 2):\n        # Initialize two pointers\n        left = i + 1\n        right = n - 1\n        \n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            if current_sum == target_sum:\n                return (arr[i], arr[left], arr[right])\n            elif current_sum < target_sum:\n                left += 1\n            else:\n                right -= 1\n                \n    return None\n\n# Example usage\nassert find_triplet_array([1, 4, 45, 6, 10, 8], 6, 22) == (4, 10, 8)"}
{"task_id": "MBPP/921", "entry_point": "chunk_tuples", "completion": "def chunk_tuples(input_tuple, n):\n    # Use a list comprehension to create chunks of size n\n    return [input_tuple[i:i + n] for i in range(0, len(input_tuple), n)]\n\n# Test the function with the provided assertion\nassert chunk_tuples((10, 4, 5, 6, 7, 6, 8, 3, 4), 3) == [(10, 4, 5), (6, 7, 6), (8, 3, 4)]"}
{"task_id": "MBPP/925", "entry_point": "mutiple_tuple", "completion": "def multiple_tuple(numbers):\n    product = 1\n    for number in numbers:\n        product *= number\n    return product\n\n# Test the function with the provided assertion\nassert multiple_tuple((4, 3, 2, 2, -1, 18)) == -864"}
{"task_id": "MBPP/924", "entry_point": "max_of_two", "completion": "def max_of_two(a, b):\n    \"\"\"Return the maximum of two numbers.\"\"\"\n    return a if a > b else b\n\n# Test the function\nassert max_of_two(10, 20) == 20"}
{"task_id": "MBPP/922", "entry_point": "max_product", "completion": "def max_product(arr):\n    if len(arr) < 2:\n        raise ValueError(\"Array must contain at least two elements.\")\n    \n    # Initialize variables to keep track of the two largest numbers\n    max1 = max2 = float('-inf')\n    \n    for num in arr:\n        if num > max1:\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max2 = num\n    \n    return (max2, max1)\n\n# Test the function with the provided assertion\nassert max_product([1, 2, 3, 4, 7, 0, 8, 4]) == (7, 8)"}
{"task_id": "MBPP/928", "entry_point": "change_date_format", "completion": "def change_date_format(date_str):\n    # Split the input date string by '-'\n    year, month, day = date_str.split('-')\n    # Rearrange the components to the desired format\n    return f\"{day}-{month}-{year}\"\n\n# Test the function with the provided assertion\nassert change_date_format('2026-01-02') == '02-01-2026'"}
{"task_id": "MBPP/918", "entry_point": "coin_change", "completion": "def coin_change(coins, num_coins, amount):\n    # Create a list to store the number of ways to make change for each amount\n    dp = [0] * (amount + 1)\n    \n    # There is one way to make change for 0 amount: use no coins\n    dp[0] = 1\n    \n    # Iterate over each coin\n    for coin in coins:\n        # Update the dp array for all amounts from coin to the target amount\n        for x in range(coin, amount + 1):\n            dp[x] += dp[x - coin]\n    \n    return dp[amount]\n\n# Test the function with the provided assertion\nassert coin_change([1, 2, 3], 3, 4) == 4"}
{"task_id": "MBPP/920", "entry_point": "remove_tuple", "completion": "def remove_tuple(tuple_list):\n    # Filter out tuples that are all None\n    filtered_tuples = [t for t in tuple_list if any(value is not None for value in t)]\n    return str(filtered_tuples)\n\n# Test the function with the provided assertion\nassert remove_tuple([(None, 2), (None, None), (3, 4), (12, 3), (None, )]) == '[(None, 2), (3, 4), (12, 3)]'"}
{"task_id": "MBPP/931", "entry_point": "sum_series", "completion": "def sum_series(n):\n    return sum(i**3 for i in range(1, n + 1))\n\n# Test the function with the provided assertion\nassert sum_series(7) == 784"}
{"task_id": "MBPP/929", "entry_point": "count_tuplex", "completion": "def count_tuplex(tup, item):\n    return tup.count(item)\n\n# Test the function with the provided assertion\nassert count_tuplex((2, 4, 5, 6, 2, 3, 4, 4, 7), 4) == 3"}
{"task_id": "MBPP/930", "entry_point": "text_match", "completion": "import re\n\ndef text_match(string):\n    # Define the regex pattern for 'a' followed by zero or more 'b's\n    pattern = r'a(b*)'\n    \n    # Use re.fullmatch to check if the entire string matches the pattern\n    if re.fullmatch(pattern, string):\n        return 'Matched!'\n    else:\n        return 'Not matched!'\n\n# Test the function\nassert text_match(\"msb\") == 'Not matched!'"}
{"task_id": "MBPP/932", "entry_point": "remove_duplic_list", "completion": "def remove_duplic_list(words):\n    # Use a set to track seen words and maintain order\n    seen = set()\n    result = []\n    for word in words:\n        if word not in seen:\n            seen.add(word)\n            result.append(word)\n    return result\n\n# Test the function with the provided assertion\nassert remove_duplic_list([\"Python\", \"Exercises\", \"Practice\", \"Solution\", \"Exercises\"]) == ['Python', 'Exercises', 'Practice', 'Solution']"}
{"task_id": "MBPP/935", "entry_point": "series_sum", "completion": "def series_sum(n):\n    return sum(i**2 for i in range(1, n + 1))\n\n# Test the function with the provided assertion\nassert series_sum(6) == 91"}
{"task_id": "MBPP/926", "entry_point": "rencontres_number", "completion": "def rencontres_number(n, k):\n    # Create a 2D list to store the rencontres numbers\n    R = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    # Base case\n    R[0][0] = 1  # R(0, 0) = 1\n    \n    # Fill the table using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            R[i][j] = j * R[i - 1][j - 1] + (i - j) * R[i - 1][j]\n    \n    return R[n][k]\n\n# Test the function with the provided assertion\nassert rencontres_number(7, 2) == 924"}
{"task_id": "MBPP/933", "entry_point": "camel_to_snake", "completion": "import re\n\ndef camel_to_snake(camel_str):\n    # Use regex to find the positions where a lowercase letter is followed by an uppercase letter\n    # and replace it with the lowercase letter followed by an underscore and the lowercase version of the uppercase letter\n    snake_str = re.sub(r'(?<!^)(?=[A-Z])', '_', camel_str).lower()\n    return snake_str\n\n# Test the function\nassert camel_to_snake('GoogleAssistant') == 'google_assistant'"}
{"task_id": "MBPP/936", "entry_point": "re_arrange_tuples", "completion": "def re_arrange_tuples(tuples_list, order):\n    # Create a dictionary to map the first element of each tuple to the tuple itself\n    tuple_dict = {t[0]: t for t in tuples_list}\n    \n    # Use the order list to create a new list of tuples in the specified order\n    arranged_tuples = [tuple_dict[i] for i in order if i in tuple_dict]\n    \n    return arranged_tuples\n\n# Example usage\nassert re_arrange_tuples([(4, 3), (1, 9), (2, 10), (3, 2)], [1, 4, 2, 3]) == [(1, 9), (4, 3), (2, 10), (3, 2)]"}
{"task_id": "MBPP/927", "entry_point": "candidate", "completion": "class TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\ndef max_height(root):\n    if root is None:\n        return -1  # Return -1 for null nodes to count edges correctly\n    else:\n        left_height = max_height(root.left)\n        right_height = max_height(root.right)\n        return 1 + max(left_height, right_height)\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Constructing a binary tree\n    #       1\n    #      / \\\n    #     2   3\n    #    / \\\n    #   4   5\n    #  /\n    # 6\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.left.left.left = TreeNode(6)\n\n    assert (max_height(root)) == 3  # The height of this tree is 3"}
{"task_id": "MBPP/937", "entry_point": "max_char", "completion": "from collections import Counter\n\ndef max_char(s):\n    # Count the occurrences of each character in the string\n    char_count = Counter(s)\n    # Find the character with the maximum count\n    most_common_char = char_count.most_common(1)[0][0]\n    return most_common_char\n\n# Test the function with the provided assertion\nassert max_char(\"hello world\") == 'l'"}
{"task_id": "MBPP/939", "entry_point": "sorted_models", "completion": "def sorted_models(models):\n    return sorted(models, key=lambda x: x['model'])\n\n# Test the function with the provided assertion\nassert sorted_models([\n    {'make': 'Nokia', 'model': 216, 'color': 'Black'},\n    {'make': 'Mi Max', 'model': 2, 'color': 'Gold'},\n    {'make': 'Samsung', 'model': 7, 'color': 'Blue'}\n]) == [\n    {'make': 'Nokia', 'model': 216, 'color': 'Black'},\n    {'make': 'Samsung', 'model': 7, 'color': 'Blue'},\n    {'make': 'Mi Max', 'model': 2, 'color': 'Gold'}\n]"}
{"task_id": "MBPP/923", "entry_point": "super_seq", "completion": "def lcs_length(str1, str2):\n    m = len(str1)\n    n = len(str2)\n    \n    # Create a 2D array to store lengths of longest common subsequence\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Build the dp array\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[m][n]\n\ndef super_seq(str1, str2, len1, len2):\n    lcs_len = lcs_length(str1, str2)\n    return len1 + len2 - lcs_len\n\n# Test the function with the provided assertion\nassert super_seq(\"AGGTAB\", \"GXTXAYB\", 6, 7) == 9"}
{"task_id": "MBPP/941", "entry_point": "count_elim", "completion": "def count_elim(lst):\n    count = 0\n    for element in lst:\n        if isinstance(element, tuple):\n            break\n        count += 1\n    return count\n\n# Test the function with the provided assertion\nassert count_elim([10, 20, 30, (10, 20), 40]) == 3"}
{"task_id": "MBPP/942", "entry_point": "check_element", "completion": "def check_element(elements, lst):\n    return any(elem in lst for elem in elements)\n\n# Test the function with the provided assertion\nassert check_element((4, 5, 7, 9, 3), [6, 7, 10, 11]) == True"}
{"task_id": "MBPP/934", "entry_point": "dealnnoy_num", "completion": "def delannoy_num(m, n):\n    # Create a 2D array to store the Delannoy numbers\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Base cases\n    for i in range(m + 1):\n        dp[i][0] = 1  # Only one way to reach any cell in the first column\n    for j in range(n + 1):\n        dp[0][j] = 1  # Only one way to reach any cell in the first row\n    \n    # Fill the dp table using the recursive relation\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + dp[i - 1][j - 1]\n    \n    return dp[m][n]\n\n# Test the function with the provided assertion\nassert delannoy_num(3, 4) == 129"}
{"task_id": "MBPP/945", "entry_point": "tuple_to_set", "completion": "def tuple_to_set(input_tuple):\n    return set(input_tuple)\n\n# Test the function with the provided assertion\nassert tuple_to_set(('x', 'y', 'z')) == {'y', 'x', 'z'}"}
{"task_id": "MBPP/943", "entry_point": "combine_lists", "completion": "import heapq\n\ndef combine_lists(list1, list2):\n    return list(heapq.merge(list1, list2))\n\n# Test the function with the provided assertion\nassert combine_lists([1, 3, 5, 7, 9, 11], [0, 2, 4, 6, 8, 10]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]"}
{"task_id": "MBPP/946", "entry_point": "most_common_elem", "completion": "from collections import Counter\n\ndef most_common_elem(text, n):\n    # Count the frequency of each character in the text\n    counter = Counter(text)\n    # Get the n most common elements\n    most_common = counter.most_common(n)\n    return most_common\n\n# Test the function with the provided assertion\nassert most_common_elem('lkseropewdssafsdfafkpwe', 3) == [('s', 4), ('e', 3), ('f', 3)]"}
{"task_id": "MBPP/940", "entry_point": "heap_sort", "completion": "def heapify(arr, n, i):\n    largest = i  # Initialize largest as root\n    left = 2 * i + 1  # left = 2*i + 1\n    right = 2 * i + 2  # right = 2*i + 2\n\n    # If left child is larger than root\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n\n    # If right child is larger than largest so far\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n\n    # If largest is not root\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # swap\n\n        # Recursively heapify the affected sub-tree\n        heapify(arr, n, largest)\n\ndef heap_sort(arr):\n    n = len(arr)\n\n    # Build a maxheap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    # One by one extract elements from heap\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]  # swap\n        heapify(arr, i, 0)\n\n    return arr\n\n# Test the function\nassert heap_sort([12, 2, 4, 5, 2, 3]) == [2, 2, 3, 4, 5, 12]"}
{"task_id": "MBPP/947", "entry_point": "len_log", "completion": "def len_log(words):\n    if not words:\n        return 0  # Return 0 if the list is empty\n    return min(len(word) for word in words)\n\n# Example usage\nassert len_log([\"win\", \"lose\", \"great\"]) == 3"}
{"task_id": "MBPP/938", "entry_point": "find_closet", "completion": "def find_closet(arr1, arr2, arr3, n1, n2, n3):\n    # Initialize pointers for each array\n    i, j, k = 0, 0, 0\n    # Initialize the result to store the closest elements\n    closest = (0, 0, 0)\n    # Initialize the minimum difference to a large value\n    min_diff = float('inf')\n\n    while i < n1 and j < n2 and k < n3:\n        # Get the current elements from each array\n        a, b, c = arr1[i], arr2[j], arr3[k]\n        # Find the maximum and minimum of the three elements\n        current_max = max(a, b, c)\n        current_min = min(a, b, c)\n        # Calculate the difference\n        current_diff = current_max - current_min\n        \n        # Update the closest elements if the current difference is smaller\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest = (a, b, c)\n        \n        # Move the pointer of the array with the smallest element\n        if current_min == a:\n            i += 1\n        elif current_min == b:\n            j += 1\n        else:\n            k += 1\n\n    return closest\n\n# Test the function with the provided assertion\nassert find_closet([1, 4, 10], [2, 15, 20], [10, 12], 3, 3, 2) == (10, 15, 10)"}
{"task_id": "MBPP/948", "entry_point": "get_item", "completion": "def get_item(tup, index):\n    return tup[index:index+1]\n\n# Test the function with the provided assertion\nassert get_item((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"), 3) == ('e',)"}
{"task_id": "MBPP/944", "entry_point": "num_position", "completion": "def num_position(s):\n    # Initialize a list to hold the positions of numbers\n    positions = []\n    \n    # Split the string into words\n    words = s.split()\n    \n    # Iterate through the words and their indices\n    for index, word in enumerate(words):\n        # Check if the word is a digit\n        if word.isdigit():\n            # Print the number and its position\n            print(f\"Number: {word}, Position: {index}\")\n            # Append the position to the list\n            positions.append(index)\n    \n    # Return the count of numbers found\n    return len(positions)\n\n# Example usage\nassert num_position(\"there are 70 flats in this apartment\") == 1"}
{"task_id": "MBPP/950", "entry_point": "chinese_zodiac", "completion": "def chinese_zodiac(year):\n    zodiac_signs = [\n        'Rat', 'Ox', 'Tiger', 'Rabbit', 'Dragon', \n        'Snake', 'Horse', 'Goat', 'Monkey', 'Rooster', \n        'Dog', 'Pig'\n    ]\n    return zodiac_signs[(year - 4) % 12]\n\n# Test the function with the provided assertion\nassert chinese_zodiac(1997) == 'Ox'"}
{"task_id": "MBPP/954", "entry_point": "profit_amount", "completion": "def profit_amount(selling_price, cost_price):\n    profit = selling_price - cost_price\n    return profit if profit > 0 else None\n\n# Test the function with the provided assertion\nassert profit_amount(1500, 1200) == 300"}
{"task_id": "MBPP/956", "entry_point": "split_list", "completion": "import re\n\ndef split_list(s):\n    # Use regex to split the string at uppercase letters\n    return re.findall(r'[A-Z][a-z]*|[a-z]+', s)\n\n# Test the function with the provided assertion\nassert split_list(\"LearnToBuildAnythingWithGoogle\") == ['Learn', 'To', 'Build', 'Anything', 'With', 'Google']"}
{"task_id": "MBPP/949", "entry_point": "sort_list", "completion": "def sort_list(tuples_list):\n    # Function to calculate the total number of digits in a tuple\n    def total_digits(tup):\n        return sum(len(str(abs(num))) for num in tup)\n    \n    # Sort the list of tuples based on the total number of digits\n    sorted_list = sorted(tuples_list, key=total_digits)\n    \n    # Return the sorted list as a string\n    return str(sorted_list)\n\n# Test the function with the provided assertion\nassert sort_list([(3, 4, 6, 723), (1, 2), (12345,), (134, 234, 34)]) == '[(1, 2), (12345,), (3, 4, 6, 723), (134, 234, 34)]'"}
{"task_id": "MBPP/955", "entry_point": "is_abundant", "completion": "def is_abundant(n):\n    if n < 1:\n        return False\n    \n    # Calculate the sum of proper divisors\n    sum_of_divisors = sum(i for i in range(1, n) if n % i == 0)\n    \n    # Check if the sum of divisors is greater than the number\n    return sum_of_divisors > n\n\n# Test the function with the provided assertion\nassert is_abundant(12) == True"}
{"task_id": "MBPP/953", "entry_point": "subset", "completion": "def subset(arr, n):\n    from collections import Counter\n    \n    # Count the frequency of each element in the array\n    frequency = Counter(arr)\n    \n    # The minimum number of subsets needed is the maximum frequency\n    return max(frequency.values())\n\n# Test the function with the provided assertion\nassert subset([1, 2, 3, 4], 4) == 1"}
{"task_id": "MBPP/959", "entry_point": "Average", "completion": "def Average(numbers):\n    if not numbers:  # Check if the list is empty\n        return 0\n    return sum(numbers) / len(numbers)\n\n# Test the function with the provided assertion\nassert Average([15, 9, 55, 41, 35, 20, 62, 49]) == 35.75"}
{"task_id": "MBPP/951", "entry_point": "max_similar_indices", "completion": "def max_similar_indices(list1, list2):\n    # Ensure both lists are of the same length\n    if len(list1) != len(list2):\n        raise ValueError(\"Both lists must have the same length.\")\n    \n    # Create a new list to store the maximum tuples\n    max_tuples = []\n    \n    # Iterate through both lists simultaneously\n    for tuple1, tuple2 in zip(list1, list2):\n        # Append the maximum of the two tuples to the result list\n        max_tuples.append(max(tuple1, tuple2))\n    \n    return max_tuples\n\n# Test the function with the provided assertion\nassert max_similar_indices([(2, 4), (6, 7), (5, 1)], [(5, 4), (8, 10), (8, 14)]) == [(5, 4), (8, 10), (8, 14)]"}
{"task_id": "MBPP/957", "entry_point": "get_First_Set_Bit_Pos", "completion": "def get_First_Set_Bit_Pos(n):\n    if n == 0:\n        return -1  # Return -1 if there are no set bits\n    position = 1\n    while (n & 1) == 0:\n        n >>= 1\n        position += 1\n    return position\n\n# Test the function with the provided assertion\nassert get_First_Set_Bit_Pos(12) == 3"}
{"task_id": "MBPP/952", "entry_point": "nCr_mod_p", "completion": "def factorial_mod(n, p):\n    \"\"\"Compute n! % p for n >= 0.\"\"\"\n    if n == 0:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % p\n    return result\n\ndef mod_inverse(a, p):\n    \"\"\"Compute the modular inverse of a under modulo p using Fermat's Little Theorem.\"\"\"\n    return pow(a, p - 2, p)\n\ndef nCr_mod_p(n, r, p):\n    \"\"\"Compute nCr % p.\"\"\"\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    \n    # Calculate n!, r!, and (n-r)!\n    num = factorial_mod(n, p)\n    denom = (factorial_mod(r, p) * factorial_mod(n - r, p)) % p\n    \n    # Calculate the modular inverse of denom\n    denom_inv = mod_inverse(denom, p)\n    \n    # Calculate nCr % p\n    return (num * denom_inv) % p\n\n# Test the function with the provided assertion\nassert nCr_mod_p(10, 2, 13) == 6"}
{"task_id": "MBPP/958", "entry_point": "int_to_roman", "completion": "def int_to_roman(num):\n    # Define the mapping of integers to Roman numerals\n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syms = [\n        \"M\", \"CM\", \"D\", \"CD\",\n        \"C\", \"XC\", \"L\", \"XL\",\n        \"X\", \"IX\", \"V\", \"IV\",\n        \"I\"\n    ]\n    \n    roman_numeral = \"\"\n    i = 0\n    while num > 0:\n        for _ in range(num // val[i]):\n            roman_numeral += syms[i]\n            num -= val[i]\n        i += 1\n    return roman_numeral\n\n# Test the function with the provided assertion\nassert int_to_roman(1) == \"I\""}
{"task_id": "MBPP/966", "entry_point": "remove_empty", "completion": "def remove_empty(tuples_list):\n    return [t for t in tuples_list if t]\n\n# Test the function with the provided assertion\nassert remove_empty([(), (), ('',), ('a', 'b'), ('a', 'b', 'c'), ('d')]) == [('',), ('a', 'b'), ('a', 'b', 'c'), 'd']"}
{"task_id": "MBPP/964", "entry_point": "word_len", "completion": "def word_len(word):\n    return len(word) % 2 == 0\n\n# Test the function with the provided assertion\nassert word_len(\"program\") == False"}
{"task_id": "MBPP/962", "entry_point": "sum_Even", "completion": "def sum_Even(l, r):\n    # Ensure l is even; if not, increment it by 1\n    if l % 2 != 0:\n        l += 1\n    # Ensure r is even; if not, decrement it by 1\n    if r % 2 != 0:\n        r -= 1\n    # Calculate the sum of even numbers in the range\n    return sum(range(l, r + 1, 2))\n\n# Test the function with the provided assertion\nassert sum_Even(2, 5) == 6"}
{"task_id": "MBPP/965", "entry_point": "camel_to_snake", "completion": "def camel_to_snake(camel_str):\n    # Initialize an empty list to hold the characters\n    snake_str = []\n    \n    for char in camel_str:\n        # If the character is uppercase, add an underscore before it (if it's not the first character)\n        if char.isupper() and snake_str:\n            snake_str.append('_')\n        # Append the lowercase version of the character\n        snake_str.append(char.lower())\n    \n    # Join the list into a string and return\n    return ''.join(snake_str)\n\n# Test the function\nassert camel_to_snake('PythonProgram') == 'python_program'"}
{"task_id": "MBPP/961", "entry_point": "roman_to_int", "completion": "def roman_to_int(s: str) -> int:\n    roman_numerals = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    }\n    \n    total = 0\n    prev_value = 0\n    \n    for char in reversed(s):\n        current_value = roman_numerals[char]\n        if current_value < prev_value:\n            total -= current_value\n        else:\n            total += current_value\n        prev_value = current_value\n    \n    return total\n\n# Test the function with the provided assertion\nassert roman_to_int('MMMCMLXXXVI') == 3986"}
{"task_id": "MBPP/963", "entry_point": "discriminant_value", "completion": "def discriminant_value(a, b, c):\n    D = b**2 - 4*a*c  # Calculate the discriminant\n    if D > 0:\n        return (\"Two solutions\", D)\n    elif D == 0:\n        return (\"One solution\", D)\n    else:\n        return (\"No real solutions\", D)\n\n# Test the function with the provided assertion\nassert discriminant_value(4, 8, 2) == (\"Two solutions\", 32)"}
{"task_id": "MBPP/967", "entry_point": "check", "completion": "def check(s):\n    # Define a set of vowels\n    vowels = set('aeiou')\n    # Convert the input string to lowercase and create a set of characters\n    input_set = set(s.lower())\n    # Check if all vowels are in the input set\n    if vowels.issubset(input_set):\n        return 'accepted'\n    else:\n        return 'not accepted'\n\n# Test the function with the provided assertion\nassert check(\"SEEquoiaL\") == 'accepted'"}
{"task_id": "MBPP/960", "entry_point": "get_noOfways", "completion": "def get_noOfways(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    \n    # Initialize the first two values\n    prev2 = 1  # This is F(1)\n    prev1 = 2  # This is F(2)\n    \n    # Use dynamic programming to calculate the number of ways\n    for i in range(3, n + 1):\n        current = prev1 + prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n\n# Test the function with the provided assertion\nassert get_noOfways(4) == 3"}
{"task_id": "MBPP/969", "entry_point": "join_tuples", "completion": "def join_tuples(tuples):\n    from collections import defaultdict\n\n    # Create a dictionary to hold lists of tuples by their first element\n    grouped = defaultdict(list)\n\n    # Group tuples by their first element\n    for t in tuples:\n        grouped[t[0]].append(t[1])\n\n    # Create the result list by joining the first element with the corresponding values\n    result = []\n    for key, values in grouped.items():\n        result.append((key,) + tuple(values))\n\n    return result\n\n# Test the function with the provided assertion\nassert join_tuples([(5, 6), (5, 7), (6, 8), (6, 10), (7, 13)]) == [(5, 6, 7), (6, 8, 10), (7, 13)]"}
{"task_id": "MBPP/970", "entry_point": "min_of_two", "completion": "def min_of_two(a, b):\n    \"\"\"Return the minimum of two numbers.\"\"\"\n    return a if a < b else b\n\n# Test the function with the provided assertion\nassert min_of_two(10, 20) == 10"}
{"task_id": "MBPP/968", "entry_point": "floor_Max", "completion": "def floor_Max(a, b, c):\n    return max(a, b, c)\n\n# Test the function with the provided assertion\nassert floor_Max(11, 10, 9) == 11"}
{"task_id": "MBPP/973", "entry_point": "left_rotate", "completion": "def left_rotate(s, n):\n    # Ensure n is within the bounds of the string length\n    n = n % len(s) if s else 0\n    return s[n:] + s[:n]\n\n# Test the function with the provided assertion\nassert left_rotate(\"python\", 2) == \"thonpy\""}
{"task_id": "MBPP/972", "entry_point": "concatenate_nested", "completion": "def concatenate_nested(tuple1, tuple2):\n    return tuple1 + tuple2\n\n# Test the function with the provided assertion\nassert concatenate_nested((3, 4), (5, 6)) == (3, 4, 5, 6)"}
{"task_id": "MBPP/974", "entry_point": "min_sum_path", "completion": "def min_sum_path(triangle):\n    # Start from the second to last row and move upwards\n    for row in range(len(triangle) - 2, -1, -1):\n        for col in range(len(triangle[row])):\n            # Update the current element to be the sum of itself and the minimum of the two elements below it\n            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])\n    \n    # The top element now contains the minimum path sum\n    return triangle[0][0]\n\n# Test the function with the provided assertion\nassert min_sum_path([[2], [3, 9], [1, 6, 7]]) == 6"}
{"task_id": "MBPP/971", "entry_point": "maximum_segments", "completion": "def maximum_segments(n, a, b, c):\n    # Create a dp array initialized to -1\n    dp = [-1] * (n + 1)\n    dp[0] = 0  # Base case: 0 length can be formed with 0 segments\n\n    # Iterate through each length from 1 to n\n    for i in range(1, n + 1):\n        # Check if we can form a segment of length a\n        if i >= a and dp[i - a] != -1:\n            dp[i] = max(dp[i], dp[i - a] + 1)\n        # Check if we can form a segment of length b\n        if i >= b and dp[i - b] != -1:\n            dp[i] = max(dp[i], dp[i - b] + 1)\n        # Check if we can form a segment of length c\n        if i >= c and dp[i - c] != -1:\n            dp[i] = max(dp[i], dp[i - c] + 1)\n\n    return dp[n] if dp[n] != -1 else 0\n\n# Test the function with the provided assertion\nassert maximum_segments(7, 5, 2, 5) == 2"}
