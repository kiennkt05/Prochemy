{"task_id": "MBPP/173", "completion": "import re\n\ndef remove_splchar(text):\n    \"\"\"\n    Remove everything except alphanumeric characters from a string.\n    \n    Parameters:\n    text (str): The input string from which to remove special characters.\n    \n    Returns:\n    str: A string containing only alphanumeric characters.\n    \"\"\"\n    # Use regular expression to replace non-alphanumeric characters with an empty string\n    return re.sub(r'[^a-zA-Z0-9]', '', text)\n\n# Test cases\nif __name__ == \"__main__\":\n    print(remove_splchar(\"Hello, World!\"))  # Expected output: \"HelloWorld\"\n    print(remove_splchar(\"Python3.8\"))      # Expected output: \"Python38\"\n    print(remove_splchar(\"123@abc#def$\"))    # Expected output: \"123abcdef\"\n    print(remove_splchar(\"!@#$%^&*()\"))      # Expected output: \"\"\n    print(remove_splchar(\"Test123!\"))        # Expected output: \"Test123\"", "result": "passed", "passed": true}
{"task_id": "MBPP/954", "completion": "def profit_amount(actual_cost, sale_amount):\n    \"\"\"\n    Calculate the profit amount based on actual cost and sale amount.\n    \n    If the sale amount is greater than the actual cost, return the profit amount.\n    Otherwise, return None.\n    \n    Parameters:\n    actual_cost (float): The cost price of the item.\n    sale_amount (float): The selling price of the item.\n    \n    Returns:\n    float or None: The profit amount if there is a profit, otherwise None.\n    \"\"\"\n    if sale_amount > actual_cost:\n        return sale_amount - actual_cost\n    else:\n        return None\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test case 1: Profit scenario\n    print(profit_amount(100, 150))  # Expected output: 50\n\n    # Test case 2: No profit scenario\n    print(profit_amount(100, 100))  # Expected output: None\n\n    # Test case 3: Loss scenario\n    print(profit_amount(100, 80))   # Expected output: None\n\n    # Test case 4: Profit with decimal values\n    print(profit_amount(99.99, 150.00))  # Expected output: 50.01", "result": "failed: ", "passed": false}
{"task_id": "MBPP/460", "completion": "def Extract(lst):\n    \"\"\"\n    Get the first element of each sublist in the given list of lists.\n    \n    Parameters:\n    lst (list of list): A list containing sublists.\n    \n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst if sublist]  # Check if sublist is not empty\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test case 1: Regular case with multiple sublists\n    print(Extract([[1, 2, 3], [4, 5], [6]]))  # Expected output: [1, 4, 6]\n\n    # Test case 2: Some empty sublists\n    print(Extract([[1, 2], [], [3, 4]]))  # Expected output: [1, 3]\n\n    # Test case 3: All empty sublists\n    print(Extract([[], [], []]))  # Expected output: []\n\n    # Test case 4: Single sublist\n    print(Extract([[10]]))  # Expected output: [10]\n\n    # Test case 5: Mixed types\n    print(Extract([[1, 'a'], [2.5, 3], ['hello', 'world']]))  # Expected output: [1, 2.5, 'hello']", "result": "passed", "passed": true}
{"task_id": "MBPP/801", "completion": "def test_three_equal(x, y, z):\n    \"\"\"\n    Count the number of equal numbers from three given integers.\n\n    Parameters:\n    x (int): First integer\n    y (int): Second integer\n    z (int): Third integer\n\n    Returns:\n    int: The count of equal numbers among the three integers\n    \"\"\"\n    # Initialize a count for equal numbers\n    count = 0\n    \n    # Check for equality among the three integers\n    if x == y:\n        count += 1\n    if y == z:\n        count += 1\n    if x == z:\n        count += 1\n    \n    # If all three are equal, we should count it as one unique case\n    if x == y == z:\n        count = 3  # All three are equal, so we return 3\n    \n    return count\n\n# Test cases\nif __name__ == \"__main__\":\n    print(test_three_equal(1, 1, 1))  # Output: 3 (all equal)\n    print(test_three_equal(1, 2, 1))  # Output: 2 (two equal)\n    print(test_three_equal(1, 2, 3))  # Output: 0 (none equal)\n    print(test_three_equal(2, 2, 3))  # Output: 2 (two equal)\n    print(test_three_equal(3, 3, 3))  # Output: 3 (all equal)", "result": "failed: ", "passed": false}
{"task_id": "MBPP/929", "completion": "def count_tuplex(tuplex, value):\n    \"\"\"\n    Count the occurrences of a specific value in a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple in which to count occurrences.\n    value: The value to count in the tuple.\n\n    Returns:\n    int: The count of occurrences of the value in the tuple.\n    \"\"\"\n    return tuplex.count(value)\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test case 1: Count occurrences of 'a' in a tuple\n    test_tuplex1 = ('a', 'b', 'c', 'a', 'd', 'a')\n    print(count_tuplex(test_tuplex1, 'a'))  # Expected output: 3\n\n    # Test case 2: Count occurrences of 1 in a tuple\n    test_tuplex2 = (1, 2, 3, 1, 4, 1)\n    print(count_tuplex(test_tuplex2, 1))  # Expected output: 3\n\n    # Test case 3: Count occurrences of a value not in the tuple\n    test_tuplex3 = (1, 2, 3, 4)\n    print(count_tuplex(test_tuplex3, 5))  # Expected output: 0\n\n    # Test case 4: Count occurrences of a string in a tuple\n    test_tuplex4 = ('apple', 'banana', 'apple', 'orange')\n    print(count_tuplex(test_tuplex4, 'apple'))  # Expected output: 2", "result": "passed", "passed": true}
{"task_id": "MBPP/865", "completion": "def ntimes_list(nums, n):\n    \"\"\"\n    Print each element of the list 'nums' n times using the map function.\n    \n    Parameters:\n    nums (list): A list of elements to be printed.\n    n (int): The number of times to print each element.\n    \"\"\"\n    # Create a function that repeats an element n times\n    def repeat_element(x):\n        return [x] * n\n    \n    # Use map to apply the repeat_element function to each item in nums\n    repeated = map(repeat_element, nums)\n    \n    # Flatten the list of lists and print each element\n    for item in repeated:\n        for element in item:\n            print(element)\n\n# Example usage\nntimes_list([1, 2, 3], 2)", "result": "failed: ", "passed": false}
{"task_id": "MBPP/645", "completion": "def find_k_product(test_list, K):\n    \"\"\"\n    Find the product of the elements at the Kth index in the given list of tuples.\n\n    Parameters:\n    test_list (list of tuples): A list containing tuples of numbers.\n    K (int): The index of the elements to be multiplied.\n\n    Returns:\n    int: The product of the elements at the Kth index in the tuples.\n    \"\"\"\n    # Initialize the product to 1 (multiplicative identity)\n    product = 1\n    \n    # Iterate through each tuple in the list\n    for tup in test_list:\n        # Check if the Kth index exists in the tuple\n        if K < len(tup):\n            product *= tup[K]\n        else:\n            raise IndexError(f\"Index {K} is out of range for tuple {tup}\")\n\n    return product\n\n# Example test cases\nif __name__ == \"__main__\":\n    # Test case 1: Normal case\n    test_list1 = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\n    K1 = 1\n    print(find_k_product(test_list1, K1))  # Output: 2 * 5 * 8 = 80\n\n    # Test case 2: K is out of range\n    test_list2 = [(1, 2), (3, 4)]\n    K2 = 2\n    try:\n        print(find_k_product(test_list2, K2))  # Should raise IndexError\n    except IndexError as e:\n        print(e)  # Output: Index 2 is out of range for tuple (1, 2)\n\n    # Test case 3: Empty list\n    test_list3 = []\n    K3 = 0\n    print(find_k_product(test_list3, K3))  # Output: 1 (no elements to multiply)", "result": "passed", "passed": true}
{"task_id": "MBPP/4_3", "completion": "def gcd(a, b):\n    \"\"\"\n    Return the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.\n    \n    Parameters:\n    a (int): First number\n    b (int): Second number\n    \n    Returns:\n    int: The GCD of the two numbers\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return abs(a)\n\n# Test cases\nif __name__ == \"__main__\":\n    print(gcd(48, 18))  # Expected output: 6\n    print(gcd(56, 98))  # Expected output: 14\n    print(gcd(101, 10)) # Expected output: 1\n    print(gcd(0, 5))    # Expected output: 5\n    print(gcd(5, 0))    # Expected output: 5\n    print(gcd(0, 0))    # Expected output: 0 (undefined, but can return 0 for this implementation)", "result": "passed", "passed": true}
{"task_id": "MBPP/4_2", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:\n                return \"\"  # No common prefix found\n    \n    return prefix\n\n# Test cases\nif __name__ == \"__main__\":\n    print(longest_common_prefix([\"flower\", \"flow\", \"flight\"]))  # Output: \"fl\"\n    print(longest_common_prefix([\"dog\", \"racecar\", \"car\"]))     # Output: \"\"\n    print(longest_common_prefix([\"\"]))                           # Output: \"\"\n    print(longest_common_prefix([\"a\"]))                          # Output: \"a\"\n    print(longest_common_prefix([\"ab\", \"a\"]))                    # Output: \"a\"", "result": "passed", "passed": true}
{"task_id": "MBPP/4_1", "completion": "def fibonacci(n):\n    \"\"\"\n    Return the n-th Fibonacci number.\n    \n    The Fibonacci sequence is defined as follows:\n    F(0) = 0, F(1) = 1, and F(n) = F(n-1) + F(n-2) for n > 1.\n    \n    Parameters:\n    n (int): The index of the Fibonacci number to return.\n    \n    Returns:\n    int: The n-th Fibonacci number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input should be a non-negative integer.\")\n    elif n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\n# Test cases\nif __name__ == \"__main__\":\n    print(fibonacci(0))  # Output: 0\n    print(fibonacci(1))  # Output: 1\n    print(fibonacci(2))  # Output: 1\n    print(fibonacci(3))  # Output: 2\n    print(fibonacci(4))  # Output: 3\n    print(fibonacci(5))  # Output: 5\n    print(fibonacci(10)) # Output: 55\n    print(fibonacci(20)) # Output: 6765", "result": "passed", "passed": true}
{"task_id": "MBPP/4_6", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string among an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:\n                return \"\"  # No common prefix found\n    \n    return prefix\n\n# Test cases\nif __name__ == \"__main__\":\n    print(longest_common_prefix([\"flower\", \"flow\", \"flight\"]))  # Output: \"fl\"\n    print(longest_common_prefix([\"dog\", \"racecar\", \"car\"]))     # Output: \"\"\n    print(longest_common_prefix([\"\"]))                           # Output: \"\"\n    print(longest_common_prefix([\"a\"]))                          # Output: \"a\"\n    print(longest_common_prefix([\"ab\", \"a\"]))                    # Output: \"a\"", "result": "passed", "passed": true}
{"task_id": "MBPP/4_7", "completion": "def max_value(arr):\n    \"\"\"\n    Find the maximum value in a list of integers.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    int: The maximum integer in the list. If the list is empty, returns None.\n    \"\"\"\n    if not arr:  # Check if the list is empty\n        return None\n    \n    max_val = arr[0]  # Initialize max_val with the first element\n    for num in arr:  # Iterate through the list\n        if num > max_val:  # Update max_val if a larger number is found\n            max_val = num\n            \n    return max_val  # Return the maximum value found\n\n# Test cases\nif __name__ == \"__main__\":\n    print(max_value([1, 2, 3, 4, 5]))  # Expected output: 5\n    print(max_value([-1, -2, -3, -4, -5]))  # Expected output: -1\n    print(max_value([5, 5, 5, 5]))  # Expected output: 5\n    print(max_value([]))  # Expected output: None\n    print(max_value([10]))  # Expected output: 10", "result": "passed", "passed": true}
{"task_id": "MBPP/495", "completion": "import re\n\ndef remove_lowercase(str1):\n    \"\"\"\n    Remove all lowercase substrings from the given string using regex.\n    \n    Parameters:\n    str1 (str): The input string from which lowercase substrings will be removed.\n    \n    Returns:\n    str: The modified string with all lowercase substrings removed.\n    \"\"\"\n    # Use regex to replace all lowercase substrings with an empty string\n    result = re.sub(r'[a-z]+', '', str1)\n    return result\n\n# Test cases\nif __name__ == \"__main__\":\n    print(remove_lowercase(\"Hello World!\"))  # Output: \"H W!\"\n    print(remove_lowercase(\"This is a Test\"))  # Output: \"T T\"\n    print(remove_lowercase(\"123abcXYZ\"))  # Output: \"123XYZ\"\n    print(remove_lowercase(\"NoLowercaseHere\"))  # Output: \"NoLowercaseHere\"\n    print(remove_lowercase(\"\"))  # Output: \"\"", "result": "passed", "passed": true}
{"task_id": "MBPP/4_5", "completion": "def longest_common_substring(s1, s2):\n    \"\"\"\n    Find the length of the longest common substring between two strings.\n    \n    Parameters:\n    s1 (str): The first string.\n    s2 (str): The second string.\n    \n    Returns:\n    int: The length of the longest common substring.\n    \"\"\"\n    # Create a 2D array to store lengths of longest common suffixes\n    m, n = len(s1), len(s2)\n    longest = 0\n    # Create a 2D list initialized to 0\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Build the dp array\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                longest = max(longest, dp[i][j])\n            else:\n                dp[i][j] = 0  # Reset if characters do not match\n\n    return longest\n\n# Test cases\nif __name__ == \"__main__\":\n    print(longest_common_substring(\"abcde\", \"abfce\"))  # Output: 2 (\"ab\")\n    print(longest_common_substring(\"abcdef\", \"zcdemf\"))  # Output: 2 (\"cd\")\n    print(longest_common_substring(\"xyz\", \"xyz\"))  # Output: 3 (\"xyz\")\n    print(longest_common_substring(\"hello\", \"world\"))  # Output: 1 (\"o\")\n    print(longest_common_substring(\"\", \"abc\"))  # Output: 0\n    print(longest_common_substring(\"abc\", \"\"))  # Output: 0\n    print(longest_common_substring(\"\", \"\"))  # Output: 0", "result": "passed", "passed": true}
{"task_id": "MBPP/4_8", "completion": "def longest_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    # Start with the first string as the prefix\n    prefix = strs[0]\n\n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:\n                return \"\"  # No common prefix found\n\n    return prefix\n\n# Test cases\nif __name__ == \"__main__\":\n    print(longest_prefix([\"flower\", \"flow\", \"flight\"]))  # Output: \"fl\"\n    print(longest_prefix([\"dog\", \"racecar\", \"car\"]))     # Output: \"\"\n    print(longest_prefix([\"\"]))                            # Output: \"\"\n    print(longest_prefix([\"a\"]))                           # Output: \"a\"\n    print(longest_prefix([\"ab\", \"a\"]))                    # Output: \"a\"", "result": "passed", "passed": true}
{"task_id": "MBPP/131", "completion": "def reverse_vowels(str1):\n    \"\"\"\n    Reverse only the vowels of a given string.\n    \n    Parameters:\n    str1 (str): The input string from which vowels will be reversed.\n    \n    Returns:\n    str: A new string with the vowels reversed.\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    str_list = list(str1)\n    left, right = 0, len(str_list) - 1\n\n    while left < right:\n        # Move left pointer to the next vowel\n        while left < right and str_list[left] not in vowels:\n            left += 1\n        # Move right pointer to the previous vowel\n        while left < right and str_list[right] not in vowels:\n            right -= 1\n        \n        # Swap the vowels\n        if left < right:\n            str_list[left], str_list[right] = str_list[right], str_list[left]\n            left += 1\n            right -= 1\n\n    return ''.join(str_list)\n\n# Test cases\nif __name__ == \"__main__\":\n    print(reverse_vowels(\"hello\"))  # Output: \"holle\"\n    print(reverse_vowels(\"leetcode\"))  # Output: \"leotcede\"\n    print(reverse_vowels(\"aA\"))  # Output: \"Aa\"\n    print(reverse_vowels(\"racecar\"))  # Output: \"racecar\"\n    print(reverse_vowels(\"!@#$%^&*()\"))  # Output: \"!@#$%^&*()\"", "result": "passed", "passed": true}
{"task_id": "MBPP/4_4", "completion": "def rotate_matrix(matrix):\n    \"\"\"\n    Rotate a given matrix by 90 degrees clockwise.\n    \n    Parameters:\n    matrix (list of list of int): 2D list representing the matrix to be rotated.\n    \n    Returns:\n    list of list of int: The rotated matrix.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return matrix  # Return the original matrix if it's empty\n\n    # Get the number of rows and columns\n    rows, cols = len(matrix), len(matrix[0])\n    \n    # Create a new matrix to hold the rotated values\n    rotated = [[0] * rows for _ in range(cols)]\n    \n    # Fill the rotated matrix\n    for r in range(rows):\n        for c in range(cols):\n            rotated[c][rows - 1 - r] = matrix[r][c]\n    \n    return rotated\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test case 1: 2x2 matrix\n    matrix1 = [[1, 2], [3, 4]]\n    print(rotate_matrix(matrix1))  # Expected: [[3, 1], [4, 2]]\n\n    # Test case 2: 3x3 matrix\n    matrix2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    print(rotate_matrix(matrix2))  # Expected: [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n    # Test case 3: 4x4 matrix\n    matrix3 = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]\n    print(rotate_matrix(matrix3))  # Expected: [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]\n\n    # Test case 4: Empty matrix\n    matrix4 = []\n    print(rotate_matrix(matrix4))  # Expected: []\n\n    # Test case 5: Single element matrix\n    matrix5 = [[1]]\n    print(rotate_matrix(matrix5))  # Expected: [[1]]", "result": "passed", "passed": true}
{"task_id": "MBPP/4_9", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:\n                return \"\"\n    \n    return prefix\n\n# Test cases\nif __name__ == \"__main__\":\n    print(longest_common_prefix([\"flower\", \"flow\", \"flight\"]))  # Output: \"fl\"\n    print(longest_common_prefix([\"dog\", \"racecar\", \"car\"]))    # Output: \"\"\n    print(longest_common_prefix([\"\"]))                          # Output: \"\"\n    print(longest_common_prefix([\"a\"]))                         # Output: \"a\"\n    print(longest_common_prefix([\"ab\", \"a\"]))                   # Output: \"a\"", "result": "passed", "passed": true}
{"task_id": "MBPP/4_0", "completion": "def longest_common_subsequence(s1, s2):\n    \"\"\"\n    Find the length of the longest common subsequence of two strings.\n    \n    Parameters:\n    s1 (str): The first string.\n    s2 (str): The second string.\n    \n    Returns:\n    int: The length of the longest common subsequence.\n    \"\"\"\n    # Create a 2D array to store lengths of longest common subsequence\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # Build the dp array\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]\n\n# Test cases\nif __name__ == \"__main__\":\n    # Test case 1\n    print(longest_common_subsequence(\"abcde\", \"ace\"))  # Output: 3\n    # Test case 2\n    print(longest_common_subsequence(\"abc\", \"abc\"))    # Output: 3\n    # Test case 3\n    print(longest_common_subsequence(\"abc\", \"def\"))    # Output: 0\n    # Test case 4\n    print(longest_common_subsequence(\"AGGTAB\", \"GXTXAYB\"))  # Output: 4\n    # Test case 5\n    print(longest_common_subsequence(\"\", \"abc\"))  # Output: 0\n    # Test case 6\n    print(longest_common_subsequence(\"abc\", \"\"))  # Output: 0", "result": "passed", "passed": true}
{"task_id": "MBPP/402", "completion": "def ncr_modp(n, r, p):\n    \"\"\"\n    Compute the value of nCr % p using Fermat's Little Theorem.\n    \n    Parameters:\n    n (int): The total number of items.\n    r (int): The number of items to choose.\n    p (int): The modulus.\n    \n    Returns:\n    int: The value of nCr % p.\n    \"\"\"\n    \n    # Function to compute x^y % p using iterative method\n    def power(x, y, p):\n        res = 1  # Initialize result\n        x = x % p  # Update x if it is more than or equal to p\n        while y > 0:\n            # If y is odd, multiply x with result\n            if (y & 1):\n                res = (res * x) % p\n            # y must be even now\n            y = y >> 1  # y = y // 2\n            x = (x * x) % p  # Change x to x^2\n        return res\n\n    # Function to return nCr % p\n    def nCr(n, r, p):\n        if r > n:\n            return 0\n        if r == 0 or r == n:\n            return 1\n        \n        # Precompute factorials and their modular inverses\n        fac = [0] * (n + 1)\n        fac[0] = 1\n        for i in range(1, n + 1):\n            fac[i] = fac[i - 1] * i % p\n        \n        # Using Fermat's Little Theorem to find modular inverse\n        inv_r = power(fac[r], p - 2, p)\n        inv_n_r = power(fac[n - r], p - 2, p)\n        \n        return (fac[n] * inv_r % p * inv_n_r % p) % p\n\n    return nCr(n, r, p)\n\n# Example test cases\nif __name__ == \"__main__\":\n    print(ncr_modp(5, 2, 13))  # Output: 10\n    print(ncr_modp(10, 2, 1000))  # Output: 45\n    print(ncr_modp(100, 50, 1000000007))  # Output: 538992043", "result": "failed: ", "passed": false}
