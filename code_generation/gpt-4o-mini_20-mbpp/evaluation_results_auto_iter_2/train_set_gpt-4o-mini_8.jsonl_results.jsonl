{"task_id": "MBPP/954", "completion": "def profit_amount(actual_cost, sale_amount):\n    \"\"\"\n    Calculate the profit amount based on actual cost and sale amount.\n    \n    Parameters:\n    actual_cost (float): The cost price of the item.\n    sale_amount (float): The selling price of the item.\n    \n    Returns:\n    float or None: The profit amount if there is a profit, otherwise None.\n    \"\"\"\n    if sale_amount > actual_cost:\n        return sale_amount - actual_cost\n    else:\n        return None\n\n# Unit tests\ndef test_profit_amount():\n    # Test cases with expected results\n    assert profit_amount(100, 150) == 50  # Profit case\n    assert profit_amount(200, 150) is None  # No profit case\n    assert profit_amount(100, 100) is None  # No profit case\n    assert profit_amount(0, 100) == 100  # Profit case with zero cost\n    assert profit_amount(100, 0) is None  # No profit case with zero sale\n    assert profit_amount(-50, 100) == 150  # Profit case with negative cost\n    assert profit_amount(100, -50) is None  # No profit case with negative sale\n\n# Run the tests\ntest_profit_amount()\n\nprint(\"All tests passed!\")", "result": "failed: ", "passed": false}
{"task_id": "MBPP/173", "completion": "import re\n\ndef remove_splchar(text):\n    \"\"\"\n    Remove everything except alphanumeric characters from a string.\n    \n    Parameters:\n    text (str): The input string from which to remove special characters.\n    \n    Returns:\n    str: A string containing only alphanumeric characters.\n    \"\"\"\n    # Use regex to substitute non-alphanumeric characters with an empty string\n    return re.sub(r'[^a-zA-Z0-9]', '', text)\n\n# Example usage\nif __name__ == \"__main__\":\n    sample_text = \"Hello, World! 123.\"\n    cleaned_text = remove_splchar(sample_text)\n    print(cleaned_text)  # Output: HelloWorld123", "result": "passed", "passed": true}
{"task_id": "MBPP/929", "completion": "def count_tuplex(tuplex, value):\n    \"\"\"\n    Count the occurrences of a specific value in a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple in which to count occurrences.\n    value: The value to count in the tuple.\n\n    Returns:\n    int: The count of occurrences of the value in the tuple.\n    \"\"\"\n    return tuplex.count(value)\n\n# Unit tests\ndef test_count_tuplex():\n    # Test cases with expected results\n    assert count_tuplex((1, 2, 3, 1, 4, 1), 1) == 3, \"Test case 1 failed\"\n    assert count_tuplex((1, 2, 3, 4), 5) == 0, \"Test case 2 failed\"\n    assert count_tuplex(('a', 'b', 'a', 'c'), 'a') == 2, \"Test case 3 failed\"\n    assert count_tuplex((), 1) == 0, \"Test case 4 failed\"  # Empty tuple\n    assert count_tuplex((True, False, True), True) == 2, \"Test case 5 failed\"\n    assert count_tuplex((1, 1, 1, 1, 1), 1) == 5, \"Test case 6 failed\"  # All elements are the same\n\n    print(\"All test cases passed!\")\n\n# Run the tests\ntest_count_tuplex()", "result": "passed", "passed": true}
{"task_id": "MBPP/131", "completion": "def reverse_vowels(str1):\n    \"\"\"\n    Reverse only the vowels of a given string.\n\n    Parameters:\n    str1 (str): The input string.\n\n    Returns:\n    str: The string with vowels reversed.\n    \"\"\"\n    # Define a set of vowels for easy lookup\n    vowels = set('aeiouAEIOU')\n    \n    # Extract vowels from the string\n    vowel_list = [char for char in str1 if char in vowels]\n    \n    # Create a list to hold the characters of the result\n    result = []\n    \n    # Index for the reversed vowels\n    vowel_index = len(vowel_list) - 1\n    \n    # Iterate through the original string\n    for char in str1:\n        if char in vowels:\n            # Replace with the next vowel from the end of the vowel_list\n            result.append(vowel_list[vowel_index])\n            vowel_index -= 1\n        else:\n            # Keep the consonants and other characters as they are\n            result.append(char)\n    \n    # Join the list into a string and return\n    return ''.join(result)\n\n# Example usage\nprint(reverse_vowels(\"hello\"))  # Output: \"holle\"\nprint(reverse_vowels(\"leetcode\"))  # Output: \"leotcede\"", "result": "passed", "passed": true}
{"task_id": "MBPP/801", "completion": "def test_three_equal(x, y, z):\n    \"\"\"\n    Count the number of equal numbers from three given integers.\n\n    Parameters:\n    x (int): The first integer.\n    y (int): The second integer.\n    z (int): The third integer.\n\n    Returns:\n    int: The count of equal integers (0, 1, 2, or 3).\n    \"\"\"\n    # Initialize a count for equal numbers\n    count = 0\n    \n    # Check for equality among the three integers\n    if x == y:\n        count += 1\n    if y == z:\n        count += 1\n    if x == z:\n        count += 1\n    \n    # If all three are equal, we should return 3 instead of 3 pairs\n    if count == 3:\n        return 3\n    \n    # Return the count of equal pairs\n    return count\n\n# Example usage\nprint(test_three_equal(1, 1, 1))  # Output: 3\nprint(test_three_equal(1, 2, 1))  # Output: 2\nprint(test_three_equal(1, 2, 3))  # Output: 0\nprint(test_three_equal(2, 2, 2))  # Output: 3\nprint(test_three_equal(2, 2, 3))  # Output: 2", "result": "failed: ", "passed": false}
{"task_id": "MBPP/460", "completion": "def Extract(lst):\n    \"\"\"\n    Extract the first element of each sublist in the given list.\n    \n    Parameters:\n    lst (list of lists): A list containing sublists from which to extract the first elements.\n    \n    Returns:\n    list: A list containing the first elements of each sublist. If a sublist is empty, None is added to the result.\n    \"\"\"\n    return [sublist[0] if sublist else None for sublist in lst]\n\n# Example usage:\n# result = Extract([[1, 2, 3], [4, 5], [], [6]])\n# print(result)  # Output: [1, 4, None, 6]", "result": "passed", "passed": true}
{"task_id": "MBPP/645", "completion": "def find_k_product(test_list, K):\n    \"\"\"\n    Find the product of the elements at the Kth index in the given list of tuples.\n\n    Parameters:\n    test_list (list of tuples): A list containing tuples of numbers.\n    K (int): The index of the elements to multiply.\n\n    Returns:\n    int: The product of the elements at the Kth index, or 1 if no valid elements are found.\n    \"\"\"\n    product = 1\n    found_valid = False  # To check if we found any valid elements\n\n    for tup in test_list:\n        if K < len(tup):  # Check if K is a valid index for the tuple\n            product *= tup[K]\n            found_valid = True\n\n    return product if found_valid else 1  # Return 1 if no valid elements were found\n\n# Unit tests\ndef test_find_k_product():\n    assert find_k_product([(1, 2, 3), (4, 5, 6), (7, 8, 9)], 1) == 2 * 5 * 8  # 80\n    assert find_k_product([(1, 2), (3, 4), (5, 6)], 0) == 1 * 3 * 5  # 15\n    assert find_k_product([(1, 2, 3), (4, 5)], 2) == 3 * 6  # 18\n    assert find_k_product([(1, 2), (3, 4), (5, 6)], 3) == 1  # No valid index, should return 1\n    assert find_k_product([], 0) == 1  # Empty list, should return 1\n    assert find_k_product([(1, 2, 3)], 2) == 3  # Single tuple, valid index\n\n    print(\"All tests passed!\")\n\n# Run the tests\ntest_find_k_product()", "result": "failed: ", "passed": false}
{"task_id": "MBPP/402", "completion": "def factorial_mod(n, p):\n    \"\"\"Compute n! % p for n >= 0.\"\"\"\n    if n == 0:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % p\n    return result\n\ndef mod_inverse(a, p):\n    \"\"\"Compute the modular inverse of a under modulo p using Fermat's Little Theorem.\"\"\"\n    return pow(a, p - 2, p)\n\ndef ncr_modp(n, r, p):\n    \"\"\"\n    Compute the value of nCr % p.\n    \n    Parameters:\n    n (int): The total number of items.\n    r (int): The number of items to choose.\n    p (int): The modulus.\n    \n    Returns:\n    int: The value of nCr % p.\n    \"\"\"\n    if r > n:\n        return 0  # nCr is 0 if r > n\n    if r == 0 or r == n:\n        return 1  # nC0 and nCn are both 1\n\n    # Calculate n!, r!, and (n-r)!\n    num = factorial_mod(n, p)\n    denom = (factorial_mod(r, p) * factorial_mod(n - r, p)) % p\n    \n    # Calculate nCr % p\n    return (num * mod_inverse(denom, p)) % p\n\n# Unit tests\ndef test_ncr_modp():\n    assert ncr_modp(5, 2, 13) == 10  # 5C2 % 13 = 10\n    assert ncr_modp(10, 3, 17) == 120  # 10C3 % 17 = 120\n    assert ncr_modp(0, 0, 5) == 1  # 0C0 % 5 = 1\n    assert ncr_modp(5, 0, 7) == 1  # 5C0 % 7 = 1\n    assert ncr_modp(5, 5, 11) == 1  # 5C5 % 11 = 1\n    assert ncr_modp(10, 5, 100) == 252  # 10C5 % 100 = 252\n    assert ncr_modp(10, 6, 100) == 210  # 10C6 % 100 = 210\n    assert ncr_modp(10, 11, 100) == 0  # 10C11 % 100 = 0 (r > n)\n\n    print(\"All tests passed!\")\n\n# Run tests\ntest_ncr_modp()", "result": "failed: ", "passed": false}
{"task_id": "MBPP/865", "completion": "def ntimes_list(nums, n):\n    \"\"\"\n    Print the list nums n times using the map function.\n    \n    Parameters:\n    nums (list): The list of elements to be printed.\n    n (int): The number of times to print the list.\n    \"\"\"\n    # Create a new list that contains the original list repeated n times\n    repeated_list = list(map(lambda x: nums, range(n)))\n    \n    # Print each instance of the list\n    for lst in repeated_list:\n        print(lst)\n\n# Example usage\nntimes_list([1, 2, 3], 3)", "result": "failed: ", "passed": false}
{"task_id": "MBPP/495", "completion": "import re\n\ndef remove_lowercase(str1):\n    \"\"\"\n    Remove all lowercase substrings from the given string using regex.\n    \n    Parameters:\n    str1 (str): The input string from which lowercase substrings will be removed.\n    \n    Returns:\n    str: The modified string with all lowercase substrings removed.\n    \"\"\"\n    # Regex pattern to match lowercase letters\n    pattern = r'[a-z]+'\n    # Replace all lowercase substrings with an empty string\n    result = re.sub(pattern, '', str1)\n    return result\n\n# Unit tests\ndef test_remove_lowercase():\n    assert remove_lowercase(\"Hello World\") == \"H W\"\n    assert remove_lowercase(\"This is a Test\") == \"T T\"\n    assert remove_lowercase(\"123abc456\") == \"123456\"\n    assert remove_lowercase(\"NoLowercaseHere\") == \"NoLowercaseHere\"\n    assert remove_lowercase(\"\") == \"\"\n    assert remove_lowercase(\"ALLUPPERCASE\") == \"ALLUPPERCASE\"\n    assert remove_lowercase(\"MixedCASE123\") == \"MCASE123\"\n    assert remove_lowercase(\"lowercase\") == \"\"\n    \n    print(\"All tests passed!\")\n\n# Run the tests\ntest_remove_lowercase()", "result": "failed: ", "passed": false}
{"task_id": "MBPP/4_6", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string among an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:  # If prefix is empty, return immediately\n                return \"\"\n    \n    return prefix\n\n# Unit tests\ndef test_longest_common_prefix():\n    assert longest_common_prefix([\"flower\", \"flow\", \"flight\"]) == \"fl\"\n    assert longest_common_prefix([\"dog\", \"racecar\", \"car\"]) == \"\"\n    assert longest_common_prefix([\"\"]) == \"\"\n    assert longest_common_prefix([\"a\"]) == \"a\"\n    assert longest_common_prefix([\"ab\", \"a\"]) == \"a\"\n    assert longest_common_prefix([\"interspecies\", \"interstellar\", \"interstate\"]) == \"inters\"\n    assert longest_common_prefix([\"throne\", \"dungeon\"]) == \"\"\n    assert longest_common_prefix([\"throne\", \"throne\"]) == \"throne\"\n    \n    print(\"All tests passed!\")\n\n# Run the tests\ntest_longest_common_prefix()", "result": "passed", "passed": true}
{"task_id": "MBPP/4_2", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the initial prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for s in strs[1:]:\n        # Update the prefix until it matches the start of the string s\n        while not s.startswith(prefix):\n            # Reduce the prefix by one character from the end\n            prefix = prefix[:-1]\n            # If the prefix is empty, return immediately\n            if not prefix:\n                return \"\"\n    \n    return prefix\n\n# Unit tests\ndef test_longest_common_prefix():\n    assert longest_common_prefix([\"flower\", \"flow\", \"flight\"]) == \"fl\"\n    assert longest_common_prefix([\"dog\", \"racecar\", \"car\"]) == \"\"\n    assert longest_common_prefix([\"interspecies\", \"interstellar\", \"interstate\"]) == \"inters\"\n    assert longest_common_prefix([\"throne\", \"throne\"]) == \"throne\"\n    assert longest_common_prefix([]) == \"\"\n    assert longest_common_prefix([\"a\"]) == \"a\"\n    assert longest_common_prefix([\"\"]) == \"\"\n    assert longest_common_prefix([\"abc\", \"ab\", \"a\"]) == \"a\"\n    \n    print(\"All tests passed!\")\n\n# Run the tests\ntest_longest_common_prefix()", "result": "passed", "passed": true}
{"task_id": "MBPP/4_7", "completion": "def max_value(arr):\n    \"\"\"\n    Find the maximum value in a list of integers.\n\n    Parameters:\n    arr (list of int): A list of integers.\n\n    Returns:\n    int or None: The maximum integer in the list, or None if the list is empty.\n    \"\"\"\n    if not arr:  # Check if the list is empty\n        return None  # Return None for an empty list\n    return max(arr)  # Return the maximum value using the built-in max function\n\n# Unit tests\ndef test_max_value():\n    assert max_value([1, 2, 3, 4, 5]) == 5, \"Test case 1 failed\"\n    assert max_value([-1, -2, -3, -4, -5]) == -1, \"Test case 2 failed\"\n    assert max_value([0, 0, 0]) == 0, \"Test case 3 failed\"\n    assert max_value([5]) == 5, \"Test case 4 failed\"\n    assert max_value([]) is None, \"Test case 5 failed\"  # Test for empty list\n    assert max_value([1, 2, 3, 2, 1]) == 3, \"Test case 6 failed\"\n    assert max_value([-10, -20, -30, -5]) == -5, \"Test case 7 failed\"\n    \n    print(\"All test cases passed!\")\n\n# Run the tests\ntest_max_value()", "result": "passed", "passed": true}
{"task_id": "MBPP/4_4", "completion": "def rotate_matrix(matrix):\n    \"\"\"\n    Rotate a given matrix by 90 degrees clockwise.\n\n    Parameters:\n    matrix (list of list of int): A 2D list representing the matrix to be rotated.\n\n    Returns:\n    list of list of int: The rotated matrix.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return matrix  # Return the original matrix if it's empty\n\n    # Transpose the matrix\n    transposed = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\n    \n    # Reverse each row to get the rotated matrix\n    rotated = [row[::-1] for row in transposed]\n    \n    return rotated", "result": "passed", "passed": true}
{"task_id": "MBPP/4_3", "completion": "def gcd(a, b):\n    \"\"\"\n    Return the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.\n    \n    Parameters:\n    a (int): First number\n    b (int): Second number\n    \n    Returns:\n    int: The GCD of a and b\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return abs(a)  # Return the absolute value of GCD", "result": "passed", "passed": true}
{"task_id": "MBPP/4_1", "completion": "def fibonacci(n):\n    \"\"\"\n    Return the n-th Fibonacci number.\n    \n    Parameters:\n    n (int): The index of the Fibonacci number to return. Must be a non-negative integer.\n    \n    Returns:\n    int: The n-th Fibonacci number.\n    \n    Raises:\n    ValueError: If n is a negative integer.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\n# Unit tests\ndef test_fibonacci():\n    assert fibonacci(0) == 0, \"Test case 0 failed\"\n    assert fibonacci(1) == 1, \"Test case 1 failed\"\n    assert fibonacci(2) == 1, \"Test case 2 failed\"\n    assert fibonacci(3) == 2, \"Test case 3 failed\"\n    assert fibonacci(4) == 3, \"Test case 4 failed\"\n    assert fibonacci(5) == 5, \"Test case 5 failed\"\n    assert fibonacci(6) == 8, \"Test case 6 failed\"\n    assert fibonacci(7) == 13, \"Test case 7 failed\"\n    assert fibonacci(8) == 21, \"Test case 8 failed\"\n    assert fibonacci(9) == 34, \"Test case 9 failed\"\n    assert fibonacci(10) == 55, \"Test case 10 failed\"\n    \n    try:\n        fibonacci(-1)\n    except ValueError:\n        pass  # Expected behavior\n\n    print(\"All test cases passed!\")\n\n# Run the tests\ntest_fibonacci()", "result": "passed", "passed": true}
{"task_id": "MBPP/4_5", "completion": "def longest_common_substring(s1, s2):\n    \"\"\"\n    Find the length of the longest common substring between two strings.\n\n    Parameters:\n    s1 (str): The first string.\n    s2 (str): The second string.\n\n    Returns:\n    int: The length of the longest common substring.\n    \"\"\"\n    # Get the lengths of both strings\n    len1, len2 = len(s1), len(s2)\n    \n    # Create a 2D array to store lengths of longest common suffixes\n    # Initialize with zeros\n    dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]\n    \n    longest_length = 0  # Variable to keep track of the longest length found\n\n    # Build the dp array\n    for i in range(1, len1 + 1):\n        for j in range(1, len2 + 1):\n            if s1[i - 1] == s2[j - 1]:  # Characters match\n                dp[i][j] = dp[i - 1][j - 1] + 1  # Increment length of common substring\n                longest_length = max(longest_length, dp[i][j])  # Update longest length\n            else:\n                dp[i][j] = 0  # No common substring at this position\n\n    return longest_length\n\n# Example usage:\n# print(longest_common_substring(\"abcde\", \"abfce\"))  # Output: 2 (\"ab\")", "result": "passed", "passed": true}
{"task_id": "MBPP/4_8", "completion": "def longest_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    If there is no common prefix, return an empty string \"\".\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Start with the first string as the prefix\n    prefix = strs[0]\n    \n    # Compare the prefix with each string in the list\n    for string in strs[1:]:\n        # Reduce the prefix until it matches the start of the string\n        while not string.startswith(prefix):\n            prefix = prefix[:-1]  # Remove the last character\n            if not prefix:\n                return \"\"  # No common prefix found\n    \n    return prefix\n\n# Unit tests\ndef test_longest_prefix():\n    assert longest_prefix([\"flower\", \"flow\", \"flight\"]) == \"fl\"\n    assert longest_prefix([\"dog\", \"racecar\", \"car\"]) == \"\"\n    assert longest_prefix([\"\"]) == \"\"\n    assert longest_prefix([\"a\"]) == \"a\"\n    assert longest_prefix([\"ab\", \"a\"]) == \"a\"\n    assert longest_prefix([\"interspecies\", \"interstellar\", \"interstate\"]) == \"inter\"\n    assert longest_prefix([]) == \"\"\n    assert longest_prefix([\"prefix\", \"prefixes\", \"prefixed\"]) == \"prefix\"\n    \n    print(\"All tests passed!\")\n\n# Run the tests\ntest_longest_prefix()", "result": "failed: ", "passed": false}
{"task_id": "MBPP/4_9", "completion": "def longest_common_prefix(strs):\n    \"\"\"\n    Find the longest common prefix string amongst an array of strings.\n    \n    :param strs: List of strings\n    :return: Longest common prefix string\n    \"\"\"\n    if not strs:\n        return \"\"\n    \n    # Take the first string as the reference\n    prefix = strs[0]\n    \n    for string in strs[1:]:\n        # Compare the prefix with each string\n        while string[:len(prefix)] != prefix and prefix:\n            # Shorten the prefix by one character from the end\n            prefix = prefix[:-1]\n    \n    return prefix\n\n# Unit tests\ndef test_longest_common_prefix():\n    assert longest_common_prefix([\"flower\", \"flow\", \"flight\"]) == \"fl\"\n    assert longest_common_prefix([\"dog\", \"racecar\", \"car\"]) == \"\"\n    assert longest_common_prefix([\"\"]) == \"\"\n    assert longest_common_prefix([\"a\"]) == \"a\"\n    assert longest_common_prefix([\"ab\", \"a\"]) == \"a\"\n    assert longest_common_prefix([\"interspecies\", \"interstellar\", \"interstate\"]) == \"inters\"\n    assert longest_common_prefix([]) == \"\"\n    assert longest_common_prefix([\"prefix\", \"prefixes\", \"prefixed\"]) == \"prefix\"\n    \n    print(\"All tests passed!\")\n\n# Run the tests\ntest_longest_common_prefix()", "result": "passed", "passed": true}
{"task_id": "MBPP/4_0", "completion": "def longest_common_subsequence(s1, s2):\n    \"\"\"\n    Find the length of the longest common subsequence of two strings.\n    \n    Parameters:\n    s1 (str): The first string.\n    s2 (str): The second string.\n    \n    Returns:\n    int: The length of the longest common subsequence.\n    \"\"\"\n    # Create a 2D array to store lengths of longest common subsequence\n    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n    \n    # Build the dp array\n    for i in range(1, len(s1) + 1):\n        for j in range(1, len(s2) + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    # The length of the longest common subsequence is in the bottom-right cell\n    return dp[len(s1)][len(s2)]\n\n# Example usage\nif __name__ == \"__main__\":\n    print(longest_common_subsequence(\"abcde\", \"ace\"))  # Output: 3\n    print(longest_common_subsequence(\"abc\", \"abc\"))    # Output: 3\n    print(longest_common_subsequence(\"abc\", \"def\"))    # Output: 0", "result": "passed", "passed": true}
