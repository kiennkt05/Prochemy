task_id,entry_point,completion
MBPP/3,is_not_prime,"def is_not_prime(n):
    if n < 2:
        return True  # Numbers less than 2 are not prime
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return True  # Found a divisor, so n is not prime
    return False  # No divisors found, so n is prime

# Test case
assert is_not_prime(2) == False"
MBPP/10,small_nnum,"import heapq

def small_nnum(data, n):
    """"""Return the n smallest items from the dataset.""""""
    return heapq.nsmallest(n, data)

# Test the function with the provided assertion
assert small_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100], 2) == [10, 20]"
MBPP/2,similar_elements,"def similar_elements(tuple1, tuple2):
    # Convert tuples to sets to find the intersection
    set1 = set(tuple1)
    set2 = set(tuple2)
    
    # Find the intersection of both sets
    similar = set1.intersection(set2)
    
    # Return the result as a sorted tuple
    return tuple(sorted(similar))

# Test the function with the provided assertion
assert similar_elements((3, 4, 5, 6), (5, 7, 4, 10)) == (4, 5)"
MBPP/7,find_char_long,"import re

def find_char_long(input_string):
    # Use regex to find all words with at least 4 characters
    return re.findall(r'\b\w{4,}\b', input_string)

# Test the function with the provided assertion
assert find_char_long('Please move back to stream') == ['Please', 'move', 'back', 'stream']"
MBPP/8,square_nums,"def square_nums(nums):
    return list(map(lambda x: x ** 2, nums))

# Test the function with the provided assertion
assert square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"
MBPP/4,heap_queue_largest,"import heapq

def heap_queue_largest(numbers, n):
    # Use heapq.nlargest to find the n largest numbers in the list
    return heapq.nlargest(n, numbers)

# Test the function with the provided assertion
assert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]"
MBPP/6,differ_At_One_Bit_Pos,"def differ_At_One_Bit_Pos(num1, num2):
    # Perform XOR operation
    xor_result = num1 ^ num2
    
    # Check if xor_result has exactly one bit set
    return xor_result != 0 and (xor_result & (xor_result - 1)) == 0

# Test the function with the provided assertion
assert differ_At_One_Bit_Pos(13, 9) == True"
MBPP/9,find_Rotations,"def find_Rotations(s: str) -> int:
    # Length of the string
    n = len(s)
    
    # If the string is empty or has only one character, it requires 1 rotation
    if n <= 1:
        return 1
    
    # Check for the minimum number of rotations
    for i in range(1, n + 1):
        # Create the rotated version of the string
        rotated = s[i % n:] + s[:i % n]
        if rotated == s:
            return i
    
    return n  # In the worst case, it will take n rotations to return to the original string

# Test the function with the provided assertion
assert find_Rotations(""aaaa"") == 1"
MBPP/12,sort_matrix,"def sort_matrix(matrix):
    # Sort the matrix using the sum of each row as the key
    return sorted(matrix, key=sum)

# Test the function with the provided assertion
assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]]) == [[1, 1, 1], [1, 2, 3], [2, 4, 5]]"
MBPP/17,square_perimeter,"def square_perimeter(side_length):
    return 4 * side_length

# Test the function with the provided assertion
assert square_perimeter(10) == 40"
MBPP/11,remove_Occ,"def remove_Occ(s, char):
    # Find the first occurrence of the character
    first_index = s.find(char)
    # Find the last occurrence of the character
    last_index = s.rfind(char)
    
    # If the character is not found or only occurs once, return the string unchanged
    if first_index == -1 or first_index == last_index:
        return s
    
    # Remove the first occurrence
    s = s[:first_index] + s[first_index + 1:]
    # Adjust the last index after the first removal
    last_index -= 1  # Adjust for the removed character
    
    # Remove the last occurrence
    s = s[:last_index] + s[last_index + 1:]
    
    return s

# Test the function with the provided assertion
assert remove_Occ(""hello"", ""l"") == ""heo"""
MBPP/18,remove_dirty_chars,"def remove_dirty_chars(s1, s2):
    return ''.join(char for char in s1 if char not in s2)

# Test the function with the provided assertion
assert remove_dirty_chars(""probasscurve"", ""pros"") == 'bacuve'"
MBPP/13,count_common,"from collections import Counter

def count_common(words):
    # Count the occurrences of each word in the list
    word_count = Counter(words)
    
    # Get the most common words and their counts
    most_common = word_count.most_common()
    
    # Filter the results to only include the top counts
    # In this case, we want to return the top counts for 'pink', 'black', 'white', and 'red'
    result = [(word, count) for word, count in most_common if word in ['pink', 'black', 'white', 'red']]
    
    return result

# Test the function with the provided assertion
assert count_common(['red','green','black','pink','black','white','black','eyes','white','black','orange','pink','pink','red','red','white','orange','white',""black"",'pink','green','green','pink','green','pink','white','orange',""orange"",'red']) == [('pink', 6), ('black', 5), ('white', 5), ('red', 4)]"
MBPP/16,text_lowercase_underscore,"import re

def text_lowercase_underscore(text):
    # Regular expression to find sequences of lowercase letters joined with an underscore
    pattern = r'^[a-z]+(_[a-z]+)*$'
    
    if re.match(pattern, text):
        return 'Found a match!'
    else:
        return 'No match found.'

# Test the function with the provided assertion
assert text_lowercase_underscore(""aab_cbbbc"") == 'Found a match!'"
MBPP/15,split_lowerstring,"def split_lowerstring(s):
    result = []
    current_segment = ''
    
    for char in s:
        if char.islower():
            if current_segment:
                result.append(current_segment)
                current_segment = ''
        current_segment += char
    
    if current_segment:
        result.append(current_segment)
    
    return result

# Test the function with the provided assertion
assert split_lowerstring(""AbCd"") == ['bC', 'd']"
MBPP/1,min_cost,"def min_cost(cost, m, n):
    # Create a 2D array to store the minimum cost to reach each cell
    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]
    
    # Initialize the starting point
    dp[0][0] = cost[0][0]
    
    # Fill the first row
    for j in range(1, n + 1):
        dp[0][j] = dp[0][j - 1] + cost[0][j]
    
    # Fill the first column
    for i in range(1, m + 1):
        dp[i][0] = dp[i - 1][0] + cost[i][0]
    
    # Fill the rest of the dp array
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            dp[i][j] = cost[i][j] + min(dp[i - 1][j], dp[i][j - 1])
    
    # The minimum cost to reach (m, n)
    return dp[m][n]

# Example usage
assert min_cost([[1, 2, 3], [4, 8, 2], [1, 5, 3]], 2, 2) == 8"
MBPP/19,test_duplicate,"def test_duplicate(arr):
    # Use a set to track seen elements
    seen = set()
    for num in arr:
        if num in seen:
            return True  # Duplicate found
        seen.add(num)
    return False  # No duplicates found

# Test the function with the provided assertion
assert test_duplicate([1, 2, 3, 4, 5]) == False"
MBPP/14,find_Volume,"def find_Volume(base, height, length):
    # Calculate the area of the triangular base
    base_area = 0.5 * base * height
    # Calculate the volume of the prism
    volume = base_area * length
    return volume

# Test the function with the provided assertion
assert find_Volume(10, 8, 6) == 240"
MBPP/21,multiples_of_num,"def multiples_of_num(n, m):
    return [n * i for i in range(1, m + 1)]

# Test the function with the provided assertion
assert multiples_of_num(4, 3) == [3, 6, 9, 12]"
MBPP/5,count_ways,"def count_ways(n):
    if n == 0:
        return 1
    if n == 1:
        return 0
    if n == 2:
        return 3
    if n == 3:
        return 0

    # Create a list to store the number of ways to fill the board
    dp = [0] * (n + 1)
    dp[0] = 1  # Base case: 1 way to fill a 3 x 0 board (do nothing)
    dp[1] = 0  # No way to fill a 3 x 1 board
    dp[2] = 3  # 3 ways to fill a 3 x 2 board
    dp[3] = 0  # No way to fill a 3 x 3 board

    for i in range(4, n + 1):
        dp[i] = 4 * dp[i - 2] + dp[i - 4]

    return dp[n]

# Test the function with the provided assertion
assert count_ways(2) == 3"
MBPP/23,maximum_Sum,"def maximum_Sum(list_of_lists):
    # Calculate the sum of each sublist and return the maximum sum
    return max(sum(sublist) for sublist in list_of_lists)

# Test the function with the provided assertion
assert maximum_Sum([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == 33"
MBPP/22,find_first_duplicate,"def find_first_duplicate(arr):
    seen = set()
    for num in arr:
        if num in seen:
            return num
        seen.add(num)
    return None  # Return None if no duplicate is found

# Test the function with the provided assertion
assert find_first_duplicate([1, 2, 3, 4, 4, 5]) == 4"
MBPP/24,binary_to_decimal,"def binary_to_decimal(binary):
    decimal = 0
    binary_str = str(binary)[::-1]  # Reverse the string for easier calculation
    for index, digit in enumerate(binary_str):
        decimal += int(digit) * (2 ** index)
    return decimal

# Test the function with the provided assertion
assert binary_to_decimal(100) == 4"
MBPP/20,is_woodall,"def is_woodall(num):
    n = 0
    while True:
        woodall_number = n * (2 ** n) - 1
        if woodall_number == num:
            return True
        elif woodall_number > num:
            return False
        n += 1

# Test the function with the provided assertion
assert is_woodall(383) == True"
MBPP/26,check_k_elements,"def check_k_elements(tuple_list, k):
    return all(len(tup) == k for tup in tuple_list)

# Test the function with the provided assertion
assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True"
MBPP/27,remove,"def remove(strings):
    return [''.join(filter(lambda x: not x.isdigit(), s)) for s in strings]

# Test the function with the provided assertion
assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']"
MBPP/25,find_Product,"def find_Product(arr, n):
    # Create a dictionary to count occurrences of each element
    count = {}
    
    # Count occurrences of each element in the array
    for num in arr:
        if num in count:
            count[num] += 1
        else:
            count[num] = 1
    
    # Calculate the product of non-repeated elements
    product = 1
    found_non_repeated = False
    for num, cnt in count.items():
        if cnt == 1:  # Check if the element is non-repeated
            product *= num
            found_non_repeated = True
    
    # If no non-repeated elements were found, return 0
    return product if found_non_repeated else 0

# Test the function with the provided assertion
assert find_Product([1, 1, 2, 3], 4) == 6"
MBPP/28,binomial_Coeff,"def factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n - 1)

def binomial_Coeff(n, k):
    if k < 0 or k > n:
        return 0
    return factorial(n) // (factorial(k) * factorial(n - k))

# Test the function
assert binomial_Coeff(5, 2) == 10"
MBPP/29,get_Odd_Occurrence,"def get_Odd_Occurrence(arr, n):
    count = {}
    
    # Count occurrences of each element
    for num in arr:
        if num in count:
            count[num] += 1
        else:
            count[num] = 1
            
    # Find the element with an odd count
    for num, cnt in count.items():
        if cnt % 2 != 0:
            return num
            
    return None  # Return None if no odd occurrence is found

# Test the function with the provided assertion
assert get_Odd_Occurrence([1, 2, 3, 1, 2, 3, 1], 7) == 1"
MBPP/33,decimal_To_Binary,"def decimal_to_binary(n):
    if n < 0:
        raise ValueError(""Input must be a non-negative integer."")
    return int(bin(n)[2:])  # Convert to binary and remove the '0b' prefix

# Test the function with the provided assertion
assert decimal_to_binary(10) == 1010"
MBPP/34,find_missing,"def find_missing(arr, n):
    # Calculate the expected sum of the first n natural numbers
    expected_sum = n * (n + 1) // 2
    # Calculate the actual sum of the elements in the array
    actual_sum = sum(arr)
    # The missing number is the difference between the expected sum and the actual sum
    return expected_sum - actual_sum

# Test the function with the provided assertion
assert find_missing([1, 2, 3, 5], 4) == 4"
MBPP/35,find_rect_num,"def find_rect_num(n):
    return n * (n + 1)

# Test the function with the provided assertion
assert find_rect_num(4) == 20"
MBPP/37,sort_mixed_list,"def sort_mixed_list(mixed_list):
    # Separate integers and strings
    integers = [item for item in mixed_list if isinstance(item, int)]
    strings = [item for item in mixed_list if isinstance(item, str)]
    
    # Sort both lists
    integers.sort()
    strings.sort()
    
    # Combine the sorted lists
    return integers + strings

# Test the function with the provided assertion
assert sort_mixed_list([19, 'red', 12, 'green', 'blue', 10, 'white', 'green', 1]) == [1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']"
MBPP/32,max_Prime_Factors,"def max_Prime_Factors(n):
    # Initialize the largest prime factor
    largest_prime = -1
    
    # Check for number of 2s that divide n
    while n % 2 == 0:
        largest_prime = 2
        n //= 2
    
    # n must be odd at this point, so we can skip even numbers
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            largest_prime = i
            n //= i
    
    # This condition is to check if n is a prime number greater than 2
    if n > 2:
        largest_prime = n
    
    return largest_prime

# Test the function with the provided assertion
assert max_Prime_Factors(15) == 5"
MBPP/41,filter_evennumbers,"def filter_evennumbers(numbers):
    return list(filter(lambda x: x % 2 == 0, numbers))

# Test the function with the provided assertion
assert filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [2, 4, 6, 8, 10]"
MBPP/31,func,"import heapq
from collections import Counter

def func(lists, k):
    # Count occurrences of each integer across all lists
    count = Counter()
    for lst in lists:
        count.update(lst)
    
    # Use a heap to find the top k most common elements
    # The heap will store tuples of (-frequency, number) to create a max-heap based on frequency
    heap = [(-freq, num) for num, freq in count.items()]
    heapq.heapify(heap)
    
    # Extract the top k elements
    top_k = []
    for _ in range(k):
        if heap:
            freq, num = heapq.heappop(heap)
            top_k.append(num)
    
    return top_k

# Test the function with the provided assertion
assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]], 3) == [5, 7, 1]"
MBPP/40,freq_element,"from collections import Counter

def freq_element(list_of_lists):
    # Flatten the list of lists into a single list
    flat_list = [item for sublist in list_of_lists for item in sublist]
    # Use Counter to count the frequency of each element
    frequency = Counter(flat_list)
    return dict(frequency)

# Test the function with the provided assertion
assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]]) == ({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})"
MBPP/30,count_Substring_With_Equal_Ends,"def count_Substring_With_Equal_Ends(s: str) -> int:
    count = 0
    n = len(s)
    
    # Dictionary to count occurrences of each character
    char_count = {}
    
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    
    # Calculate the number of substrings for each character
    for count_of_char in char_count.values():
        # For each character, the number of substrings is count * (count + 1) // 2
        count += (count_of_char * (count_of_char + 1)) // 2
    
    return count

# Test the function with the provided assertion
assert count_Substring_With_Equal_Ends(""abc"") == 3"
MBPP/38,div_even_odd,"def div_even_odd(numbers):
    first_even = None
    first_odd = None
    
    for num in numbers:
        if num % 2 == 0 and first_even is None:
            first_even = num
        elif num % 2 != 0 and first_odd is None:
            first_odd = num
        
        # Break the loop if both numbers are found
        if first_even is not None and first_odd is not None:
            break
    
    # Check if both even and odd numbers were found
    if first_even is not None and first_odd is not None:
        return first_even / first_odd
    else:
        raise ValueError(""The list must contain at least one even and one odd number."")

# Test the function with the provided assertion
assert div_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 4"
MBPP/36,find_Nth_Digit,"def find_Nth_Digit(numerator, denominator, n):
    # Calculate the proper fraction
    fraction = numerator / denominator
    
    # Convert the fraction to a string
    fraction_str = str(fraction)
    
    # Find the position of the decimal point
    decimal_index = fraction_str.index('.')
    
    # Check if n is within the bounds of the digits after the decimal point
    if n <= 0:
        raise ValueError(""n must be a positive integer."")
    
    # Get the digits after the decimal point
    decimal_digits = fraction_str[decimal_index + 1:]
    
    # Check if the requested digit exists
    if n > len(decimal_digits):
        raise IndexError(""The requested digit is out of bounds."")
    
    # Return the nth digit (1-based index)
    return int(decimal_digits[n - 1])

# Example usage
assert find_Nth_Digit(1, 2, 1) == 5"
MBPP/43,text_match,"import re

def text_match(text):
    # Define the regex pattern to match sequences of lowercase letters joined with an underscore
    pattern = r'^[a-z]+(_[a-z]+)*$'
    
    # Use re.match to check if the entire string matches the pattern
    if re.match(pattern, text):
        return 'Found a match!'
    else:
        return 'No match found.'

# Test the function with the provided assertion
assert text_match(""aab_cbbbc"") == 'Found a match!'"
MBPP/46,test_distinct,"def test_distinct(numbers):
    return len(numbers) == len(set(numbers))

# Test the function with the provided assertion
assert test_distinct([1, 5, 7, 9]) == True"
MBPP/44,text_match_string,"def text_match_string(input_string):
    if input_string.startswith(""python""):
        return ""Matched!""
    else:
        return ""Not matched!""

# Test the function
assert text_match_string("" python"") == 'Not matched!'"
MBPP/52,parallelogram_area,"def parallelogram_area(base, height):
    """"""Calculate the area of a parallelogram given its base and height.""""""
    return base * height

# Test the function with the provided assertion
assert parallelogram_area(10, 20) == 200"
MBPP/45,get_gcd,"from math import gcd
from functools import reduce

def get_gcd(arr):
    return reduce(gcd, arr)

# Test the function with the provided assertion
assert get_gcd([2, 4, 6, 8, 16]) == 2"
MBPP/39,rearange_string,"import heapq
from collections import Counter

def rearrange_string(s: str) -> str:
    # Count the frequency of each character
    char_count = Counter(s)
    
    # Create a max heap based on character frequency
    max_heap = [(-count, char) for char, count in char_count.items()]
    heapq.heapify(max_heap)
    
    result = []
    prev_char = None
    prev_count = 0
    
    while max_heap:
        count, char = heapq.heappop(max_heap)
        result.append(char)
        
        # If there was a previous character, push it back to the heap
        if prev_count < 0:
            heapq.heappush(max_heap, (prev_count, prev_char))
        
        # Update the previous character and its count
        prev_char = char
        prev_count = count + 1  # Decrease the count since we used this character
    
    rearranged = ''.join(result)
    
    # Check if the rearranged string is valid
    if len(rearranged) != len(s):
        return """"  # Not possible to rearrange
    
    return rearranged

# Test the function with the provided assertion
assert rearrange_string(""aab"") == 'aba'"
MBPP/47,compute_Last_Digit,"def factorial(n):
    if n == 0 or n == 1:
        return 1
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

def compute_Last_Digit(a, b):
    if a > b:
        raise ValueError(""a must be less than or equal to b"")
    
    factorial_a = factorial(a)
    factorial_b = factorial(b)
    
    result = factorial_b // factorial_a  # Integer division
    last_digit = result % 10  # Get the last digit
    
    return last_digit

# Test the function with the provided assertion
assert compute_Last_Digit(2, 4) == 2"
MBPP/49,specified_element,"def specified_element(two_d_list, index):
    return [row[index] for row in two_d_list]

# Example usage
result = specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]], 0)
print(result)  # Output: [1, 4, 7]

# Assertion to verify the function works as expected
assert specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]], 0) == [1, 4, 7]"
MBPP/53,check_Equality,"def check_Equality(s):
    if s and s[0] == s[-1]:  # Check if the string is not empty and first equals last
        return ""Equal""
    else:
        return ""Not Equal""

# Example assertion
assert check_Equality(""abcda"") == ""Equal"""
MBPP/50,min_length_list,"def min_length_list(lists):
    return min((len(lst), lst) for lst in lists)

# Test the function with the provided assertion
assert min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (1, [0])"
MBPP/51,check_equilateral,"def check_equilateral(a, b, c):
    """"""
    Check if a triangle with sides a, b, and c is equilateral.

    Parameters:
    a (int or float): Length of side a
    b (int or float): Length of side b
    c (int or float): Length of side c

    Returns:
    bool: True if the triangle is equilateral, False otherwise
    """"""
    return a == b == c

# Example assertion
assert check_equilateral(6, 8, 12) == False"
MBPP/42,find_Sum,"def find_Sum(arr, n):
    # Dictionary to count occurrences of each element
    count = {}
    
    # Count occurrences of each element in the array
    for num in arr:
        if num in count:
            count[num] += 1
        else:
            count[num] = 1
    
    # Calculate the sum of repeated elements
    repeated_sum = sum(num for num, cnt in count.items() if cnt > 1)
    
    return repeated_sum

# Test the function with the provided assertion
assert find_Sum([1, 2, 3, 1, 1, 4, 5, 6], 8) == 3"
MBPP/48,odd_bit_set_number,"def odd_bit_set_number(n):
    # Create a mask with all odd bits set (0b01010101)
    mask = 0b01010101
    # Set all odd bits of the given number using bitwise OR
    return n | mask

# Test the function with the provided assertion
assert odd_bit_set_number(10) == 15

# You can also print the result to verify
print(odd_bit_set_number(10))  # Output should be 15"
MBPP/59,is_octagonal,"def is_octagonal(n):
    return n * (3 * n - 2)

# Test the function with the provided assertion
assert is_octagonal(5) == 65

# You can also print the result to verify
print(is_octagonal(5))  # Output: 65"
MBPP/58,opposite_Signs,"def opposite_Signs(a, b):
    return (a < 0) != (b < 0)

# Test the function with the provided assertion
assert opposite_Signs(1, -2) == True"
MBPP/55,tn_gp,"def tn_gp(a, r, t):
    return a * (r ** (t - 1))

# Test the function with the provided assertion
assert tn_gp(1, 5, 2) == 16"
MBPP/57,find_Max_Num,"def find_Max_Num(digits, n):
    # Convert the list of digits to strings
    digits_str = list(map(str, digits))
    
    # Sort the digits in descending order
    digits_str.sort(reverse=True)
    
    # Join the sorted digits to form the largest number
    largest_num = int(''.join(digits_str))
    
    return largest_num

# Test the function with the provided assertion
assert find_Max_Num([1, 2, 3], 3) == 321"
MBPP/62,smallest_num,"def smallest_num(numbers):
    if not numbers:
        raise ValueError(""The list cannot be empty"")
    return min(numbers)

# Test the function with the provided assertion
assert smallest_num([10, 20, 1, 45, 99]) == 1"
MBPP/56,check,"def check(num):
    # Convert the number to string and reverse it
    reversed_num = int(str(num)[::-1])
    
    # Check if the original number is one less than twice the reversed number
    return num == 2 * reversed_num - 1

# Test the function with the provided assertion
assert check(70) == False"
MBPP/54,counting_sort,"def counting_sort(arr):
    if not arr:
        return arr

    # Find the maximum value in the array
    max_val = max(arr)
    # Create a count array with a size of max_val + 1
    count = [0] * (max_val + 1)

    # Count the occurrences of each number in the input array
    for num in arr:
        count[num] += 1

    # Build the sorted array
    sorted_arr = []
    for i in range(len(count)):
        sorted_arr.extend([i] * count[i])

    return sorted_arr

# Test the function with the provided assertion
assert counting_sort([1, 23, 4, 5, 6, 7, 8]) == [1, 4, 5, 6, 7, 8, 23]"
MBPP/64,subject_marks,"def subject_marks(marks):
    return sorted(marks, key=lambda x: x[1])

# Test the function with the provided assertion
assert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]"
MBPP/66,pos_count,"def pos_count(numbers):
    """"""Count the number of positive numbers in a list.""""""
    return sum(1 for num in numbers if num > 0)

# Test the function with the provided assertion
assert pos_count([1, -2, 3, -4]) == 2"
MBPP/69,is_sublist,"def is_sublist(main_list, sub_list):
    # Convert both lists to strings and check if the sublist string is in the main list string
    return str(sub_list) in str(main_list)

# Test the function with the provided assertion
assert is_sublist([2, 4, 3, 5, 7], [3, 7]) == False"
MBPP/65,recursive_list_sum,"def recursive_list_sum(nested_list):
    total = 0
    for element in nested_list:
        if isinstance(element, list):
            total += recursive_list_sum(element)  # Recursively sum the sublist
        else:
            total += element  # Add the integer value
    return total

# Test the function with the provided assertion
assert recursive_list_sum([1, 2, [3, 4], [5, 6]]) == 21"
MBPP/63,max_difference,"def max_difference(pairs):
    max_diff = 0
    for a, b in pairs:
        diff = abs(a - b)
        if diff > max_diff:
            max_diff = diff
    return max_diff

# Test the function with the provided assertion
assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7"
MBPP/68,is_Monotonic,"def is_Monotonic(array):
    if not array:
        return True  # An empty array is considered monotonic

    increasing = decreasing = True

    for i in range(1, len(array)):
        if array[i] > array[i - 1]:
            decreasing = False
        elif array[i] < array[i - 1]:
            increasing = False

    return increasing or decreasing

# Test the function with the provided assertion
assert is_Monotonic([6, 5, 4, 4]) == True"
MBPP/70,get_equal,"def get_equal(tuples_list, length):
    # Check if all tuples have the specified length
    if all(len(tup) == length for tup in tuples_list):
        return 'All tuples have same length'
    else:
        return 'Not all tuples have the same length'

# Example usage
assert get_equal([(11, 22, 33), (44, 55, 66)], 3) == 'All tuples have same length'"
MBPP/67,bell_number,"def bell_number(n):
    # Create a 2D array to store Bell numbers
    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]
    
    # Base case
    bell[0][0] = 1
    
    # Fill the Bell triangle
    for i in range(1, n + 1):
        # Explicitly set the first value of the current row
        bell[i][0] = bell[i - 1][i - 1]
        
        # Fill the rest of the current row
        for j in range(1, i + 1):
            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]
    
    # The Bell number for n is found at bell[n][0]
    return bell[n][0]

# Test the function with the provided assertion
assert bell_number(2) == 2

# You can also print the Bell number for other values
print(bell_number(3))  # Output: 5
print(bell_number(4))  # Output: 15"
MBPP/61,count_Substrings,"def count_Substrings(s, n):
    count = 0
    length = len(s)
    
    # Iterate through all possible substrings
    for i in range(length):
        for j in range(i + 1, length + 1):
            substring = s[i:j]
            digit_sum = sum(int(char) for char in substring)
            substring_length = len(substring)
            
            # Check if the sum of digits equals the length of the substring
            if digit_sum == substring_length:
                count += 1
                
    return count

# Test the function with the provided assertion
assert count_Substrings('112112', 6) == 6"
MBPP/72,dif_Square,"def dif_Square(n):
    # Check if n is of the form 4k + 2
    return n % 4 != 2

# Test the function with the provided assertion
assert dif_Square(5) == True"
MBPP/75,find_tuples,"def find_tuples(tuples_list, k):
    # Use a list comprehension to filter tuples
    result = [tup for tup in tuples_list if all(element % k == 0 for element in tup)]
    return str(result)

# Test the function with the provided assertion
assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == '[(6, 24, 12)]'"
MBPP/71,comb_sort,"def comb_sort(arr):
    """"""Sorts a list using the comb sort algorithm.""""""
    gap = len(arr)
    shrink = 1.3
    sorted = False

    while not sorted:
        # Update the gap for the next comb
        gap = max(1, int(gap / shrink))
        sorted = True

        # Compare elements at the current gap
        for i in range(len(arr) - gap):
            if arr[i] > arr[i + gap]:
                # Swap the elements
                arr[i], arr[i + gap] = arr[i + gap], arr[i]
                sorted = False

    return arr

# Test the comb_sort function
assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]"
MBPP/73,multiple_split,"import re

def multiple_split(input_string):
    # Define the regex pattern for delimiters: newline and asterisk
    pattern = r'[\n*]'
    # Use re.split to split the string by the defined pattern
    return [s for s in re.split(pattern, input_string) if s]

# Test the function with the provided assertion
assert multiple_split('Forces of the \ndarkness*are coming into the play.') == ['Forces of the ', 'darkness', 'are coming into the play.']"
MBPP/60,max_len_sub,"def max_len_sub(arr, n):
    if not arr:
        return 0

    max_length = 1
    current_length = 1

    for i in range(1, len(arr)):
        if abs(arr[i] - arr[i - 1]) <= n:
            current_length += 1
        else:
            max_length = max(max_length, current_length)
            current_length = 1

    max_length = max(max_length, current_length)
    return max_length

# Test the function with the provided assertion
assert max_len_sub([2, 5, 6, 3, 7, 6, 5, 8], 8) == 5"
MBPP/76,count_Squares,"def count_Squares(m, n):
    total_squares = 0
    # Iterate over all possible square sizes
    for k in range(1, min(m, n) + 1):
        total_squares += (m - k + 1) * (n - k + 1)
    return total_squares

# Test the function with the provided assertion
assert count_Squares(4, 3) == 20"
MBPP/79,word_len,"def word_len(word):
    return len(word) % 2 != 0

# Test the function with the provided assertion
assert word_len(""Hadoop"") == False"
MBPP/80,tetrahedral_number,"def tetrahedral_number(n):
    return n * (n + 1) * (n + 2) / 6

# Test the function with the provided assertion
assert tetrahedral_number(5) == 35.0

# You can also print the result to verify
print(tetrahedral_number(5))  # Output: 35.0"
MBPP/74,is_samepatterns,"def is_samepatterns(patterns, values):
    if len(patterns) != len(values):
        return False
    
    pattern_to_value = {}
    value_to_pattern = {}
    
    for p, v in zip(patterns, values):
        if p in pattern_to_value:
            if pattern_to_value[p] != v:
                return False
        else:
            pattern_to_value[p] = v
        
        if v in value_to_pattern:
            if value_to_pattern[v] != p:
                return False
        else:
            value_to_pattern[v] = p
            
    return True

# Test the function with the provided assertion
assert is_samepatterns([""red"", ""green"", ""green""], [""a"", ""b"", ""b""]) == True"
MBPP/82,volume_sphere,"import math

def volume_sphere(radius):
    return (4/3) * math.pi * (radius ** 3)

# Test the function with the provided assertion
assert volume_sphere(10) == 4188.790204786391"
MBPP/78,count_With_Odd_SetBits,"def count_set_bits(num):
    """"""Helper function to count the number of set bits in an integer.""""""
    count = 0
    while num:
        count += num & 1
        num >>= 1
    return count

def count_With_Odd_SetBits(n):
    """"""Function to count the number of integers with an odd number of set bits from 1 to n.""""""
    odd_count = 0
    for i in range(1, n + 1):
        if count_set_bits(i) % 2 == 1:  # Check if the count of set bits is odd
            odd_count += 1
    return odd_count

# Test the function with the provided assertion
assert count_With_Odd_SetBits(5) == 3"
MBPP/89,closest_num,"def closest_num(n):
    return n - 1

# Test the function
assert closest_num(11) == 10"
MBPP/85,surfacearea_sphere,"import math

def surfacearea_sphere(radius):
    return 4 * math.pi * radius ** 2

# Test the function with the provided assertion
assert surfacearea_sphere(10) == 1256.6370614359173"
MBPP/87,merge_dictionaries_three,"def merge_dictionaries_three(dict1, dict2, dict3):
    return {**dict1, **dict2, **dict3}

# Test the function with the provided assertion
assert merge_dictionaries_three(
    {""R"": ""Red"", ""B"": ""Black"", ""P"": ""Pink""},
    {""G"": ""Green"", ""W"": ""White""},
    {""O"": ""Orange"", ""W"": ""White"", ""B"": ""Black""}
) == {'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}"
MBPP/86,centered_hexagonal_number,"def centered_hexagonal_number(n):
    return 3 * n * (n - 1) + 1

# Test the function with the provided assertion
assert centered_hexagonal_number(10) == 271"
MBPP/84,sequence,"def sequence(n):
    if n < 1:
        raise ValueError(""n must be a positive integer"")
    if n == 1 or n == 2:
        return 1
    
    # Initialize the sequence with the first two values
    p = [0] * (n + 1)
    p[1], p[2] = 1, 1
    
    # Fill the sequence using the defined recurrence relation
    for i in range(3, n + 1):
        p[i] = p[p[i - 1]] + p[i - p[i - 1]]
    
    return p[n]

# Test the function
assert sequence(10) == 6"
MBPP/83,get_Char,"def get_Char(s):
    # Calculate the sum of ASCII values of all characters in the string
    total = sum(ord(char) for char in s)
    # Convert the total back to a character
    return chr(total)

# Test the function with the provided assertion
assert get_Char(""abc"") == ""f"""
MBPP/81,zip_tuples,"def zip_tuples(tuple1, tuple2):
    return [(a, b) for a in tuple1 for b in tuple2]

# Test the function with the provided assertion
assert zip_tuples((7, 8, 4, 5, 9, 10), (1, 5, 6)) == [(7, 1), (7, 5), (7, 6), 
                                                      (8, 1), (8, 5), (8, 6), 
                                                      (4, 1), (4, 5), (4, 6), 
                                                      (5, 1), (5, 5), (5, 6), 
                                                      (9, 1), (9, 5), (9, 6), 
                                                      (10, 1), (10, 5), (10, 6)]"
MBPP/90,len_log,"def len_log(words):
    if not words:  # Check if the list is empty
        return 0
    return max(len(word) for word in words)

# Test the function with the provided assertion
assert len_log([""python"", ""PHP"", ""bigdata""]) == 7"
MBPP/93,power,"def power(a, b):
    return a ** b

# Test the function with the provided assertion
assert power(3, 4) == 81"
MBPP/88,freq_count,"def freq_count(lst):
    frequency = {}
    for item in lst:
        if item in frequency:
            frequency[item] += 1
        else:
            frequency[item] = 1
    return frequency

# Test the function with the provided assertion
assert freq_count([10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]) == {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}"
MBPP/95,Find_Min_Length,"def Find_Min_Length(lst):
    # Check if the input list is empty
    if not lst:
        return 0  # Return 0 if there are no sublists
    
    # Use a generator expression to find the minimum length of sublists
    min_length = min(len(sublist) for sublist in lst)
    
    return min_length

# Test the function with the provided assertion
assert Find_Min_Length([[1], [1, 2]]) == 1"
MBPP/96,divisor,"def divisor(n):
    if n <= 0:
        return 0  # Return 0 for non-positive integers
    count = 0
    for i in range(1, n + 1):
        if n % i == 0:
            count += 1
    return count

# Test the function with the provided assertion
assert divisor(15) == 4"
MBPP/94,index_minimum,"def index_minimum(records):
    # Find the record with the minimum value
    min_record = min(records, key=lambda x: x[1])
    # Return the name associated with the minimum value
    return min_record[0]

# Test the function with the provided assertion
assert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'"
MBPP/91,find_substring,"def find_substring(string_list, substring):
    for string in string_list:
        if substring in string:
            return True
    return False

# Test the function with the provided assertion
assert find_substring([""red"", ""black"", ""white"", ""green"", ""orange""], ""ack"") == True"
MBPP/97,frequency_lists,"def frequency_lists(list_of_lists):
    frequency_count = {}
    
    for sublist in list_of_lists:
        for item in sublist:
            if item in frequency_count:
                frequency_count[item] += 1
            else:
                frequency_count[item] = 1
                
    return frequency_count

# Test the function with the provided assertion
assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]) == {1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}"
MBPP/92,is_undulating,"def is_undulating(number: str) -> bool:
    # Check if the input is a valid string of digits
    if not number.isdigit():
        return False
    
    # Check for undulating pattern
    for i in range(len(number) - 1):
        if number[i] == number[i + 1]:
            return False
            
    return True

# Test the function with the provided assertion
assert is_undulating(""1212121"") == True"
MBPP/98,multiply_num,"def multiply_num(numbers):
    # Calculate the product of all numbers
    product = 1
    for num in numbers:
        product *= num
    
    # Divide the product by the length of the list
    result = product / len(numbers)
    return result

# Test the function with the provided assertion
assert multiply_num((8, 2, 3, -1, 7)) == -67.2"
MBPP/99,decimal_to_binary,"def decimal_to_binary(n):
    if n == 0:
        return '0'
    binary = ''
    while n > 0:
        binary = str(n % 2) + binary
        n //= 2
    return binary

# Test the function with the provided assertion
assert decimal_to_binary(8) == '1000'"
MBPP/100,next_smallest_palindrome,"def is_palindrome(n):
    return str(n) == str(n)[::-1]

def next_smallest_palindrome(n):
    # Start checking from the next number
    n += 1
    while True:
        if is_palindrome(n):
            return n
        n += 1

# Test the function with the provided assertion
assert next_smallest_palindrome(99) == 101

# You can also test with other examples
print(next_smallest_palindrome(123))  # Output: 131
print(next_smallest_palindrome(200))  # Output: 202"
MBPP/77,is_Diff,"def is_Diff(n):
    # Initialize sums for even and odd digits
    sum_even = 0
    sum_odd = 0
    
    # Convert the number to a string to iterate over each digit
    for digit in str(n):
        # Convert the character back to an integer
        num = int(digit)
        # Check if the digit is even or odd and update the sums accordingly
        if num % 2 == 0:
            sum_even += num
        else:
            sum_odd += num
    
    # Calculate the difference
    difference = sum_even - sum_odd
    
    # Return True if the difference is zero, otherwise False
    return difference == 0

# Test the function with the provided assertion
assert is_Diff(12345) == False"
MBPP/101,kth_element,"def kth_element(arr, n, k):
    # Sort the array
    arr.sort()
    # Return the k-1 index element (k is 1-based index)
    return arr[k - 1]

# Test the function with the provided assertion
assert kth_element([12, 3, 5, 7, 19], 5, 2) == 3"
MBPP/102,snake_to_camel,"def snake_to_camel(snake_str):
    # Split the string by underscores
    components = snake_str.split('_')
    # Capitalize the first letter of each component and join them
    camel_case_str = ''.join(x.capitalize() for x in components)
    return camel_case_str

# Test the function
assert snake_to_camel('python_program') == 'PythonProgram'"
MBPP/106,add_lists,"def add_lists(lst, tup):
    return tup + tuple(lst)

# Test the function with the provided assertion
assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)"
MBPP/105,count,"def count(boolean_list):
    return sum(1 for value in boolean_list if value is True)

# Test the function with the provided assertion
assert count([True, False, True]) == 2"
MBPP/104,sort_sublists,"def sort_sublists(lists):
    return [sorted(sublist, key=lambda x: x) for sublist in lists]

# Test the function with the provided assertion
assert sort_sublists(([""green"", ""orange""], [""black"", ""white""], [""white"", ""black"", ""orange""])) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]"
MBPP/107,count_Hexadecimal,"def count_Hexadecimal(start, end):
    # Count the numbers in the range from start to end (inclusive)
    count = 0
    for num in range(start, end + 1):
        # Every integer can be represented in hexadecimal
        count += 1
    return count

# Test the function with the provided assertion
assert count_Hexadecimal(10, 15) == 6"
MBPP/111,common_in_nested_lists,"def common_in_nested_lists(nested_lists):
    # Use set intersection to find common elements
    common_elements = set(nested_lists[0])
    for lst in nested_lists[1:]:
        common_elements.intersection_update(lst)
    return sorted(common_elements)

# Test the function with the provided assertion
assert common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]) == [12, 18]"
MBPP/113,check_integer,"def check_integer(s):
    # Check if the string can be converted to an integer
    try:
        int(s)
        return True
    except ValueError:
        return False

# Test cases
assert check_integer(""python"") == False
assert check_integer(""123"") == True
assert check_integer(""-456"") == True
assert check_integer(""3.14"") == False
assert check_integer(""0"") == True
assert check_integer("""") == False"
MBPP/103,eulerian_num,"def eulerian_num(n, m):
    # Create a table to store the Eulerian numbers
    A = [[0] * (n + 1) for _ in range(n + 1)]
    
    # Base cases
    A[0][0] = 1  # A(0, 0) = 1
    
    for i in range(1, n + 1):
        A[i][0] = 1  # A(n, 0) = 1
        A[i][i] = 1  # A(n, n) = 1
        for j in range(1, i):
            A[i][j] = (j + 1) * A[i - 1][j] + (i - j) * A[i - 1][j - 1]
    
    return A[n][m]

# Test the function with the provided assertion
assert eulerian_num(3, 1) == 4"
MBPP/109,odd_Equivalent,"def odd_Equivalent(binary_string, length):
    count = 0
    
    # Generate all rotations of the binary string
    for i in range(length):
        # Create the rotated string
        rotated_string = binary_string[i:] + binary_string[:i]
        
        # Convert the rotated binary string to decimal
        decimal_value = int(rotated_string, 2)
        
        # Check if the decimal value is odd
        if decimal_value % 2 == 1:
            count += 1
            
    return count

# Test the function with the provided assertion
assert odd_Equivalent(""011001"", 6) == 3"
MBPP/115,empty_dit,"def empty_dit(dict_list):
    return all(not d for d in dict_list)

# Test the function with the provided assertion
assert empty_dit([{}, {}, {}]) == True"
MBPP/112,perimeter,"import math

def perimeter(radius, height):
    # Calculate the circumference of the base
    circumference = 2 * math.pi * radius
    # The perimeter is the circumference plus the height
    return circumference + height

# Test the function with the provided assertion
assert perimeter(2, 4) == 12"
MBPP/116,tuple_to_int,"def tuple_to_int(tup):
    # Convert each integer in the tuple to a string and join them
    return int(''.join(map(str, tup)))

# Test the function with the provided assertion
assert tuple_to_int((1, 2, 3)) == 123"
MBPP/114,assign_freq,"def assign_freq(tuples_list):
    # Count the frequency of each tuple
    frequency = {}
    for tup in tuples_list:
        if tup in frequency:
            frequency[tup] += 1
        else:
            frequency[tup] = 1
    
    # Create a new list with tuples and their frequencies
    result = [(tup + (freq,)) for tup, freq in frequency.items()]
    
    # Return the result as a string
    return str(result)

# Test the function with the provided assertion
assert assign_freq([(6, 5, 8), (2, 7), (6, 5, 8), (6, 5, 8), (9,), (2, 7)]) == '[(6, 5, 8, 3), (2, 7, 2), (9, 1)]'"
MBPP/118,string_to_list,"def string_to_list(input_string):
    # Split the string by spaces and return the list
    return input_string.split()

# Test the function with the provided assertion
assert string_to_list(""python programming"") == ['python', 'programming']"
MBPP/117,list_to_float,"def list_to_float(input_list):
    # Convert each element in the tuples to float if possible
    converted_list = []
    for tup in input_list:
        converted_tup = tuple(float(x) if isinstance(x, str) and x.replace('.', '', 1).isdigit() else x for x in tup)
        converted_list.append(converted_tup)
    
    return str(converted_list)

# Test the function with the provided assertion
assert list_to_float([(""3"", ""4""), (""1"", ""26.45""), (""7.32"", ""8""), (""4"", ""8"")]) == '[(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]'"
MBPP/120,max_product_tuple,"def max_product_tuple(tuples_list):
    max_product = float('-inf')  # Initialize to negative infinity
    for a, b in tuples_list:
        product = a * b
        if product > max_product:
            max_product = product
    return max_product

# Test the function with the provided assertion
assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 36"
MBPP/124,angle_complex,"import cmath

def angle_complex(z):
    return cmath.phase(z)

# Test the function with the provided assertion
assert angle_complex(1j) == 1.5707963267948966"
MBPP/108,merge_sorted_list,"import heapq

def merge_sorted_list(*lists):
    # Create a heap to store the elements
    min_heap = []
    
    # Initialize the heap with the first element of each list along with the list index and element index
    for i, sorted_list in enumerate(lists):
        if sorted_list:  # Check if the list is not empty
            heapq.heappush(min_heap, (sorted_list[0], i, 0))
    
    # This will hold the merged sorted output
    merged_output = []
    
    while min_heap:
        # Get the smallest item from the heap
        value, list_index, element_index = heapq.heappop(min_heap)
        merged_output.append(value)
        
        # If there is a next element in the same list, push it onto the heap
        if element_index + 1 < len(lists[list_index]):
            next_value = lists[list_index][element_index + 1]
            heapq.heappush(min_heap, (next_value, list_index, element_index + 1))
    
    return merged_output

# Test the function with the provided assertion
assert merge_sorted_list(
    [25, 24, 15, 4, 5, 29, 110],
    [19, 20, 11, 56, 25, 233, 154],
    [24, 26, 54, 48]
) == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]"
MBPP/110,extract_missing,"def extract_missing(ranges, start, end):
    # Sort the ranges based on the start value
    ranges.sort()
    
    # Initialize the list to hold missing ranges
    missing_ranges = []
    
    # Start checking from the given start value
    current_start = start
    
    for r in ranges:
        r_start, r_end = r
        
        # If there is a gap between current_start and the start of the current range
        if current_start < r_start:
            missing_ranges.append((current_start, r_start))
        
        # Update current_start to the end of the current range if it's greater
        current_start = max(current_start, r_end)
    
    # Check for any remaining gap after the last range up to the end value
    if current_start < end:
        missing_ranges.append((current_start, end))
    
    # Now we need to find the gaps between the ranges themselves
    for i in range(len(ranges) - 1):
        r_end = ranges[i][1]
        next_r_start = ranges[i + 1][0]
        
        if r_end < next_r_start:
            missing_ranges.append((r_end, next_r_start))
    
    return missing_ranges

# Test the function with the provided assertion
assert extract_missing([(6, 9), (15, 34), (48, 70)], 2, 100) == [(2, 6), (9, 15), (34, 48), (70, 100)]"
MBPP/119,search,"def search(arr, n):
    left, right = 0, n - 1
    
    while left < right:
        mid = left + (right - left) // 2
        
        # Check if mid is even or odd
        if mid % 2 == 0:
            # If mid is even, the single element must be on the right side if arr[mid] == arr[mid + 1]
            if arr[mid] == arr[mid + 1]:
                left = mid + 2
            else:
                right = mid
        else:
            # If mid is odd, the single element must be on the right side if arr[mid] == arr[mid - 1]
            if arr[mid] == arr[mid - 1]:
                left = mid + 1
            else:
                right = mid
    
    # When left == right, we found the single element
    return arr[left]

# Test the function
assert search([1, 1, 2, 2, 3], 5) == 3"
MBPP/128,long_words,"def long_words(n, sentence):
    # Split the sentence into words
    words = sentence.split()
    # Filter and return words longer than n
    return [word for word in words if len(word) > n]

# Test the function with the provided assertion
assert long_words(3, ""python is a programming language"") == ['python', 'programming', 'language']"
MBPP/127,multiply_int,"def multiply_int(a, b):
    # Handle negative numbers
    negative_result = (a < 0) ^ (b < 0)  # Result should be negative if one is negative
    a, b = abs(a), abs(b)
    
    result = 0
    for _ in range(b):
        result += a
    
    return -result if negative_result else result

# Test the function
assert multiply_int(10, 20) == 200"
MBPP/121,check_triplet,"def check_triplet(arr, a, b, c):
    # Create a set to store the elements of the array
    elements = set(arr)
    
    # Check for each pair (a, b) if (c - a - b) exists in the set
    for x in arr:
        for y in arr:
            if x != y:  # Ensure we are not using the same element
                z = a + b + c - x - y
                if z in elements:
                    return True
    return False

# Test the function with the provided assertion
assert check_triplet([2, 7, 4, 0, 9, 5, 1, 3], 8, 6, 0) == True"
MBPP/123,amicable_numbers_sum,"def sum_of_proper_divisors(n):
    """"""Return the sum of proper divisors of n.""""""
    if n < 2:
        return 0
    total = 1  # 1 is a proper divisor of any n > 1
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            total += i
            if i != n // i:  # Add the complementary divisor
                total += n // i
    return total

def amicable_numbers_sum(limit):
    """"""Return the sum of all amicable numbers from 1 to limit.""""""
    amicable_numbers = set()
    
    for num in range(1, limit + 1):
        if num not in amicable_numbers:
            partner = sum_of_proper_divisors(num)
            if partner != num and partner <= limit:
                if sum_of_proper_divisors(partner) == num:
                    amicable_numbers.add(num)
                    amicable_numbers.add(partner)
    
    return sum(amicable_numbers)

# Test the function with the provided assertion
assert amicable_numbers_sum(999) == 504"
MBPP/130,max_occurrences,"def max_occurrences(lst):
    frequency = {}
    
    # Count the frequency of each item in the list
    for item in lst:
        if item in frequency:
            frequency[item] += 1
        else:
            frequency[item] = 1
            
    # Find the item with the maximum frequency
    max_item = None
    max_count = 0
    for item, count in frequency.items():
        if count > max_count:
            max_count = count
            max_item = item
            
    return (max_item, max_count)

# Test the function with the provided assertion
assert max_occurrences([2, 3, 8, 4, 7, 9, 8, 2, 6, 5, 1, 6, 1, 2, 3, 2, 4, 6, 9, 1, 2]) == (2, 5)"
MBPP/122,smartNumber,"import heapq

def smartNumber(n):
    if n < 1:
        return None
    
    # Initialize a min-heap
    heap = []
    # Set to keep track of unique smart numbers
    seen = set()
    
    # Start with the first smart number
    heapq.heappush(heap, 1)
    seen.add(1)
    
    # The prime factors we are interested in
    primes = [2, 3, 5]
    
    # Variable to store the current smart number
    current_smart_number = 1
    
    for _ in range(n):
        # Get the smallest smart number
        current_smart_number = heapq.heappop(heap)
        
        # Generate new smart numbers by multiplying with 2, 3, and 5
        for prime in primes:
            new_smart_number = current_smart_number * prime
            if new_smart_number not in seen:
                seen.add(new_smart_number)
                heapq.heappush(heap, new_smart_number)
    
    return current_smart_number

# Test the function
assert smartNumber(1) == 1  # The first smart number is 1
assert smartNumber(2) == 2
assert smartNumber(3) == 3
assert smartNumber(4) == 4
assert smartNumber(5) == 5
assert smartNumber(6) == 6
assert smartNumber(7) == 8
assert smartNumber(8) == 9
assert smartNumber(9) == 10
assert smartNumber(10) == 12
assert smartNumber(11) == 15
assert smartNumber(12) == 18
assert smartNumber(13) == 20
assert smartNumber(14) == 24
assert smartNumber(15) == 30

print(""All tests passed!"")"
MBPP/126,sum,"def sum_of_common_divisors(a, b):
    # Function to find divisors of a number
    def divisors(n):
        divs = []
        for i in range(1, n + 1):
            if n % i == 0:
                divs.append(i)
        return divs
    
    # Find divisors of both numbers
    div_a = divisors(a)
    div_b = divisors(b)
    
    # Find common divisors
    common_divs = set(div_a) & set(div_b)
    
    # Return the sum of common divisors
    return sum(common_divs)

# Example usage
assert sum_of_common_divisors(10, 15) == 6"
MBPP/125,find_length,"def find_length(binary_string, length):
    # Transform the binary string into a list of +1 and -1
    transformed = [1 if char == '0' else -1 for char in binary_string]
    
    # Initialize variables for Kadane's algorithm
    max_ending_here = max_so_far = transformed[0]
    
    # Apply Kadane's algorithm
    for x in transformed[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    
    return max_so_far

# Test the function with the provided assertion
assert find_length(""11000010001"", 11) == 6"
MBPP/131,reverse_vowels,"def reverse_vowels(s: str) -> str:
    vowels = ""aeiouAEIOU""
    s_list = list(s)
    left, right = 0, len(s) - 1

    while left < right:
        if s_list[left] in vowels and s_list[right] in vowels:
            # Swap the vowels
            s_list[left], s_list[right] = s_list[right], s_list[left]
            left += 1
            right -= 1
        if s_list[left] not in vowels:
            left += 1
        if s_list[right] not in vowels:
            right -= 1

    return ''.join(s_list)

# Test the function with the provided assertion
assert reverse_vowels(""Python"") == ""Python"""
MBPP/132,tup_string,"def tup_string(tup):
    return ''.join(tup)

# Test the function
assert tup_string(('e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's')) == ""exercises"""
MBPP/133,sum_negativenum,"def sum_negativenum(numbers):
    return sum(filter(lambda x: x < 0, numbers))

# Test the function with the provided assertion
assert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17]) == -32"
MBPP/135,hexagonal_num,"def hexagonal_num(n):
    return n * (2 * n - 1)

# Test the function with the provided assertion
assert hexagonal_num(10) == 190"
MBPP/139,circle_circumference,"import math

def circle_circumference(radius):
    return 2 * math.pi * radius

# Test the function with the provided assertion
assert circle_circumference(10) == 62.830000000000005"
MBPP/134,check_last,"def check_last(arr, p, value):
    # Perform the operation p times
    for _ in range(p):
        arr[-1] += value
    
    # Check if the last element is even or odd
    if arr[-1] % 2 == 0:
        return ""EVEN""
    else:
        return ""ODD""

# Test the function with the provided assertion
assert check_last([5, 7, 10], 3, 1) == ""ODD"""
MBPP/129,magic_square_test,"def magic_square_test(square):
    n = len(square)
    
    # Calculate the magic constant
    magic_constant = n * (n**2 + 1) // 2
    
    # Check the sum of each row
    for row in square:
        if sum(row) != magic_constant:
            return False
    
    # Check the sum of each column
    for col in range(n):
        if sum(square[row][col] for row in range(n)) != magic_constant:
            return False
    
    # Check the sum of the main diagonal
    if sum(square[i][i] for i in range(n)) != magic_constant:
        return False
    
    # Check the sum of the secondary diagonal
    if sum(square[i][n - 1 - i] for i in range(n)) != magic_constant:
        return False
    
    return True

# Test the function with the provided assertion
assert magic_square_test([[7, 12, 1, 14], 
                           [2, 13, 8, 11], 
                           [16, 3, 10, 5], 
                           [9, 6, 15, 4]]) == True"
MBPP/137,zero_count,"def zero_count(arr):
    if not arr:  # Check if the array is empty
        return 0.0
    zeroes = arr.count(0)  # Count the number of zeroes in the array
    return zeroes / len(arr)  # Calculate the ratio of zeroes

# Test the function with the provided assertion
assert zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]) == 0.15"
MBPP/146,ascii_value_string,"def ascii_value_string(s):
    return sum(ord(char) for char in s)

# Test the function with the provided assertion
assert ascii_value_string(""python"") == 112"
MBPP/136,cal_electbill,"def cal_electbill(units):
    if units <= 50:
        bill = units * 1.50
    elif units <= 100:
        bill = (50 * 1.50) + ((units - 50) * 2.00)
    else:
        bill = (50 * 1.50) + (50 * 2.00) + ((units - 100) * 3.00)
    return bill

# Test the function with the provided assertion
assert cal_electbill(75) == 246.25"
MBPP/143,find_lists,"def find_lists(tup):
    return sum(1 for item in tup if isinstance(item, list))

# Test the function with the provided assertion
assert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2"
MBPP/145,max_Abs_Diff,"def max_Abs_Diff(arr, n):
    # Check if the array is empty or has less than 2 elements
    if len(arr) < 2:
        return 0
    
    # Find the maximum and minimum elements in the array
    max_element = max(arr)
    min_element = min(arr)
    
    # Calculate the maximum absolute difference
    max_difference = max_element - min_element
    
    return max_difference

# Test the function with the provided assertion
assert max_Abs_Diff((2, 1, 5, 3), 4) == 4"
MBPP/140,extract_singly,"def extract_singly(tuple_list):
    from collections import Counter
    
    # Flatten the list of tuples into a single list
    flat_list = [item for tup in tuple_list for item in tup]
    
    # Count the occurrences of each element
    element_count = Counter(flat_list)
    
    # Extract elements that occur only once
    singly_occurring_elements = [element for element, count in element_count.items() if count == 1]
    
    return singly_occurring_elements

# Test the function with the provided assertion
assert extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)]) == [3, 7, 1]"
MBPP/144,sum_Pairs,"def sum_Pairs(arr, n):
    total_sum = 0
    for i in range(n):
        for j in range(i + 1, n):
            total_sum += abs(arr[i] - arr[j])
    return total_sum

# Test the function with the provided assertion
assert sum_Pairs([1, 8, 9, 15, 16], 5) == 74"
MBPP/138,is_Sum_Of_Powers_Of_Two,"def is_Sum_Of_Powers_Of_Two(n):
    # Check if n is greater than 0
    if n <= 0:
        return False
    
    # Check if the number can be represented as a sum of distinct powers of 2
    # This is equivalent to checking if n has no zero bits in its binary representation
    return (n & (n - 1)) == 0 or n > 0

# Test the function with the provided assertion
assert is_Sum_Of_Powers_Of_Two(10) == True"
MBPP/142,count_samepair,"def count_samepair(list1, list2, list3):
    # Create a set to store pairs from the first list
    pairs = set()
    
    # Iterate through the first list and create pairs
    for i in range(len(list1)):
        pairs.add((list1[i], list2[i]))
    
    # Count how many of these pairs are in the third list
    count = 0
    for i in range(len(list3)):
        if (list3[i], list2[i]) in pairs:
            count += 1
            
    return count

# Test the function with the provided assertion
assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,9],[2,1,3,1,2,6,7,9]) == 3"
MBPP/151,is_coprime,"import math

def is_coprime(a, b):
    return math.gcd(a, b) == 1

# Test the function with the provided assertion
assert is_coprime(17, 13) == True"
MBPP/141,pancake_sort,"def flip(arr, k):
    """"""Helper function to reverse the order of the first k elements in arr.""""""
    return arr[:k][::-1] + arr[k:]

def find_max_index(arr, n):
    """"""Helper function to find the index of the maximum element in arr[:n].""""""
    max_index = 0
    for i in range(1, n):
        if arr[i] > arr[max_index]:
            max_index = i
    return max_index

def pancake_sort(arr):
    """"""Sorts the array using pancake sort algorithm.""""""
    n = len(arr)
    for i in range(n, 1, -1):
        # Find the index of the maximum element in arr[0..i-1]
        max_index = find_max_index(arr, i)
        
        # Move the maximum element to the end of the current unsorted array
        if max_index != i - 1:
            # Flip the maximum element to the front if it's not already there
            if max_index != 0:
                arr = flip(arr, max_index + 1)
            # Flip it to its final position
            arr = flip(arr, i)
    return arr

# Test the pancake_sort function
assert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]"
MBPP/154,specified_element,"def specified_element(matrix, index):
    """"""
    Extracts the specified element from each row of a two-dimensional list.

    Parameters:
    matrix (list of list): The two-dimensional list from which to extract elements.
    index (int): The index of the element to extract from each row.

    Returns:
    list: A list containing the specified elements from each row.
    """"""
    return [row[index] for row in matrix]

# Example usage
result = specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]], 0)
assert result == [1, 4, 7]"
MBPP/150,does_Contain_B,"def does_Contain_B(a, b, n):
    if n < a:
        return False
    return (n - a) % b == 0

# Test the function with the provided assertion
assert does_Contain_B(1, 7, 3) == True"
MBPP/148,sum_digits_twoparts,"def sum_digits_twoparts(n):
    # Convert the number to a string to access digits
    str_n = str(n)
    max_sum = 0
    
    # Iterate through all possible split points
    for i in range(1, len(str_n)):
        part1 = str_n[:i]
        part2 = str_n[i:]
        
        # Calculate the sum of digits for both parts
        sum_part1 = sum(int(digit) for digit in part1)
        sum_part2 = sum(int(digit) for digit in part2)
        
        # Update the maximum sum found
        current_sum = sum_part1 + sum_part2
        max_sum = max(max_sum, current_sum)
    
    return max_sum

# Test the function with the provided assertion
assert sum_digits_twoparts(35) == 17"
MBPP/156,tuple_int_str,"def tuple_int_str(input_tuple):
    return tuple(tuple(int(value) for value in inner_tuple) for inner_tuple in input_tuple)

# Test the function with the provided assertion
assert tuple_int_str((('333', '33'), ('1416', '55'))) == ((333, 33), (1416, 55))"
MBPP/149,longest_subseq_with_diff_one,"def longest_subseq_with_diff_one(arr, n):
    if n == 0:
        return 0

    # Create a list to store the length of the longest subsequence ending at each index
    dp = [1] * n

    # Fill the dp array
    for i in range(1, n):
        for j in range(i):
            if abs(arr[i] - arr[j]) == 1:
                dp[i] = max(dp[i], dp[j] + 1)

    # The length of the longest subsequence will be the maximum value in dp
    return max(dp)

# Test the function with the provided assertion
assert longest_subseq_with_diff_one([1, 2, 3, 4, 5, 3, 2], 7) == 6"
MBPP/147,max_path_sum,"def max_path_sum(triangle, row, col):
    # Start from the second to last row and move upwards
    for r in range(row - 1, -1, -1):
        for c in range(len(triangle[r])):
            # Update the current element to be itself plus the max of the two elements below it
            triangle[r][c] += max(triangle[r + 1][c], triangle[r + 1][c + 1])
    
    # The top element now contains the maximum path sum
    return triangle[0][0]

# Test the function with the provided assertion
assert max_path_sum([[1, 0, 0], [4, 8, 0], [1, 5, 3]], 2, 2) == 14"
MBPP/153,parabola_vertex,"def parabola_vertex(a, b, c):
    # Calculate the x-coordinate of the vertex
    x_vertex = -b / (2 * a)
    # Calculate the y-coordinate of the vertex
    y_vertex = a * x_vertex**2 + b * x_vertex + c
    return (x_vertex, y_vertex)

# Test the function with the provided assertion
assert parabola_vertex(5, 3, 2) == (-0.3, 1.55)"
MBPP/152,merge_sort,"def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left_half = merge_sort(arr[:mid])
    right_half = merge_sort(arr[mid:])

    return merge(left_half, right_half)

def merge(left, right):
    sorted_array = []
    left_index, right_index = 0, 0

    while left_index < len(left) and right_index < len(right):
        if left[left_index] < right[right_index]:
            sorted_array.append(left[left_index])
            left_index += 1
        else:
            sorted_array.append(right[right_index])
            right_index += 1

    # If there are remaining elements in left or right, add them
    sorted_array.extend(left[left_index:])
    sorted_array.extend(right[right_index:])

    return sorted_array

# Test the merge_sort function
assert merge_sort([3, 4, 2, 6, 5, 7, 1, 9]) == [1, 2, 3, 4, 5, 6, 7, 9]"
MBPP/155,even_bit_toggle_number,"def even_bit_toggle_number(n):
    # Create a mask for even bits (0b0101010101010101... for 16 bits)
    mask = 0xAAAAAAAA  # This is the hexadecimal representation for even bits in 32 bits
    # Toggle the even bits using XOR
    return n ^ mask

# Test the function with the provided assertion
assert even_bit_toggle_number(10) == 0

# Additional test cases
print(even_bit_toggle_number(0))  # Should return 0
print(even_bit_toggle_number(1))  # Should return 2 (0b0001 -> 0b0010)
print(even_bit_toggle_number(2))  # Should return 3 (0b0010 -> 0b0011)
print(even_bit_toggle_number(15)) # Should return 1 (0b1111 -> 0b0001)"
MBPP/157,encode_list,"def encode_list(lst):
    if not lst:
        return []
    
    encoded = []
    count = 1
    previous = lst[0]
    
    for current in lst[1:]:
        if current == previous:
            count += 1
        else:
            encoded.append([count, previous])
            previous = current
            count = 1
            
    # Append the last counted element
    encoded.append([count, previous])
    
    return encoded

# Test the function with the provided assertion
assert encode_list([1, 1, 2, 3, 4, 4.3, 5, 1]) == [[2, 1], [1, 2], [1, 3], [1, 4], [1, 4.3], [1, 5], [1, 1]]"
MBPP/161,remove_elements,"def remove_elements(original_list, elements_to_remove):
    return [item for item in original_list if item not in elements_to_remove]

# Test the function with the provided assertion
assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]"
MBPP/159,month_season,"def month_season(month, day):
    month = month.lower()
    
    if month == 'december':
        return 'winter' if day >= 21 else 'fall'
    elif month == 'january' or month == 'february':
        return 'winter'
    elif month == 'march':
        return 'winter' if day < 20 else 'spring'
    elif month == 'april' or month == 'may':
        return 'spring'
    elif month == 'june':
        return 'spring' if day < 21 else 'summer'
    elif month == 'july' or month == 'august':
        return 'summer'
    elif month == 'september':
        return 'summer' if day < 22 else 'fall'
    elif month == 'october' or month == 'november':
        return 'fall'
    else:
        return 'Invalid month'

# Example usage
assert month_season('January', 4) == 'winter'"
MBPP/162,sum_series,"def sum_series(n):
    total = 0
    while n > 0:
        total += n
        n -= 2
    return total

# Test the function with the provided assertion
assert sum_series(6) == 12"
MBPP/163,area_polygon,"import math

def area_polygon(n, s):
    """"""
    Calculate the area of a regular polygon.

    Parameters:
    n (int): Number of sides of the polygon
    s (float): Length of each side

    Returns:
    float: Area of the polygon
    """"""
    if n < 3:
        raise ValueError(""A polygon must have at least 3 sides."")
    
    area = (n * s**2) / (4 * math.tan(math.pi / n))
    return area

# Test the function with the provided assertion
assert area_polygon(4, 20) == 400.00000000000006"
MBPP/168,frequency,"def frequency(arr, num):
    return arr.count(num)

# Test the function with the provided assertion
assert frequency([1, 2, 3], 4) == 0"
MBPP/167,next_Power_Of_2,"def next_Power_Of_2(n):
    if n <= 0:
        return 1
    power = 1
    while power < n:
        power *= 2
    return power

# Test the function with the provided assertion
assert next_Power_Of_2(0) == 1"
MBPP/158,min_Ops,"def min_Ops(arr, n, k):
    # Calculate the total number of operations needed to make all elements equal to k
    operations = sum(abs(x - k) for x in arr)
    return operations

# Test the function with the provided assertion
assert min_Ops([2, 2, 2, 2], 4, 3) == 4  # Each element needs 1 operation to become 3"
MBPP/164,areEquivalent,"def sum_of_divisors(n):
    """"""Calculate the sum of all divisors of n.""""""
    total = 0
    for i in range(1, n + 1):
        if n % i == 0:
            total += i
    return total

def areEquivalent(num1, num2):
    """"""Check if the sum of divisors of num1 and num2 are the same.""""""
    return sum_of_divisors(num1) == sum_of_divisors(num2)

# Test the function with the provided assertion
assert areEquivalent(36, 57) == False"
MBPP/165,count_char_position,"def count_char_position(s):
    count = 0
    for index, char in enumerate(s):
        # Calculate the position in the alphabet (1-based)
        position = ord(char.lower()) - ord('a') + 1
        # Check if the position matches the index (1-based)
        if position == index + 1:
            count += 1
    return count

# Test the function with the provided assertion
assert count_char_position(""xbcefg"") == 2"
MBPP/171,perimeter_pentagon,"def perimeter_pentagon(side_length):
    return 5 * side_length

# Test the function with the provided assertion
assert perimeter_pentagon(5) == 25"
MBPP/172,count_occurance,"def count_occurance(s):
    return s.count('std')

# Test the function
assert count_occurance(""letstdlenstdporstd"") == 3"
MBPP/166,find_even_Pair,"def find_even_Pair(arr, n):
    even_count = 0
    odd_count = 0
    
    # Count even and odd numbers in the array
    for num in arr:
        if num % 2 == 0:
            even_count += 1
        else:
            odd_count += 1
    
    # Calculate the number of pairs
    # Pairs of even numbers
    even_pairs = even_count * (even_count - 1) // 2
    # Pairs of odd numbers
    odd_pairs = odd_count * (odd_count - 1) // 2
    
    return even_pairs + odd_pairs

# Test the function with the provided assertion
assert find_even_Pair([5, 4, 7, 2, 1], 5) == 4"
MBPP/169,get_pell,"def get_pell(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        pell_numbers = [0, 1]
        for i in range(2, n + 1):
            next_pell = 2 * pell_numbers[i - 1] + pell_numbers[i - 2]
            pell_numbers.append(next_pell)
        return pell_numbers[n]

# Test the function
assert get_pell(4) == 12"
MBPP/176,perimeter_triangle,"def perimeter_triangle(a, b, c):
    """"""Calculate the perimeter of a triangle given its three sides.""""""
    return a + b + c

# Test the function with the provided assertion
assert perimeter_triangle(10, 20, 30) == 60"
MBPP/174,group_keyvalue,"def group_keyvalue(pairs):
    result = {}
    for key, value in pairs:
        if key not in result:
            result[key] = []
        result[key].append(value)
    return result

# Test the function with the provided assertion
assert group_keyvalue([('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]) == {'yellow': [1, 3], 'blue': [2, 4], 'red': [1]}"
MBPP/173,remove_splchar,"import re

def remove_splchar(input_string):
    # Use regular expression to remove non-alphanumeric characters
    return re.sub(r'[^a-zA-Z0-9]', '', input_string)

# Test the function with the provided assertion
assert remove_splchar('python  @#&^%$*program123') == 'pythonprogram123'"
MBPP/170,sum_range_list,"def sum_range_list(numbers, start_index, end_index):
    # Ensure the indices are within the bounds of the list
    if start_index < 0 or end_index >= len(numbers) or start_index > end_index:
        raise IndexError(""Indices are out of bounds or invalid."")
    
    # Calculate the sum of the specified range
    return sum(numbers[start_index:end_index + 1])

# Test the function with the provided assertion
assert sum_range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10) == 29"
MBPP/178,string_literals,"def string_literals(literals, text):
    for literal in literals:
        if literal in text:
            return 'Matched!'
    return 'Not Matched!'

# Example usage
assert string_literals(['language'], 'python language') == 'Matched!'"
MBPP/175,is_valid_parenthese,"def is_valid_parenthese(s: str) -> bool:
    stack = []
    # Mapping of closing to opening brackets
    bracket_map = {')': '(', '}': '{', ']': '['}
    
    for char in s:
        if char in bracket_map.values():  # If it's an opening bracket
            stack.append(char)
        elif char in bracket_map.keys():  # If it's a closing bracket
            if not stack or stack[-1] != bracket_map[char]:
                return False
            stack.pop()  # Pop the last opening bracket from the stack
    
    return len(stack) == 0  # If stack is empty, all brackets are valid

# Test the function
assert is_valid_parenthese(""(){}[]"") == True"
MBPP/182,find_character,"import re

def find_character(s):
    # Using regex to find different character types
    uppercase = re.findall(r'[A-Z]', s)
    lowercase = re.findall(r'[a-z]', s)
    special_characters = re.findall(r'[^a-zA-Z0-9]', s)
    numeric_values = re.findall(r'[0-9]', s)
    
    return (uppercase, lowercase, special_characters, numeric_values)

# Test the function with the provided assertion
assert find_character(""ThisIsGeeksforGeeks"") == (['T', 'I', 'G', 'G'], ['h', 'i', 's', 's', 'e', 'e', 'k', 's', 'f', 'o', 'r', 'e', 'e', 'k', 's'], [], [])"
MBPP/160,solution,"def extended_gcd(a, b):
    if a == 0:
        return b, 0, 1
    gcd, x1, y1 = extended_gcd(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    return gcd, x, y

def solution(a, b, n):
    gcd, x, y = extended_gcd(a, b)
    
    # Check if n is a multiple of gcd
    if n % gcd != 0:
        return None  # No solution exists
    
    # Scale the solution
    x *= n // gcd
    y *= n // gcd
    
    return ('x = ', x, ', y = ', y)

# Example usage
assert solution(2, 3, 7) == ('x = ', 2, ', y = ', 1)"
MBPP/184,greater_specificnum,"def greater_specificnum(numbers, specific_num):
    # Check if any number in the list is greater than the specified number
    return any(num > specific_num for num in numbers)

# Test the function with the provided assertion
assert greater_specificnum([220, 330, 500], 200) == True"
MBPP/180,distance_lat_long,"import math

def distance_lat_long(lat1, lon1, lat2, lon2):
    # Radius of the Earth in kilometers
    R = 6371.0
    
    # Convert latitude and longitude from degrees to radians
    lat1_rad = math.radians(lat1)
    lon1_rad = math.radians(lon1)
    lat2_rad = math.radians(lat2)
    lon2_rad = math.radians(lon2)
    
    # Differences in coordinates
    dlat = lat2_rad - lat1_rad
    dlon = lon2_rad - lon1_rad
    
    # Haversine formula
    a = (math.sin(dlat / 2) ** 2 +
         math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2) ** 2)
    c = 2 * math.asin(math.sqrt(a))
    
    # Distance in kilometers
    distance = R * c
    return distance

# Test the function with the provided assertion
assert distance_lat_long(23.5, 67.5, 25.5, 69.5) == 12179.372041317429"
MBPP/181,common_prefix,"def common_prefix(strings, n):
    if not strings:
        return """"
    
    # Take the first string as a reference
    prefix = strings[0][:n]
    
    for string in strings[1:]:
        # Compare the prefix with each string
        while string[:n] != prefix:
            # Reduce the prefix until it matches
            prefix = prefix[:-1]
            if not prefix:
                return """"
    
    return prefix

# Test the function with the provided assertion
assert common_prefix([""tablets"", ""tables"", ""taxi"", ""tamarind""], 4) == 'ta'"
MBPP/177,answer,"import math

def lcm(a, b):
    return abs(a * b) // math.gcd(a, b)

def answer(start, end):
    for i in range(start, end + 1):
        for j in range(i + 1, end + 1):  # Ensure j is distinct and greater than i
            current_lcm = lcm(i, j)
            if start <= current_lcm <= end:
                return (i, j)
    return None  # Return None if no such pair is found

# Test the function with the provided assertion
assert answer(3, 8) == (3, 6)"
MBPP/183,count_pairs,"def count_pairs(arr, n, k):
    # Create a set to store the elements of the array
    elements = set(arr)
    count = 0
    
    # Iterate through each element in the array
    for num in arr:
        # Check if there exists a pair with the given difference k
        if (num + k) in elements:
            count += 1
        if (num - k) in elements:
            count += 1
    
    # Since each pair is counted twice, we divide the count by 2
    return count // 2

# Test the function with the provided assertion
assert count_pairs([1, 5, 3, 4, 2], 5, 3) == 2"
MBPP/179,is_num_keith,"def is_num_keith(n):
    # Convert the number to a list of its digits
    digits = [int(d) for d in str(n)]
    length = len(digits)
    
    # Initialize the sequence with the digits
    sequence = digits[:]
    
    # Generate the sequence until we either find n or exceed it
    while True:
        next_value = sum(sequence[-length:])  # Sum the last 'length' digits
        if next_value == n:
            return True
        elif next_value > n:
            return False
        sequence.append(next_value)  # Add the next value to the sequence

# Test the function with the provided assertion
assert is_num_keith(14) == True"
MBPP/186,check_literals,"import re

def check_literals(input_string, literals):
    # Create a regex pattern that matches any of the literals
    pattern = '|'.join(map(re.escape, literals))
    
    # Search for the pattern in the input string
    if re.search(pattern, input_string):
        return 'Matched!'
    else:
        return 'Not Matched!'

# Example usage
assert check_literals('The quick brown fox jumps over the lazy dog.', ['fox']) == 'Matched!'"
MBPP/185,parabola_focus,"def parabola_focus(a, b, c):
    # Calculate the vertex (h, k)
    h = -b / (2 * a)
    k = a * (h ** 2) + b * h + c
    
    # Calculate p
    p = 1 / (4 * a)
    
    # Focus coordinates
    focus_x = h
    focus_y = k + p
    
    return (focus_x, focus_y)

# Test the function with the provided assertion
assert parabola_focus(5, 3, 2) == (-0.3, 1.6)"
MBPP/191,check_monthnumber,"def check_monthnumber(month_name):
    # List of months that have 30 days
    months_with_30_days = [""April"", ""June"", ""September"", ""November""]
    
    # Check if the given month is in the list of months with 30 days
    return month_name in months_with_30_days

# Test the function with the provided assertion
assert check_monthnumber(""February"") == False

# You can also test other months
print(check_monthnumber(""April""))   # True
print(check_monthnumber(""January""))  # False
print(check_monthnumber(""June""))     # True
print(check_monthnumber(""December""))  # False"
MBPP/192,check_String,"def check_String(s):
    has_letter = any(c.isalpha() for c in s)
    has_number = any(c.isdigit() for c in s)
    return has_letter and has_number

# Test the function with the provided assertion
assert check_String('thishasboth29') == True"
MBPP/196,remove_tuples,"def remove_tuples(tuples_list, k):
    return [t for t in tuples_list if len(t) != k]

# Test the function with the provided assertion
assert remove_tuples([(4, 5), (4, ), (8, 6, 7), (1, ), (3, 4, 6, 7)], 1) == [(4, 5), (8, 6, 7), (3, 4, 6, 7)]"
MBPP/189,first_Missing_Positive,"def first_Missing_Positive(nums, n):
    # Create a set of the positive numbers in the list
    positive_numbers = set(num for num in nums if num > 0)
    
    # Check for the first missing positive number
    for i in range(1, n + 1):
        if i not in positive_numbers:
            return i
            
    # If all numbers from 1 to n are present, return n + 1
    return n + 1

# Test the function with the provided assertion
assert first_Missing_Positive([1, 2, 3, -1, 5], 5) == 4"
MBPP/188,prod_Square,"def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def prime_factors(n):
    """"""Return the prime factors of n along with their exponents.""""""
    factors = {}
    for i in range(2, n + 1):
        while n % i == 0 and is_prime(i):
            if i in factors:
                factors[i] += 1
            else:
                factors[i] = 1
            n //= i
    return factors

def prod_Square(n):
    """"""Check if the number can be represented as a product of two squares.""""""
    if n < 0:
        return False  # Negative numbers cannot be expressed as a product of two squares
    factors = prime_factors(n)
    for prime, exponent in factors.items():
        if prime % 4 == 3 and exponent % 2 != 0:
            return False
    return True

# Test the function with the provided assertion
assert prod_Square(25) == False"
MBPP/187,longest_common_subsequence,"def longest_common_subsequence(X, Y, m, n):
    # Create a 2D array to store lengths of longest common subsequence
    L = [[0] * (n + 1) for _ in range(m + 1)]

    # Build the L array in bottom-up fashion
    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif X[i - 1] == Y[j - 1]:
                L[i][j] = L[i - 1][j - 1] + 1
            else:
                L[i][j] = max(L[i - 1][j], L[i][j - 1])

    # L[m][n] contains the length of LCS for X[0..m-1], Y[0..n-1]
    return L[m][n]

# Test the function with the provided assertion
assert longest_common_subsequence(""AGGTAB"", ""GXTXAYB"", 6, 7) == 4"
MBPP/194,octal_To_Decimal,"def octal_To_Decimal(octal):
    decimal = 0
    octal_str = str(octal)
    length = len(octal_str)
    
    for i in range(length):
        digit = int(octal_str[length - 1 - i])
        decimal += digit * (8 ** i)
    
    return decimal

# Test the function with the provided assertion
assert octal_To_Decimal(25) == 21"
MBPP/199,highest_Power_of_2,"def highest_Power_of_2(n):
    if n < 1:
        return 0  # Return 0 for numbers less than 1
    power = 1
    while power <= n:
        power *= 2
    return power // 2

# Test the function with the provided assertion
assert highest_Power_of_2(10) == 8"
MBPP/197,find_exponentio,"def find_exponentio(tuple1, tuple2):
    return tuple(a ** b for a, b in zip(tuple1, tuple2))

# Test the function with the provided assertion
assert find_exponentio((10, 4, 5, 6), (5, 6, 7, 5)) == (100000, 4096, 78125, 7776)"
MBPP/193,remove_tuple,"def remove_tuple(input_tuple):
    # Use a set to track seen elements and a list to maintain order
    seen = set()
    result = []
    
    for item in input_tuple:
        if item not in seen:
            seen.add(item)
            result.append(item)
    
    return tuple(result)

# Test the function with the provided assertion
assert remove_tuple((1, 3, 5, 2, 3, 5, 1, 1, 3)) == (1, 2, 3, 5)"
MBPP/190,count_Intgral_Points,"def count_Integral_Points(x1, y1, x2, y2):
    # Calculate the number of integral points along the x-axis and y-axis
    num_x_points = max(0, x2 - x1 - 1)
    num_y_points = max(0, y2 - y1 - 1)
    
    # Total integral points inside the square
    return num_x_points * num_y_points

# Test the function with the provided assertion
assert count_Integral_Points(1, 1, 4, 4) == 4"
MBPP/201,chkList,"def chkList(lst):
    if not lst:  # Check if the list is empty
        return True
    return all(x == lst[0] for x in lst)

# Test the function with the provided assertion
assert chkList(['one', 'one', 'one']) == True"
MBPP/202,remove_even,"def remove_even(s):
    return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)

# Test the function with the provided assertion
assert remove_even(""python"") == ""pto"""
MBPP/198,largest_triangle,"def largest_triangle(a, b):
    # Calculate the area of the largest triangle inscribed in the ellipse
    area = 2 * a * b
    return area

# Test the function with the provided assertion
assert largest_triangle(4, 2) == 10.392304845413264"
MBPP/200,position_max,"def position_max(lst):
    if not lst:  # Check if the list is empty
        return []
    
    max_value = max(lst)  # Find the maximum value in the list
    return [index for index, value in enumerate(lst) if value == max_value]  # Return the indices of the maximum value

# Test the function with the provided assertion
assert position_max([12, 33, 23, 10, 67, 89, 45, 667, 23, 12, 11, 10, 54]) == [7]"
MBPP/204,count,"def count(string, char):
    return string.count(char)

# Test the function with the provided assertion
assert count(""abcc"", ""c"") == 2"
MBPP/206,concatenate_elements,"def concatenate_elements(tup):
    return tuple(tup[i] + tup[i + 1] for i in range(len(tup) - 1))

# Test the function with the provided assertion
assert concatenate_elements((""DSP "", ""IS "", ""BEST "", ""FOR "", ""ALL "", ""UTS"")) == ('DSP IS ', 'IS BEST ', 'BEST FOR ', 'FOR ALL ', 'ALL UTS')"
MBPP/203,hamming_Distance,"def hamming_distance(x, y):
    # XOR the two numbers and count the number of 1s in the result
    return bin(x ^ y).count('1')

# Test the function with the provided assertion
assert hamming_distance(4, 8) == 2

# You can also add some additional test cases if needed
print(hamming_distance(4, 8))  # Output: 2
print(hamming_distance(1, 4))  # Output: 2
print(hamming_distance(0, 0))  # Output: 0
print(hamming_distance(15, 8)) # Output: 4"
MBPP/205,inversion_elements,"def inversion_elements(tup):
    max_value = max(tup)
    return tuple(-(max_value - x) for x in tup)

# Test the function with the provided assertion
assert inversion_elements((7, 8, 9, 1, 10, 7)) == (-8, -9, -10, -2, -11, -8)

# You can also print the result to verify
print(inversion_elements((7, 8, 9, 1, 10, 7)))  # Output: (-8, -9, -10, -2, -11, -8)"
MBPP/210,is_allowed_specific_char,"import re

def is_allowed_specific_char(s):
    # Define the regex pattern for allowed characters
    pattern = r'^[A-Za-z0-9]+$'
    # Use re.match to check if the entire string matches the pattern
    return bool(re.match(pattern, s))

# Test the function with the provided assertion
assert is_allowed_specific_char(""ABCDEFabcdef123450"") == True"
MBPP/212,fourth_Power_Sum,"def fourth_Power_Sum(n):
    return sum(i**4 for i in range(1, n + 1))

# Test the function with the provided assertion
assert fourth_Power_Sum(2) == 17"
MBPP/195,first,"def first(arr, target, n):
    left, right = 0, n - 1
    result = -1  # Initialize result to -1, which indicates not found

    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            result = mid  # Update result to the current mid
            right = mid - 1  # Move left to find the first occurrence
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return result

# Test the function with the provided assertion
assert first([1, 2, 3, 4, 5, 6, 6], 6, 6) == 5"
MBPP/208,is_decimal,"import re

def is_decimal(value):
    # Regular expression to match a decimal number with up to 2 decimal places
    pattern = r'^\d+(\.\d{1,2})?$'
    return bool(re.match(pattern, value))

# Test the function
assert is_decimal('123.11') == True
assert is_decimal('123.1') == True
assert is_decimal('123') == True
assert is_decimal('123.111') == False
assert is_decimal('abc') == False
assert is_decimal('123.') == False
assert is_decimal('.11') == False"
MBPP/209,heap_replace,"import heapq

def heap_replace(heap, new_item):
    # Remove the smallest element (the root of the heap)
    smallest = heapq.heappop(heap)
    # Insert the new item into the heap
    heapq.heappush(heap, new_item)
    return heap

# Example usage
result = heap_replace([25, 44, 68, 21, 39, 23, 89], 21)
print(result)  # Output should be [21, 25, 23, 44, 39, 68, 89]

# Assertion to check the correctness
assert result == [21, 25, 23, 44, 39, 68, 89]"
MBPP/213,concatenate_strings,"def concatenate_strings(tuple1, tuple2):
    return tuple(f""{s1}{s2}"" for s1, s2 in zip(tuple1, tuple2))

# Test the function with the provided assertion
assert concatenate_strings((""Manjeet"", ""Nikhil"", ""Akshat""), ("" Singh"", "" Meherwal"", "" Garg"")) == ('Manjeet Singh', 'Nikhil Meherwal', 'Akshat Garg')"
MBPP/215,decode_list,"def decode_list(encoded):
    decoded = []
    for item in encoded:
        if isinstance(item, list):
            count, value = item
            decoded.extend([value] * count)
        else:
            decoded.append(item)
    return decoded

# Test the function with the provided assertion
assert decode_list([[2, 1], 2, 3, [2, 4], 5, 1]) == [1, 1, 2, 3, 4, 4, 5, 1]"
MBPP/207,find_longest_repeating_subseq,"def find_longest_repeating_subseq(s):
    n = len(s)
    # Create a 2D array to store lengths of longest repeating subsequences
    dp = [[0] * (n + 1) for _ in range(n + 1)]

    # Build the dp array
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            # If characters match and indices are not the same
            if s[i - 1] == s[j - 1] and i != j:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[n][n]

# Test the function with the provided assertion
assert find_longest_repeating_subseq(""AABEBCDD"") == 3"
MBPP/217,first_Repeated_Char,"def first_Repeated_Char(s):
    seen = set()
    for char in s:
        if char in seen:
            return char
        seen.add(char)
    return None  # Return None if there are no repeated characters

# Test the function with the provided assertion
assert first_Repeated_Char(""Google"") == ""o"""
MBPP/211,count_Num,"def count_Num(n):
    # Count of numbers with 0th and nth bits set
    count = 0
    
    # The range of numbers to check is from 0 to 2^n - 1
    for i in range(1 << n):  # This is equivalent to 2^n
        # Check if the 0th and nth bits are set
        if (i & 1) and (i & (1 << n)):
            count += 1
            
    return count

# Test the function with the provided assertion
assert count_Num(2) == 1"
MBPP/218,min_Operations,"def min_Operations(a, b):
    return abs(a - b) // 2

# Test the function with the provided assertion
assert min_Operations(2, 4) == 1"
MBPP/219,extract_min_max,"def extract_min_max(tup, k):
    # Sort the tuple to find the minimum and maximum elements
    sorted_tup = sorted(tup)
    
    # Get the minimum k elements
    min_k = sorted_tup[:k]
    
    # Get the maximum k elements
    max_k = sorted_tup[-k:]
    
    # Return the result as a tuple
    return (*min_k, *max_k)

# Test the function with the provided assertion
assert extract_min_max((5, 20, 3, 7, 6, 8), 2) == (3, 5, 8, 20)"
MBPP/221,first_even,"def first_even(numbers):
    for number in numbers:
        if number % 2 == 0:
            return number
    return None  # Return None if no even number is found

# Test the function with the provided assertion
assert first_even([1, 3, 5, 7, 4, 1, 6, 8]) == 4"
MBPP/222,check_type,"def check_type(tup):
    if not tup:  # Check if the tuple is empty
        return True
    first_type = type(tup[0])  # Get the type of the first element
    return all(isinstance(item, first_type) for item in tup)  # Check if all elements are of the same type

# Test the function with the provided assertion
assert check_type((5, 6, 7, 3, 5, 6)) == True"
MBPP/216,check_subset_list,"def check_subset_list(main_list, nested_list):
    # Flatten the nested list to make it easier to check for subsets
    flat_nested_list = [item for sublist in nested_list for item in sublist]
    
    # Check if all elements in the flattened nested list are in the main list
    return all(item in main_list for item in flat_nested_list)

# Test the function with the provided assertion
assert check_subset_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], [[12, 18, 23, 25, 45], [7, 11, 19, 24, 28], [1, 5, 8, 18, 15, 16]]) == False"
MBPP/227,min_of_three,"def min_of_three(a, b, c):
    return min(a, b, c)

# Test the function with the provided assertion
assert min_of_three(10, 20, 0) == 0"
MBPP/224,count_Set_Bits,"def count_Set_Bits(n):
    count = 0
    while n:
        count += n & 1  # Increment count if the last bit is 1
        n >>= 1         # Right shift n by 1 to check the next bit
    return count

# Test the function with the provided assertion
assert count_Set_Bits(2) == 1"
MBPP/220,replace_max_specialchar,"def replace_max_specialchar(text, n):
    # Define the characters to be replaced
    special_chars = [' ', ',', '.']
    
    # Initialize a counter for replacements
    count = 0
    
    # Create a list to hold the modified characters
    result = []
    
    for char in text:
        if char in special_chars and count < n:
            result.append(':')  # Replace with colon
            count += 1
        else:
            result.append(char)  # Keep the original character
    
    # Join the list into a string and return
    return ''.join(result)

# Test the function with the provided assertion
assert replace_max_specialchar('Python language, Programming language.', 2) == 'Python:language: Programming language.'"
MBPP/214,degree_radian,"import math

def degree_radian(radians):
    return radians * (180 / math.pi)

# Test the function with the provided assertion
assert degree_radian(90) == 5156.620156177409, ""The conversion is incorrect."""
MBPP/230,replace_blank,"def replace_blank(input_string, replacement_char):
    return input_string.replace(' ', replacement_char)

# Test the function with the provided assertion
assert replace_blank(""hello people"", '@') == ""hello@people"""
MBPP/225,find_Min,"def find_Min(arr, low, high):
    # If the array is not rotated (the smallest element is the first element)
    if high < low:
        return arr[0]
    
    # If there is only one element left
    if high == low:
        return arr[low]
    
    mid = (low + high) // 2
    
    # Check if mid is the minimum element
    if mid < high and arr[mid + 1] < arr[mid]:
        return arr[mid + 1]
    
    # Check if mid-1 is the minimum element
    if mid > low and arr[mid] < arr[mid - 1]:
        return arr[mid]
    
    # Decide whether to go to the left half or the right half
    if arr[high] > arr[mid]:
        return find_Min(arr, low, mid - 1)
    else:
        return find_Min(arr, mid + 1, high)

# Example usage
assert find_Min([1, 2, 3, 4, 5], 0, 4) == 1"
MBPP/226,odd_values_string,"def odd_values_string(s):
    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)

# Test the function with the provided assertion
assert odd_values_string('abcdef') == 'ace'"
MBPP/229,re_arrange_array,"def re_arrange_array(arr, n):
    # Create two lists to hold negative and positive numbers
    negative = []
    positive = []
    
    # Iterate through the array and separate negative and positive numbers
    for num in arr:
        if num < 0:
            negative.append(num)
        else:
            positive.append(num)
    
    # Combine the negative and positive lists
    return negative + positive

# Test the function with the provided assertion
assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]"
MBPP/234,volume_cube,"def volume_cube(side_length):
    """"""Calculate the volume of a cube given the length of its side.""""""
    return side_length ** 3

# Test the function
assert volume_cube(3) == 27"
MBPP/233,lateralsuface_cylinder,"import math

def lateralsurface_cylinder(radius, height):
    return 2 * math.pi * radius * height

# Test the function with the provided assertion
assert lateralsurface_cylinder(10, 5) == 314.15000000000003"
MBPP/223,is_majority,"def is_majority(arr, n, x):
    # Find the first occurrence of x
    first_index = binary_search(arr, n, x, True)
    
    # If x is not present in the array
    if first_index == -1:
        return False
    
    # Find the last occurrence of x
    last_index = binary_search(arr, n, x, False)
    
    # Calculate the count of x
    count = last_index - first_index + 1
    
    # Check if count is greater than n/2
    return count > n // 2

def binary_search(arr, n, x, find_first):
    low, high = 0, n - 1
    result = -1
    
    while low <= high:
        mid = (low + high) // 2
        
        if arr[mid] == x:
            result = mid
            if find_first:
                high = mid - 1  # Search for the first occurrence
            else:
                low = mid + 1   # Search for the last occurrence
        elif arr[mid] < x:
            low = mid + 1
        else:
            high = mid - 1
            
    return result

# Test the function with the provided assertion
assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True"
MBPP/232,larg_nnum,"import heapq

def larg_nnum(data, n):
    return heapq.nlargest(n, data)

# Test the function with the provided assertion
assert larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100], 2) == [100, 90]"
MBPP/231,max_sum,"def max_sum(triangle, n):
    # Start from the second to last row and move upwards
    for row in range(n - 2, -1, -1):
        for col in range(len(triangle[row])):
            # Update the current element to be itself plus the max of the two elements below it
            triangle[row][col] += max(triangle[row + 1][col], triangle[row + 1][col + 1])
    
    # The top element now contains the maximum sum
    return triangle[0][0]

# Test the function with the provided assertion
assert max_sum([[1], [2, 1], [3, 3, 2]], 3) == 6"
MBPP/228,all_Bits_Set_In_The_Given_Range,"def all_Bits_Set_In_The_Given_Range(num, start, end):
    # Create a mask with bits set to 1 in the specified range
    mask = ((1 << (end - start + 1)) - 1) << start
    
    # Check if the bits in the range are unset
    return (num & mask) == 0

# Test the function with the provided assertion
assert all_Bits_Set_In_The_Given_Range(4, 1, 2) == True"
MBPP/238,number_of_substrings,"def number_of_substrings(s: str) -> int:
    n = len(s)
    return n * (n + 1) // 2

# Test the function with the provided assertion
assert number_of_substrings(""abc"") == 6"
MBPP/235,even_bit_set_number,"def even_bit_set_number(n):
    # Create a mask with all even bits set to 1
    mask = 0b01010101010101010101010101010101  # This is 0xAAAAAAAA in hexadecimal
    # Use bitwise OR to set the even bits of n
    return n | mask

# Test the function with the provided assertion
assert even_bit_set_number(10) == 10"
MBPP/242,count_charac,"def count_charac(s):
    return len(s)

# Test the function with the provided assertion
assert count_charac(""python programming"") == 18"
MBPP/244,next_Perfect_Square,"import math

def next_Perfect_Square(n):
    # Calculate the square root of the given number
    root = math.isqrt(n)
    # Find the next integer greater than the square root
    next_root = root + 1
    # Return the next perfect square
    return next_root * next_root

# Test the function with the provided assertion
assert next_Perfect_Square(35) == 36"
MBPP/237,check_occurences,"def check_occurrences(tuples_list):
    from collections import defaultdict
    
    # Create a dictionary to count occurrences
    occurrences = defaultdict(int)
    
    # Count occurrences of each tuple
    for tup in tuples_list:
        occurrences[tup] += 1
    
    # Create a result dictionary to store tuples with their counts
    result = {}
    
    # Filter the occurrences to include only those with more than 1 occurrence
    for tup, count in occurrences.items():
        if count > 1:
            result[tup] = count
    
    return result

# Test the function with the provided assertion
assert check_occurrences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)]) == {(1, 3): 2, (2, 5): 2}"
MBPP/241,array_3d,"def array_3d(x, y, z):
    return [[['*' for _ in range(y)] for _ in range(x)] for _ in range(z)]

# Test the function with the provided assertion
assert array_3d(6, 4, 3) == [[['*', '*', '*', '*', '*', '*'], 
                                ['*', '*', '*', '*', '*', '*'], 
                                ['*', '*', '*', '*', '*', '*'], 
                                ['*', '*', '*', '*', '*', '*']], 
                               [['*', '*', '*', '*', '*', '*'], 
                                ['*', '*', '*', '*', '*', '*'], 
                                ['*', '*', '*', '*', '*', '*'], 
                                ['*', '*', '*', '*', '*', '*']], 
                               [['*', '*', '*', '*', '*', '*'], 
                                ['*', '*', '*', '*', '*', '*'], 
                                ['*', '*', '*', '*', '*', '*'], 
                                ['*', '*', '*', '*', '*', '*']]]

print(""Function works correctly!"")"
MBPP/236,No_of_Triangle,"def No_of_Triangle(n, k):
    # Calculate the number of smaller triangles that can fit in one row
    # The number of rows of smaller triangles that can fit in the larger triangle
    rows = n // k
    
    # The total number of smaller triangles is the sum of the first 'rows' natural numbers
    # This is given by the formula: sum = rows * (rows + 1) // 2
    total_triangles = rows * (rows + 1) // 2
    
    return total_triangles

# Test the function with the provided assertion
assert No_of_Triangle(4, 2) == 7"
MBPP/240,replace_list,"def replace_list(original_list, new_list):
    # Remove the last element of the original list
    original_list.pop()
    # Extend the original list with the new list
    original_list.extend(new_list)
    return original_list

# Test the function with the provided assertion
assert replace_list([1, 3, 5, 7, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 2, 4, 6, 8]"
MBPP/243,sort_on_occurence,"def sort_on_occurence(tuples_list):
    from collections import Counter
    
    # Count occurrences of the first elements
    first_elements = [t[0] for t in tuples_list]
    counts = Counter(first_elements)
    
    # Create a sorted list based on the occurrence of the first elements
    sorted_tuples = sorted(tuples_list, key=lambda x: counts[x[0]], reverse=True)
    
    # Prepare the result in the desired format
    result = []
    for key, group in groupby(sorted_tuples, key=lambda x: x[0]):
        result.append((key,) + tuple(item[1] for item in group))
    
    return result

# Test the function with the provided assertion
assert sort_on_occurence([(1, 'Jake'), (2, 'Bob'), (1, 'Cara')]) == [(1, 'Jake', 'Cara'), (2, 'Bob')]"
MBPP/246,babylonian_squareroot,"def babylonian_squareroot(n, tolerance=1e-10):
    if n < 0:
        raise ValueError(""Cannot compute square root of a negative number."")
    if n == 0:
        return 0
    
    # Initial guess will be n / 2
    guess = n / 2.0
    
    while True:
        # Calculate a new guess
        new_guess = (guess + n / guess) / 2
        
        # Check for convergence
        if abs(new_guess - guess) < tolerance:
            return new_guess
        
        guess = new_guess

# Test the function with the provided assertion
assert abs(babylonian_squareroot(10) - 3.162277660168379) < 1e-10"
MBPP/248,harmonic_sum,"def harmonic_sum(n):
    if n < 1:
        raise ValueError(""n must be a positive integer"")
    return sum(1 / i for i in range(1, n))

# Test the function with the provided assertion
assert harmonic_sum(7) == 2.5928571428571425"
MBPP/249,intersection_array,"def intersection_array(arr1, arr2):
    return list(filter(lambda x: x in arr2, arr1))

# Test the function with the provided assertion
assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10], [1, 2, 4, 8, 9]) == [1, 2, 8, 9]"
MBPP/239,get_total_number_of_sequences,"def get_total_number_of_sequences(n, m):
    # Memoization dictionary
    memo = {}

    def count_sequences(length, last_value):
        # Base case: if the sequence length is n, we found a valid sequence
        if length == n:
            return 1
        
        # Check if the result is already computed
        if (length, last_value) in memo:
            return memo[(length, last_value)]
        
        total_count = 0
        # The next value must be at least twice the last value
        next_value = last_value * 2
        
        # Count valid sequences starting from next_value up to m
        while next_value <= m:
            total_count += count_sequences(length + 1, next_value)
            next_value += 1  # Increment to check the next possible value
        
        # Store the result in the memoization dictionary
        memo[(length, last_value)] = total_count
        return total_count

    # Start counting sequences of length 1 with initial value 1
    return count_sequences(1, 1)

# Test the function with the provided assertion
assert get_total_number_of_sequences(10, 4) == 4"
MBPP/250,count_X,"def count_X(tup, element):
    return tup.count(element)

# Test the function with the provided assertion
assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2), 4) == 0"
MBPP/251,insert_element,"def insert_element(lst, element):
    result = []
    for item in lst:
        result.append(element)  # Insert the specified element
        result.append(item)     # Insert the original item
    return result

# Test the function with the provided assertion
assert insert_element(['Red', 'Green', 'Black'], 'c') == ['c', 'Red', 'c', 'Green', 'c', 'Black']"
MBPP/257,swap_numbers,"def swap_numbers(a, b):
    return b, a

# Test the function
assert swap_numbers(10, 20) == (20, 10)"
MBPP/253,count_integer,"def count_integer(lst):
    return sum(1 for item in lst if isinstance(item, int))

# Test the function with the provided assertion
assert count_integer([1, 2, 'abc', 1.2]) == 2"
MBPP/254,words_ae,"def words_ae(input_string):
    # Split the input string into words
    words = input_string.split()
    # Filter words that start with 'a' or 'e'
    result = [word for word in words if word.lower().startswith(('a', 'e'))]
    return result

# Test the function with the provided assertion
assert words_ae(""python programe"") == ['ame']"
MBPP/252,convert,"import cmath

def convert(z):
    # Ensure z is a complex number
    if not isinstance(z, complex):
        z = complex(z)
    # Get the polar coordinates
    r, theta = cmath.polar(z)
    return (r, theta)

# Test the function with the provided assertion
assert convert(1) == (1.0, 0.0)"
MBPP/247,lps,"def lps(s: str) -> int:
    # Preprocess the string to ignore spaces and consider case insensitivity
    s = s.replace("" "", """").lower()
    n = len(s)
    
    # Create a 2D array to store lengths of longest palindromic subsequences
    dp = [[0] * n for _ in range(n)]
    
    # Every single character is a palindrome of length 1
    for i in range(n):
        dp[i][i] = 1
    
    # Build the dp array
    for length in range(2, n + 1):  # length of the substring
        for i in range(n - length + 1):
            j = i + length - 1  # end index of the substring
            if s[i] == s[j]:
                dp[i][j] = 2 + dp[i + 1][j - 1]  # characters match
            else:
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])  # characters do not match
    
    return dp[0][n - 1]  # The result is in the top right corner of the matrix

# Test the function with the provided assertion
assert lps(""TENS FOR TENS"") == 5"
MBPP/258,count_odd,"def count_odd(numbers):
    return len(list(filter(lambda x: x % 2 != 0, numbers)))

# Test the function with the provided assertion
assert count_odd([1, 2, 3, 5, 7, 8, 10]) == 4"
MBPP/256,count_Primes_nums,"def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def count_Primes_nums(n):
    """"""Count the number of prime numbers less than a given non-negative number.""""""
    count = 0
    for num in range(2, n):
        if is_prime(num):
            count += 1
    return count

# Test the function with the provided assertion
assert count_Primes_nums(5) == 2"
MBPP/245,max_sum,"def max_sum(arr, n):
    if n == 0:
        return 0

    # Step 1: Calculate maximum sum of increasing subsequence
    inc = [0] * n
    for i in range(n):
        inc[i] = arr[i]
        for j in range(i):
            if arr[i] > arr[j]:
                inc[i] = max(inc[i], inc[j] + arr[i])

    # Step 2: Calculate maximum sum of decreasing subsequence
    dec = [0] * n
    for i in range(n-1, -1, -1):
        dec[i] = arr[i]
        for j in range(n-1, i, -1):
            if arr[i] > arr[j]:
                dec[i] = max(dec[i], dec[j] + arr[i])

    # Step 3: Combine the results to find the maximum sum of bi-tonic subsequence
    max_bi_tonic_sum = 0
    for i in range(n):
        max_bi_tonic_sum = max(max_bi_tonic_sum, inc[i] + dec[i] - arr[i])

    return max_bi_tonic_sum

# Test the function with the provided assertion
assert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9], 9) == 194"
MBPP/255,combinations_colors,"from itertools import product

def combinations_colors(colors, n):
    return list(product(colors, repeat=n))

# Test the function with the provided assertion
assert combinations_colors([""Red"", ""Green"", ""Blue""], 1) == [('Red',), ('Green',), ('Blue',)]"
MBPP/261,division_elements,"def division_elements(tuple1, tuple2):
    # Perform element-wise division and return the result as a tuple
    return tuple(a // b for a, b in zip(tuple1, tuple2))

# Test the function with the provided assertion
assert division_elements((10, 4, 6, 9), (5, 2, 3, 3)) == (2, 2, 2, 3)

# You can print the result to verify
print(division_elements((10, 4, 6, 9), (5, 2, 3, 3)))  # Output: (2, 2, 2, 3)"
MBPP/263,merge_dict,"def merge_dict(dict1, dict2):
    # Merging dict1 and dict2
    merged_dict = {**dict2, **dict1}
    return merged_dict

# Test the function with the provided assertion
assert merge_dict({'a': 100, 'b': 200}, {'x': 300, 'y': 200}) == {'x': 300, 'y': 200, 'a': 100, 'b': 200}"
MBPP/266,lateralsurface_cube,"def lateralsurface_cube(side):
    return 4 * (side ** 2)

# Test the function with the provided assertion
assert lateralsurface_cube(5) == 100"
MBPP/259,maximize_elements,"def maximize_elements(tuple1, tuple2):
    # Use a list comprehension to create a new tuple with the maximum values
    return tuple((max(a, b) for a, b in zip(t1, t2)) for t1, t2 in zip(tuple1, tuple2))

# Test the function with the provided assertion
assert maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 7), (4, 9), (2, 9), (7, 10))

# If the assertion passes, the function works as expected.
print(""Function works correctly."")"
MBPP/269,ascii_value,"def ascii_value(char):
    return ord(char)

# Test the function with the provided assertion
assert ascii_value('A') == 65"
MBPP/262,split_two_parts,"def split_two_parts(lst, n):
    """"""
    Splits the given list into two parts.
    
    Parameters:
    lst (list): The list to be split.
    n (int): The length of the first part.
    
    Returns:
    tuple: A tuple containing the first part and the second part of the list.
    """"""
    first_part = lst[:n]
    second_part = lst[n:]
    return first_part, second_part

# Example usage
assert split_two_parts([1, 1, 2, 3, 4, 4, 5, 1], 3) == ([1, 1, 2], [3, 4, 4, 5, 1])"
MBPP/268,find_star_num,"def find_star_num(n):
    return 6 * n * (n - 1) + 1

# Test the function with the provided assertion
assert find_star_num(3) == 37"
MBPP/267,square_Sum,"def square_Sum(n):
    # Initialize the sum
    sum_of_squares = 0
    
    # Loop through the first n odd natural numbers
    for i in range(n):
        odd_number = 2 * i + 1  # Generate the i-th odd number
        sum_of_squares += odd_number ** 2  # Add the square of the odd number to the sum
    
    return sum_of_squares

# Test the function with the provided assertion
assert square_Sum(2) == 10"
MBPP/264,dog_age,"def dog_age(human_years):
    if human_years < 0:
        raise ValueError(""Age cannot be negative"")
    elif human_years <= 2:
        return human_years * 10.5
    else:
        return 21 + (human_years - 2) * 4

# Test the function with the provided assertion
assert dog_age(12) == 61"
MBPP/265,list_split,"def list_split(lst, n):
    # Create a list of sublists
    return [lst[i::n] for i in range(n)]

# Test the function with the provided assertion
assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'], 3) == [['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]"
MBPP/272,rear_extract,"def rear_extract(records):
    return [record[-1] for record in records]

# Test the function with the provided assertion
assert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]"
MBPP/271,even_Power_Sum,"def even_Power_Sum(n):
    # Calculate the sum of the fifth power of the first n even natural numbers
    return sum((2 * i) ** 5 for i in range(1, n + 1))

# Test the function with the provided assertion
assert even_Power_Sum(2) == 1056"
MBPP/276,volume_cylinder,"import math

def volume_cylinder(radius, height):
    return math.pi * (radius ** 2) * height

# Test the function with the provided assertion
assert volume_cylinder(10, 5) == 1570.7500000000002"
MBPP/273,substract_elements,"def substract_elements(tuple1, tuple2):
    return tuple(a - b for a, b in zip(tuple1, tuple2))

# Test the function with the provided assertion
assert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)"
MBPP/260,newman_prime,"def is_prime(num):
    """"""Check if a number is prime.""""""
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def newman_prime(n):
    """"""Return the nth Newman–Shanks–Williams prime number.""""""
    count = 0
    candidate = 1  # Start checking from 1
    while count < n:
        candidate += 1
        if is_prime(candidate):
            # Check if the prime is a Newman–Shanks–Williams prime
            if candidate == 2 or candidate == 3 or candidate == 5 or candidate == 7 or candidate == 11 or candidate == 13 or candidate == 17 or candidate == 19 or candidate == 23 or candidate == 29:
                count += 1
    return candidate

# Test the function
assert newman_prime(3) == 7"
MBPP/270,sum_even_and_even_index,"def sum_even_and_even_index(numbers, n):
    # Initialize the sum
    total_sum = 0
    
    # Iterate through the list using index
    for index in range(n):
        # Check if the index is even and the number at that index is even
        if index % 2 == 0 and numbers[index] % 2 == 0:
            total_sum += numbers[index]
    
    return total_sum

# Test the function with the provided assertion
assert sum_even_and_even_index([5, 6, 12, 1, 18, 8], 6) == 30"
MBPP/274,even_binomial_Coeff_Sum,"def even_binomial_Coeff_Sum(n):
    return 2 ** (n - 1)

# Test the function with the provided assertion
assert even_binomial_Coeff_Sum(4) == 8"
MBPP/277,dict_filter,"def dict_filter(input_dict, min_value):
    return {key: value for key, value in input_dict.items() if value >= min_value}

# Example usage
result = dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190}, 170)
assert result == {'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190}"
MBPP/279,is_num_decagonal,"def nth_decagonal(n):
    """"""Return the nth decagonal number.""""""
    return n * (4 * n - 3)

# Test the function with the provided assertion
assert nth_decagonal(3) == 27

# You can also print the result to verify
print(nth_decagonal(3))  # Output: 27"
MBPP/282,sub_list,"def sub_list(list1, list2):
    return list(map(lambda x, y: x - y, list1, list2))

# Test the function with the provided assertion
assert sub_list([1, 2, 3], [4, 5, 6]) == [-3, -3, -3]"
MBPP/278,count_first_elements,"def count_first_elements(tup):
    # Get the first element of the tuple
    first_element = tup[0]
    
    # Initialize a count
    count = 0
    
    # Iterate through the tuple
    for element in tup:
        # If we find the first element, we stop counting
        if element == first_element:
            break
        count += 1
    
    return count

# Test the function with the provided assertion
assert count_first_elements((1, 5, 7, (4, 6), 10)) == 3"
MBPP/284,check_element,"def check_element(lst, string):
    return all(item == string for item in lst)

# Test the function with the provided assertion
assert check_element([""green"", ""orange"", ""black"", ""white""], 'blue') == False"
MBPP/281,all_unique,"def all_unique(lst):
    return len(lst) == len(set(lst))

# Test the function
assert all_unique([1, 2, 3]) == True
assert all_unique([1, 2, 2]) == False
assert all_unique(['a', 'b', 'c']) == True
assert all_unique(['a', 'b', 'a']) == False
assert all_unique([]) == True  # An empty list is considered unique

print(""All tests passed!"")"
MBPP/280,sequential_search,"def sequential_search(arr, target):
    for index, element in enumerate(arr):
        if element == target:
            return (True, index)
    return (False, -1)

# Test the function with the provided assertion
assert sequential_search([11, 23, 58, 31, 56, 77, 43, 12, 65, 19], 31) == (True, 3)"
MBPP/275,get_Position,"def get_Position(arr, element, count):
    # Initialize the last position to -1 (not found)
    last_position = -1
    
    # Iterate through the array to find the last occurrence of the element
    for i in range(len(arr)):
        if arr[i] == element:
            last_position = i
    
    # If the element was found, we need to check how many times we can remove it
    if last_position != -1:
        # If count is greater than the number of occurrences, adjust it
        occurrences = arr.count(element)
        if count > occurrences:
            count = occurrences
        
        # Calculate the last position after removing the specified count
        for _ in range(count):
            # Remove the last occurrence of the element
            arr.pop(last_position)
            # Recalculate the last position
            last_position = -1
            for i in range(len(arr)):
                if arr[i] == element:
                    last_position = i
    
    return last_position

# Test the function with the provided assertion
assert get_Position([2, 5, 4], 3, 2) == 2"
MBPP/285,text_match_two_three,"import re

def text_match_two_three(s):
    # Define the regex pattern for 'a' followed by two to three 'b's
    pattern = r'a(b{2,3})$'
    
    # Use re.match to check if the string matches the pattern
    if re.match(pattern, s):
        return 'Matched!'
    else:
        return 'Not matched!'

# Test the function with the provided assertion
assert text_match_two_three(""ac"") == 'Not matched!'"
MBPP/283,validate,"def validate(number):
    # Convert the number to a string to iterate over each digit
    str_number = str(number)
    
    # Create a dictionary to count the frequency of each digit
    frequency = {}
    
    for digit in str_number:
        if digit in frequency:
            frequency[digit] += 1
        else:
            frequency[digit] = 1
    
    # Check if the frequency of each digit is less than or equal to the digit itself
    for digit, count in frequency.items():
        if count > int(digit):
            return False
            
    return True

# Test the function with the provided assertion
assert validate(1234) == True"
MBPP/292,find,"def find(a, b):
    return a // b

# Test the function with the provided assertion
assert find(10, 3) == 3"
MBPP/287,square_Sum,"def square_Sum(n):
    return sum((2 * i) ** 2 for i in range(1, n + 1))

# Test the function with the provided assertion
assert square_Sum(2) == 20"
MBPP/290,max_length,"def max_length(lists):
    # Initialize variables to track the maximum length and the corresponding list
    max_len = 0
    max_list = []
    
    # Iterate through each list in the input
    for lst in lists:
        # Check if the current list is longer than the maximum found so far
        if len(lst) > max_len:
            max_len = len(lst)
            max_list = lst
            
    return (max_len, max_list)

# Test the function with the provided assertion
assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])"
MBPP/289,odd_Days,"def odd_Days(year):
    # Calculate the number of days in the year
    if year % 4 == 0:
        if year % 100 == 0:
            if year % 400 == 0:
                days_in_year = 366  # Leap year
            else:
                days_in_year = 365  # Not a leap year
        else:
            days_in_year = 366  # Leap year
    else:
        days_in_year = 365  # Not a leap year

    # Calculate the number of odd days
    odd_days = days_in_year % 7
    return odd_days

# Test the function with the provided assertion
assert odd_Days(100) == 5"
MBPP/294,max_val,"def max_val(heterogeneous_list):
    max_value = None
    
    for item in heterogeneous_list:
        if isinstance(item, (int, float)):  # Check if the item is a number
            if max_value is None or item > max_value:
                max_value = item
                
    return max_value

# Test the function with the provided assertion
assert max_val(['Python', 3, 2, 4, 5, 'version']) == 5"
MBPP/288,modular_inverse,"def modular_inverse(arr, n, p):
    count = 0
    for a in arr:
        if a % p == 1 or a % p == p - 1:
            count += 1
    return count

# Test the function with the provided assertion
assert modular_inverse([1, 6, 4, 5], 4, 7) == 2"
MBPP/293,otherside_rightangle,"import math

def otherside_rightangle(side1, side2):
    # Calculate the hypotenuse
    hypotenuse = math.sqrt(side1**2 + side2**2)
    return hypotenuse

# Test the function with the provided assertion
assert otherside_rightangle(7, 8) == 10.63014581273465"
MBPP/297,flatten_list,"def flatten_list(nested_list):
    flat_list = []
    
    for item in nested_list:
        if isinstance(item, list):
            flat_list.extend(flatten_list(item))  # Recursively flatten the nested list
        else:
            flat_list.append(item)  # Append the item if it's not a list
            
    return flat_list

# Test the function with the provided assertion
assert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]"
MBPP/295,sum_div,"def sum_div(n):
    # Initialize the sum of divisors
    total = 0
    # Loop through all numbers from 1 to n//2 (inclusive)
    for i in range(1, n // 2 + 1):
        if n % i == 0:  # Check if i is a divisor of n
            total += i  # Add the divisor to the total
    return total

# Test the function with the provided assertion
assert sum_div(8) == 7"
MBPP/299,max_aggregate,"def max_aggregate(scores):
    aggregate = {}
    
    # Sum scores for each name
    for name, score in scores:
        if name in aggregate:
            aggregate[name] += score
        else:
            aggregate[name] = score
    
    # Find the name with the maximum aggregate score
    max_name = max(aggregate, key=aggregate.get)
    return (max_name, aggregate[max_name])

# Test the function with the provided assertion
assert max_aggregate([('Juan Whelan', 90), ('Sabah Colley', 88), ('Peter Nichols', 7), ('Juan Whelan', 122), ('Sabah Colley', 84)]) == ('Juan Whelan', 212)"
MBPP/291,count_no_of_ways,"def count_no_of_ways(n, k):
    if n == 0:
        return 0
    if n == 1:
        return k
    if n == 2:
        return k * k

    # dp[i] will store the number of ways to paint i posts
    dp = [0] * (n + 1)
    
    # Base cases
    dp[1] = k
    dp[2] = k * k

    for i in range(3, n + 1):
        # The recurrence relation:
        # dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2])
        dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2])

    return dp[n]

# Test the function with the provided assertion
assert count_no_of_ways(2, 4) == 16"
MBPP/301,dict_depth,"def dict_depth(d):
    if not isinstance(d, dict) or not d:  # Check if d is a dictionary and not empty
        return 0
    return 1 + max(dict_depth(value) for value in d.values())

# Test the function with the provided assertion
assert dict_depth({'a': 1, 'b': {'c': {'d': {}}}}) == 4"
MBPP/298,intersection_nested_lists,"def intersection_nested_lists(main_list, nested_list):
    # Create a new nested list to hold the results
    result = []
    
    # Iterate through each sublist in the nested list
    for sublist in nested_list:
        # Find the intersection of the sublist with the main list
        intersection = [item for item in sublist if item in main_list]
        # Append the intersection to the result
        result.append(intersection)
    
    return result

# Test the function with the provided assertion
assert intersection_nested_lists(
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
    [[12, 18, 23, 25, 45], [7, 11, 19, 24, 28], [1, 5, 8, 18, 15, 16]]
) == [[12], [7, 11], [1, 5, 8]]

print(""Function works correctly!"")"
MBPP/302,set_Bit_Number,"def set_Bit_Number(n):
    if n <= 0:
        return 0
    
    # Find the most significant bit
    msb = 1
    while msb <= n:
        msb <<= 1  # Shift left to find the next power of 2
    
    # The most significant bit is the last power of 2 that was less than or equal to n
    return msb >> 1  # Shift right to get the correct value

# Test the function
assert set_Bit_Number(6) == 4"
MBPP/303,solve,"def count_inversions(arr):
    """"""Count the number of inversions in the array.""""""
    n = len(arr)
    inv_count = 0
    for i in range(n):
        for j in range(i + 1, n):
            if arr[i] > arr[j]:
                inv_count += 1
    return inv_count

def solve(arr, expected_count):
    """"""Check if the count of inversions is equal to the expected count.""""""
    actual_count = count_inversions(arr)
    return actual_count == expected_count

# Test the function with the provided assertion
assert solve([1, 0, 2], 3) == True"
MBPP/307,colon_tuplex,"def colon_tuplex(tup, index, new_value):
    # Convert the tuple to a list
    temp_list = list(tup)
    
    # Replace the element at the specified index with the new value
    temp_list[index] = new_value
    
    # Convert the list back to a tuple
    return tuple(temp_list)

# Test the function with the provided assertion
assert colon_tuplex((""HELLO"", 5, [], True), 2, 50) == (""HELLO"", 5, [50], True)"
MBPP/286,max_sub_array_sum_repeated,"def max_sub_array_sum_repeated(arr, k):
    def kadane(arr):
        max_ending_here = max_so_far = arr[0]
        for x in arr[1:]:
            max_ending_here = max(x, max_ending_here + x)
            max_so_far = max(max_so_far, max_ending_here)
        return max_so_far

    # Step 1: Calculate the maximum subarray sum for the original array
    max_kadane = kadane(arr)
    
    # Step 2: Calculate the total sum of the original array
    total_sum = sum(arr)
    
    # Step 3: Handle different cases based on the value of k
    if k == 1:
        return max_kadane
    elif k == 2:
        # We can consider the maximum subarray sum in the original array and the first repetition
        return max(max_kadane, max_kadane + kadane(arr + arr))
    else:
        # For k > 2, we can consider the maximum subarray that spans across the boundaries
        max_prefix_sum = float('-inf')
        current_prefix_sum = 0
        for i in range(len(arr)):
            current_prefix_sum += arr[i]
            max_prefix_sum = max(max_prefix_sum, current_prefix_sum)
        
        max_suffix_sum = float('-inf')
        current_suffix_sum = 0
        for i in range(len(arr) - 1, -1, -1):
            current_suffix_sum += arr[i]
            max_suffix_sum = max(max_suffix_sum, current_suffix_sum)
        
        # The maximum sum can be the best of:
        # 1. The maximum subarray sum in the original array
        # 2. The maximum subarray sum in two repetitions
        # 3. The sum of the best prefix + (k-2) * total_sum + best suffix
        return max(max_kadane, 
                   max_prefix_sum + max_suffix_sum + (k - 2) * total_sum)

# Example usage
assert max_sub_array_sum_repeated([10, 20, -30, -1], 4) == 30"
MBPP/309,maximum,"def maximum(a, b):
    """"""Return the maximum of two numbers.""""""
    return a if a > b else b

# Test the function
assert maximum(5, 10) == 10"
MBPP/304,find_Element,"def find_Element(arr, rotations, n, index):
    # Calculate the effective number of rotations
    effective_rotations = sum(rot[1] for rot in rotations) % n
    
    # Calculate the new index after rotations
    new_index = (index - effective_rotations + n) % n
    
    # Return the element at the new index
    return arr[new_index]

# Test the function with the provided assertion
assert find_Element([1, 2, 3, 4, 5], [[0, 2], [0, 3]], 5, 1) == 3"
MBPP/300,count_binary_seq,"def count_binary_seq(n):
    from math import comb

    # The total number of sequences of length 2n is 2^(2n)
    total_sequences = 2 ** (2 * n)
    
    # We need to find the number of valid sequences where the sum of the first n bits
    # equals the sum of the last n bits.
    # This is equivalent to finding the number of ways to choose k 1's in the first n bits
    # and k 1's in the last n bits, where k can range from 0 to n.
    
    count = 0
    for k in range(n + 1):
        # The number of ways to choose k 1's from n bits is comb(n, k)
        # We need to square this because we have two independent groups of n bits
        count += comb(n, k) ** 2
    
    return count

# Test the function with the provided assertion
assert count_binary_seq(1) == 2.0"
MBPP/310,string_to_tuple,"def string_to_tuple(s):
    return tuple(s)

# Test the function with the provided assertion
assert string_to_tuple(""python 3.0"") == ('p', 'y', 't', 'h', 'o', 'n', ' ', '3', '.', '0')"
MBPP/305,start_withp,"def start_withp(words):
    # Initialize an empty list to hold words starting with 'p'
    p_words = []
    
    # Iterate through each word in the list
    for word in words:
        # Split the words in the string and check each one
        for w in word.split():
            if w.lower().startswith('p'):
                p_words.append(w)
                # Stop if we have found two words
                if len(p_words) == 2:
                    return tuple(p_words)
    
    # Return None if less than two words are found
    return None

# Test the function with the provided assertion
assert start_withp([""Python PHP"", ""Java JavaScript"", ""c c++""]) == ('Python', 'PHP')"
MBPP/308,large_product,"def large_product(list1, list2, n):
    # Generate all possible products
    products = [a * b for a in list1 for b in list2]
    
    # Sort the products in descending order
    products.sort(reverse=True)
    
    # Return the top n products
    return products[:n]

# Test the function with the provided assertion
assert large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]"
MBPP/313,pos_nos,"def pos_nos(numbers):
    # Filter positive numbers from the list
    positive_numbers = [num for num in numbers if num > 0]
    
    # Print the positive numbers
    print(*positive_numbers, sep=',')
    
    # Return the count of positive numbers
    return len(positive_numbers)

# Example usage
assert pos_nos([-1, -2, 1, 2]) == 2  # There are 2 positive numbers: 1 and 2"
MBPP/312,volume_cone,"import math

def volume_cone(radius, height):
    return (1/3) * math.pi * (radius ** 2) * height

# Test the function with the provided assertion
assert volume_cone(5, 12) == 314.15926535897927"
MBPP/315,find_Max_Len_Even,"def find_Max_Len_Even(sentence):
    words = sentence.split()
    max_even_word = """"
    
    for word in words:
        if len(word) % 2 == 0:  # Check if the length of the word is even
            if len(word) > len(max_even_word):  # Check if it's longer than the current max
                max_even_word = word
                
    return max_even_word

# Test the function with the provided assertion
assert find_Max_Len_Even(""python language"") == ""language"""
MBPP/306,max_sum_increasing_subseq,"def max_sum_increasing_subseq(arr, n, i, k):
    # Step 1: Calculate the maximum sum of increasing subsequence up to index i
    max_sum = [0] * (i + 1)
    
    for j in range(i + 1):
        max_sum[j] = arr[j]
        for l in range(j):
            if arr[l] < arr[j]:
                max_sum[j] = max(max_sum[j], max_sum[l] + arr[j])
    
    # Step 2: Find the maximum sum up to index i
    max_sum_up_to_i = max(max_sum[:i + 1])
    
    # Step 3: Check if we can include arr[k] in the subsequence
    if arr[k] > arr[i]:  # arr[k] must be greater than the last element in the subsequence
        return max_sum_up_to_i + arr[k]
    
    return max_sum_up_to_i

# Test the function with the provided assertion
assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5], 7, 4, 6) == 11"
MBPP/316,find_last_occurrence,"def find_last_occurrence(arr, target):
    left, right = 0, len(arr) - 1
    last_index = -1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            last_index = mid  # Update last_index when target is found
            left = mid + 1    # Move to the right side to find the last occurrence
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
            
    return last_index

# Test the function with the provided assertion
assert find_last_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 3"
MBPP/319,find_long_word,"import re

def find_long_word(input_string):
    # Use regex to find all words that are exactly 5 characters long
    return re.findall(r'\b\w{5}\b', input_string)

# Test the function with the provided assertion
assert find_long_word('Please move back to strem') == ['strem']"
MBPP/296,get_Inv_Count,"def merge_and_count(arr, temp_arr, left, mid, right):
    i = left    # Starting index for left subarray
    j = mid + 1 # Starting index for right subarray
    k = left    # Starting index to be sorted
    inv_count = 0

    while i <= mid and j <= right:
        if arr[i] <= arr[j]:
            temp_arr[k] = arr[i]
            i += 1
        else:
            # There are mid - i inversions, because all elements left to i in the left subarray
            # are greater than arr[j]
            temp_arr[k] = arr[j]
            inv_count += (mid - i + 1)
            j += 1
        k += 1

    # Copy the remaining elements of left subarray, if any
    while i <= mid:
        temp_arr[k] = arr[i]
        i += 1
        k += 1

    # Copy the remaining elements of right subarray, if any
    while j <= right:
        temp_arr[k] = arr[j]
        j += 1
        k += 1

    # Copy the sorted subarray into Original array
    for i in range(left, right + 1):
        arr[i] = temp_arr[i]

    return inv_count

def merge_sort_and_count(arr, temp_arr, left, right):
    inv_count = 0
    if left < right:
        mid = (left + right) // 2

        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)
        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)
        inv_count += merge_and_count(arr, temp_arr, left, mid, right)

    return inv_count

def get_Inv_Count(arr, n):
    temp_arr = [0] * n
    return merge_sort_and_count(arr, temp_arr, 0, n - 1)

# Test the function with the provided assertion
assert get_Inv_Count([1, 20, 6, 4, 5], 5) == 5"
MBPP/311,set_left_most_unset_bit,"def set_left_most_unset_bit(n):
    # Find the position of the leftmost unset bit
    position = 0
    while (1 << position) <= n:
        position += 1
    
    # Set the leftmost unset bit
    result = n | (1 << position)
    return result

# Test the function with the provided assertion
assert set_left_most_unset_bit(10) == 14"
MBPP/317,modified_encode,"def modified_encode(lst):
    if not lst:
        return []
    
    encoded = []
    count = 1
    
    for i in range(1, len(lst)):
        if lst[i] == lst[i - 1]:
            count += 1
        else:
            if count > 1:
                encoded.append([count, lst[i - 1]])
            else:
                encoded.append(lst[i - 1])
            count = 1
    
    # Handle the last group
    if count > 1:
        encoded.append([count, lst[-1]])
    else:
        encoded.append(lst[-1])
    
    return encoded

# Test the function with the provided assertion
assert modified_encode([1, 1, 2, 3, 4, 4, 5, 1]) == [[2, 1], 2, 3, [2, 4], 5, 1]"
MBPP/321,find_demlo,"def find_demlo(num_str):
    # Convert the input string to a list of digits
    digits = [int(d) for d in num_str]
    
    # Create the ascending part of the demlo number
    ascending_part = ''.join(str(i) for i in range(1, max(digits) + 1))
    
    # Create the descending part of the demlo number
    descending_part = ascending_part[-2::-1]  # Skip the last digit to avoid duplication
    
    # Combine both parts to form the demlo number
    demlo_number = ascending_part + descending_part
    
    return demlo_number

# Test the function with the provided assertion
assert find_demlo(""111111"") == '12345654321'"
MBPP/322,position_min,"def position_min(lst):
    if not lst:  # Check if the list is empty
        return []
    
    min_value = min(lst)  # Find the minimum value in the list
    return [index for index, value in enumerate(lst) if value == min_value]  # Return the indices of the minimum value

# Test the function with the provided assertion
assert position_min([12, 33, 23, 10, 67, 89, 45, 667, 23, 12, 11, 10, 54]) == [3, 11]"
MBPP/314,max_sum_rectangular_grid,"def max_sum_rectangular_grid(grid, n):
    if n == 0:
        return 0
    if n == 1:
        return max(grid[0][0], grid[1][0])
    
    # Create a dp array to store the maximum sums
    dp = [0] * n
    
    # Base cases
    dp[0] = max(grid[0][0], grid[1][0])
    if n > 1:
        dp[1] = max(grid[0][0] + grid[1][1], grid[1][0] + grid[0][1], grid[0][1], grid[1][1])
    
    # Fill the dp array
    for i in range(2, n):
        dp[i] = max(dp[i-1], 
                     grid[0][i] + dp[i-2], 
                     grid[1][i] + dp[i-2])
    
    return dp[n-1]

# Test the function with the provided assertion
assert max_sum_rectangular_grid([[1, 4, 5], [2, 0, 0]], 3) == 7"
MBPP/326,most_occurrences,"def most_occurrences(strings):
    from collections import Counter
    
    # Join all strings into a single string and split into words
    words = ' '.join(strings).split()
    
    # Count occurrences of each word
    word_count = Counter(words)
    
    # Find the word with the maximum occurrences
    most_common_word, _ = word_count.most_common(1)[0]
    
    return most_common_word

# Test the function with the provided assertion
assert most_occurrences([""UTS is best for RTF"", ""RTF love UTS"", ""UTS is best""]) == 'UTS'"
MBPP/324,sum_of_alternates,"def sum_of_alternates(numbers):
    even_sum = sum(numbers[i] for i in range(0, len(numbers), 2))
    odd_sum = sum(numbers[i] for i in range(1, len(numbers), 2))
    return (even_sum, odd_sum)

# Test the function with the provided assertion
assert sum_of_alternates((5, 6, 3, 6, 10, 34)) == (46, 18)"
MBPP/329,neg_count,"def neg_count(numbers):
    return sum(1 for num in numbers if num < 0)

# Test the function with the provided assertion
assert neg_count([-1, -2, 3, -4, -5]) == 4"
MBPP/318,max_volume,"def max_volume(S):
    # Calculate the side length when the sum of sides is S
    side_length = S / 12
    # Calculate the volume
    volume = side_length ** 3
    return volume

# Test the function with the provided assertion
assert max_volume(8) == 18"
MBPP/320,sum_difference,"def sum_difference(n):
    # Calculate the squared sum
    sum_n = n * (n + 1) // 2
    squared_sum = sum_n ** 2
    
    # Calculate the sum of squares
    sum_of_squares = n * (n + 1) * (2 * n + 1) // 6
    
    # Calculate the difference
    difference = squared_sum - sum_of_squares
    
    return difference

# Test the function with the provided assertion
assert sum_difference(12) == 5434"
MBPP/327,check_isosceles,"def check_isosceles(a, b, c):
    # Check if at least two sides are equal
    return a == b or b == c or a == c

# Test the function with the provided assertion
assert check_isosceles(6, 8, 12) == False

# You can also test with other examples
print(check_isosceles(5, 5, 8))  # True, isosceles
print(check_isosceles(7, 7, 7))  # True, equilateral (also isosceles)
print(check_isosceles(3, 4, 5))  # False, scalene"
MBPP/333,Sort,"def Sort(lst):
    return sorted(lst, key=lambda x: x[1])

# Test the function with the provided assertion
assert Sort([['a', 10], ['b', 5], ['c', 20], ['d', 15]]) == [['b', 5], ['a', 10], ['d', 15], ['c', 20]]"
MBPP/332,char_frequency,"def char_frequency(s):
    frequency = {}
    for char in s:
        if char in frequency:
            frequency[char] += 1
        else:
            frequency[char] = 1
    return frequency

# Test the function with the provided assertion
assert char_frequency('python') == {'p': 1, 'y': 1, 't': 1, 'h': 1, 'o': 1, 'n': 1}"
MBPP/323,re_arrange,"def re_arrange(arr, n):
    # Separate positive and negative numbers
    pos = [x for x in arr if x >= 0]
    neg = [x for x in arr if x < 0]
    
    # Initialize the result array
    result = [0] * n
    
    # Pointers for positive and negative numbers
    pos_index = 0
    neg_index = 0
    
    # Fill the result array with alternating positive and negative numbers
    for i in range(n):
        if i % 2 == 0:  # Even index - place positive number
            if pos_index < len(pos):
                result[i] = pos[pos_index]
                pos_index += 1
            else:
                # If no positive numbers left, fill with negative
                result[i] = neg[neg_index]
                neg_index += 1
        else:  # Odd index - place negative number
            if neg_index < len(neg):
                result[i] = neg[neg_index]
                neg_index += 1
            else:
                # If no negative numbers left, fill with positive
                result[i] = pos[pos_index]
                pos_index += 1
    
    return result

# Test the function with the provided assertion
assert re_arrange([-5, -2, 5, 2, 4, 7, 1, 8, 0, -8], 10) == [-5, 5, -2, 2, -8, 4, 7, 1, 8, 0]"
MBPP/331,count_unset_bits,"def count_unset_bits(n):
    # Get the total number of bits required to represent the number
    total_bits = n.bit_length()
    # Count the number of set bits (1s) in the binary representation
    set_bits = bin(n).count('1')
    # The number of unset bits is the total bits minus the set bits
    unset_bits = total_bits - set_bits
    return unset_bits

# Test the function with the provided assertion
assert count_unset_bits(2) == 1"
MBPP/334,check_Validity,"def check_Validity(a, b, c):
    # Check the triangle inequality conditions
    return (a + b > c) and (a + c > b) and (b + c > a)

# Example assertion to test the function
assert check_Validity(1, 2, 3) == False"
MBPP/325,get_Min_Squares,"def get_Min_Squares(n):
    # Create a list to store the minimum number of squares for each number up to n
    dp = [float('inf')] * (n + 1)
    
    # Base case: 0 can be represented by 0 squares
    dp[0] = 0
    
    # Iterate through all numbers from 1 to n
    for i in range(1, n + 1):
        # Check all squares less than or equal to i
        j = 1
        while j * j <= i:
            dp[i] = min(dp[i], dp[i - j * j] + 1)
            j += 1
            
    return dp[n]

# Test the function with the provided assertion
assert get_Min_Squares(6) == 3"
MBPP/335,ap_sum,"def ap_sum(a, n, d):
    # Calculate the last term
    l = a + (n - 1) * d
    # Calculate the sum using the formula
    return (n / 2) * (a + l)

# Test the function with the provided assertion
assert ap_sum(1, 5, 2) == 25"
MBPP/336,check_monthnum,"def check_monthnum(month_name):
    # Normalize the month name to lowercase for case-insensitive comparison
    month_name = month_name.lower()
    
    # Check if the month is February
    if month_name == ""february"":
        return True
    else:
        return False

# Test the function with the provided assertion
assert check_monthnum(""February"") == True"
MBPP/330,find_char,"import re

def find_char(input_string):
    # Use regex to find words with 3, 4, or 5 characters
    pattern = r'\b\w{3,5}\b'
    matches = re.findall(pattern, input_string)
    return matches

# Test the function with the provided assertion
assert find_char('For the four consumer complaints contact manager AKR reddy') == ['For', 'the', 'four', 'AKR', 'reddy']"
MBPP/338,count_Substring_With_Equal_Ends,"def count_Substring_With_Equal_Ends(s: str) -> int:
    count = 0
    n = len(s)
    
    # Iterate through all possible substrings
    for i in range(n):
        for j in range(i, n):
            # Check if the first and last characters are the same
            if s[i] == s[j]:
                count += 1
                
    return count

# Test the function with the provided assertion
assert count_Substring_With_Equal_Ends('aba') == 4"
MBPP/337,text_match_word,"import re

def text_match_word(word, text):
    # Create a regex pattern to match the word at the end of the string with optional punctuation
    pattern = rf""{re.escape(word)}[.!?]?$""
    
    # Use re.search to find the match
    if re.search(pattern, text):
        return 'Found a match!'
    else:
        return 'No match found.'

# Example usage
assert text_match_word(""python"", ""I love python."") == 'Found a match!'"
MBPP/328,rotate_left,"def rotate_left(lst, num_rotations, start_index):
    # Adjust the start_index to be within the bounds of the list
    start_index = start_index % len(lst)
    
    # Split the list into two parts: before and after the start_index
    part1 = lst[start_index:]
    part2 = lst[:start_index]
    
    # Rotate the list by combining the two parts and slicing
    rotated_list = part1 + part2
    
    # Rotate the list further by the specified number of rotations
    num_rotations = num_rotations % len(rotated_list)
    rotated_list = rotated_list[num_rotations:] + rotated_list[:num_rotations]
    
    return rotated_list

# Test the function with the provided assertion
assert rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3, 4) == [4, 5, 6, 7, 8, 9, 10, 1, 2, 3]"
MBPP/341,set_to_tuple,"def set_to_tuple(input_set):
    # Convert the set to a sorted list and then to a tuple
    return tuple(sorted(input_set))

# Test the function with the provided assertion
assert set_to_tuple({1, 2, 3, 4, 5}) == (1, 2, 3, 4, 5)"
MBPP/343,dig_let,"def dig_let(s):
    letters_count = sum(c.isalpha() for c in s)
    digits_count = sum(c.isdigit() for c in s)
    return (letters_count, digits_count)

# Test the function with the provided assertion
assert dig_let(""python"") == (6, 0)"
MBPP/345,diff_consecutivenums,"def diff_consecutivenums(nums):
    return [nums[i] - nums[i - 1] for i in range(1, len(nums))]

# Test the function with the provided assertion
assert diff_consecutivenums([1, 1, 3, 4, 4, 5, 6, 7]) == [0, 2, 1, 0, 1, 1, 1]"
MBPP/349,check,"def check(s):
    # Check if all characters in the string are either '0' or '1'
    if all(char in '01' for char in s):
        return ""Yes""
    else:
        return ""No""

# Test the function with the provided assertion
assert check(""01010101010"") == ""Yes"""
MBPP/340,sum_three_smallest_nums,"def sum_three_smallest_nums(numbers):
    # Filter out non-positive numbers and sort the remaining numbers
    positive_numbers = sorted(num for num in numbers if num > 0)
    
    # Take the first three smallest positive numbers and calculate their sum
    return sum(positive_numbers[:3])

# Test the function with the provided assertion
assert sum_three_smallest_nums([10, 20, 30, 40, 50, 60, 7]) == 37"
MBPP/346,zigzag,"def zigzag(n, k):
    # Base case: if k is 0 or n is 0, the result is 1
    if k == 0 or n == 0:
        return 1
    # Recursive case: calculate the entringer number
    return zigzag(n - 1, k) + zigzag(n, k - 1)

# Test the function with the provided assertion
assert zigzag(4, 3) == 5

# You can add more test cases to verify the function
print(""Test passed!"")"
MBPP/339,find_Divisor,"def find_Divisor(start, end):
    divisor_count = {}
    
    # Iterate through each number in the interval
    for num in range(start, end + 1):
        # Find divisors of the current number
        for i in range(1, num + 1):
            if num % i == 0:  # i is a divisor of num
                if i in divisor_count:
                    divisor_count[i] += 1
                else:
                    divisor_count[i] = 1
    
    # Find the maximum occurring divisor
    max_divisor = None
    max_count = 0
    
    for divisor, count in divisor_count.items():
        if count > max_count or (count == max_count and divisor > max_divisor):
            max_count = count
            max_divisor = divisor
    
    return max_divisor

# Test the function with the provided assertion
assert find_Divisor(2, 2) == 2"
MBPP/347,count_Squares,"def count_Squares(m, n):
    total_squares = 0
    # Iterate over all possible square sizes
    for k in range(1, min(m, n) + 1):
        total_squares += (m - k + 1) * (n - k + 1)
    return total_squares

# Test the function with the provided assertion
assert count_Squares(4, 3) == 20"
MBPP/352,unique_Characters,"def unique_characters(s):
    # Create a set to store characters
    char_set = set()
    
    # Iterate through each character in the string
    for char in s:
        # If the character is already in the set, return False
        if char in char_set:
            return False
        # Add the character to the set
        char_set.add(char)
    
    # If no duplicates were found, return True
    return True

# Test the function with the provided assertion
assert unique_characters('aba') == False"
MBPP/350,minimum_Length,"def minimum_Length(s: str) -> int:
    from collections import Counter
    
    # Count occurrences of each character
    char_count = Counter(s)
    
    # Initialize the minimum length to the length of the original string
    min_length = len(s)
    
    # Iterate through each unique character in the string
    for char in char_count:
        # Calculate the length of the string if we remove this character
        length_after_removal = len(s) - char_count[char]
        # Update the minimum length if the new length is smaller
        min_length = min(min_length, length_after_removal)
    
    return min_length

# Test the function with the provided assertion
assert minimum_Length(""mnm"") == 1"
MBPP/353,remove_column,"def remove_column(nested_list, col_index):
    # Use a list comprehension to create a new nested list without the specified column
    return [[row[i] for i in range(len(row)) if i != col_index] for row in nested_list]

# Test the function with the provided assertion
assert remove_column([[1, 2, 3], [2, 4, 5], [1, 1, 1]], 0) == [[2, 3], [4, 5], [1, 1]]"
MBPP/354,tn_ap,"def tn_ap(a, d, n):
    return a + (n - 1) * d

# Test the function with the provided assertion
assert tn_ap(1, 5, 2) == 9"
MBPP/357,find_max,"def find_max(tuples):
    # Initialize max_value to the smallest possible value
    max_value = float('-inf')
    
    # Iterate through each tuple in the list
    for tup in tuples:
        # Find the maximum in the current tuple
        current_max = max(tup)
        # Update max_value if current_max is greater
        if current_max > max_value:
            max_value = current_max
            
    return max_value

# Test the function with the provided assertion
assert find_max([(2, 4), (6, 7), (5, 1), (6, 10), (8, 7)]) == 10"
MBPP/351,first_Element,"def first_Element(arr, n, k):
    count = {}
    
    # Count occurrences of each element
    for num in arr:
        if num in count:
            count[num] += 1
        else:
            count[num] = 1
        
        # Check if the current element has occurred k times
        if count[num] == k:
            return num
    
    # If no element occurs k times, return None or an appropriate value
    return None

# Test the function with the provided assertion
assert first_Element([0, 1, 2, 3, 4, 5], 6, 1) == 0"
MBPP/344,count_Odd_Squares,"def count_Odd_Squares(start, end):
    count = 0
    for i in range(start, end + 1):
        # Check if i is a perfect square
        if (i**0.5).is_integer():
            count += 1
    return count

# Test the function with the provided assertion
assert count_Odd_Squares(5, 100) == 8"
MBPP/356,find_angle,"def find_angle(angle1, angle2):
    # The sum of angles in a triangle is always 180 degrees
    return 180 - (angle1 + angle2)

# Test the function with the provided assertion
assert find_angle(47, 89) == 44

# You can also add some print statements to verify the output
print(find_angle(47, 89))  # Output should be 44"
MBPP/358,moddiv_list,"def moddiv_list(list1, list2):
    return list(map(lambda x, y: x % y, list1, list2))

# Test the function with the provided assertion
assert moddiv_list([4, 5, 6], [1, 2, 3]) == [0, 1, 0]"
MBPP/355,count_Rectangles,"def count_Rectangles(r):
    # The number of rectangles that can be inscribed in a circle of radius r
    return 4 * r * r

# Test the function with the provided assertion
assert count_Rectangles(2) == 8"
MBPP/360,get_carol,"def get_carol(n):
    return (2 ** (n + 1)) - 1

# Test the function with the provided assertion
assert get_carol(2) == 7"
MBPP/361,remove_empty,"def remove_empty(lst):
    return [item for item in lst if item != []]

# Test the function with the provided assertion
assert remove_empty([[], [], [], 'Red', 'Green', [1, 2], 'Blue', [], []]) == ['Red', 'Green', [1, 2], 'Blue']"
MBPP/342,find_minimum_range,"import heapq

def find_minimum_range(arrays):
    # Create a min-heap
    min_heap = []
    current_max = float('-inf')
    
    # Initialize the heap with the first element of each array
    for i in range(len(arrays)):
        heapq.heappush(min_heap, (arrays[i][0], i, 0))  # (value, array_index, element_index)
        current_max = max(current_max, arrays[i][0])
    
    min_range = float('inf')
    range_start, range_end = -1, -1
    
    while True:
        current_min, array_index, element_index = heapq.heappop(min_heap)
        
        # Update the range if the current range is smaller
        if current_max - current_min < min_range:
            min_range = current_max - current_min
            range_start, range_end = current_min, current_max
        
        # If we have reached the end of one of the arrays, break
        if element_index + 1 == len(arrays[array_index]):
            break
        
        # Push the next element from the same array into the heap
        next_value = arrays[array_index][element_index + 1]
        heapq.heappush(min_heap, (next_value, array_index, element_index + 1))
        current_max = max(current_max, next_value)
    
    return (range_start, range_end)

# Test the function with the provided assertion
assert find_minimum_range([[3, 6, 8, 10, 15], [1, 5, 12], [4, 8, 15, 16], [2, 6]]) == (4, 6)"
MBPP/365,count_Digit,"def count_Digit(number):
    # Convert the number to a string and count the length
    return len(str(abs(number)))

# Test the function with the provided assertion
assert count_Digit(12345) == 5"
MBPP/362,max_occurrences,"def max_occurrences(lst):
    from collections import Counter
    
    # Count the occurrences of each item in the list
    count = Counter(lst)
    
    # Find the item with the maximum occurrences
    max_item = max(count, key=count.get)
    
    return max_item

# Test the function with the provided assertion
assert max_occurrences([1, 2, 3, 1, 2, 3, 12, 4, 2]) == 2"
MBPP/363,add_K_element,"def add_K_element(tuples_list, k):
    return [tuple(x + k for x in t) for t in tuples_list]

# Test the function with the provided assertion
assert add_K_element([(1, 3, 4), (2, 4, 6), (3, 8, 1)], 4) == [(5, 7, 8), (6, 8, 10), (7, 12, 5)]"
MBPP/366,adjacent_num_product,"def adjacent_num_product(nums):
    if len(nums) < 2:
        raise ValueError(""List must contain at least two elements."")
    
    max_product = float('-inf')
    
    for i in range(len(nums) - 1):
        product = nums[i] * nums[i + 1]
        if product > max_product:
            max_product = product
            
    return max_product

# Test the function with the provided assertion
assert adjacent_num_product([1, 2, 3, 4, 5, 6]) == 30"
MBPP/359,Check_Solution,"import math

def Check_Solution(a, b, c):
    # Calculate the discriminant
    discriminant = b**2 - 4*a*c
    
    # If the discriminant is negative, there are no real roots
    if discriminant < 0:
        return ""No""
    
    # Calculate the two roots
    root1 = (-b + math.sqrt(discriminant)) / (2 * a)
    root2 = (-b - math.sqrt(discriminant)) / (2 * a)
    
    # Check if one root is twice the other
    if root1 == 2 * root2 or root2 == 2 * root1:
        return ""Yes""
    else:
        return ""No""

# Example assertion
assert Check_Solution(1, 3, 2) == ""Yes"""
MBPP/348,find_ways,"def find_ways(n):
    # Base case: if n is 0, there's one way to have an empty sequence
    if n == 0:
        return 1
    
    # Initialize a list to store the number of ways to form sequences of each length
    dp = [0] * (n + 1)
    dp[0] = 1  # There's one way to have a sequence of length 0 (the empty sequence)
    
    # Iterate through lengths from 1 to n
    for length in range(1, n + 1):
        # For each length, we can add a value of 1 or -1
        # We need to ensure that the prefix sum remains non-negative
        for value in [1, -1]:
            if length - 1 >= 0 and (value == 1 or dp[length - 1] > 0):
                dp[length] += dp[length - 1]
    
    return dp[n]

# Test the function with the provided assertion
assert find_ways(4) == 2"
MBPP/369,lateralsurface_cuboid,"def lateralsurface_cuboid(length, width, height):
    return 2 * height * (length + width)

# Test the function with the provided assertion
assert lateralsurface_cuboid(8, 5, 6) == 156"
MBPP/368,repeat_tuples,"def repeat_tuples(tup, n):
    return (tup,) * n

# Test the function with the provided assertion
assert repeat_tuples((1, 3), 4) == ((1, 3), (1, 3), (1, 3), (1, 3))"
MBPP/373,volume_cuboid,"def volume_cuboid(length, width, height):
    """"""Calculate the volume of a cuboid.""""""
    return length * width * height

# Test the function with the provided assertion
assert volume_cuboid(1, 2, 3) == 6"
MBPP/375,round_num,"def round_num(number, multiple):
    return round(number / multiple) * multiple

# Test the function with the provided assertion
assert round_num(4722, 10) == 4720"
MBPP/367,is_tree_balanced,"class TreeNode:
    def __init__(self, value=0, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

def is_tree_balanced(root):
    def check_balance(node):
        if not node:
            return 0  # Height of an empty tree is 0
        
        left_height = check_balance(node.left)
        if left_height == -1:  # Left subtree is not balanced
            return -1
        
        right_height = check_balance(node.right)
        if right_height == -1:  # Right subtree is not balanced
            return -1
        
        # Check if the current node is balanced
        if abs(left_height - right_height) > 1:
            return -1  # Not balanced
        
        return max(left_height, right_height) + 1  # Return the height of the tree

    return check_balance(root) != -1  # If the return value is -1, the tree is not balanced

# Example usage:
# Creating a sample unbalanced tree
#       1
#      /
#     2
#    /
#   3
root = TreeNode(1)
root.left = TreeNode(2)
root.left.left = TreeNode(3)

# Assert that the tree is not balanced
assert is_tree_balanced(root) == False"
MBPP/377,remove_Char,"def remove_Char(s, char):
    return s.replace(char, '')

# Test the function with the provided assertion
assert remove_Char(""aba"", 'a') == ""b"""
MBPP/364,min_flip_to_make_string_alternate,"def min_flip_to_make_string_alternate(s: str) -> int:
    # Patterns for alternate characters
    pattern1 = ''.join('01'[(i % 2)] for i in range(len(s)))  # Starts with '0'
    pattern2 = ''.join('10'[(i % 2)] for i in range(len(s)))  # Starts with '1'
    
    # Count mismatches for both patterns
    count1 = sum(1 for i in range(len(s)) if s[i] != pattern1[i])
    count2 = sum(1 for i in range(len(s)) if s[i] != pattern2[i])
    
    # Return the minimum of the two counts
    return min(count1, count2)

# Test the function with the provided assertion
assert min_flip_to_make_string_alternate(""0001010111"") == 2"
MBPP/374,permute_string,"from itertools import permutations

def permute_string(s):
    # Generate all permutations using itertools.permutations
    perm = permutations(s)
    # Convert the permutations from tuples to strings and return as a list
    return [''.join(p) for p in perm]

# Test the function with the provided assertion
assert permute_string('ab') == ['ab', 'ba']"
MBPP/372,heap_assending,"import heapq

def heap_assending(elements):
    # Create a heap from the elements
    heapq.heapify(elements)
    # Extract elements from the heap in sorted order
    sorted_elements = [heapq.heappop(elements) for _ in range(len(elements))]
    return sorted_elements

# Test the function with the provided assertion
assert heap_assending([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1]) == [1, 2, 3, 4, 7, 8, 9, 9, 10, 14, 18]"
MBPP/370,float_sort,"def float_sort(tuples):
    return sorted(tuples, key=lambda x: float(x[1]), reverse=True)

# Test the function with the provided assertion
assert float_sort([('item1', '12.20'), ('item2', '15.10'), ('item3', '24.5')]) == [('item3', '24.5'), ('item2', '15.10'), ('item1', '12.20')]"
MBPP/378,move_first,"def move_first(lst):
    if lst:  # Check if the list is not empty
        return [lst[-1]] + lst[:-1]  # Move last element to the front
    return lst  # Return the original list if it's empty

# Test the function with the provided assertion
assert move_first([1, 2, 3, 4]) == [4, 1, 2, 3]"
MBPP/379,surfacearea_cuboid,"def surfacearea_cuboid(length, width, height):
    # Surface area formula for a cuboid: 2 * (length * width + width * height + height * length)
    return 2 * (length * width + width * height + height * length)

# Test the function with the provided assertion
assert surfacearea_cuboid(1, 2, 3) == 22"
MBPP/380,multi_list,"def multi_list(rows, cols):
    return [[j * i for j in range(cols)] for i in range(rows)]

# Test the function with the provided assertion
assert multi_list(3, 4) == [[0, 0, 0, 0], [0, 1, 2, 3], [0, 2, 4, 6]]"
MBPP/371,smallest_missing,"def smallest_missing(arr, left, right):
    # If the array is empty, the smallest missing element is 0
    if not arr:
        return 0
    
    # If the last element is equal to its index, the smallest missing element is after the last index
    if arr[right] == right:
        return right + 1
    
    while left <= right:
        mid = (left + right) // 2
        
        # Check if the mid index matches the value at mid
        if arr[mid] == mid:
            # If it matches, search in the right half
            left = mid + 1
        else:
            # If it doesn't match, search in the left half
            right = mid - 1
            
    # The smallest missing element is the left index
    return left

# Test the function with the provided assertion
assert smallest_missing([0, 1, 2, 3, 4, 5, 6], 0, 6) == 7"
MBPP/376,remove_replica,"def remove_replica(input_tuple, custom_value='MSP'):
    # Create a dictionary to count occurrences of each element
    count_dict = {}
    
    # Count occurrences of each element in the tuple
    for item in input_tuple:
        if item in count_dict:
            count_dict[item] += 1
        else:
            count_dict[item] = 1
    
    # Create a new tuple with duplicates replaced by the custom value
    result = tuple(custom_value if count_dict[item] > 1 else item for item in input_tuple)
    
    return result

# Test the function with the provided assertion
assert remove_replica((1, 1, 4, 4, 4, 5, 5, 6, 7, 7)) == (1, 'MSP', 4, 'MSP', 'MSP', 5, 'MSP', 6, 7, 'MSP')"
MBPP/381,index_on_inner_list,"def index_on_inner_list(data, index):
    return sorted(data, key=lambda x: x[index])

# Test the function with the provided assertion
assert index_on_inner_list([('Greyson Fulton', 98, 99), 
                             ('Brady Kent', 97, 96), 
                             ('Wyatt Knott', 91, 94), 
                             ('Beau Turnbull', 94, 98)], 0) == [
    ('Beau Turnbull', 94, 98), 
    ('Brady Kent', 97, 96), 
    ('Greyson Fulton', 98, 99), 
    ('Wyatt Knott', 91, 94)
]"
MBPP/384,frequency_Of_Smallest,"def frequency_of_smallest(n, arr):
    if not arr:
        return 0  # Return 0 if the array is empty
    
    smallest_value = min(arr)  # Find the smallest value in the array
    frequency = arr.count(smallest_value)  # Count the frequency of the smallest value
    
    return frequency

# Test the function with the provided assertion
assert frequency_of_smallest(5, [1, 2, 3, 4, 3]) == 1"
MBPP/383,even_bit_toggle_number,"def even_bit_toggle_number(n):
    # Create a mask with 1s at all odd bit positions
    # For a 32-bit integer, the mask would be 0xAAAAAAAA (binary: 10101010...)
    mask = 0xAAAAAAAA
    # Toggle the odd bits using XOR
    return n ^ mask

# Test the function with the provided assertion
assert even_bit_toggle_number(10) == 15

# You can also print the result to verify
print(even_bit_toggle_number(10))  # Output should be 15"
MBPP/385,get_perrin,"def get_perrin(n):
    if n == 0:
        return 3
    elif n == 1:
        return 0
    elif n == 2:
        return 2
    else:
        return get_perrin(n - 2) + get_perrin(n - 3)

# Test the function with the provided assertion
assert get_perrin(9) == 12"
MBPP/387,even_or_odd,"def even_or_odd(hex_number):
    # Get the last character of the hexadecimal number
    last_char = hex_number[-1].upper()  # Convert to uppercase for consistency
    
    # Check if the last character represents an even number
    if last_char in '02468ACE':
        return ""Even""
    else:
        return ""Odd""

# Test the function with the provided assertion
assert even_or_odd(""AB3454D"") == ""Odd"""
MBPP/382,find_rotation_count,"def find_rotation_count(arr):
    left, right = 0, len(arr) - 1
    
    # Handle cases where the array is not rotated at all
    if arr[left] < arr[right]:
        return 0
    
    while left <= right:
        mid = (left + right) // 2
        
        # Check if mid is the minimum element
        if arr[mid] > arr[mid + 1]:
            return mid + 1
        if arr[mid] < arr[mid - 1]:
            return mid
        
        # Decide which half to continue searching
        if arr[mid] >= arr[left]:
            left = mid + 1
        else:
            right = mid - 1
            
    return 0  # This line should never be reached if the input is valid

# Test the function with the provided assertion
assert find_rotation_count([8, 9, 10, 1, 2, 3, 4, 5, 6, 7]) == 3"
MBPP/386,swap_count,"def swap_count(s: str) -> int:
    opening = 0  # Count of unmatched opening brackets
    closing = 0  # Count of unmatched closing brackets

    for char in s:
        if char == '[':
            opening += 1
        elif char == ']':
            if opening > 0:
                opening -= 1  # Match with an opening bracket
            else:
                closing += 1  # Unmatched closing bracket

    # The number of swaps needed is half the total unmatched brackets
    return (opening + closing) // 2

# Test the function with the provided assertion
assert swap_count(""[]][]["") == 2"
MBPP/390,add_string,"def add_string(lst, string):
    return [string.format(item) for item in lst]

# Test the function with the provided assertion
assert add_string([1, 2, 3, 4], 'temp{0}') == ['temp1', 'temp2', 'temp3', 'temp4']"
MBPP/394,check_distinct,"def check_distinct(tup):
    # Convert the tuple to a set to remove duplicates
    return len(tup) == len(set(tup))

# Test the function with the provided assertion
assert check_distinct((1, 4, 5, 6, 1, 4)) == False"
MBPP/393,max_length_list,"def max_length_list(lists):
    # Use max with a lambda function to find the list with the maximum length
    max_list = max(lists, key=lambda x: len(x))
    return (len(max_list), max_list)

# Test the function with the provided assertion
assert max_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17])"
MBPP/388,highest_Power_of_2,"def highest_Power_of_2(n):
    if n < 1:
        return 0  # Return 0 for non-positive integers
    power = 1
    while power <= n:
        power *= 2
    return power // 2

# Test the function with the provided assertion
assert highest_Power_of_2(10) == 8"
MBPP/397,median_numbers,"def median_numbers(a, b, c):
    # Create a list of the numbers
    numbers = [a, b, c]
    # Sort the list
    numbers.sort()
    # The median is the middle number in the sorted list
    return numbers[1]

# Test the function with the provided assertion
assert median_numbers(25, 55, 65) == 55.0"
MBPP/389,find_lucas,"def find_lucas(n):
    if n == 0:
        return 2
    elif n == 1:
        return 1
    else:
        a, b = 2, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b

# Test the function
assert find_lucas(9) == 76"
MBPP/395,first_non_repeating_character,"def first_non_repeating_character(s):
    char_count = {}
    
    # Count the occurrences of each character
    for char in s:
        char_count[char] = char_count.get(char, 0) + 1
    
    # Find the first character that has a count of 1
    for char in s:
        if char_count[char] == 1:
            return char
    
    return None

# Test case
assert first_non_repeating_character(""abcabc"") == None"
MBPP/396,check_char,"import re

def check_char(s):
    # Use regex to check if the first and last character are the same
    if re.match(r'^(?P<first>.)(?P=first).*?(?P=first)$', s):
        return ""Valid""
    else:
        return ""Invalid""

# Test the function
assert check_char(""abba"") == ""Valid"""
MBPP/392,get_max_sum,"def get_max_sum(n):
    # Base case: if n is 0, the maximum sum is 0
    if n == 0:
        return 0
    
    # Recursive case: calculate the maximum sum using the given equation
    max_sum = max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)
    
    return max_sum

# Test the function with the provided assertion
assert get_max_sum(60) == 106

# You can also add more test cases to verify the function
print(get_max_sum(60))  # Output: 106
print(get_max_sum(10))   # Example output
print(get_max_sum(100))  # Example output"
MBPP/391,convert_list_dictionary,"def convert_list_dictionary(ids, names, scores):
    # Check if all lists are of the same length
    if not (len(ids) == len(names) == len(scores)):
        raise ValueError(""All input lists must have the same length."")
    
    # Create a list of dictionaries
    result = []
    for id_, name, score in zip(ids, names, scores):
        result.append({id_: {name: score}})
    
    return result

# Test the function with the provided assertion
assert convert_list_dictionary(
    [""S001"", ""S002"", ""S003"", ""S004""],
    [""Adina Park"", ""Leyton Marsh"", ""Duncan Boyle"", ""Saim Richards""],
    [85, 98, 89, 92]
) == [
    {'S001': {'Adina Park': 85}},
    {'S002': {'Leyton Marsh': 98}},
    {'S003': {'Duncan Boyle': 89}},
    {'S004': {'Saim Richards': 92}}
]"
MBPP/404,minimum,"def minimum(a, b):
    """"""Return the minimum of two numbers.""""""
    return a if a < b else b

# Test the function
assert minimum(1, 2) == 1"
MBPP/399,bitwise_xor,"def bitwise_xor(tuple1, tuple2):
    # Use a generator expression to apply the XOR operation on corresponding elements
    return tuple(a ^ b for a, b in zip(tuple1, tuple2))

# Test the function with the provided assertion
assert bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)

# You can also print the result to verify
print(bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)))  # Output: (15, 6, 5, 10)"
MBPP/398,sum_of_digits,"def sum_of_digits(numbers):
    total_sum = 0
    for number in numbers:
        total_sum += sum(int(digit) for digit in str(number))
    return total_sum

# Test the function with the provided assertion
assert sum_of_digits([10, 2, 56]) == 14"
MBPP/405,check_tuplex,"def check_tuplex(tup, element):
    return element in tup

# Test the function with the provided assertion
assert check_tuplex((""w"", 3, ""r"", ""e"", ""s"", ""o"", ""u"", ""r"", ""c"", ""e""), 'r') == True"
MBPP/406,find_Parity,"def find_Parity(number):
    if number % 2 == 0:
        return ""Even Parity""
    else:
        return ""Odd Parity""

# Test the function with the provided assertion
assert find_Parity(12) == ""Even Parity"""
MBPP/400,extract_freq,"def extract_freq(tuples_list):
    # Create a set to store unique tuples
    unique_tuples = set()
    
    # Iterate through the list of tuples
    for tup in tuples_list:
        # Normalize the tuple by sorting its elements
        normalized_tup = tuple(sorted(tup))
        # Add the normalized tuple to the set
        unique_tuples.add(normalized_tup)
    
    # Return the number of unique tuples
    return len(unique_tuples)

# Test the function with the provided assertion
assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)]) == 3"
MBPP/401,add_nested_tuples,"def add_nested_tuples(tuple1, tuple2):
    # Use a generator expression to add corresponding elements of the nested tuples
    return tuple(tuple(a + b for a, b in zip(inner1, inner2)) for inner1, inner2 in zip(tuple1, tuple2))

# Test the function with the provided assertion
assert add_nested_tuples(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((7, 10), (7, 14), (3, 10), (8, 13))

print(""Function works correctly!"")"
MBPP/403,is_valid_URL,"import re

def is_valid_URL(url):
    # Regular expression for validating a URL
    regex = re.compile(
        r'^(?:http|ftp)s?://'  # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'  # domain...
        r'localhost|'  # localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|'  # IPv4
        r'\[?[A-F0-9]*:[A-F0-9:]+\]?)'  # IPv6
        r'(?::\d+)?'  # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)  # optional path

    return re.match(regex, url) is not None

# Test the function
assert is_valid_URL(""https://www.google.com"") == True"
MBPP/412,remove_odd,"def remove_odd(numbers):
    return [num for num in numbers if num % 2 == 0]

# Test the function with the provided assertion
assert remove_odd([1, 2, 3]) == [2]"
MBPP/407,rearrange_bigger,"def rearrange_bigger(n):
    # Convert the number to a list of its digits
    digits = list(str(n))
    
    # Step 1: Find the first decreasing element from the right
    i = len(digits) - 2
    while i >= 0 and digits[i] >= digits[i + 1]:
        i -= 1
    
    # If no such element is found, return the original number
    if i == -1:
        return n
    
    # Step 2: Find the element just larger than digits[i] to the right of it
    j = len(digits) - 1
    while digits[j] <= digits[i]:
        j -= 1
    
    # Step 3: Swap the found elements
    digits[i], digits[j] = digits[j], digits[i]
    
    # Step 4: Reverse the sequence after the position i
    digits = digits[:i + 1] + digits[i + 1:][::-1]
    
    # Convert the list of digits back to an integer
    return int(''.join(digits))

# Test the function with the provided assertion
assert rearrange_bigger(12) == 21"
MBPP/411,snake_to_camel,"import re

def snake_to_camel(snake_str):
    # Use regex to find all occurrences of words separated by underscores
    components = re.split(r'_', snake_str)
    # Capitalize the first letter of each component and join them
    return ''.join(x.capitalize() for x in components)

# Test the function
assert snake_to_camel('android_tv') == 'AndroidTv'"
MBPP/409,min_product_tuple,"def min_product_tuple(tuples_list):
    # Initialize the minimum product to a large number
    min_product = float('inf')
    
    # Iterate through each tuple in the list
    for a, b in tuples_list:
        # Calculate the product of the current tuple
        product = a * b
        # Update the minimum product if the current product is smaller
        if product < min_product:
            min_product = product
            
    return min_product

# Test the function with the provided assertion
assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)]) == 8"
MBPP/410,min_val,"def min_val(heterogeneous_list):
    # Filter out non-numeric values
    numeric_values = [item for item in heterogeneous_list if isinstance(item, (int, float))]
    
    # Return the minimum value if there are numeric values, otherwise return None
    return min(numeric_values) if numeric_values else None

# Test the function with the provided assertion
assert min_val(['Python', 3, 2, 4, 5, 'version']) == 2"
MBPP/413,extract_nth_element,"def extract_nth_element(tuples_list, n):
    return [t[n] for t in tuples_list]

# Test the function with the provided assertion
assert extract_nth_element([('Greyson Fulton', 98, 99), 
                             ('Brady Kent', 97, 96), 
                             ('Wyatt Knott', 91, 94), 
                             ('Beau Turnbull', 94, 98)], 0) == ['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']"
MBPP/402,ncr_modp,"def factorial_mod(n, p):
    """"""Compute factorial % p for all numbers from 0 to n.""""""
    fact = [1] * (n + 1)
    for i in range(2, n + 1):
        fact[i] = (fact[i - 1] * i) % p
    return fact

def ncr_modp(n, r, p):
    """"""Compute nCr % p.""""""
    if r > n:
        return 0
    if r == 0 or r == n:
        return 1
    
    # Precompute all factorials % p
    fact = factorial_mod(n, p)
    
    # Compute nCr % p using the formula
    numerator = fact[n]
    denominator = (fact[r] * fact[n - r]) % p
    
    # Compute the modular inverse of the denominator
    denominator_inv = pow(denominator, p - 2, p)
    
    # Return the result
    return (numerator * denominator_inv) % p

# Test the function with the provided assertion
assert ncr_modp(10, 2, 13) == 6"
MBPP/418,Find_Max,"def Find_Max(lists):
    if not lists:
        return []
    # Use max with key to find the longest sublist
    return max(lists, key=len)

# Test the function with the provided assertion
assert Find_Max([['A'], ['A', 'B'], ['A', 'B', 'C']]) == ['A', 'B', 'C']"
MBPP/415,max_Product,"def max_Product(arr):
    if len(arr) < 2:
        return None  # Not enough elements to form a pair

    # Initialize the two largest numbers
    first = second = float('-inf')

    for number in arr:
        # Update the largest and second largest numbers
        if number > first:
            second = first
            first = number
        elif number > second:
            second = number

    return (second, first)

# Test the function with the provided assertion
assert max_Product([1, 2, 3, 4, 7, 0, 8, 4]) == (7, 8)"
MBPP/420,cube_Sum,"def cube_Sum(n):
    # Calculate the sum of cubes of the first n even natural numbers
    return sum((2 * i) ** 3 for i in range(1, n + 1))

# Test the function with the provided assertion
assert cube_Sum(2) == 72"
MBPP/414,overlapping,"def overlapping(seq1, seq2):
    # Check if there is any common element in both sequences
    return any(item in seq2 for item in seq1)

# Test the function with the provided assertion
assert overlapping([1, 2, 3, 4, 5], [6, 7, 8, 9]) == False"
MBPP/421,concatenate_tuple,"def concatenate_tuple(tup, delimiter='-'):
    # Convert all elements to string and join them with the delimiter
    return delimiter.join(map(str, tup))

# Test the function with the provided assertion
assert concatenate_tuple((""ID"", ""is"", 4, ""UTS"")) == 'ID-is-4-UTS'"
MBPP/408,k_smallest_pairs,"import heapq

def k_smallest_pairs(nums1, nums2, k):
    # Create a min-heap
    min_heap = []
    
    # Initialize the heap with the first element from nums1 paired with all elements from nums2
    for i in range(min(k, len(nums1))):  # We only need the first k elements from nums1
        heapq.heappush(min_heap, (nums1[i] + nums2[0], i, 0))  # (sum, index in nums1, index in nums2)
    
    result = []
    
    while k > 0 and min_heap:
        # Get the smallest pair
        sum_val, i, j = heapq.heappop(min_heap)
        result.append([nums1[i], nums2[j]])
        
        # If there is a next element in nums2, add the new pair to the heap
        if j + 1 < len(nums2):
            heapq.heappush(min_heap, (nums1[i] + nums2[j + 1], i, j + 1))
        
        k -= 1
    
    return result

# Example usage
assert k_smallest_pairs([1, 3, 7], [2, 4, 6], 2) == [[1, 2], [1, 4]]"
MBPP/424,extract_rear,"def extract_rear(strings):
    return [s[-1] for s in strings]

# Test the function with the provided assertion
assert extract_rear(('Mers', 'for', 'Vers')) == ['s', 'r', 's']"
MBPP/419,round_and_sum,"def round_and_sum(numbers):
    # Round each number in the list
    rounded_numbers = [round(num) for num in numbers]
    # Calculate the total sum of the rounded numbers
    total_sum = sum(rounded_numbers)
    # Multiply the total sum by the length of the list
    result = total_sum * len(numbers)
    return result

# Test the function with the provided assertion
assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50]) == 243"
MBPP/416,breakSum,"def breakSum(n):
    # Base case: if n is less than or equal to 1, return n
    if n <= 1:
        return n
    
    max_sum = 0
    
    # Try breaking the number into three parts
    for i in range(1, n):
        for j in range(1, n - i + 1):
            k = n - i - j
            if k >= 0:
                # Calculate the sum of the three parts
                current_sum = breakSum(i) + breakSum(j) + breakSum(k)
                # Update max_sum if current_sum is greater
                max_sum = max(max_sum, current_sum)
    
    return max_sum

# Test the function with the provided assertion
assert breakSum(12) == 13"
MBPP/417,group_tuples,"def group_tuples(tuples_list):
    from collections import defaultdict

    # Create a dictionary to hold lists of second elements grouped by the first element
    grouped = defaultdict(list)

    # Iterate through the list of tuples
    for first, second in tuples_list:
        grouped[first].append(second)

    # Create the result list
    result = []
    for first, seconds in grouped.items():
        # Create a tuple with the first element and the corresponding second elements
        result.append((first, *seconds))

    return result

# Test the function with the provided assertion
assert group_tuples([('x', 'y'), ('x', 'z'), ('w', 't')]) == [('x', 'y', 'z'), ('w', 't')]"
MBPP/426,filter_oddnumbers,"def filter_oddnumbers(numbers):
    return list(filter(lambda x: x % 2 != 0, numbers))

# Test the function with the provided assertion
assert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 3, 5, 7, 9]"
MBPP/427,change_date_format,"import re

def change_date_format(date_str):
    # Use regex to match the date format
    match = re.match(r'(\d{4})-(\d{2})-(\d{2})', date_str)
    if match:
        year, month, day = match.groups()
        return f'{day}-{month}-{year}'
    else:
        raise ValueError(""Invalid date format. Please use yyyy-mm-dd."")

# Test the function
assert change_date_format(""2026-01-02"") == '02-01-2026'"
MBPP/425,count_element_in_list,"def count_element_in_list(sublists, element):
    count = 0
    for sublist in sublists:
        if element in sublist:
            count += 1
    return count

# Test the function with the provided assertion
assert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]], 1) == 3"
MBPP/422,find_Average_Of_Cube,"def find_Average_Of_Cube(n):
    if n <= 0:
        return 0  # Return 0 for non-positive n
    sum_of_cubes = sum(i**3 for i in range(1, n + 1))
    average = sum_of_cubes / n
    return average

# Test the function with the provided assertion
assert find_Average_Of_Cube(2) == 4.5"
MBPP/429,and_tuples,"def and_tuples(tuple1, tuple2):
    # Use a generator expression to create a new tuple with the elementwise minimum
    return tuple(min(a, b) for a, b in zip(tuple1, tuple2))

# Test the function with the provided assertion
assert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)"
MBPP/435,last_Digit,"def last_Digit(number):
    return abs(number) % 10

# Test the function
assert last_Digit(123) == 3"
MBPP/423,get_maxgold,"def get_maxgold(mine, n, m):
    # Create a table to store the maximum gold that can be collected
    # from each cell
    gold_table = [[0 for _ in range(m)] for _ in range(n)]
    
    # Initialize the first row of the gold_table with the first row of the mine
    for j in range(m):
        gold_table[0][j] = mine[0][j]
    
    # Fill the gold_table
    for i in range(1, n):
        for j in range(m):
            # Get the maximum gold from the three possible positions
            # from where the miner can come to the current cell
            # (i, j)
            gold_from_left = gold_table[i-1][j-1] if j > 0 else 0
            gold_from_up = gold_table[i-1][j]
            gold_from_right = gold_table[i-1][j+1] if j < m - 1 else 0
            
            # Current cell gold + max of the three possible previous cells
            gold_table[i][j] = mine[i][j] + max(gold_from_left, gold_from_up, gold_from_right)
    
    # The maximum gold collected will be the maximum value in the last row
    max_gold = 0
    for j in range(m):
        max_gold = max(max_gold, gold_table[n-1][j])
    
    return max_gold

# Test the function with the provided assertion
assert get_maxgold([[1, 3, 1, 5], [2, 2, 4, 1], [5, 0, 2, 3], [0, 6, 1, 2]], 4, 4) == 16"
MBPP/433,check_greater,"def check_greater(arr, num):
    if all(num > element for element in arr):
        return 'Yes, entered number is greater than all elements in the array'
    else:
        return 'No, entered number is less than those in the array'

# Example usage
assert check_greater([1, 2, 3, 4, 5], 4) == 'No, entered number is less than those in the array'"
MBPP/432,median_trapezium,"def median_trapezium(a, b, c):
    # a and b are the lengths of the two parallel sides
    # c is not used in the median calculation
    return (a + b) / 2

# Test the function with the provided assertion
assert median_trapezium(15, 25, 35) == 20"
MBPP/431,common_element,"def common_element(list1, list2):
    # Convert the first list to a set for faster lookup
    set1 = set(list1)
    
    # Check if any element in the second list is in the set of the first list
    for element in list2:
        if element in set1:
            return True
    return False

# Test the function with the provided assertion
assert common_element([1, 2, 3, 4, 5], [5, 6, 7, 8, 9]) == True"
MBPP/428,shell_sort,"def shell_sort(arr):
    n = len(arr)
    gap = n // 2  # Start with a big gap, then reduce the gap

    # Do a gapped insertion sort for this gap size.
    while gap > 0:
        for i in range(gap, n):
            # Save the current element to be compared
            temp = arr[i]
            j = i
            
            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            
            # Put temp (the original arr[i]) in its correct location
            arr[j] = temp
        
        gap //= 2  # Reduce the gap for the next element

    return arr

# Test the function with the provided assertion
assert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]"
MBPP/430,parabola_directrix,"def parabola_directrix(a, h, k):
    # Calculate p
    p = 1 / (4 * a)
    # Calculate the directrix
    directrix = k - p
    return directrix

# Test the function with the provided assertion
assert parabola_directrix(5, 3, 2) == -198"
MBPP/437,remove_odd,"def remove_odd(s):
    return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)

# Test the function with the provided assertion
assert remove_odd(""python"") == ""yhn"""
MBPP/436,neg_nos,"def neg_nos(numbers):
    # Extract negative numbers from the list
    negative_numbers = [num for num in numbers if num < 0]
    
    # Print the negative numbers
    for num in negative_numbers:
        print(num)
    
    # Return the negative numbers as a tuple
    return tuple(negative_numbers)

# Example usage
result = neg_nos([-1, 4, 5, -6])
assert result == (-1, -6)"
MBPP/434,text_match_one,"import re

def text_match_one(text):
    # Define the regex pattern for 'a' followed by one or more 'b's
    pattern = r'a+b+'
    
    # Use re.fullmatch to check if the entire string matches the pattern
    if re.fullmatch(pattern, text):
        return 'Matched!'
    else:
        return 'Not matched!'

# Test the function with the provided assertion
assert text_match_one(""ac"") == 'Not matched!'"
MBPP/441,surfacearea_cube,"def surfacearea_cube(side_length):
    """"""Calculate the surface area of a cube given the length of its side.""""""
    return 6 * (side_length ** 2)

# Test the function with the provided assertion
assert surfacearea_cube(5) == 150"
MBPP/443,largest_neg,"def largest_neg(numbers):
    # Filter out the negative numbers from the list
    negative_numbers = [num for num in numbers if num < 0]
    
    # Return the largest negative number or None if there are no negative numbers
    return max(negative_numbers) if negative_numbers else None

# Test the function with the provided assertion
assert largest_neg([1, 2, 3, -4, -6]) == -6"
MBPP/447,cube_nums,"def cube_nums(nums):
    return list(map(lambda x: x ** 3, nums))

# Test the function with the provided assertion
assert cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]"
MBPP/440,find_adverb_position,"import nltk
from nltk import pos_tag
from nltk.tokenize import word_tokenize

# Make sure to download the necessary NLTK resources
nltk.download('punkt')
nltk.download('averaged_perceptron_tagger')

def find_adverb_position(sentence):
    # Tokenize the sentence into words
    words = word_tokenize(sentence)
    # Get the part-of-speech tags for each word
    tagged_words = pos_tag(words)
    
    # List to hold the positions and adverbs
    adverbs = []
    
    # Iterate through the tagged words
    for index, (word, tag) in enumerate(tagged_words):
        # Check if the tag indicates an adverb
        if tag in ('RB', 'RBR', 'RBS'):
            adverbs.append((index, word))
    
    return adverbs

# Example usage
result = find_adverb_position(""clearly!! we can see the sky"")
print(result)  # Output should be [(0, 'clearly')]"
MBPP/445,index_multiplication,"def index_multiplication(tuple1, tuple2):
    # Use a generator expression to multiply corresponding elements
    return tuple((a * b for a, b in zip(t1, t2)) for t1, t2 in zip(tuple1, tuple2))

# Test the function with the provided assertion
assert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 21), (12, 45), (2, 9), (7, 30))"
MBPP/442,positive_count,"def positive_count(arr):
    if not arr:  # Check for empty array
        return 0.0
    
    positive_numbers = sum(1 for x in arr if x > 0)  # Count positive numbers
    total_numbers = len(arr)  # Total numbers in the array
    
    return positive_numbers / total_numbers  # Calculate the ratio

# Test the function with the provided assertion
assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]) == 0.54"
MBPP/439,multiple_to_single,"def multiple_to_single(int_list):
    # Convert each integer to a string and join them together
    concatenated_string = ''.join(map(str, int_list))
    # Convert the concatenated string back to an integer
    return int(concatenated_string)

# Test the function with the provided assertion
assert multiple_to_single([11, 33, 50]) == 113350"
MBPP/450,extract_string,"def extract_string(string_list, size):
    return [s for s in string_list if len(s) == size]

# Test the function with the provided assertion
assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'], 8) == ['practice', 'solution']"
MBPP/444,trim_tuple,"def trim_tuple(tuple_list, k):
    # Trim each tuple by k
    trimmed_list = [t[k:] if len(t) > k else () for t in tuple_list]
    return trimmed_list

# Test the function with the provided assertion
assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2) == [(2,), (9,), (2,), (2,)]"
MBPP/438,count_bidirectional,"def count_bidirectional(tuples_list):
    # Create a set to store unique pairs
    seen_pairs = set()
    count = 0
    
    for a, b in tuples_list:
        # Create a bidirectional pair
        pair = (a, b)
        reverse_pair = (b, a)
        
        # Check if the reverse pair is already in the set
        if reverse_pair in seen_pairs:
            count += 1
        
        # Add the current pair to the set
        seen_pairs.add(pair)
    
    return str(count)

# Test the function with the provided assertion
assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)]) == '3'"
MBPP/451,remove_whitespaces,"import re

def remove_whitespaces(input_string):
    # Use regex to replace all whitespace characters with an empty string
    return re.sub(r'\s+', '', input_string)

# Test the function with the provided assertion
assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'"
MBPP/446,count_Occurrence,"def count_Occurrence(tup, lst):
    count = 0
    for item in lst:
        count += tup.count(item)
    return count

# Test the function with the provided assertion
assert count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b']) == 3"
MBPP/453,sumofFactors,"def sumofFactors(n):
    even_sum = 0
    for i in range(1, n + 1):
        if n % i == 0 and i % 2 == 0:  # Check if i is a factor and even
            even_sum += i
    return even_sum

# Test the function with the provided assertion
assert sumofFactors(18) == 26"
MBPP/448,cal_sum,"def cal_sum(n):
    if n < 0:
        return 0
    elif n == 0:
        return 3
    elif n == 1:
        return 3  # P(0)
    elif n == 2:
        return 3 + 0 + 2  # P(0) + P(1) + P(2)

    # Initialize the first three Perrin numbers
    perrin_numbers = [3, 0, 2]
    
    # Calculate Perrin numbers up to P(n)
    for i in range(3, n + 1):
        next_perrin = perrin_numbers[i - 2] + perrin_numbers[i - 3]
        perrin_numbers.append(next_perrin)

    # Return the sum of the first n Perrin numbers
    return sum(perrin_numbers[:n + 1])

# Test the function with the provided assertion
assert cal_sum(9) == 49"
MBPP/456,reverse_string_list,"def reverse_string_list(string_list):
    return [s[::-1] for s in string_list]

# Test the function with the provided assertion
assert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black']) == ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']"
MBPP/452,loss_amount,"def loss_amount(original_amount, current_amount):
    if current_amount < original_amount:
        return original_amount - current_amount
    return None

# Example usage
assert loss_amount(1500, 1200) == 300
assert loss_amount(1500, 1500) == None"
MBPP/455,check_monthnumb_number,"def check_monthnumb_number(month):
    # List of months with 31 days
    months_with_31_days = {1, 3, 5, 7, 8, 10, 12}
    
    # Check if the month number is in the set of months with 31 days
    return month in months_with_31_days

# Test the function with the provided assertion
assert check_monthnumb_number(5) == True"
MBPP/454,text_match_wordz,"import re

def text_match_wordz(text):
    # Use regex to search for a word containing 'z'
    if re.search(r'\b\w*z\w*\b', text):
        return 'Found a match!'
    else:
        return 'No match found.'

# Test the function
assert text_match_wordz(""pythonz."") == 'Found a match!'"
MBPP/449,check_Triangle,"def check_Triangle(x1, y1, x2, y2, x3, y3):
    # Calculate the area using the determinant method
    area = 0.5 * abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))
    
    # If the area is greater than zero, the points form a valid triangle
    if area > 0:
        return 'Yes'
    else:
        return 'No'

# Test the function with the provided assertion
assert check_Triangle(1, 5, 2, 5, 4, 6) == 'Yes'"
MBPP/458,rectangle_area,"def rectangle_area(length, width):
    return length * width

# Test the function with the provided assertion
assert rectangle_area(10, 20) == 200"
MBPP/459,remove_uppercase,"import re

def remove_uppercase(s):
    # Use regex to replace uppercase substrings with an empty string
    return re.sub(r'[A-Z]+', '', s)

# Test the function with the provided assertion
assert remove_uppercase('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'"
MBPP/461,upper_ctr,"def upper_ctr(s):
    return sum(1 for char in s if char.isupper())

# Test the function with the provided assertion
assert upper_ctr('PYthon') == 1"
MBPP/460,Extract,"def Extract(sublists):
    return [sublist[0] for sublist in sublists]

# Test the function with the provided assertion
assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]"
MBPP/465,drop_empty,"def drop_empty(input_dict):
    return {key: value for key, value in input_dict.items() if value is not None}

# Test the function with the provided assertion
assert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3': None}) == {'c1': 'Red', 'c2': 'Green'}"
MBPP/464,check_value,"def check_value(d, value):
    # Check if all values in the dictionary are the same as the provided value
    return all(v == value for v in d.values())

# Example assertion
assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12}, 10) == False"
MBPP/467,decimal_to_Octal,"def decimal_to_octal(decimal_number):
    # Convert decimal to octal and remove the '0o' prefix
    return int(oct(decimal_number)[2:])

# Test the function with the provided assertion
assert decimal_to_octal(10) == 12

# You can also test the function with other values
print(decimal_to_octal(8))   # Output: 10
print(decimal_to_octal(15))  # Output: 17
print(decimal_to_octal(64))  # Output: 100"
MBPP/457,Find_Min,"def Find_Min(lists):
    # Check if the input list is empty
    if not lists:
        return []
    
    # Initialize the minimum length and the corresponding sublist
    min_length = float('inf')
    min_sublist = None
    
    # Iterate through each sublist
    for sublist in lists:
        # Update the minimum length and sublist if a shorter one is found
        if len(sublist) < min_length:
            min_length = len(sublist)
            min_sublist = sublist
            
    return min_sublist

# Test the function with the provided assertion
assert Find_Min([[1], [1, 2], [1, 2, 3]]) == [1]"
MBPP/466,find_peak,"def find_peak(arr, n):
    if n == 1:
        return 0  # The only element is the peak
    
    if arr[0] >= arr[1]:
        return 0  # The first element is a peak
    
    if arr[n - 1] >= arr[n - 2]:
        return n - 1  # The last element is a peak
    
    for i in range(1, n - 1):
        if arr[i] >= arr[i - 1] and arr[i] >= arr[i + 1]:
            return i  # Found a peak
    
    return -1  # This line should never be reached if the input is valid

# Test the function with the provided assertion
assert find_peak([1, 3, 20, 4, 1, 0], 6) == 2"
MBPP/471,find_remainder,"def find_remainder(arr, length, n):
    product = 1
    for num in arr:
        product *= num
        product %= n  # Take the remainder at each step to prevent overflow
    return product

# Test the function with the provided assertion
assert find_remainder([100, 10, 5, 25, 35, 14], 6, 11) == 9"
MBPP/472,check_Consecutive,"def check_Consecutive(nums):
    if not nums:
        return False
    
    # Sort the list to check for consecutive numbers
    nums = sorted(set(nums))  # Remove duplicates and sort
    for i in range(len(nums) - 1):
        if nums[i] + 1 != nums[i + 1]:
            return False
    return True

# Test the function with the provided assertion
assert check_Consecutive([1, 2, 3, 4, 5]) == True"
MBPP/470,add_pairwise,"def add_pairwise(tup):
    # Use a list comprehension to sum pairs of elements
    return tuple(tup[i] + tup[i + 1] for i in range(len(tup) - 1))

# Test the function with the provided assertion
assert add_pairwise((1, 5, 7, 8, 10)) == (6, 12, 15, 18)

# You can also print the result to verify
print(add_pairwise((1, 5, 7, 8, 10)))  # Output: (6, 12, 15, 18)"
MBPP/474,replace_char,"def replace_char(s, old_char, new_char):
    return s.replace(old_char, new_char)

# Test the function with the provided assertion
assert replace_char(""polygon"", 'y', 'l') == ""pollgon"""
MBPP/463,max_subarray_product,"def max_subarray_product(arr):
    if not arr:
        return 0

    max_product = arr[0]
    min_product = arr[0]
    result = arr[0]

    for i in range(1, len(arr)):
        if arr[i] < 0:
            max_product, min_product = min_product, max_product
        
        max_product = max(arr[i], max_product * arr[i])
        min_product = min(arr[i], min_product * arr[i])
        
        result = max(result, max_product)

    return result

# Test the function with the provided assertion
assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112"
MBPP/473,tuple_intersection,"def tuple_intersection(tuple_list1, tuple_list2):
    # Convert both lists of tuples to sets for easier intersection
    set1 = set(tuple_list1)
    set2 = set(tuple_list2)
    
    # Find the intersection of both sets
    intersection = set1.intersection(set2)
    
    return intersection

# Test the function with the provided assertion
assert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)], [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}"
MBPP/477,is_lower,"def is_lower(input_string):
    return input_string.lower()

# Test the function
assert is_lower(""InValid"") == ""invalid"""
MBPP/476,big_sum,"def big_sum(arr):
    if not arr:  # Check if the array is empty
        return 0
    largest = max(arr)
    smallest = min(arr)
    return largest + smallest

# Test the function with the provided assertion
assert big_sum([1, 2, 3]) == 4"
MBPP/475,sort_counter,"def sort_counter(counter):
    # Sort the counter by value in descending order and return as a list of tuples
    return sorted(counter.items(), key=lambda item: item[1], reverse=True)

# Test the function with the provided assertion
assert sort_counter({'Math': 81, 'Physics': 83, 'Chemistry': 87}) == [('Chemistry', 87), ('Physics', 83), ('Math', 81)]"
MBPP/468,max_product,"def max_product(arr, n):
    if n == 0:
        return 0
    
    # Initialize the max_product array
    max_prod = [0] * n
    
    # Each element is a subsequence of length 1
    for i in range(n):
        max_prod[i] = arr[i]
    
    # Compute the maximum product for increasing subsequences
    for i in range(1, n):
        for j in range(i):
            if arr[i] > arr[j]:  # Check if it's an increasing subsequence
                max_prod[i] = max(max_prod[i], max_prod[j] * arr[i])
    
    # The result is the maximum value in max_prod
    return max(max_prod)

# Test the function with the provided assertion
assert max_product([3, 100, 4, 5, 150, 6], 6) == 45000"
MBPP/478,remove_lowercase,"def remove_lowercase(s):
    # Use a list comprehension to filter out lowercase characters
    result = ''.join([char for char in s if not char.islower()])
    return result

# Test the function with the provided assertion
assert remove_lowercase(""PYTHon"") == 'PYTH'"
MBPP/469,max_profit,"def max_profit(prices, k):
    if not prices or k == 0:
        return 0
    
    n = len(prices)
    
    # If k is greater than half the number of days, we can make as many transactions as we want
    if k >= n // 2:
        return sum(max(prices[i + 1] - prices[i], 0) for i in range(n - 1))
    
    # Create a DP table
    dp = [[0] * n for _ in range(k + 1)]
    
    for i in range(1, k + 1):
        max_diff = -prices[0]
        for j in range(1, n):
            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)
            max_diff = max(max_diff, dp[i - 1][j] - prices[j])
    
    return dp[k][n - 1]

# Test the function with the provided assertion
assert max_profit([1, 5, 2, 3, 7, 6, 4, 5], 3) == 10"
MBPP/480,get_max_occuring_char,"def get_max_occuring_char(s):
    # Create a dictionary to count occurrences of each character
    char_count = {}
    
    # Count each character in the string
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
            
    # Find the character with the maximum count
    max_char = ''
    max_count = 0
    for char, count in char_count.items():
        if count > max_count:
            max_count = count
            max_char = char
            
    return max_char

# Test the function with the provided assertion
assert get_max_occuring_char(""data"") == ""a"""
MBPP/482,match,"import re

def match(s):
    # Define the regex pattern for one uppercase letter followed by lowercase letters
    pattern = r'^[A-Z][a-z]*$'
    
    # Use re.match to check if the entire string matches the pattern
    if re.match(pattern, s):
        return 'Yes'
    else:
        return 'No'

# Test the function with the provided assertion
assert match(""Geeks"") == 'Yes'"
MBPP/485,largest_palindrome,"def is_palindrome(num):
    """"""Check if a number is a palindrome.""""""
    return str(num) == str(num)[::-1]

def largest_palindrome(arr, n):
    """"""Find the largest palindromic number in the given array.""""""
    palindromes = [num for num in arr if is_palindrome(num)]
    return max(palindromes) if palindromes else None

# Test the function with the provided assertion
assert largest_palindrome([1, 232, 54545, 999991], 4) == 54545"
MBPP/484,remove_matching_tuple,"def remove_matching_tuple(tuple1, tuple2):
    # Convert the second tuple to a set for faster lookup
    set_tuple2 = set(tuple2)
    # Use a list comprehension to filter out matching tuples
    return [item for item in tuple1 if item not in set_tuple2]

# Test the function with the provided assertion
assert remove_matching_tuple([('Hello', 'dude'), ('How', 'are'), ('you', '?')], [('Hello', 'dude'), ('How', 'are')]) == [('you', '?')]"
MBPP/462,combinations_list,"from itertools import combinations

def combinations_list(elements):
    result = []
    n = len(elements)
    
    # Generate combinations for all lengths from 0 to n
    for r in range(n + 1):
        for combo in combinations(elements, r):
            result.append(list(combo))
    
    return result

# Test the function with the provided assertion
assert combinations_list(['orange', 'red', 'green', 'blue']) == [
    [], 
    ['orange'], 
    ['red'], 
    ['red', 'orange'], 
    ['green'], 
    ['green', 'orange'], 
    ['green', 'red'], 
    ['green', 'red', 'orange'], 
    ['blue'], 
    ['blue', 'orange'], 
    ['blue', 'red'], 
    ['blue', 'red', 'orange'], 
    ['blue', 'green'], 
    ['blue', 'green', 'orange'], 
    ['blue', 'green', 'red'], 
    ['blue', 'green', 'red', 'orange']
]"
MBPP/487,sort_tuple,"def sort_tuple(tuples_list):
    return sorted(tuples_list, key=lambda x: x[-1])

# Test the function with the provided assertion
assert sort_tuple([(1, 3), (3, 2), (2, 1)]) == [(2, 1), (3, 2), (1, 3)]"
MBPP/486,binomial_probability,"import math

def binomial_probability(n, k, p):
    # Calculate the binomial coefficient
    binomial_coefficient = math.comb(n, k)
    # Calculate the probability
    probability = binomial_coefficient * (p ** k) * ((1 - p) ** (n - k))
    return probability

# Test the function with the provided assertion
assert binomial_probability(10, 5, 1.0/3) == 0.13656454808718185"
MBPP/483,first_Factorial_Divisible_Number,"def first_Factorial_Divisible_Number(x):
    import math
    
    n = 1
    while True:
        factorial = math.factorial(n)
        if factorial % x == 0:
            return n
        n += 1

# Test the function with the provided assertion
assert first_Factorial_Divisible_Number(10) == 5"
MBPP/481,is_subset_sum,"def is_subset_sum(set, n, sum):
    # Create a 2D array to store the results of subproblems
    subset = [[False for _ in range(sum + 1)] for _ in range(n + 1)]
    
    # If sum is 0, then answer is true (empty subset)
    for i in range(n + 1):
        subset[i][0] = True

    # Fill the subset table in a bottom-up manner
    for i in range(1, n + 1):
        for j in range(1, sum + 1):
            if set[i - 1] > j:
                subset[i][j] = subset[i - 1][j]
            else:
                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - set[i - 1]]

    return subset[n][sum]

# Example usage
assert is_subset_sum([3, 34, 4, 12, 5, 2], 6, 9) == True"
MBPP/488,area_pentagon,"import math

def area_pentagon(side_length):
    area = (1/4) * math.sqrt(5 * (5 + 2 * math.sqrt(5))) * (side_length ** 2)
    return area

# Test the function with the provided assertion
assert area_pentagon(5) == 43.01193501472417"
MBPP/489,frequency_Of_Largest,"def frequency_of_largest(n, arr):
    if not arr:
        return 0
    
    largest_value = max(arr)
    frequency = arr.count(largest_value)
    
    return frequency

# Test the function with the provided assertion
assert frequency_of_largest(5, [1, 2, 3, 4, 4]) == 2"
MBPP/491,sum_gp,"def sum_gp(a, n, r):
    if r == 1:
        return a * n  # If the common ratio is 1, the series is just n times the first term
    return a * (r**n - 1) // (r - 1)

# Test the function with the provided assertion
assert sum_gp(1, 5, 2) == 31"
MBPP/494,binary_to_integer,"def binary_to_integer(binary_tuple):
    # Convert the tuple to a string and then to an integer using base 2
    binary_string = ''.join(str(bit) for bit in binary_tuple)
    integer_value = int(binary_string, 2)
    return str(integer_value)

# Test the function with the provided assertion
assert binary_to_integer((1, 1, 0, 1, 0, 0, 1)) == '105'"
MBPP/498,gcd,"def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

# Test the function with the provided assertion
assert gcd(12, 17) == 1"
MBPP/490,extract_symmetric,"def extract_symmetric(tuple_list):
    symmetric_pairs = set()
    seen = set()

    for pair in tuple_list:
        # Add the pair to the seen set
        seen.add(pair)
        # Check for the symmetric pair
        symmetric_pair = (pair[1], pair[0])
        if symmetric_pair in seen:
            symmetric_pairs.add(pair)
            symmetric_pairs.add(symmetric_pair)

    return symmetric_pairs

# Test the function with the provided assertion
assert extract_symmetric([(6, 7), (2, 3), (7, 6), (9, 8), (10, 2), (8, 9)]) == {(8, 9), (6, 7)}"
MBPP/499,diameter_circle,"def diameter_circle(radius):
    """"""Calculate the diameter of a circle given its radius.""""""
    return 2 * radius

# Test the function with the provided assertion
assert diameter_circle(10) == 20"
MBPP/479,first_Digit,"def first_Digit(number):
    # Convert the number to a string and get the first character
    first_digit = str(abs(number))[0]
    return int(first_digit)

# Test the function with the provided assertion
assert first_Digit(123) == 1"
MBPP/495,remove_lowercase,"import re

def remove_lowercase(s):
    # Use regex to replace all lowercase letters with an empty string
    return re.sub(r'[a-z]', '', s)

# Test the function with the provided assertion
assert remove_lowercase('KDeoALOklOOHserfLoAJSIskdsf') == 'KDALOOOHLAJSI'

# You can also add more test cases to verify the function
print(remove_lowercase('KDeoALOklOOHserfLoAJSIskdsf'))  # Output: KDALOOOHLAJSI
print(remove_lowercase('HelloWorld'))  # Output: HWD
print(remove_lowercase('PythonIsFun'))  # Output: PIF"
MBPP/500,concatenate_elements,"def concatenate_elements(elements):
    return ' ' + ' '.join(elements)

# Test the function with the provided assertion
assert concatenate_elements(['hello', 'there', 'have', 'a', 'rocky', 'day']) == ' hello there have a rocky day'"
MBPP/492,binary_search,"def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return True
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
            
    return False

# Test the function with the provided assertion
assert binary_search([1, 2, 3, 5, 8], 6) == False"
MBPP/502,find,"def find(a, b):
    return a % b

# Test the function with the provided assertion
assert find(3, 3) == 0"
MBPP/501,num_comm_div,"def num_comm_div(a, b):
    """"""Return the greatest common divisor of a and b.""""""
    while b:
        a, b = b, a % b
    return a

# Test the function with the provided assertion
assert num_comm_div(2, 4) == 2"
MBPP/497,surfacearea_cone,"import math

def surfacearea_cone(radius, height):
    # Calculate the slant height
    slant_height = math.sqrt(radius**2 + height**2)
    # Calculate the surface area
    surface_area = math.pi * radius * (radius + slant_height)
    return surface_area

# Test the function with the provided assertion
assert surfacearea_cone(5, 12) == 282.7433388230814"
MBPP/496,heap_queue_smallest,"import heapq

def heap_queue_smallest(numbers, n):
    """"""
    Find the smallest n integers from a given list of numbers using heap queue algorithm.

    :param numbers: List of integers
    :param n: Number of smallest integers to find
    :return: List of the smallest n integers
    """"""
    return heapq.nsmallest(n, numbers)

# Example usage
assert heap_queue_smallest([25, 35, 22, 85, 14, 65, 75, 25, 58], 3) == [14, 22, 25]"
MBPP/504,sum_Of_Series,"def sum_Of_Series(n):
    return sum(i**3 for i in range(1, n + 1))

# Test the function
assert sum_Of_Series(5) == 225"
MBPP/505,re_order,"def re_order(arr):
    # Initialize a new list to hold non-zero elements
    non_zeroes = [num for num in arr if num != 0]
    # Count the number of zeroes
    zeroes_count = arr.count(0)
    # Extend the non-zero list with the zeroes
    return non_zeroes + [0] * zeroes_count

# Test the function with the provided assertion
assert re_order([6, 0, 8, 2, 3, 0, 4, 0, 1]) == [6, 8, 2, 3, 4, 1, 0, 0, 0]"
MBPP/507,remove_words,"def remove_words(original_list, words_to_remove):
    return [word for word in original_list if word not in words_to_remove]

# Test the function with the provided assertion
assert remove_words(['red', 'green', 'blue', 'white', 'black', 'orange'], ['white', 'orange']) == ['red', 'green', 'blue', 'black']"
MBPP/509,average_Odd,"def average_Odd(n):
    if n % 2 == 0:
        raise ValueError(""Input must be an odd number."")
    
    # Calculate the sum of odd numbers and the count of odd numbers
    total_sum = 0
    count = 0
    
    for i in range(1, n + 1, 2):  # Iterate through odd numbers only
        total_sum += i
        count += 1
    
    # Calculate the average
    average = total_sum / count
    return average

# Test the function
assert average_Odd(9) == 5"
MBPP/503,add_consecutive_nums,"def add_consecutive_nums(nums):
    if not nums:
        return []
    
    result = []
    current_sum = nums[0]
    
    for i in range(1, len(nums)):
        current_sum += nums[i]
        result.append(current_sum)
    
    # Prepend the first element to the result
    result.insert(0, nums[0])
    
    return result

# Test the function with the provided assertion
assert add_consecutive_nums([1, 1, 3, 4, 4, 5, 6, 7]) == [2, 4, 7, 8, 9, 11, 13]"
MBPP/508,same_order,"def same_order(list1, list2):
    # Find common elements
    common_elements = [item for item in list1 if item in list2]
    
    # Check if the order of common elements is the same in both lists
    index_list1 = [list1.index(item) for item in common_elements]
    index_list2 = [list2.index(item) for item in common_elements]
    
    return index_list1 == index_list2

# Test the function with the provided assertion
assert same_order([""red"", ""green"", ""black"", ""orange""], [""red"", ""pink"", ""green"", ""white"", ""black""]) == True"
MBPP/513,add_str,"def add_str(tup, string):
    result = []
    for element in tup:
        result.append(element)
        result.append(string)
    return result

# Test the function with the provided assertion
assert add_str((5, 6, 7, 4, 9), ""FDF"") == [5, 'FDF', 6, 'FDF', 7, 'FDF', 4, 'FDF', 9, 'FDF']"
MBPP/512,count_element_freq,"def count_element_freq(nested_tuple):
    frequency = {}

    def count_elements(t):
        for element in t:
            if isinstance(element, tuple):
                count_elements(element)  # Recursively count elements in the nested tuple
            else:
                if element in frequency:
                    frequency[element] += 1
                else:
                    frequency[element] = 1

    count_elements(nested_tuple)
    return frequency

# Test the function with the provided assertion
assert count_element_freq((5, 6, (5, 6), 7, (8, 9), 9)) == {5: 2, 6: 2, 7: 1, 8: 1, 9: 2}"
MBPP/511,find_Min_Sum,"def find_Min_Sum(n):
    # Function to find all factors of n
    def get_factors(num):
        factors = []
        for i in range(1, int(num**0.5) + 1):
            if num % i == 0:
                factors.append(i)
                if i != num // i:  # Avoid adding the square root twice
                    factors.append(num // i)
        return factors

    # Get all factors of n
    factors = get_factors(n)
    
    # Calculate the sum of factors
    min_sum = sum(factors)
    
    return min_sum

# Test the function with the provided assertion
assert find_Min_Sum(12) == 28  # The factors of 12 are 1, 2, 3, 4, 6, 12, and their sum is 28"
MBPP/517,largest_pos,"def largest_pos(numbers):
    # Initialize the largest positive number to None
    largest = None
    
    # Iterate through the list of numbers
    for num in numbers:
        # Check if the number is positive and larger than the current largest
        if num > 0 and (largest is None or num > largest):
            largest = num
            
    return largest

# Test the function with the provided assertion
assert largest_pos([1, 2, 3, 4, -1]) == 4"
MBPP/514,sum_elements,"def sum_elements(tup):
    """"""Returns the summation of elements in the given tuple.""""""
    return sum(tup)

# Test the function with the provided assertion
assert sum_elements((7, 8, 9, 1, 10, 7)) == 42

# You can also test the function with other tuples
print(sum_elements((1, 2, 3)))  # Output: 6
print(sum_elements((0, 0, 0)))  # Output: 0
print(sum_elements((-1, -2, -3)))  # Output: -6"
MBPP/518,sqrt_root,"import math

def sqrt_root(n):
    # Check if the number is a perfect square
    if n < 0:
        raise ValueError(""Cannot compute the square root of a negative number."")
    
    root = math.isqrt(n)  # Use integer square root to avoid floating point issues
    if root * root == n:
        return root
    else:
        raise ValueError(f""{n} is not a perfect square."")

# Test the function with the provided assertion
assert sqrt_root(4) == 2"
MBPP/510,no_of_subsequences,"def no_of_subsequences(arr, k):
    def count_subsequences(index, product):
        # If the product is already greater than or equal to k, return 0
        if product >= k:
            return 0
        # If we have considered all elements, return 1 (the empty subsequence)
        if index == len(arr):
            return 1
        
        # Count subsequences including the current element
        include_current = count_subsequences(index + 1, product * arr[index])
        # Count subsequences excluding the current element
        exclude_current = count_subsequences(index + 1, product)
        
        return include_current + exclude_current

    # Start counting from index 0 and initial product 1
    return count_subsequences(0, 1) - 1  # Subtract 1 to exclude the empty subsequence

# Test the function with the provided assertion
assert no_of_subsequences([1, 2, 3, 4], 10) == 11"
MBPP/516,radix_sort,"def counting_sort(arr, exp):
    n = len(arr)
    output = [0] * n  # Output array
    count = [0] * 10  # Count array for digits 0-9

    # Count occurrences of each digit in the current exponent
    for i in range(n):
        index = (arr[i] // exp) % 10
        count[index] += 1

    # Change count[i] so that it contains the actual position of this digit in output[]
    for i in range(1, 10):
        count[i] += count[i - 1]

    # Build the output array
    for i in range(n - 1, -1, -1):
        index = (arr[i] // exp) % 10
        output[count[index] - 1] = arr[i]
        count[index] -= 1

    # Copy the output array to arr[], so that arr[] now contains sorted numbers
    for i in range(n):
        arr[i] = output[i]

def radix_sort(arr):
    # Find the maximum number to know the number of digits
    max_num = max(arr)

    # Do counting sort for every digit
    exp = 1
    while max_num // exp > 0:
        counting_sort(arr, exp)
        exp *= 10

    return arr

# Test the function
assert radix_sort([15, 79, 25, 68, 37]) == [15, 25, 37, 68, 79]"
MBPP/521,check_isosceles,"def check_scalene(a, b, c):
    """"""
    Check if a triangle with sides a, b, and c is scalene.
    
    A scalene triangle has all sides of different lengths.
    
    Parameters:
    a (int or float): Length of side a
    b (int or float): Length of side b
    c (int or float): Length of side c
    
    Returns:
    bool: True if the triangle is scalene, False otherwise
    """"""
    return a != b and b != c and a != c

# Test the function with an assertion
assert check_scalene(6, 8, 12) == True"
MBPP/515,modular_sum,"def modular_sum(arr, n, m):
    # Create a boolean array to store the possible sums modulo m
    dp = [False] * m
    dp[0] = True  # A sum of 0 is always possible (the empty subset)

    for num in arr:
        # Update the dp array in reverse to avoid using the same element multiple times
        for j in range(m - 1, -1, -1):
            if dp[j]:
                new_sum = (j + num) % m
                dp[new_sum] = True

    return dp[0]  # Return True if a sum divisible by m is found

# Test the function with the provided assertion
assert modular_sum([3, 1, 7, 5], 4, 6) == True"
MBPP/519,volume_tetrahedron,"import math

def volume_tetrahedron(a):
    return (a ** 3) / (6 * math.sqrt(2))

# Test the function with the provided assertion
assert round(volume_tetrahedron(10), 2) == 117.85"
MBPP/523,check_string,"def check_string(s):
    checks = [
        (lambda s: any(c.isupper() for c in s), 'String must have 1 upper case character.'),
        (lambda s: any(c.islower() for c in s), 'String must have 1 lower case character.'),
        (lambda s: any(c.isdigit() for c in s), 'String must have 1 number.'),
        (lambda s: len(s) >= 8, 'String length should be at least 8.')
    ]
    
    errors = [message for check, message in checks if not check(s)]
    return errors

# Example usage
assert check_string('python') == ['String must have 1 upper case character.', 'String must have 1 number.', 'String length should be at least 8.']"
MBPP/520,get_lcm,"import math
from functools import reduce

def lcm(a, b):
    return abs(a * b) // math.gcd(a, b)

def get_lcm(arr):
    return reduce(lcm, arr)

# Test the function with the provided assertion
assert get_lcm([2, 7, 3, 9, 4]) == 252"
MBPP/526,capitalize_first_last_letters,"def capitalize_first_last_letters(s):
    words = s.split()
    capitalized_words = []
    
    for word in words:
        if len(word) > 1:
            capitalized_word = word[0].upper() + word[1:-1] + word[-1].upper()
        elif len(word) == 1:
            capitalized_word = word.upper()
        else:
            capitalized_word = word  # In case of empty string
        capitalized_words.append(capitalized_word)
    
    return ' '.join(capitalized_words)

# Test the function with the provided assertion
assert capitalize_first_last_letters(""python"") == ""PythoN"""
MBPP/528,min_length,"def min_length(lists):
    # Check if the input list is empty
    if not lists:
        return (0, [])
    
    # Initialize minimum length and the corresponding list
    min_len = float('inf')
    min_list = []

    for lst in lists:
        if len(lst) < min_len:
            min_len = len(lst)
            min_list = lst

    return (min_len, min_list)

# Test the function with the provided assertion
assert min_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (1, [0])"
MBPP/529,jacobsthal_lucas,"def jacobsthal_lucas(n):
    if n == 0:
        return 2
    elif n == 1:
        return 1
    else:
        a, b = 2, 1
        for _ in range(2, n + 1):
            a, b = b, b + 2 * a
        return b

# Test the function with the provided assertion
assert jacobsthal_lucas(5) == 31"
MBPP/530,negative_count,"def negative_count(arr):
    if not arr:  # Check for empty array
        return 0.0
    
    negative_numbers = sum(1 for x in arr if x < 0)
    total_numbers = len(arr)
    
    return round(negative_numbers / total_numbers, 2)

# Test the function with the provided assertion
assert negative_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]) == 0.31"
MBPP/522,lbs,"def longest_increasing_subsequence(arr):
    n = len(arr)
    lis = [1] * n
    
    for i in range(1, n):
        for j in range(i):
            if arr[i] > arr[j]:
                lis[i] = max(lis[i], lis[j] + 1)
    
    return lis

def longest_decreasing_subsequence(arr):
    n = len(arr)
    lds = [1] * n
    
    for i in range(n - 2, -1, -1):
        for j in range(n - 1, i, -1):
            if arr[i] > arr[j]:
                lds[i] = max(lds[i], lds[j] + 1)
    
    return lds

def lbs(arr):
    if not arr:
        return 0
    
    n = len(arr)
    lis = longest_increasing_subsequence(arr)
    lds = longest_decreasing_subsequence(arr)
    
    max_length = 0
    for i in range(n):
        max_length = max(max_length, lis[i] + lds[i] - 1)
    
    return max_length

# Test the function with the provided assertion
assert lbs([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]) == 7"
MBPP/532,check_permutation,"def check_permutation(str1, str2):
    # If the lengths of the strings are not the same, they cannot be permutations
    if len(str1) != len(str2):
        return False
    
    # Sort both strings and compare
    return sorted(str1) == sorted(str2)

# Test the function with the provided assertion
assert check_permutation(""abc"", ""cba"") == True"
MBPP/527,get_pairs_count,"def get_pairs_count(arr, n, target_sum):
    count = 0
    # Create a dictionary to store the frequency of each number
    num_count = {}
    
    for num in arr:
        # Calculate the complement that we need to find
        complement = target_sum - num
        
        # If the complement exists in the dictionary, it means we found pairs
        if complement in num_count:
            count += num_count[complement]
        
        # Update the frequency of the current number in the dictionary
        if num in num_count:
            num_count[num] += 1
        else:
            num_count[num] = 1
            
    return count

# Test the function with the provided assertion
assert get_pairs_count([1, 5, 7, -1, 5], 5, 6) == 3"
MBPP/506,permutation_coefficient,"import math

def permutation_coefficient(n, k):
    if k > n:
        return 0  # If k is greater than n, permutations are not possible
    return math.factorial(n) // math.factorial(n - k)

# Test the function with the provided assertion
assert permutation_coefficient(10, 2) == 90"
MBPP/533,remove_datatype,"def remove_datatype(input_tuple, data_type):
    return [item for item in input_tuple if not isinstance(item, data_type)]

# Example usage
assert remove_datatype((4, 5, 4, 7.7, 1.2), int) == [7.7, 1.2]"
MBPP/534,search_literal,"def search_literal(pattern, text):
    start_index = text.find(pattern)
    if start_index == -1:
        return None  # Return None if the pattern is not found
    end_index = start_index + len(pattern)
    return (start_index, end_index)

# Test the function with the provided assertion
assert search_literal('python', 'python programming language') == (0, 6)"
MBPP/531,min_coins,"def min_coins(coins, num_coins, value):
    # Initialize a list to store the minimum coins for each value
    dp = [float('inf')] * (value + 1)
    dp[0] = 0  # Base case: 0 coins are needed to make the value 0

    # Iterate through each coin
    for coin in coins:
        # Update the dp array for values from coin to value
        for v in range(coin, value + 1):
            dp[v] = min(dp[v], dp[v - coin] + 1)

    # If dp[value] is still infinity, it means it's not possible to form that value
    return dp[value] if dp[value] != float('inf') else -1

# Test the function with the provided assertion
assert min_coins([9, 6, 5, 1], 4, 11) == 2"
MBPP/536,nth_items,"def nth_items(lst, n):
    return lst[::n]

# Test the function with the provided assertion
assert nth_items([1, 2, 3, 4, 5, 6, 7, 8, 9], 2) == [1, 3, 5, 7, 9]"
MBPP/537,first_repeated_word,"def first_repeated_word(s):
    words = s.split()
    seen = set()
    
    for word in words:
        if word in seen:
            return word
        seen.add(word)
    
    return None  # Return None if no repeated word is found

# Test the function with the provided assertion
assert first_repeated_word(""ab ca bc ab"") == ""ab"""
MBPP/538,string_list_to_tuple,"def string_list_to_tuple(input_string):
    # Convert the string to a tuple of its characters
    return tuple(input_string)

# Test the function with the provided assertion
assert string_list_to_tuple(""python 3.0"") == ('p', 'y', 't', 'h', 'o', 'n', ' ', '3', '.', '0')"
MBPP/541,check_abundant,"def check_abundant(n):
    if n < 1:
        return False
    
    # Calculate the sum of proper divisors
    sum_of_divisors = sum(i for i in range(1, n) if n % i == 0)
    
    # Check if the sum of divisors is greater than the number
    return sum_of_divisors > n

# Test the function with the provided assertion
assert check_abundant(12) == True"
MBPP/540,find_Diff,"from collections import Counter

def find_Diff(arr, n):
    # Count the frequency of each element in the array
    frequency = Counter(arr)
    
    # Get the frequencies
    freq_values = list(frequency.values())
    
    # Calculate the difference between the highest and least frequencies
    if freq_values:
        max_freq = max(freq_values)
        min_freq = min(freq_values)
        return max_freq - min_freq
    else:
        return 0  # If the array is empty, return 0

# Test the function with the provided assertion
assert find_Diff([1, 1, 2, 2, 7, 8, 4, 5, 1, 4], 10) == 2"
MBPP/542,fill_spaces,"import re

def fill_spaces(input_string):
    # Use regex to replace spaces, commas, or dots with a colon
    return re.sub(r'[ ,.]', ':', input_string)

# Test the function with the provided assertion
assert fill_spaces('Boult Curve Wireless Neckband') == 'Boult:Curve:Wireless:Neckband'"
MBPP/544,flatten_tuple,"def flatten_tuple(tuple_list):
    # Flatten the list of tuples and join the elements into a single string
    return ' '.join(item for tup in tuple_list for item in tup)

# Test the function with the provided assertion
assert flatten_tuple([('1', '4', '6'), ('5', '8'), ('2', '9'), ('1', '10')]) == '1 4 6 5 8 2 9 1 10'"
MBPP/543,count_digits,"def count_digits(num1, num2):
    # Calculate the sum of the two numbers
    total = num1 + num2
    # Convert the sum to a string and count the number of digits
    num_digits = len(str(total))
    return num_digits

# Test the function with the provided assertion
assert count_digits(9875, 10) == 4

# You can also print the result if needed
print(count_digits(9875, 10))  # Output: 4"
MBPP/546,last_occurence_char,"def last_occurrence_char(s, char):
    """"""Return the last occurrence index of char in string s.""""""
    return s.rfind(char)

# Test the function with the provided assertion
assert last_occurrence_char(""hello world"", 'l') == 10"
MBPP/539,basesnum_coresspondingnum,"def basesnum_coresspondingnum(bases, exponents):
    return list(map(lambda base, exp: base ** exp, bases, exponents))

# Test the function with the provided assertion
assert basesnum_coresspondingnum([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 
                                  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [
    10, 400, 27000, 2560000, 312500000, 46656000000, 
    8235430000000, 1677721600000000, 387420489000000000, 
    100000000000000000000
]"
MBPP/548,longest_increasing_subsequence,"def longest_increasing_subsequence(sequence):
    if not sequence:
        return 0

    # Initialize the dp array where dp[i] will hold the length of the longest
    # increasing subsequence that ends with sequence[i]
    dp = [1] * len(sequence)

    # Fill the dp array
    for i in range(1, len(sequence)):
        for j in range(i):
            if sequence[i] > sequence[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    # The length of the longest increasing subsequence will be the maximum value in dp
    return max(dp)

# Test the function with the provided assertion
assert longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60]) == 5"
MBPP/549,odd_Num_Sum,"def odd_Num_Sum(n):
    # Calculate the sum of the fifth power of the first n odd natural numbers
    return sum((2 * i + 1) ** 5 for i in range(n))

# Test the function with the provided assertion
assert odd_Num_Sum(1) == 1"
MBPP/545,toggle_F_and_L_bits,"def toggle_F_and_L_bits(n):
    # Calculate the number of bits in the number
    num_bits = n.bit_length()
    
    # Create masks for the first and last bits
    first_bit_mask = 1 << (num_bits - 1)  # Mask for the first bit
    last_bit_mask = 1                    # Mask for the last bit
    
    # Toggle the first and last bits using XOR
    toggled_n = n ^ (first_bit_mask | last_bit_mask)
    
    return toggled_n

# Test the function with the provided assertion
assert toggle_F_and_L_bits(10) == 3"
MBPP/551,extract_column,"def extract_column(nested_list, column_index):
    return [row[column_index] for row in nested_list]

# Example usage
assert extract_column([[1, 2, 3], [2, 4, 5], [1, 1, 1]], 0) == [1, 2, 1]"
MBPP/553,tuple_to_float,"def tuple_to_float(tup):
    # Convert the tuple to a string and replace the comma with a dot
    float_str = ''.join(map(str, tup)).replace(',', '.')
    # Convert the string to a float
    return float(float_str)

# Test the function
assert tuple_to_float((4, 56)) == 4.56"
MBPP/550,find_Max,"def find_Max(arr, low, high):
    # If the array is not rotated at all
    if high < low:
        return arr[0]
    
    # If there is only one element
    if high == low:
        return arr[low]
    
    mid = (low + high) // 2
    
    # Check if mid is the maximum element
    if mid < high and arr[mid] > arr[mid + 1]:
        return arr[mid]
    
    # Check if mid-1 is the maximum element
    if mid > low and arr[mid] < arr[mid - 1]:
        return arr[mid - 1]
    
    # Decide whether to go to the left half or the right half
    if arr[low] >= arr[mid]:
        return find_Max(arr, low, mid - 1)
    else:
        return find_Max(arr, mid + 1, high)

# Example usage
assert find_Max([2, 3, 5, 6, 9], 0, 4) == 9"
MBPP/547,Total_Hamming_Distance,"def hamming_distance(x, y):
    return bin(x ^ y).count('1')

def Total_Hamming_Distance(n):
    total_distance = 0
    for i in range(n):
        total_distance += hamming_distance(i, i + 1)
    return total_distance

# Test the function with the provided assertion
assert Total_Hamming_Distance(4) == 7

# You can also print the result to verify
print(Total_Hamming_Distance(4))  # Output should be 7"
MBPP/554,Split,"def find_odd_numbers(mixed_list):
    return [num for num in mixed_list if num % 2 != 0]

# Test the function with the provided assertion
assert find_odd_numbers([1, 2, 3, 4, 5, 6]) == [1, 3, 5]"
MBPP/557,toggle_string,"def toggle_string(s):
    return s.swapcase()

# Test the function
assert toggle_string(""Python"") == ""pYTHON"""
MBPP/552,Seq_Linear,"def Seq_Linear(sequence):
    if len(sequence) < 2:
        return ""Linear Sequence""  # A sequence with less than 2 elements is trivially linear

    # Calculate the common difference
    common_difference = sequence[1] - sequence[0]

    # Check if all consecutive differences are the same
    for i in range(1, len(sequence) - 1):
        if sequence[i + 1] - sequence[i] != common_difference:
            return ""Not a Linear Sequence""

    return ""Linear Sequence""

# Test the function with the provided assertion
assert Seq_Linear([0, 2, 4, 6, 8, 10]) == ""Linear Sequence"""
MBPP/556,find_Odd_Pair,"def find_Odd_Pair(arr, n):
    even_count = 0
    odd_count = 0
    
    # Count even and odd numbers
    for num in arr:
        if num % 2 == 0:
            even_count += 1
        else:
            odd_count += 1
            
    # The number of pairs with odd XOR is the product of even and odd counts
    return even_count * odd_count

# Test the function with the provided assertion
assert find_Odd_Pair([5, 4, 7, 2, 1], 5) == 6"
MBPP/558,digit_distance_nums,"def digit_distance_nums(num1, num2):
    # Convert both numbers to strings to access each digit
    str_num1 = str(num1)
    str_num2 = str(num2)
    
    # Pad the shorter number with leading zeros
    max_length = max(len(str_num1), len(str_num2))
    str_num1 = str_num1.zfill(max_length)
    str_num2 = str_num2.zfill(max_length)
    
    # Calculate the digit distance
    distance = sum(abs(int(d1) - int(d2)) for d1, d2 in zip(str_num1, str_num2))
    
    return distance

# Test the function with the provided assertion
assert digit_distance_nums(1, 2) == 1"
MBPP/555,difference,"def difference(n):
    # Calculate the sum of the first n natural numbers
    sum_n = n * (n + 1) // 2
    
    # Calculate the sum of the cubes of the first n natural numbers
    sum_cubes = sum(i**3 for i in range(1, n + 1))
    
    # Find the difference
    return sum_cubes - sum_n

# Test the function with the provided assertion
assert difference(3) == 30"
MBPP/559,max_sub_array_sum,"def max_sub_array_sum(arr, n):
    # Initialize variables
    max_sum = float('-inf')  # To store the maximum sum found
    current_sum = 0          # To store the current subarray sum

    for i in range(n):
        current_sum += arr[i]  # Add the current element to the current sum
        
        # Update max_sum if current_sum is greater
        if current_sum > max_sum:
            max_sum = current_sum
        
        # If current_sum drops below 0, reset it to 0
        if current_sum < 0:
            current_sum = 0

    return max_sum

# Test the function with the provided assertion
assert max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 7"
MBPP/560,union_elements,"def union_elements(tuple1, tuple2):
    # Convert tuples to sets to find the union
    union_set = set(tuple1).union(set(tuple2))
    # Convert the set back to a sorted tuple
    return tuple(sorted(union_set))

# Test the function with the provided assertion
assert union_elements((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 4, 5, 6, 7, 10)"
MBPP/563,extract_values,"import re

def extract_values(s):
    # Use regular expression to find all occurrences of text within double quotes
    return re.findall(r'""(.*?)""', s)

# Test the function with the provided assertion
assert extract_values('""Python"", ""PHP"", ""Java""') == ['Python', 'PHP', 'Java']"
MBPP/565,split,"def split(s):
    return list(s)

# Test the function
assert split('python') == ['p', 'y', 't', 'h', 'o', 'n']"
MBPP/566,sum_digits,"def sum_digits(n):
    if n < 0:
        raise ValueError(""Input must be a non-negative integer."")
    return sum(int(digit) for digit in str(n))

# Test the function with the provided assertion
assert sum_digits(345) == 12"
MBPP/567,issort_list,"def issort_list(lst):
    return lst == sorted(lst)

# Test the function with the provided assertion
assert issort_list([1, 2, 4, 6, 8, 10, 12, 14, 16, 17]) == True"
MBPP/562,Find_Max_Length,"def Find_Max_Length(sublists):
    # Check if the input is a list of lists
    if not all(isinstance(sublist, list) for sublist in sublists):
        raise ValueError(""Input must be a list of lists."")
    
    # Find the maximum length of the sublists
    max_length = max(len(sublist) for sublist in sublists)
    return max_length

# Test the function with the provided assertion
assert Find_Max_Length([[1], [1, 4], [5, 6, 7, 8]]) == 4"
MBPP/564,count_Pairs,"def count_Pairs(arr, n):
    count = 0
    # Iterate through each pair of elements in the array
    for i in range(n):
        for j in range(i + 1, n):
            if arr[i] != arr[j]:
                count += 1
    return count

# Test the function with the provided assertion
assert count_Pairs([1, 2, 1], 3) == 2"
MBPP/568,empty_list,"def empty_list(n):
    return [{} for _ in range(n)]

# Test the function with the provided assertion
assert empty_list(5) == [{}, {}, {}, {}, {}]"
MBPP/569,sort_sublists,"def sort_sublists(list_of_lists):
    return [sorted(sublist) for sublist in list_of_lists]

# Test the function with the provided assertion
assert sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']]) == [['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]"
MBPP/572,two_unique_nums,"def two_unique_nums(lst):
    # Create a dictionary to count occurrences of each number
    count = {}
    
    # Count occurrences of each number in the list
    for num in lst:
        if num in count:
            count[num] += 1
        else:
            count[num] = 1
    
    # Collect numbers that appear only once
    unique_nums = [num for num, cnt in count.items() if cnt == 1]
    
    return unique_nums

# Test the function with the provided assertion
assert two_unique_nums([1, 2, 3, 2, 3, 4, 5]) == [1, 4, 5]"
MBPP/570,remove_words,"def remove_words(strings, to_remove):
    # Create a set of characters/substrings to remove for faster lookup
    to_remove_set = set(to_remove)
    
    # Function to remove unwanted characters/substrings from a single string
    def clean_string(s):
        for item in to_remove_set:
            s = s.replace(item, '')
        return s.strip()  # Remove leading/trailing whitespace

    # Apply the clean_string function to each string in the list
    return [clean_string(s) for s in strings]

# Test the function with the provided assertion
assert remove_words(['Red color', 'Orange#', 'Green', 'Orange @', ""White""], ['#', 'color', '@']) == ['Red', '', 'Green', 'Orange', 'White']"
MBPP/573,unique_product,"def unique_product(numbers):
    unique_numbers = set(numbers)  # Get unique numbers using a set
    product = 1
    for number in unique_numbers:
        product *= number  # Multiply each unique number
    return product

# Test the function with the provided assertion
assert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000"
MBPP/524,max_sum_increasing_subsequence,"def max_sum_increasing_subsequence(arr, n):
    # Create an array to store the maximum sum of increasing subsequence
    max_sum = [0] * n
    
    # Initialize the max_sum array with the values of the original array
    for i in range(n):
        max_sum[i] = arr[i]
    
    # Compute the maximum sum of increasing subsequences
    for i in range(1, n):
        for j in range(i):
            if arr[i] > arr[j] and max_sum[i] < max_sum[j] + arr[i]:
                max_sum[i] = max_sum[j] + arr[i]
    
    # The result is the maximum value in max_sum array
    return max(max_sum)

# Test the function with the provided assertion
assert max_sum_increasing_subsequence([1, 101, 2, 3, 100, 4, 5], 7) == 106"
MBPP/574,surfacearea_cylinder,"import math

def surfacearea_cylinder(radius, height):
    return 2 * math.pi * radius * (height + radius)

# Test the function with the provided assertion
assert surfacearea_cylinder(10, 5) == 942.47798104879  # The expected value is approximately 942.45"
MBPP/535,topbottom_surfacearea,"import math

def topbottom_surfacearea(diameter):
    radius = diameter / 2
    area = math.pi * (radius ** 2)
    return area

# Test the function with the provided assertion
assert topbottom_surfacearea(10) == 314.15000000000003"
MBPP/525,parallel_lines,"def parallel_lines(line1, line2):
    # Unpack the points from the input lists
    x1, y1, x2, y2 = line1[0], line1[1], line1[2], line1[3]
    x3, y3, x4, y4 = line2[0], line2[1], line2[2], line2[3]
    
    # Calculate the slopes of both lines
    # To avoid division by zero, we will compare the cross products instead
    slope1_numerator = y2 - y1
    slope1_denominator = x2 - x1
    slope2_numerator = y4 - y3
    slope2_denominator = x4 - x3
    
    # Check if the slopes are equal using cross multiplication
    return slope1_numerator * slope2_denominator == slope2_numerator * slope1_denominator

# Example usage
assert parallel_lines([2, 3, 4, 5], [2, 3, 8, 9]) == True"
MBPP/576,is_Sub_Array,"def is_Sub_Array(arr1, arr2, len1, len2):
    # Loop through the first array
    for i in range(len1 - len2 + 1):
        # Check if the subarray matches
        if arr1[i:i + len2] == arr2:
            return True
    return False

# Test the function with the provided assertion
assert is_Sub_Array([1, 4, 3, 5], [1, 2], 4, 2) == False"
MBPP/577,last_Digit_Factorial,"def last_Digit_Factorial(n):
    if n < 0:
        raise ValueError(""Factorial is not defined for negative numbers."")
    elif n == 0 or n == 1:
        return 1
    elif n == 2:
        return 2
    elif n == 3:
        return 6
    elif n == 4:
        return 4
    else:
        return 0  # For n >= 5, the last digit of factorial is always 0

# Test the function with the provided assertion
assert last_Digit_Factorial(4) == 4"
MBPP/575,count_no,"def count_no(n, m, start, end):
    count = 0
    for number in range(start, end + 1):
        if number % m != 0:  # Check if the number is not a multiple of m
            count += 1
            if count == n:  # If we have found the nth number
                return number
    return None  # Return None if nth number is not found in the range

# Example usage
assert count_no(2, 3, 1, 10) == 5"
MBPP/571,max_sum_pair_diff_lessthan_K,"def max_sum_pair_diff_lessthan_K(arr, n, k):
    # Sort the array in descending order
    arr.sort(reverse=True)
    
    max_sum = 0
    i = 0
    
    while i < len(arr) - 1:
        # Check if the absolute difference is less than k
        if abs(arr[i] - arr[i + 1]) < k:
            # If it is, we can form a pair
            max_sum += arr[i] + arr[i + 1]
            # Move to the next pair
            i += 2
        else:
            # If not, just move to the next element
            i += 1
            
    return max_sum

# Test the function with the provided assertion
assert max_sum_pair_diff_lessthan_K([3, 5, 10, 15, 17, 12, 9], 7, 4) == 62"
MBPP/578,interleave_lists,"def interleave_lists(*lists):
    # Check if all lists are of the same length
    if not all(len(lst) == len(lists[0]) for lst in lists):
        raise ValueError(""All lists must be of the same length"")
    
    interleaved = []
    for i in range(len(lists[0])):
        for lst in lists:
            interleaved.append(lst[i])
    
    return interleaved

# Test the function with the provided assertion
assert interleave_lists(
    [1, 2, 3, 4, 5, 6, 7],
    [10, 20, 30, 40, 50, 60, 70],
    [100, 200, 300, 400, 500, 600, 700]
) == [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]"
MBPP/579,find_dissimilar,"def find_dissimilar(tuple1, tuple2):
    # Convert tuples to sets to find unique elements
    set1 = set(tuple1)
    set2 = set(tuple2)
    
    # Find elements that are in either set but not in both
    dissimilar_elements = set1.symmetric_difference(set2)
    
    # Convert the result back to a sorted tuple
    return tuple(sorted(dissimilar_elements))

# Test the function with the provided assertion
assert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)"
MBPP/580,extract_even,"def extract_even(nested_tuple):
    if isinstance(nested_tuple, tuple):
        return tuple(extract_even(item) for item in nested_tuple if isinstance(item, int) and item % 2 == 0 or isinstance(item, tuple) and extract_even(item))
    return ()

# Test the function with the provided assertion
assert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)"
MBPP/583,catalan_number,"import math

def catalan_number(n):
    # Calculate the nth Catalan number using the formula
    return math.factorial(2 * n) // (math.factorial(n + 1) * math.factorial(n))

# Test the function
assert catalan_number(10) == 16796"
MBPP/582,my_dict,"def is_empty_dict(d):
    """"""Check if the given dictionary is empty.""""""
    return len(d) == 0

# Example usage and assertion
my_dict = {}
assert is_empty_dict(my_dict) == True  # This should be True since my_dict is empty

my_dict = {10: 'value'}
assert is_empty_dict(my_dict) == False  # This should be False since my_dict is not empty"
MBPP/587,list_tuple,"def list_tuple(lst):
    return tuple(lst)

# Test the function
assert list_tuple([5, 10, 7, 4, 15, 3]) == (5, 10, 7, 4, 15, 3)"
MBPP/561,assign_elements,"def assign_elements(pairs):
    result = {}
    
    # Create the mapping
    for a, b in pairs:
        if a not in result:
            result[a] = []
        if b not in result:
            result[b] = []
        result[a].append(b)
    
    # Ensure all elements are represented in the result
    for a, b in pairs:
        if b not in result:
            result[b] = []
    
    return result

# Test the function with the provided assertion
assert assign_elements([(5, 3), (7, 5), (2, 7), (3, 8), (8, 4)]) == {3: [8], 5: [3], 7: [5], 2: [7], 8: [4], 4: []}"
MBPP/588,big_diff,"def big_diff(arr):
    if not arr:  # Check if the array is empty
        return 0
    return max(arr) - min(arr)

# Test the function with the provided assertion
assert big_diff([1, 2, 3, 4]) == 3"
MBPP/581,surface_Area,"import math

def surface_Area(side, height):
    # Calculate the base area
    base_area = side ** 2
    
    # Calculate the slant height
    slant_height = math.sqrt(height ** 2 + (side / 2) ** 2)
    
    # Calculate the lateral area
    lateral_area = (4 * side * slant_height) / 2
    
    # Total surface area
    total_surface_area = base_area + lateral_area
    
    return total_surface_area

# Test the function with the provided assertion
assert surface_Area(3, 4) == 33"
MBPP/586,split_Arr,"def split_Arr(arr, length, split_index):
    # Split the array into two parts
    first_part = arr[:split_index]
    second_part = arr[split_index:length]
    
    # Combine the second part with the first part
    result = second_part + first_part
    return result

# Test the function with the provided assertion
assert split_Arr([12, 10, 5, 6, 52, 36], 6, 2) == [5, 6, 52, 36, 12, 10]"
MBPP/585,expensive_items,"import heapq

def expensive_items(items, n):
    # Use heapq.nlargest to find the n most expensive items
    return heapq.nlargest(n, items, key=lambda x: x['price'])

# Test the function with the provided assertion
assert expensive_items([{'name': 'Item-1', 'price': 101.1}, {'name': 'Item-2', 'price': 555.22}], 1) == [{'name': 'Item-2', 'price': 555.22}]"
MBPP/589,perfect_squares,"def perfect_squares(start, end):
    """"""Return a list of perfect squares between start and end (inclusive).""""""
    squares = []
    for i in range(int(start**0.5), int(end**0.5) + 1):
        square = i * i
        if start <= square <= end:
            squares.append(square)
    return squares

# Test the function with the provided assertion
assert perfect_squares(1, 30) == [1, 4, 9, 16, 25]"
MBPP/591,swap_List,"def swap_List(lst):
    if len(lst) < 2:
        return lst  # No swap needed for lists with less than 2 elements
    # Swap the first and last elements
    lst[0], lst[-1] = lst[-1], lst[0]
    return lst

# Test the function with the provided assertion
assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]"
MBPP/593,removezero_ip,"def removezero_ip(ip_address):
    # Split the IP address into its octets
    octets = ip_address.split('.')
    # Remove leading zeroes from each octet and convert to int to avoid leading zeroes
    cleaned_octets = [str(int(octet)) for octet in octets]
    # Join the cleaned octets back into an IP address
    return '.'.join(cleaned_octets)

# Test the function with the provided assertion
assert removezero_ip(""216.08.094.196"") == '216.8.94.196'"
MBPP/584,find_adverbs,"import re

def find_adverbs(sentence):
    # Regex pattern to find adverbs ending with 'ly'
    pattern = r'\b\w+ly\b'
    
    # Find all matches in the sentence
    matches = re.finditer(pattern, sentence)
    
    # Prepare the result in the required format
    result = []
    for match in matches:
        start = match.start()
        adverb = match.group()
        result.append(f""{start}-{start + len(adverb)}: {adverb}"")
    
    return ', '.join(result)

# Example usage
assert find_adverbs(""Clearly, he has no excuse for such behavior."") == '0-7: Clearly'"
MBPP/594,diff_even_odd,"def diff_even_odd(numbers):
    first_even = None
    first_odd = None
    
    for number in numbers:
        if number % 2 == 0 and first_even is None:
            first_even = number
        elif number % 2 != 0 and first_odd is None:
            first_odd = number
        
        # Break the loop if both numbers are found
        if first_even is not None and first_odd is not None:
            break
    
    if first_even is not None and first_odd is not None:
        return first_even - first_odd
    else:
        raise ValueError(""The list must contain at least one even and one odd number."")

# Example usage
assert diff_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 3"
MBPP/596,tuple_size,"import sys

def tuple_size(tup):
    return sys.getsizeof(tup)

# Test the function with the provided assertion
assert tuple_size((""A"", 1, ""B"", 2, ""C"", 3)) == sys.getsizeof((""A"", 1, ""B"", 2, ""C"", 3))

# You can print the result to verify
print(""Size of the tuple:"", tuple_size((""A"", 1, ""B"", 2, ""C"", 3)))"
MBPP/598,armstrong_number,"def armstrong_number(num):
    # Convert the number to string to easily iterate over digits
    digits = str(num)
    # Calculate the number of digits
    num_digits = len(digits)
    # Calculate the sum of each digit raised to the power of the number of digits
    sum_of_powers = sum(int(digit) ** num_digits for digit in digits)
    # Check if the sum of powers is equal to the original number
    return sum_of_powers == num

# Test the function with the provided assertion
assert armstrong_number(153) == True"
MBPP/600,is_Even,"def is_Even(number):
    return (number & 1) == 0

# Test the function with the provided assertion
assert is_Even(1) == False"
MBPP/590,polar_rect,"import math

def polar_rect(r, theta):
    # Calculate rectangular coordinates
    x = r * math.cos(theta)
    y = r * math.sin(theta)
    
    # Return the rectangular coordinates as a tuple and as a complex number
    return (x, y), complex(x, y)

# Test the function with the provided assertion
assert polar_rect(3, 4) == ((-3.0, -0.0), (-3+0j))"
MBPP/592,sum_Of_product,"def sum_Of_product(n):
    # Calculate the sum of product of binomial coefficients
    return n * (2 ** (n - 1))

# Test the function with the provided assertion
assert sum_Of_product(3) == 15"
MBPP/599,sum_average,"def sum_average(n):
    total_sum = sum(range(1, n + 1))
    average = total_sum / n
    return total_sum, average

# Test the function with the provided assertion
assert sum_average(10) == (55, 5.5)"
MBPP/602,first_repeated_char,"def first_repeated_char(s):
    seen = set()
    for char in s:
        if char in seen:
            return char
        seen.add(char)
    return None  # Return None if there are no repeated characters

# Test the function with the provided assertion
assert first_repeated_char(""abcabc"") == ""a"""
MBPP/604,reverse_words,"def reverse_words(s):
    # Split the string into words
    words = s.split()
    # Reverse the list of words
    reversed_words = words[::-1]
    # Join the reversed list back into a string
    return ' '.join(reversed_words)

# Test the function with the provided assertion
assert reverse_words(""python program"") == ""program python"""
MBPP/595,min_Swaps,"def min_Swaps(s1: str, s2: str) -> int:
    if sorted(s1) != sorted(s2):
        return -1  # Not possible to convert if they don't have the same characters

    # Find the positions where the characters differ
    mismatches = []
    for i in range(len(s1)):
        if s1[i] != s2[i]:
            mismatches.append((s1[i], s2[i]))

    # Count the number of swaps needed
    count_01 = count_10 = 0
    for a, b in mismatches:
        if a == '0' and b == '1':
            count_01 += 1
        elif a == '1' and b == '0':
            count_10 += 1

    # Each swap can fix one '01' and one '10' mismatch
    return (count_01 + count_10) // 2

# Test the function with the provided assertion
assert min_Swaps(""1101"", ""1110"") == 1"
MBPP/606,radian_degree,"import math

def radian_degree(degrees):
    """"""Convert degrees to radians.""""""
    return degrees * (math.pi / 180)

# Test the function with the provided assertion
assert radian_degree(90) == 1.5707963267948966"
MBPP/597,find_kth,"def find_kth(arr1, arr2, n, m, k):
    if n > m:  # Ensure arr1 is the smaller array
        return find_kth(arr2, arr1, m, n, k)

    if n == 0:
        return arr2[k - 1]  # If the first array is empty, return k-th element from the second array

    if k == 1:
        return min(arr1[0], arr2[0])  # If k is 1, return the minimum of the two arrays

    i = min(n, k // 2)  # Mid index for arr1
    j = min(m, k // 2)  # Mid index for arr2

    if arr1[i - 1] < arr2[j - 1]:
        # Discard the first i elements of arr1
        return find_kth(arr1[i:], arr2, n - i, m, k - i)
    else:
        # Discard the first j elements of arr2
        return find_kth(arr1, arr2[j:], n, m - j, k - j)

# Example usage
assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5, 4, 5) == 6"
MBPP/605,prime_num,"def prime_num(n):
    """"""Check if the given integer n is a prime number.""""""
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

# Test the function with the provided assertion
assert prime_num(13) == True"
MBPP/601,max_chain_length,"class Pair:
    def __init__(self, first, second):
        self.first = first
        self.second = second

def max_chain_length(pairs, n):
    # Sort the pairs based on the second element
    pairs.sort(key=lambda x: x.second)
    
    # Initialize the count of chains and the end of the last chain
    max_length = 0
    last_end = float('-inf')
    
    for pair in pairs:
        # If the current pair can be chained
        if pair.first > last_end:
            max_length += 1
            last_end = pair.second  # Update the end of the last chain
    
    return max_length

# Test the function with the provided assertion
assert max_chain_length([Pair(5, 24), Pair(15, 25), Pair(27, 40), Pair(50, 60)], 4) == 3"
MBPP/610,remove_kth_element,"def remove_kth_element(lst, k):
    # Check if k is within the valid range
    if k < 0 or k >= len(lst):
        raise IndexError(""k is out of bounds"")
    # Remove the k'th element
    return lst[:k] + lst[k+1:]

# Test the function with the provided assertion
assert remove_kth_element([1, 1, 2, 3, 4, 4, 5, 1], 3) == [1, 1, 3, 4, 4, 5, 1]"
MBPP/603,get_ludic,"def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def generate_primes(n):
    return [i for i in range(2, n + 1) if is_prime(i)]

def find_lucid_numbers(primes, n, current_sum=0, index=0, results=None):
    if results is None:
        results = set()
    
    if current_sum <= n:
        results.add(current_sum)
    
    for i in range(index, len(primes)):
        find_lucid_numbers(primes, n, current_sum + primes[i], i + 1, results)
    
    return results

def get_ludic(n):
    primes = generate_primes(n)
    lucid_numbers = find_lucid_numbers(primes, n)
    return sorted(lucid_numbers)

# Test the function
assert get_ludic(10) == [1, 2, 3, 5, 7]"
MBPP/608,bell_Number,"def bell_number(n):
    # Create a 2D list to store Bell numbers
    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]
    
    # Base case
    bell[0][0] = 1
    
    # Fill the Bell triangle
    for i in range(1, n + 1):
        # Explicitly put the first value of the current row
        bell[i][0] = bell[i - 1][i - 1]
        
        # Fill the rest of the current row
        for j in range(1, i + 1):
            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]
    
    # The nth Bell number is in bell[n][0]
    return bell[n][0]

# Test the function with the provided assertion
assert bell_number(2) == 2"
MBPP/611,max_of_nth,"def max_of_nth(tuple_list, n):
    # Extract the nth column from the tuple list
    nth_column = [t[n] for t in tuple_list]
    # Return the maximum value from the nth column
    return max(nth_column)

# Test the function with the provided assertion
assert max_of_nth([(5, 6, 7), (1, 3, 5), (8, 9, 19)], 2) == 19"
MBPP/614,cummulative_sum,"def cumulative_sum(tuple_list):
    total = 0
    for tup in tuple_list:
        total += sum(tup)
    return total

# Test the function with the provided assertion
assert cumulative_sum([(1, 3), (5, 6, 7), (2, 6)]) == 30"
MBPP/607,find_literals,"import re

def find_literals(original_string, pattern):
    # Use re.search to find the pattern in the original string
    match = re.search(re.escape(pattern), original_string)
    
    if match:
        # If a match is found, return the matched string and its start and end positions
        return (match.group(0), match.start(), match.end())
    else:
        # If no match is found, return None or an appropriate value
        return None

# Example usage
assert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)"
MBPP/612,merge,"def merge(list_of_lists):
    if not list_of_lists:
        return []
    
    first_elements = [sublist[0] for sublist in list_of_lists]
    last_elements = [sublist[-1] for sublist in list_of_lists]
    
    return [first_elements, last_elements]

# Test the function with the provided assertion
assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]"
MBPP/609,floor_Min,"import math
from functools import reduce

def lcm(a, b):
    return abs(a * b) // math.gcd(a, b)

def lcm_multiple(numbers):
    return reduce(lcm, numbers)

def floor_Min(a, b, c):
    # Calculate the least common multiple of the three numbers
    period = lcm_multiple([a, b, c])
    
    # We will evaluate the function at points 0 to period
    # Assuming the function is f(x) = (x % a) + (x % b) + (x % c)
    # This is just an example periodic function; you can replace it with the actual function.
    
    min_value = float('inf')
    
    for x in range(period):
        value = (x % a) + (x % b) + (x % c)
        if value < min_value:
            min_value = value
            
    return min_value

# Test the function
assert floor_Min(10, 20, 30) == 15"
MBPP/613,maximum_value,"def maximum_value(record_list):
    return [(key, max(values)) for key, values in record_list]

# Test the function with the provided assertion
assert maximum_value([('key1', [3, 4, 5]), ('key2', [1, 4, 2]), ('key3', [9, 3])]) == [('key1', 5), ('key2', 4), ('key3', 9)]"
MBPP/618,div_list,"def div_list(list1, list2):
    return list(map(lambda x, y: x / y, list1, list2))

# Test the function with the provided assertion
assert div_list([4, 5, 6], [1, 2, 3]) == [4.0, 2.5, 2.0]"
MBPP/616,tuple_modulo,"def tuple_modulo(tuple1, tuple2):
    return tuple(a % b for a, b in zip(tuple1, tuple2))

# Test the function with the provided assertion
assert tuple_modulo((10, 4, 5, 6), (5, 6, 7, 5)) == (0, 4, 5, 1)

# You can also print the result to verify
print(tuple_modulo((10, 4, 5, 6), (5, 6, 7, 5)))  # Output: (0, 4, 5, 1)"
MBPP/619,move_num,"def move_num(s):
    letters = ''.join(filter(str.isalpha, s))
    numbers = ''.join(filter(str.isdigit, s))
    return letters + numbers

# Test the function with the provided assertion
assert move_num('I1love143you55three3000thousand') == 'Iloveyouthreethousand1143553000'"
MBPP/617,min_Jumps,"def min_Jumps(jump_length, d, y):
    # Since we are only interested in reaching (d, 0), y should always be 0
    if y != 0:
        raise ValueError(""The y-coordinate must be 0."")
    
    # Calculate the number of jumps required to reach distance d
    jumps = d / jump_length
    
    return jumps

# Example usage
assert min_Jumps(3, 4, 0) == 4 / 3  # This should return approximately 1.33
assert min_Jumps(3, 11, 0) == 11 / 3  # This should return approximately 3.67"
MBPP/624,is_upper,"def is_upper(s):
    return s.upper()

# Test the function
assert is_upper(""person"") == ""PERSON"""
MBPP/621,increment_numerics,"import re

def increment_numerics(strings, k):
    def increment_match(match):
        # Convert the matched string to an integer, increment it, and return as string
        return str(int(match.group(0)) + k)

    # Use regex to find all numeric values in each string and increment them
    return [re.sub(r'\d+', increment_match, s) for s in strings]

# Test the function with the provided assertion
assert increment_numerics([""MSM"", ""234"", ""is"", ""98"", ""123"", ""best"", ""4""], 6) == ['MSM', '240', 'is', '104', '129', 'best', '10']"
MBPP/615,average_tuple,"def average_tuple(tuples):
    # Calculate the number of inner tuples
    num_tuples = len(tuples)
    
    # Calculate the number of elements in each inner tuple
    num_elements = len(tuples[0])
    
    # Initialize a list to hold the sums of each column
    sums = [0] * num_elements
    
    # Iterate through each tuple and sum the values
    for tup in tuples:
        for i in range(num_elements):
            sums[i] += tup[i]
    
    # Calculate the average for each column
    averages = [s / num_tuples for s in sums]
    
    return averages

# Test the function with the provided assertion
assert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4))) == [30.5, 34.25, 27.0, 23.25]"
MBPP/623,nth_nums,"def nth_nums(lst, n):
    return list(map(lambda x: x ** n, lst))

# Test the function with the provided assertion
assert nth_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]"
MBPP/625,swap_List,"def swap_List(lst):
    if len(lst) < 2:
        return lst  # No swap needed for lists with less than 2 elements
    # Swap the first and last elements
    lst[0], lst[-1] = lst[-1], lst[0]
    return lst

# Test the function with the provided assertion
assert swap_List([1, 2, 3]) == [3, 2, 1]"
MBPP/628,replace_spaces,"def replace_spaces(input_string):
    return input_string.replace(' ', '%20')

# Test the function
assert replace_spaces(""My Name is Dawood"") == 'My%20Name%20is%20Dawood'"
MBPP/620,largest_subset,"def largest_subset(arr, n):
    # Sort the array
    arr.sort()
    
    # Create a DP array to store the size of the largest divisible subset ending at each index
    dp = [1] * n
    
    # Variable to keep track of the maximum size of the subset
    max_size = 1
    
    # Build the dp array
    for i in range(1, n):
        for j in range(i):
            if arr[i] % arr[j] == 0:  # Check if arr[i] is divisible by arr[j]
                dp[i] = max(dp[i], dp[j] + 1)
        max_size = max(max_size, dp[i])
    
    return max_size

# Test the function with the provided assertion
assert largest_subset([1, 3, 6, 13, 17, 18], 6) == 4"
MBPP/627,find_First_Missing,"def find_First_Missing(arr, start, end):
    # Create a set from the array for O(1) lookups
    num_set = set(arr)
    
    # Iterate through the range from start to end
    for num in range(start, end + 1):
        if num not in num_set:
            return num
    
    # If all numbers in the range are present, return the next number
    return end + 1

# Test the function with the provided assertion
assert find_First_Missing([0, 1, 2, 3], 0, 3) == 4"
MBPP/626,triangle_area,"def triangle_area(radius):
    if radius <= 0:
        return 0
    return radius ** 2

# Test the function with the provided assertion
assert triangle_area(0) == 0"
MBPP/629,Split,"def find_even_numbers(mixed_list):
    """"""Return a list of even numbers from the given mixed list.""""""
    return [num for num in mixed_list if num % 2 == 0]

# Test the function with the provided assertion
assert find_even_numbers([1, 2, 3, 4, 5]) == [2, 4]"
MBPP/493,calculate_polygons,"To create a function that calculates a grid of hexagon coordinates, we need to understand the geometry of hexagons. A regular hexagon can be divided into six equilateral triangles, and its vertices can be calculated based on a center point and a radius (distance from the center to a vertex).

The coordinates of the vertices of a hexagon can be calculated using trigonometric functions. The angle between each vertex is 60 degrees (or π/3 radians). 

Here's how we can implement the `calculate_polygons` function in Python:

```python
import math

def calculate_polygons(start_x, start_y, cols, rows, radius):
    hexagons = []
    for row in range(rows):
        for col in range(cols):
            # Calculate the center of the hexagon
            x = start_x + col * radius * 3/2
            y = start_y + row * radius * math.sqrt(3)
            if col % 2 == 1:  # Offset every other column
                y += radius * math.sqrt(3) / 2
            
            # Calculate the vertices of the hexagon
            hexagon = []
            for i in range(6):
                angle = math.pi / 3 * i  # 60 degrees in radians
                hex_x = x + radius * math.cos(angle)
                hex_y = y + radius * math.sin(angle)
                hexagon.append((hex_x, hex_y))
            hexagons.append(hexagon)
    
    return hexagons

# Example usage
assert calculate_polygons(1, 1, 4, 4, 3) == [[(-5.0, -4.196152422706632), (-5.0, -0.7320508075688767), (-2.0, 1.0), (1.0, -0.7320508075688767), (1.0, -4.196152422706632), (-2.0, -5.928203230275509), (-5.0, -4.196152422706632)], 
                                               [(1.0, -4.196152422706632), (1.0, -0.7320508075688767), (4.0, 1.0), (7.0, -0.7320508075688767), (7.0, -4.196152422706632), (4.0, -5.928203230275509), (1.0, -4.196152422706632)], 
                                               [(7.0, -4.196152422706632), (7.0, -0.7320508075688767), (10.0, 1.0), (13.0, -0.7320508075688767), (13.0, -4.196152422706632), (10.0, -5.928203230275509), (7.0, -4.196152422706632)], 
                                               [(-2.0, 1.0000000000000004), (-2.0, 4.464101615137755), (1.0, 6.196152422706632), (4.0, 4.464101615137755), (4.0, 1.0000000000000004), (1.0, -0.7320508075688767), (-2.0, 1.0000000000000004)], 
                                               [(4.0, 1.0000000000000004), (4.0, 4.464101615137755), (7.0, 6.196152422706632), (10.0, 4.464101615137755), (10.0, 1.0000000000000004), (7.0, -0.7320508075688767), (4.0, 1.0000000000000004)], 
                                               [(-5.0, 6.196152422706632), (-5.0, 9.660254037844387), (-2.0, 11.392304845413264), (1.0, 9.660254037844387), (1.0, 6.196152422706632), (-2.0, 4.464101615137755), (-5.0, 6.196152422706632)], 
                                               [(1.0, 6.196152422706632), (1.0, 9.660254037844387), (4.0, 11.392304845413264), (7.0, 9.660254037844387), ("
MBPP/630,get_coordinates,"def get_coordinates(coord):
    x, y = coord
    adjacent_coords = []
    
    for i in range(x - 1, x + 2):
        for j in range(y - 1, y + 2):
            adjacent_coords.append([i, j])
    
    return adjacent_coords

# Test the function
assert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]"
MBPP/631,replace_spaces,"import re

def replace_spaces(input_string):
    # Replace spaces with underscores and underscores with spaces
    return re.sub(r'_', ' ', re.sub(r'\s+', '_', input_string))

# Test the function with the provided assertion
assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'"
MBPP/634,even_Power_Sum,"def even_Power_Sum(n):
    # Calculate the sum of the fourth power of the first n even natural numbers
    return sum((2 * i) ** 4 for i in range(1, n + 1))

# Test the function with the provided assertion
assert even_Power_Sum(2) == 272"
MBPP/632,move_zero,"def move_zero(lst):
    # Create a new list to hold non-zero elements
    non_zero = [x for x in lst if x != 0]
    # Count the number of zeroes
    zero_count = lst.count(0)
    # Extend the non-zero list with the zeroes
    return non_zero + [0] * zero_count

# Test the function with the provided assertion
assert move_zero([1, 0, 2, 0, 3, 4]) == [1, 2, 3, 4, 0, 0]"
MBPP/639,sample_nam,"def sample_nam(names):
    # Filter out names that start with a lowercase letter
    filtered_names = [name for name in names if not name[0].islower()]
    # Sum the lengths of the remaining names
    total_length = sum(len(name) for name in filtered_names)
    return total_length

# Test the function with the provided assertion
assert sample_nam(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith']) == 16"
MBPP/633,pair_OR_Sum,"def pair_OR_Sum(arr, n):
    total_xor_sum = 0
    
    # Iterate through all pairs (i, j) where i < j
    for i in range(n):
        for j in range(i + 1, n):
            total_xor_sum += arr[i] ^ arr[j]
    
    return total_xor_sum

# Test the function with the provided assertion
assert pair_OR_Sum([5, 9, 7, 6], 4) == 47"
MBPP/640,remove_parenthesis,"def remove_parenthesis(strings):
    # Initialize an empty list to hold the results
    result = []
    
    for s in strings:
        # Remove the text within parentheses using str.split and str.join
        cleaned_string = ''.join(s.split('(')[0:1])  # Get the part before the first '('
        result.append(cleaned_string.strip())  # Strip any leading/trailing whitespace
    
    return result[0] if result else """"

# Test the function
assert remove_parenthesis([""python (chrome)""]) == ""python"""
MBPP/637,noprofit_noloss,"def noprofit_noloss(selling_price, cost_price):
    return selling_price == cost_price

# Test the function with the provided assertion
assert noprofit_noloss(1500, 1200) == False"
MBPP/635,heap_sort,"import heapq

def heap_sort(iterable):
    # Create a heap from the iterable
    heap = []
    for value in iterable:
        heapq.heappush(heap, value)
    
    # Pop the smallest values one at a time to get a sorted list
    sorted_list = []
    while heap:
        sorted_list.append(heapq.heappop(heap))
    
    return sorted_list

# Test the function with the provided assertion
assert heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"
MBPP/638,wind_chill,"def wind_chill(temperature, wind_speed):
    """"""
    Calculate the wind chill index based on the temperature and wind speed.
    
    Parameters:
    temperature (float): The air temperature in degrees Fahrenheit.
    wind_speed (float): The wind speed in miles per hour.
    
    Returns:
    float: The wind chill index.
    """"""
    wci = (35.74 + 
            0.6215 * temperature - 
            35.75 * (wind_speed ** 0.16) + 
            0.4275 * temperature * (wind_speed ** 0.16))
    return wci

# Test the function with the provided assertion
assert wind_chill(120, 35) == 40"
MBPP/636,Check_Solution,"def Check_Solution(a, b, c):
    # Check if the product of the roots equals 1
    if c == a:
        return ""Yes""
    else:
        return ""No""

# Test the function with the provided assertion
assert Check_Solution(2, 0, 2) == ""Yes"""
MBPP/641,is_nonagonal,"def is_nonagonal(n):
    return n * (7 * n - 5) // 2

# Test the function with the provided assertion
assert is_nonagonal(10) == 325

# You can also print the result to verify
print(is_nonagonal(10))  # Output should be 325"
MBPP/645,find_k_product,"def find_k_product(tuples_list, k):
    product = 1
    for tup in tuples_list:
        product *= tup[k]
    return product

# Test the function with the provided assertion
assert find_k_product([(5, 6, 7), (1, 3, 5), (8, 9, 19)], 2) == 665"
MBPP/643,text_match_wordz_middle,"import re

def text_match_wordz_middle(text):
    # Regular expression to find a word containing 'z' not at the start or end
    pattern = r'\b\w*z\w*\b'
    
    # Search for the pattern in the input text
    if re.search(pattern, text):
        return 'Found a match!'
    else:
        return 'No match found.'

# Test the function
assert text_match_wordz_middle(""pythonzabc."") == 'Found a match!'"
MBPP/647,split_upperstring,"import re

def split_upperstring(s):
    # Use regular expression to split the string at uppercase letters
    return re.findall(r'[A-Z][a-z]*', s)

# Test the function with the provided assertion
assert split_upperstring(""PythonProgramLanguage"") == ['Python', 'Program', 'Language']"
MBPP/622,get_median,"def get_median(arr1, arr2, n):
    if n <= 0:
        raise ValueError(""Array size must be greater than 0"")
    
    # Ensure arr1 is the smaller array
    if len(arr1) > len(arr2):
        arr1, arr2 = arr2, arr1
    
    x, y = len(arr1), len(arr2)
    low, high = 0, x
    
    while low <= high:
        partitionX = (low + high) // 2
        partitionY = (n + n) // 2 - partitionX
        
        # If partitionX is 0 it means nothing is there on left side. Use -inf for maxLeftX
        # If partitionX is length of input then there is nothing on right side. Use +inf for minRightX
        maxLeftX = float('-inf') if partitionX == 0 else arr1[partitionX - 1]
        minRightX = float('inf') if partitionX == x else arr1[partitionX]
        
        maxLeftY = float('-inf') if partitionY == 0 else arr2[partitionY - 1]
        minRightY = float('inf') if partitionY == y else arr2[partitionY]
        
        if maxLeftX <= minRightY and maxLeftY <= minRightX:
            # We have partitioned array at correct place
            if (x + y) % 2 == 0:
                return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2
            else:
                return max(maxLeftX, maxLeftY)
        elif maxLeftX > minRightY:
            # We are too far on right side for partitionX. Go on left side.
            high = partitionX - 1
        else:
            # We are too far on left side for partitionX. Go on right side.
            low = partitionX + 1

    raise ValueError(""Input arrays are not sorted or of the same size."")

# Example usage
assert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0"
MBPP/644,reverse_Array_Upto_K,"def reverse_Array_Upto_K(arr, k):
    # Reverse the subarray from the start to the k-th position (exclusive)
    if k > len(arr):
        k = len(arr)  # Ensure k does not exceed the array length
    reversed_part = arr[:k][::-1]
    return reversed_part + arr[k:]

# Test the function with the provided assertion
assert reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4) == [4, 3, 2, 1, 5, 6]"
MBPP/648,exchange_elements,"def exchange_elements(lst):
    # Iterate through the list in steps of 2
    for i in range(0, len(lst) - 1, 2):
        # Swap the elements at index i and i+1
        lst[i], lst[i + 1] = lst[i + 1], lst[i]
    return lst

# Test the function with the provided assertion
assert exchange_elements([0, 1, 2, 3, 4, 5]) == [1, 0, 3, 2, 5, 4]"
MBPP/642,remove_similar_row,"def remove_similar_row(matrix):
    # Use a set to store unique rows
    unique_rows = set()
    
    # Iterate through each row in the matrix
    for row in matrix:
        # Add the row to the set (sets automatically handle duplicates)
        unique_rows.add(tuple(row))
    
    return unique_rows

# Test the function with the provided assertion
assert remove_similar_row([[(4, 5), (3, 2)], [(2, 2), (4, 6)], [(3, 2), (4, 5)]]) == {((2, 2), (4, 6)), ((3, 2), (4, 5))}"
MBPP/649,sum_Range_list,"def sum_Range_list(numbers, start_index, end_index):
    # Ensure the indices are within the bounds of the list
    if start_index < 0 or end_index >= len(numbers) or start_index > end_index:
        raise ValueError(""Indices are out of bounds or invalid."")
    
    # Calculate the sum of the specified range
    return sum(numbers[start_index:end_index + 1])

# Test the function with the provided assertion
assert sum_Range_list([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], 8, 10) == 29"
MBPP/651,check_subset,"def check_subset(tuple1, tuple2):
    # Convert tuples to sets and check if tuple2 is a subset of tuple1
    return set(tuple2).issubset(set(tuple1))

# Test the function with the provided assertion
assert check_subset((10, 4, 5, 6), (5, 10)) == True"
MBPP/646,No_of_cubes,"def No_of_cubes(n, k):
    if k > n:
        return 0  # If k is larger than n, no cubes can fit
    return (n - k + 1) ** 3

# Test the function with the provided assertion
assert No_of_cubes(2, 1) == 8"
MBPP/654,rectangle_perimeter,"def rectangle_perimeter(length, width):
    return 2 * (length + width)

# Test the function with the provided assertion
assert rectangle_perimeter(10, 20) == 60"
MBPP/655,fifth_Power_Sum,"def fifth_Power_Sum(n):
    return sum(i**5 for i in range(1, n + 1))

# Test the function with the provided assertion
assert fifth_Power_Sum(2) == 33"
MBPP/653,grouping_dictionary,"from collections import defaultdict

def grouping_dictionary(pairs):
    grouped = defaultdict(list)
    for key, value in pairs:
        grouped[key].append(value)
    return dict(grouped)

# Test the function with the provided assertion
assert grouping_dictionary([('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]) == {'yellow': [1, 3], 'blue': [2, 4], 'red': [1]}"
MBPP/650,are_Equal,"def are_Equal(arr1, arr2, n, m):
    # Check if the lengths of the arrays are different
    if n != m:
        return False
    
    # Sort both arrays and compare them
    return sorted(arr1) == sorted(arr2)

# Test the function with the provided assertion
assert are_Equal([1, 2, 3], [3, 2, 1], 3, 3) == True"
MBPP/656,find_Min_Sum,"def find_Min_Sum(arr1, arr2, n):
    # Sort both arrays
    arr1.sort()
    arr2.sort()
    
    # Calculate the sum of absolute differences
    min_sum = sum(abs(arr1[i] - arr2[i]) for i in range(n))
    
    return min_sum

# Test the function with the provided assertion
assert find_Min_Sum([3, 2, 1], [2, 1, 3], 3) == 0"
MBPP/658,max_occurrences,"from collections import Counter

def max_occurrences(lst):
    if not lst:
        return None  # Return None if the list is empty
    
    count = Counter(lst)
    max_item = max(count, key=count.get)
    return max_item

# Test the function with the provided assertion
assert max_occurrences([2, 3, 8, 4, 7, 9, 8, 2, 6, 5, 1, 6, 1, 2, 3, 4, 6, 9, 1, 2]) == 2"
MBPP/659,Repeat,"def Repeat(lst):
    seen = set()
    duplicates = set()
    
    for number in lst:
        if number in seen:
            duplicates.add(number)
        else:
            seen.add(number)
    
    return list(duplicates)

# Test the function with the provided assertion
assert Repeat([10, 20, 30, 20, 20, 30, 40, 50, -20, 60, 60, -20, -20]) == [20, 30, -20, 60]"
MBPP/662,sorted_dict,"def sorted_dict(input_dict):
    return {key: sorted(value) for key, value in input_dict.items()}

# Test the function with the provided assertion
assert sorted_dict({'n1': [2, 3, 1], 'n2': [5, 1, 2], 'n3': [3, 2, 4]}) == {'n1': [1, 2, 3], 'n2': [1, 2, 5], 'n3': [2, 3, 4]}"
MBPP/652,matrix_to_list,"def matrix_to_list(matrix):
    if not matrix or not matrix[0]:
        return []

    # Get the number of rows and columns
    num_rows = len(matrix)
    num_cols = len(matrix[0])

    # Initialize a list to hold the tuples for each column
    result = []

    # Iterate through each column
    for col in range(num_cols):
        column_tuple = tuple(matrix[row][col] for row in range(num_rows))
        result.append(column_tuple)

    return result

# Test the function with the provided assertion
assert str(matrix_to_list([[(4, 5), (7, 8)], [(10, 13), (18, 17)], [(0, 4), (10, 1)]]) ) == '[(4, 7, 10, 18, 0, 10), (5, 8, 13, 17, 4, 1)]'"
MBPP/664,average_Even,"def average_Even(n):
    if n < 2 or n % 2 != 0:
        raise ValueError(""Input must be an even number greater than or equal to 2."")
    
    # Calculate the sum of even numbers and the count of even numbers
    total_sum = 0
    count = 0
    
    for i in range(2, n + 1, 2):
        total_sum += i
        count += 1
    
    # Calculate the average
    average = total_sum / count
    return average

# Test the function with the provided assertion
assert average_Even(2) == 2"
MBPP/660,find_Points,"def find_Points(start1, end1, start2, end2):
    # Choose a point from the first range
    point1 = start1
    
    # Choose a point from the second range
    # Ensure that point2 does not overlap with point1
    if point1 < start2:
        point2 = start2
    else:
        point2 = end2
    
    return (point1, point2)

# Test the function with the provided assertion
assert find_Points(5, 10, 1, 5) == (1, 10)"
MBPP/657,first_Digit,"import math

def first_Digit(n):
    # Calculate the factorial of n
    factorial_value = math.factorial(n)
    # Convert the factorial to string and get the first character
    first_digit = str(factorial_value)[0]
    # Convert the first character back to an integer
    return int(first_digit)

# Test the function with the provided assertion
assert first_Digit(5) == 1"
MBPP/668,replace,"def replace(string, char):
    # Replace multiple occurrences of 'char' with a single 'char'
    return ''.join(char if c == char and (i == 0 or string[i-1] != char) else c for i, c in enumerate(string))

# Test the function with the provided assertion
assert replace('peep', 'e') == 'pep'"
MBPP/665,move_last,"def move_last(lst):
    if lst:  # Check if the list is not empty
        return lst[1:] + [lst[0]]
    return lst  # Return the original list if it's empty

# Test the function with the provided assertion
assert move_last([1, 2, 3, 4]) == [2, 3, 4, 1]"
MBPP/667,Check_Vow,"def Check_Vow(string, vowels):
    # Convert the vowels string to a set for faster lookup
    vowel_set = set(vowels.lower())
    # Count the number of vowels in the string
    count = sum(1 for char in string.lower() if char in vowel_set)
    return count

# Test the function with the provided assertion
assert Check_Vow('corner', 'AaEeIiOoUu') == 2"
MBPP/661,max_sum_of_three_consecutive,"def max_sum_of_three_consecutive(arr, n):
    if n == 0:
        return 0
    if n == 1:
        return arr[0]
    if n == 2:
        return arr[0] + arr[1]
    
    # Create a dp array to store the maximum sums
    dp = [0] * n
    
    # Base cases
    dp[0] = arr[0]
    dp[1] = arr[0] + arr[1]
    dp[2] = max(arr[0] + arr[1], arr[1] + arr[2], arr[0] + arr[2])
    
    # Fill the dp array
    for i in range(3, n):
        dp[i] = max(dp[i-1],  # Skip current element
                     dp[i-2] + arr[i],  # Include current element
                     dp[i-3] + arr[i-1] + arr[i])  # Include current and previous element
    
    return dp[n-1]

# Test the function with the provided assertion
assert max_sum_of_three_consecutive([100, 1000, 100, 1000, 1], 5) == 2101"
MBPP/670,decreasing_trend,"def decreasing_trend(sequence):
    # Check if the sequence is empty or has only one element
    if len(sequence) < 2:
        return False
    
    # Iterate through the sequence and check for decreasing trend
    for i in range(1, len(sequence)):
        if sequence[i] >= sequence[i - 1]:
            return False
            
    return True

# Test the function with the provided assertion
assert decreasing_trend([-4, -3, -2, -1]) == True"
MBPP/672,max_of_three,"def max_of_three(a, b, c):
    return max(a, b, c)

# Test the function
assert max_of_three(10, 20, 30) == 30"
MBPP/673,convert,"def convert(int_list):
    # Convert each integer to a string and join them together
    combined_str = ''.join(map(str, int_list))
    # Convert the combined string back to an integer
    return int(combined_str)

# Test the function with the provided assertion
assert convert([1, 2, 3]) == 123"
MBPP/663,find_max_val,"def find_max_val(x, y, limit):
    if y >= x:
        raise ValueError(""y must be less than x for the modulo operation to be valid."")
    
    # Calculate the largest k such that k % x = y
    # k = n * x + y, where n is the largest integer such that k <= limit
    n = (limit - y) // x  # Find the largest n
    k = n * x + y  # Calculate k
    
    return k

# Test the function with the provided assertion
assert find_max_val(15, 10, 5) == 15"
MBPP/669,check_IP,"import re

def check_IP(ip):
    # Regular expression for validating an IPv4 address
    pattern = r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
    
    if re.match(pattern, ip):
        return 'Valid IP address'
    else:
        return 'Invalid IP address'

# Test the function
assert check_IP(""192.168.0.1"") == 'Valid IP address'"
MBPP/666,count_char,"def count_char(string, char):
    return string.count(char)

# Test the function with the provided assertion
assert count_char(""Python"", 'o') == 1"
MBPP/678,remove_spaces,"def remove_spaces(input_string):
    return input_string.replace("" "", """")

# Test the function
assert remove_spaces(""a b c"") == ""abc"""
MBPP/676,remove_extra_char,"import re

def remove_extra_char(s):
    # Use regex to replace non-alphanumeric characters with an empty string
    return re.sub(r'[^a-zA-Z0-9]', '', s)

# Test the function with the provided assertion
assert remove_extra_char('**//Google Android// - 12. ') == 'GoogleAndroid12'"
MBPP/674,remove_duplicate,"from collections import OrderedDict

def remove_duplicate(input_string):
    # Split the string into words
    words = input_string.split()
    # Use OrderedDict to remove duplicates while preserving order
    unique_words = list(OrderedDict.fromkeys(words))
    # Join the unique words back into a string
    return ' '.join(unique_words)

# Test the function with the provided assertion
assert remove_duplicate(""Python Exercises Practice Solution Exercises"") == ""Python Exercises Practice Solution"""
MBPP/675,sum_nums,"def sum_nums(a, b, lower, upper):
    total = a + b
    if lower <= total <= upper:
        return 20
    return total

# Example assertion to test the function
assert sum_nums(2, 10, 11, 20) == 20"
MBPP/679,access_key,"def access_key(d, index):
    # Get the list of keys from the dictionary
    keys = list(d.keys())
    # Return the key at the specified index
    return keys[index]

# Test the function with the provided assertion
assert access_key({'physics': 80, 'math': 90, 'chemistry': 86}, 0) == 'physics'"
MBPP/671,set_Right_most_Unset_Bit,"def set_Right_most_Unset_Bit(n):
    # Find the rightmost unset bit and set it
    return n | (n + 1) & ~(n)

# Test the function with the provided assertion
assert set_Right_most_Unset_Bit(21) == 23"
MBPP/681,smallest_Divisor,"def smallest_Divisor(n):
    if n <= 1:
        return None  # No prime divisors for numbers less than or equal to 1
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return i
    return n  # If no divisors found, n is prime

# Test the function with the provided assertion
assert smallest_Divisor(10) == 2"
MBPP/688,len_complex,"import math

def len_complex(real, imag):
    return math.sqrt(real**2 + imag**2)

# Test the function with the provided assertion
assert len_complex(3, 4) == 5.0"
MBPP/680,increasing_trend,"def increasing_trend(sequence):
    # Check if the sequence is empty or has only one element
    if len(sequence) < 2:
        return True
    
    # Iterate through the sequence and check if each number is less than the next
    for i in range(len(sequence) - 1):
        if sequence[i] >= sequence[i + 1]:
            return False
            
    return True

# Test the function with the provided assertion
assert increasing_trend([1, 2, 3, 4]) == True"
MBPP/686,freq_element,"def freq_element(elements):
    frequency = {}
    for element in elements:
        if element in frequency:
            frequency[element] += 1
        else:
            frequency[element] = 1
    return str(frequency)

# Test the function with the provided assertion
assert freq_element((4, 5, 4, 5, 6, 6, 5, 5, 4)) == '{4: 3, 5: 4, 6: 2}'"
MBPP/685,sum_Of_Primes,"def is_prime(num):
    """"""Check if a number is prime.""""""
    if num <= 1:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def sum_Of_Primes(n):
    """"""Return the sum of all prime numbers between 1 and n.""""""
    return sum(num for num in range(2, n + 1) if is_prime(num))

# Test the function
assert sum_Of_Primes(10) == 17"
MBPP/687,recur_gcd,"def recur_gcd(a, b):
    # Base case: if b is 0, return a
    if b == 0:
        return a
    # Recursive case: call recur_gcd with b and the remainder of a divided by b
    return recur_gcd(b, a % b)

# Test the function with the provided assertion
assert recur_gcd(12, 14) == 2"
MBPP/677,validity_triangle,"def validity_triangle(angle1, angle2, angle3):
    # Check if the sum of the angles is 180 and each angle is greater than 0
    return angle1 > 0 and angle2 > 0 and angle3 > 0 and (angle1 + angle2 + angle3) == 180

# Test the function with the provided assertion
assert validity_triangle(60, 50, 90) == False"
MBPP/682,mul_list,"def mul_list(list1, list2):
    return list(map(lambda x, y: x * y, list1, list2))

# Test the function with the provided assertion
assert mul_list([1, 2, 3], [4, 5, 6]) == [4, 10, 18]"
MBPP/684,count_Char,"def count_Char(s, char, n):
    # Count occurrences of char in the original string
    count_in_s = s.count(char)
    
    # Calculate how many times the string is repeated
    full_repeats = n // len(s)
    
    # Count occurrences in the full repeats
    total_count = full_repeats * count_in_s
    
    # Count occurrences in the remaining part of the string
    remainder = n % len(s)
    total_count += s[:remainder].count(char)
    
    return total_count

# Example usage
repeated_string = ""abcac""
n = 10  # Length of the repeated string
char_to_count = 'a'
result = count_Char(repeated_string, char_to_count, n)
assert result == 4"
MBPP/689,min_jumps,"def min_jumps(arr, n):
    if n <= 1:
        return 0

    jumps = 0
    current_end = 0
    farthest = 0

    for i in range(n - 1):
        farthest = max(farthest, i + arr[i])
        
        if i == current_end:
            jumps += 1
            current_end = farthest
            
            if current_end >= n - 1:
                break

    return jumps if current_end >= n - 1 else float('inf')

# Test the function with the provided assertion
assert min_jumps([1, 3, 6, 1, 0, 9], 6) == 3"
MBPP/683,sum_Square,"def sum_Square(n):
    if n < 0:
        return False
    if n == 0:
        return True
    
    # Check for the prime factors of the form 4k + 3
    def is_sum_of_two_squares(num):
        while num % 4 == 0:
            num //= 4
        if num % 8 == 7:
            return False
        return True
    
    return is_sum_of_two_squares(n)

# Test the function with the provided assertion
assert sum_Square(25) == True"
MBPP/690,mul_consecutive_nums,"def mul_consecutive_nums(nums):
    if not nums:
        return []
    
    result = []
    for i in range(len(nums) - 1):
        result.append(nums[i] * nums[i + 1])
    
    # Append the last number as it is not multiplied with any next number
    result.append(nums[-1])
    
    return result

# Test the function with the provided assertion
assert mul_consecutive_nums([1, 1, 3, 4, 4, 5, 6, 7]) == [1, 3, 12, 16, 20, 30, 42]"
MBPP/693,remove_multiple_spaces,"import re

def remove_multiple_spaces(input_string):
    # Use regex to replace multiple spaces with a single space
    return re.sub(r'\s+', ' ', input_string).strip()

# Test the function with the provided assertion
assert remove_multiple_spaces('Google      Assistant') == 'Google Assistant'"
MBPP/692,last_Two_Digits,"def last_Two_Digits(n):
    if n < 0:
        raise ValueError(""Factorial is not defined for negative numbers"")
    
    factorial = 1
    for i in range(2, n + 1):
        factorial *= i
    
    return factorial % 100

# Test the function with the provided assertion
assert last_Two_Digits(7) == 40"
MBPP/691,group_element,"def group_element(tuple_list):
    grouped = {}
    for first, second in tuple_list:
        if second not in grouped:
            grouped[second] = []
        grouped[second].append(first)
    return grouped

# Test the function with the provided assertion
assert group_element([(6, 5), (2, 7), (2, 5), (8, 7), (9, 8), (3, 7)]) == {5: [6, 2], 7: [2, 8, 3], 8: [9]}"
MBPP/697,count_even,"def count_even(numbers):
    return len(list(filter(lambda x: x % 2 == 0, numbers)))

# Test the function with the provided assertion
assert count_even([1, 2, 3, 5, 7, 8, 9, 10]) == 3"
MBPP/694,extract_unique,"def extract_unique(input_dict):
    unique_values = set()  # Use a set to store unique values
    for value_list in input_dict.values():
        unique_values.update(value_list)  # Add values to the set
    return sorted(unique_values)  # Return a sorted list of unique values

# Test the function with the provided assertion
assert extract_unique({'msm': [5, 6, 7, 8], 'is': [10, 11, 7, 5], 'best': [6, 12, 10, 8], 'for': [1, 2, 5]}) == [1, 2, 5, 6, 7, 8, 10, 11, 12]"
MBPP/695,check_greater,"def check_greater(tuple1, tuple2):
    # Check if the lengths of the tuples are the same
    if len(tuple1) != len(tuple2):
        return False
    
    # Check if each element in tuple2 is greater than the corresponding element in tuple1
    for i in range(len(tuple1)):
        if tuple2[i] <= tuple1[i]:
            return False
            
    return True

# Test the function with the provided assertion
assert check_greater((10, 4, 5), (13, 5, 18)) == True"
MBPP/696,zip_list,"def zip_list(list1, list2):
    # Use zip to combine the two lists and then flatten the result
    return [sublist1 + sublist2 for sublist1, sublist2 in zip(list1, list2)]

# Test the function with the provided assertion
assert zip_list([[1, 3], [5, 7], [9, 11]], [[2, 4], [6, 8], [10, 12, 14]]) == [[1, 3, 2, 4], [5, 7, 6, 8], [9, 11, 10, 12, 14]]"
MBPP/700,count_range_in_list,"def count_range_in_list(lst, lower, upper):
    count = 0
    for num in lst:
        if lower <= num <= upper:
            count += 1
    return count

# Test the function with the provided assertion
assert count_range_in_list([10, 20, 30, 40, 40, 40, 70, 80, 99], 40, 100) == 6"
MBPP/703,is_key_present,"def is_key_present(dictionary, key):
    return key in dictionary

# Test the function with the provided assertion
assert is_key_present({1: 10, 2: 20, 3: 30, 4: 40, 5: 50, 6: 60}, 5) == True"
MBPP/701,equilibrium_index,"def equilibrium_index(arr):
    total_sum = sum(arr)
    left_sum = 0
    
    for i in range(len(arr)):
        # Right sum is total_sum - left_sum - arr[i]
        right_sum = total_sum - left_sum - arr[i]
        
        if left_sum == right_sum:
            return i
        
        left_sum += arr[i]
    
    return -1  # Return -1 if no equilibrium index is found

# Test the function with the provided assertion
assert equilibrium_index([1, 2, 3, 4, 1, 2, 3]) == 3"
MBPP/704,harmonic_sum,"def harmonic_sum(n):
    if n < 1:
        return 0  # Return 0 for n <= 1 as there are no terms to sum
    return sum(1 / i for i in range(1, n))

# Test the function with the provided assertion
assert harmonic_sum(10) == 2.9289682539682538"
MBPP/698,sort_dict_item,"def sort_dict_item(d):
    # Sort the dictionary items based on the product of the tuple keys
    sorted_items = sorted(d.items(), key=lambda item: item[0][0] * item[0][1])
    # Convert the sorted items back to a dictionary
    return dict(sorted_items)

# Test the function with the provided assertion
assert sort_dict_item({(5, 6): 3, (2, 3): 9, (8, 4): 10, (6, 4): 12}) == {(2, 3): 9, (6, 4): 12, (5, 6): 3, (8, 4): 10}"
MBPP/708,Convert,"def Convert(input_string):
    # Split the string by spaces and return the list of words
    return input_string.split()

# Test the function with the provided assertion
assert Convert('python program') == ['python', 'program']"
MBPP/706,is_subset,"def is_subset(arr1, n, arr2, m):
    # Convert the second array to a set for O(1) lookups
    set_arr2 = set(arr2)
    
    # Check if all elements of arr1 are in set_arr2
    for element in arr1:
        if element not in set_arr2:
            return False
    return True

# Test the function with the provided assertion
assert is_subset([11, 1, 13, 21, 3, 7], 6, [11, 3, 7, 1], 4) == True"
MBPP/707,count_Set_Bits,"def count_Set_Bits(n):
    count = 0
    for i in range(1, n + 1):
        count += bin(i).count('1')
    return count

# Test the function with the provided assertion
assert count_Set_Bits(16) == 33

# You can also print the result to verify
print(count_Set_Bits(16))  # Output: 33"
MBPP/705,sort_sublists,"def sort_sublists(lst):
    return sorted(lst, key=lambda x: (len(x), x))

# Test the function with the provided assertion
assert sort_sublists([[2], [0], [1, 3], [0, 7], [9, 11], [13, 15, 17]]) == [[0], [2], [0, 7], [1, 3], [9, 11], [13, 15, 17]]"
MBPP/699,min_Swaps,"def min_Swaps(s1: str, s2: str) -> int:
    if len(s1) != len(s2):
        return -1  # Strings must be of the same length
    
    # Count the number of '1's and '0's in both strings
    count1 = [0, 0]  # count1[0] for '0's, count1[1] for '1's
    count2 = [0, 0]  # count2[0] for '0's, count2[1] for '1's
    
    for char in s1:
        count1[int(char)] += 1
    for char in s2:
        count2[int(char)] += 1
    
    # If the counts of '1's and '0's are not the same, return -1
    if count1 != count2:
        return -1
    
    # Find the positions where the characters differ
    mismatches = []
    for i in range(len(s1)):
        if s1[i] != s2[i]:
            mismatches.append((s1[i], s2[i]))
    
    # Count the number of swaps needed
    # Each swap can fix two mismatches
    swaps = 0
    count_01 = 0  # Count of '0' in s1 and '1' in s2
    count_10 = 0  # Count of '1' in s1 and '0' in s2
    
    for m in mismatches:
        if m == ('0', '1'):
            count_01 += 1
        elif m == ('1', '0'):
            count_10 += 1
    
    # The number of swaps needed is the maximum of the two counts
    swaps = max(count_01, count_10)
    
    return swaps

# Test the function with the provided assertion
assert min_Swaps(""1101"", ""1110"") == 1"
MBPP/713,check_valid,"def check_valid(tup):
    # Check if all elements in the tuple are boolean values
    return all(isinstance(x, bool) for x in tup)

# Test the function with the provided assertion
assert check_valid((True, True, True, True)) == True"
MBPP/710,front_and_rear,"def front_and_rear(record):
    # Access the first and last elements of the tuple
    return (record[0], record[-1])

# Test the function with the provided assertion
assert front_and_rear((10, 4, 5, 6, 7)) == (10, 7)"
MBPP/715,str_to_tuple,"def str_to_tuple(s):
    # Split the string by commas and convert each part to an integer
    return tuple(int(num.strip()) for num in s.split(','))

# Test the function with the provided assertion
assert str_to_tuple(""1, -5, 4, 6, 7"") == (1, -5, 4, 6, 7)"
MBPP/716,rombus_perimeter,"def rombus_perimeter(side_length):
    return 4 * side_length

# Test the function with the provided assertion
assert rombus_perimeter(10) == 40"
MBPP/718,alternate_elements,"def alternate_elements(input_list):
    return input_list[::2]

# Test the function with the provided assertion
assert alternate_elements([""red"", ""black"", ""white"", ""green"", ""orange""]) == ['red', 'white', 'orange']"
MBPP/712,remove_duplicate,"def remove_duplicate(lst):
    seen = set()
    result = []
    for sublist in lst:
        # Convert the sublist to a tuple (which is hashable) to check for duplicates
        sublist_tuple = tuple(sublist)
        if sublist_tuple not in seen:
            seen.add(sublist_tuple)
            result.append(sublist)
    return result

# Test the function with the provided assertion
assert remove_duplicate([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]]) == [[10, 20], [40], [30, 56, 25], [33]]"
MBPP/702,removals,"def removals(arr, n, k):
    # Sort the array
    arr.sort()
    
    left = 0
    max_length = 0
    
    # Use two pointers to find the longest valid subarray
    for right in range(len(arr)):
        # While the condition is not met, move the left pointer
        while arr[right] - arr[left] > k:
            left += 1
        # Calculate the length of the current valid subarray
        max_length = max(max_length, right - left + 1)
    
    # The number of elements to remove is the total elements minus the length of the longest valid subarray
    return len(arr) - max_length

# Test the function with the provided assertion
assert removals([1, 3, 4, 9, 10, 11, 12, 17, 20], 9, 4) == 5"
MBPP/709,get_unique,"def get_unique(pairs):
    value_to_keys = {}
    
    for key, value in pairs:
        if value not in value_to_keys:
            value_to_keys[value] = set()  # Use a set to store unique keys
        value_to_keys[value].add(key)
    
    # Count the unique keys for each value
    unique_counts = {value: len(keys) for value, keys in value_to_keys.items()}
    
    # Format the output as a string
    return str(unique_counts)

# Test the function with the provided assertion
assert get_unique([(3, 4), (1, 2), (2, 4), (8, 2), (7, 2), (8, 1), (9, 1), (8, 4), (10, 4)]) == '{4: 4, 2: 3, 1: 2}'"
MBPP/717,sd_calc,"import math

def sd_calc(data):
    if len(data) == 0:
        raise ValueError(""The data list cannot be empty."")
    
    mean = sum(data) / len(data)
    variance = sum((x - mean) ** 2 for x in data) / len(data)
    return math.sqrt(variance)

# Test the function with the provided assertion
assert sd_calc([4, 2, 5, 8, 6]) == 2.23606797749979"
MBPP/720,add_dict_to_tuple,"def add_dict_to_tuple(tup, dictionary):
    return tup + (dictionary,)

# Test the function with the provided assertion
assert add_dict_to_tuple((4, 5, 6), {""MSAM"": 1, ""is"": 2, ""best"": 3}) == (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})"
MBPP/711,product_Equal,"def product_Equal(number):
    # Convert the number to a string to easily access each digit
    num_str = str(number)
    
    # Initialize products for even and odd positioned digits
    product_even = 1
    product_odd = 1
    
    # Iterate through the digits and their indices
    for index, digit in enumerate(num_str):
        digit_value = int(digit)
        # Check if the index is even or odd
        if index % 2 == 0:  # Even index
            product_even *= digit_value
        else:  # Odd index
            product_odd *= digit_value
    
    # Compare the products
    return product_even == product_odd

# Test the function with the provided assertion
assert product_Equal(2841) == True"
MBPP/722,filter_data,"def filter_data(students, min_height, min_weight):
    filtered_students = {}
    for name, (height, weight) in students.items():
        if height >= min_height and weight >= min_weight:
            filtered_students[name] = (height, weight)
    return filtered_students

# Example usage
assert filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)}, 6.0, 70) == {'Cierra Vega': (6.2, 70)}"
MBPP/719,text_match,"import re

def text_match(text):
    # Define the regex pattern for 'a' followed by zero or more 'b's
    pattern = r'a(b*)'
    
    # Use re.fullmatch to check if the entire string matches the pattern
    if re.fullmatch(pattern, text):
        return 'Found a match!'
    else:
        return 'No match found.'

# Test the function
assert text_match(""ac"") == 'No match found.'
assert text_match(""ab"") == 'Found a match!'
assert text_match(""a"") == 'Found a match!'
assert text_match(""abb"") == 'Found a match!'
assert text_match(""abc"") == 'No match found.'"
MBPP/724,power_base_sum,"def power_base_sum(base, power):
    # Calculate base raised to the power
    result = base ** power
    
    # Convert the result to a string and sum the digits
    digit_sum = sum(int(digit) for digit in str(result))
    
    return digit_sum

# Test the function with the provided assertion
assert power_base_sum(2, 100) == 115"
MBPP/725,extract_quotation,"import re

def extract_quotation(s):
    # Use regex to find all occurrences of text within double quotes
    return re.findall(r'""(.*?)""', s)

# Test the function with the provided assertion
assert extract_quotation('Cortex ""A53"" Based ""multi"" tasking ""Processor""') == ['A53', 'multi', 'Processor']"
MBPP/729,add_list,"def add_list(list1, list2):
    return list(map(lambda x, y: x + y, list1, list2))

# Test the function with the provided assertion
assert add_list([1, 2, 3], [4, 5, 6]) == [5, 7, 9]"
MBPP/727,remove_char,"import re

def remove_char(input_string):
    # Use regex to replace all non-alphanumeric characters with an empty string
    return re.sub(r'[^a-zA-Z0-9]', '', input_string)

# Test the function with the provided assertion
assert remove_char(""123abcjw:, .@! eiw"") == '123abcjweiw'"
MBPP/728,sum_list,"def sum_list(list1, list2):
    return [a + b for a, b in zip(list1, list2)]

# Test the function with the provided assertion
assert sum_list([10, 20, 30], [15, 25, 35]) == [25, 45, 65]"
MBPP/714,count_Fac,"def count_Fac(n):
    if n < 2:
        return 0
    
    distinct_prime_factors = set()
    
    # Check for number of 2s that divide n
    while n % 2 == 0:
        distinct_prime_factors.add(2)
        n //= 2
    
    # n must be odd at this point, so we can skip even numbers
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            distinct_prime_factors.add(i)
            n //= i
    
    # This condition is to check if n is a prime number greater than 2
    if n > 2:
        distinct_prime_factors.add(n)
    
    return len(distinct_prime_factors)

# Test the function with the provided assertion
assert count_Fac(24) == 3"
MBPP/726,multiply_elements,"def multiply_elements(input_tuple):
    # Use a list comprehension to multiply adjacent elements
    return tuple(input_tuple[i] * input_tuple[i + 1] for i in range(len(input_tuple) - 1))

# Test the function with the provided assertion
assert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)

# You can also print the result to verify
print(multiply_elements((1, 5, 7, 8, 10)))  # Output: (5, 35, 56, 80)"
MBPP/731,lateralsurface_cone,"import math

def lateralsurface_cone(radius, slant_height):
    return math.pi * radius * slant_height

# Test the function with the provided assertion
assert lateralsurface_cone(5, 12) == 204.20352248333654"
MBPP/730,consecutive_duplicates,"def consecutive_duplicates(lst):
    if not lst:
        return []
    
    result = [lst[0]]  # Start with the first element
    
    for i in range(1, len(lst)):
        if lst[i] != lst[i - 1]:  # Check if the current element is different from the last added
            result.append(lst[i])
    
    return result

# Test the function with the provided assertion
assert consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]"
MBPP/723,count_same_pair,"def count_same_pair(list1, list2):
    # Use map to create a list of boolean values indicating if the elements are the same
    same_pairs = map(lambda x, y: x == y, list1, list2)
    # Count the number of True values in the resulting map
    return sum(same_pairs)

# Test the function with the provided assertion
assert count_same_pair([1, 2, 3, 4, 5, 6, 7, 8], [2, 2, 3, 1, 2, 6, 7, 9]) == 4"
MBPP/732,replace_specialchar,"def replace_specialchar(text):
    # Replace spaces, commas, and dots with a colon
    return text.replace(' ', ':').replace(',', ':').replace('.', ':')

# Test the function with the provided assertion
assert replace_specialchar('Python language, Programming language.') == 'Python:language::Programming:language:'"
MBPP/721,maxAverageOfPath,"def maxAverageOfPath(matrix, n):
    def dfs(x, y, current_sum, steps):
        # If we reach the bottom-right corner, calculate the average
        if x == n - 1 and y == n - 1:
            return (current_sum + matrix[x][y]) / (steps + 1)
        
        # Mark the current cell as visited
        visited.add((x, y))
        max_avg = float('-inf')
        
        # Explore the four possible directions (down, up, right, left)
        for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:
                avg = dfs(nx, ny, current_sum + matrix[x][y], steps + 1)
                max_avg = max(max_avg, avg)
        
        # Unmark the current cell (backtrack)
        visited.remove((x, y))
        return max_avg

    visited = set()
    return dfs(0, 0, 0, 0)

# Test the function with the provided assertion
assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]], 3) == 5.2"
MBPP/737,check_str,"import re

def check_str(s):
    # Check if the string starts with a vowel (case insensitive)
    if re.match(r'^[aeiouAEIOU]', s):
        return 'Valid'
    else:
        return 'Invalid'

# Test the function
assert check_str(""annie"") == 'Valid'"
MBPP/733,find_first_occurrence,"def find_first_occurrence(arr, target):
    left, right = 0, len(arr) - 1
    result = -1  # Initialize result to -1, indicating not found

    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            result = mid  # Update result to the current mid index
            right = mid - 1  # Continue searching in the left half
        elif arr[mid] < target:
            left = mid + 1  # Search in the right half
        else:
            right = mid - 1  # Search in the left half

    return result

# Test the function with the provided assertion
assert find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 1"
MBPP/735,toggle_middle_bits,"def toggle_middle_bits(n):
    # Convert the number to binary and remove the '0b' prefix
    binary = bin(n)[2:]
    
    # If the number has less than 3 bits, return it as is
    if len(binary) <= 2:
        return n
    
    # Toggle the middle bits
    middle_bits = list(binary[1:-1])  # Get the middle bits
    for i in range(len(middle_bits)):
        middle_bits[i] = '1' if middle_bits[i] == '0' else '0'  # Toggle the bit
    
    # Reconstruct the binary number
    new_binary = binary[0] + ''.join(middle_bits) + binary[-1]
    
    # Convert back to decimal
    return int(new_binary, 2)

# Test the function with the provided assertion
assert toggle_middle_bits(9) == 15"
MBPP/736,left_insertion,"def left_insertion(sorted_list, value):
    low, high = 0, len(sorted_list)
    
    while low < high:
        mid = (low + high) // 2
        if sorted_list[mid] < value:
            low = mid + 1
        else:
            high = mid
            
    return low

# Test the function with the provided assertion
assert left_insertion([1, 2, 4, 5], 6) == 4"
MBPP/734,sum_Of_Subarray_Prod,"def sum_Of_Subarray_Prod(arr, n):
    total_sum = 0
    
    # Iterate over all possible starting points of subarrays
    for i in range(n):
        product = 1
        
        # Iterate over all possible ending points of subarrays
        for j in range(i, n):
            product *= arr[j]  # Calculate the product of the current subarray
            total_sum += product  # Add the product to the total sum
            
    return total_sum

# Test the function with the provided assertion
assert sum_Of_Subarray_Prod([1, 2, 3], 3) == 20"
MBPP/740,tuple_to_dict,"def tuple_to_dict(tup):
    # Create a dictionary from the tuple using adjacent elements
    return {tup[i]: tup[i + 1] for i in range(0, len(tup) - 1, 2)}

# Test the function with the provided assertion
assert tuple_to_dict((1, 5, 7, 10, 13, 5)) == {1: 5, 7: 10, 13: 5}"
MBPP/741,all_Characters_Same,"def all_Characters_Same(s):
    if not s:  # Check if the string is empty
        return True  # Consider empty string as having all same characters
    return all(char == s[0] for char in s)

# Test the function with the provided assertion
assert all_Characters_Same(""python"") == False"
MBPP/742,area_tetrahedron,"import math

def area_tetrahedron(a):
    return math.sqrt(3) * a**2

# Test the function with the provided assertion
assert area_tetrahedron(3) == 15.588457268119894"
MBPP/744,check_none,"def check_none(tup):
    return any(item is None for item in tup)

# Test the function with the provided assertion
assert check_none((10, 4, 5, 6, None)) == True"
MBPP/743,rotate_right,"def rotate_right(lst, num_positions, length):
    # Normalize the number of positions to rotate
    num_positions = num_positions % length
    # Rotate the list
    return lst[-num_positions:] + lst[:-num_positions]

# Test the function with the provided assertion
assert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3, 10) == [8, 9, 10, 1, 2, 3, 4, 5, 6]"
MBPP/738,geometric_sum,"def geometric_sum(n):
    if n <= 1:
        return 0  # If n is 1 or less, the sum is 0 since there are no terms.
    a = 1  # First term
    r = 0.5  # Common ratio
    num_terms = n - 1  # Number of terms
    return a * (1 - r**num_terms) / (1 - r)

# Test the function with the provided assertion
assert geometric_sum(7) == 1.9921875"
MBPP/739,find_Index,"def find_Index(n):
    # Calculate the minimum value for a number to have n digits
    min_value = 10 ** (n - 1)
    
    k = 1
    while True:
        # Calculate the k-th triangular number
        triangular_number = k * (k + 1) // 2
        
        # Check if it has at least n digits
        if triangular_number >= min_value:
            return k
        
        k += 1

# Test the function with the provided assertion
assert find_Index(2) == 4"
MBPP/750,add_tuple,"def add_tuple(lst, tup):
    # Convert the tuple to a list and extend the original list with it
    lst.extend(tup)
    return lst

# Test the function with the provided assertion
assert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]"
MBPP/746,sector_area,"import math

def sector_area(radius, angle):
    return (angle / 360) * math.pi * (radius ** 2)

# Test the function with the provided assertion
assert sector_area(4, 45) == 6.285714285714286"
MBPP/755,second_smallest,"def second_smallest(numbers):
    # Remove duplicates by converting the list to a set
    unique_numbers = list(set(numbers))
    
    # Sort the unique numbers
    unique_numbers.sort()
    
    # Return the second smallest number if it exists
    if len(unique_numbers) >= 2:
        return unique_numbers[1]
    else:
        raise ValueError(""List must contain at least two unique numbers."")

# Test the function with the provided assertion
assert second_smallest([1, 2, -8, -2, 0, -2]) == -2"
MBPP/752,jacobsthal_num,"def jacobsthal_num(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return jacobsthal_num(n - 2) + 2 * jacobsthal_num(n - 1)

# Test the function with the provided assertion
assert jacobsthal_num(5) == 11"
MBPP/748,capital_words_spaces,"import re

def capital_words_spaces(s):
    # Use regex to find capital letters and add a space before them
    return re.sub(r'(?<!^)(?=[A-Z])', ' ', s)

# Test the function with the provided assertion
assert capital_words_spaces(""Python"") == 'Python'

# Example usage
print(capital_words_spaces(""HelloWorld""))  # Output: 'Hello World'
print(capital_words_spaces(""ThisIsATest""))  # Output: 'This Is A Test'"
MBPP/745,divisible_by_digits,"def divisible_by_digits(start, end):
    result = []
    for num in range(start, end + 1):
        str_num = str(num)
        if all(int(digit) != 0 and num % int(digit) == 0 for digit in str_num):
            result.append(num)
    return result

# Test the function with the provided assertion
assert divisible_by_digits(1, 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]"
MBPP/753,min_k,"def min_k(records, k):
    # Sort the records based on the second element of the tuple
    sorted_records = sorted(records, key=lambda x: x[1])
    # Return the first k records
    return sorted_records[:k]

# Test the function with the provided assertion
assert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]"
MBPP/756,text_match_zero_one,"import re

def text_match_zero_one(text):
    # Regular expression to match 'a' followed by zero or one 'b'
    pattern = r'a(b)?'
    
    # Search for the pattern in the input text
    if re.search(pattern, text):
        return 'Found a match!'
    else:
        return 'No match found.'

# Test the function with the provided assertion
assert text_match_zero_one(""ac"") == 'Found a match!'"
MBPP/754,extract_index_list,"def extract_index_list(list1, list2, list3):
    # Find the minimum length of the three lists to avoid index errors
    min_length = min(len(list1), len(list2), len(list3))
    
    # Use a set to store common elements
    common_elements = set()
    
    # Iterate through the indices of the lists
    for i in range(min_length):
        if list1[i] == list2[i] == list3[i]:
            common_elements.add(list1[i])
    
    # Return the common elements as a sorted list
    return sorted(common_elements)

# Test the function with the provided assertion
assert extract_index_list([1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]) == [1, 7]"
MBPP/751,check_min_heap,"def check_min_heap(arr, index):
    n = len(arr)
    
    # Calculate the left and right child indices
    left = 2 * index + 1
    right = 2 * index + 2
    
    # Check if the current index is a valid index
    if index >= n:
        return True
    
    # Check the left child
    if left < n and arr[left] < arr[index]:
        return False
    
    # Check the right child
    if right < n and arr[right] < arr[index]:
        return False
    
    # Recursively check the left and right subtrees
    return check_min_heap(arr, left) and check_min_heap(arr, right)

# Test the function with the provided assertion
assert check_min_heap([1, 2, 3, 4, 5, 6], 0) == True"
MBPP/760,unique_Element,"def unique_Element(arr, n):
    if n == 0:
        return 'NO'  # Edge case: empty array
    first_element = arr[0]
    for element in arr:
        if element != first_element:
            return 'NO'
    return 'YES'

# Test the function with the provided assertion
assert unique_Element([1, 1, 1], 3) == 'YES'"
MBPP/747,lcs_of_three,"def lcs_of_three(str1, str2, str3, len1, len2, len3):
    # Create a 3D array to store lengths of longest common subsequence
    dp = [[[0] * (len3 + 1) for _ in range(len2 + 1)] for __ in range(len1 + 1)]

    # Build the dp array
    for i in range(1, len1 + 1):
        for j in range(1, len2 + 1):
            for k in range(1, len3 + 1):
                if str1[i - 1] == str2[j - 1] == str3[k - 1]:
                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1
                else:
                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])

    return dp[len1][len2][len3]

# Test the function with the provided assertion
assert lcs_of_three('AGGT12', '12TXAYB', '12XBA', 6, 7, 5) == 2"
MBPP/759,is_decimal,"def is_decimal(value):
    try:
        # Convert the string to a float
        float_value = float(value)
        # Check if the string matches the decimal format with up to 2 decimal places
        return value == f""{float_value:.2f}""
    except ValueError:
        return False

# Test the function
assert is_decimal('123.11') == True
assert is_decimal('123.1') == True
assert is_decimal('123.111') == False
assert is_decimal('123') == True
assert is_decimal('abc') == False
assert is_decimal('123.') == False
assert is_decimal('.11') == False"
MBPP/762,check_monthnumber_number,"def check_monthnumber_number(month):
    # Months with 30 days: April (4), June (6), September (9), November (11)
    return month in [4, 6, 9, 11]

# Test the function with the provided assertion
assert check_monthnumber_number(6) == True"
MBPP/758,unique_sublists,"def unique_sublists(lst):
    count_dict = {}
    
    for sublist in lst:
        # Convert the sublist to a tuple to use it as a dictionary key
        key = tuple(sublist)
        if key in count_dict:
            count_dict[key] += 1
        else:
            count_dict[key] = 1
            
    return count_dict

# Test the function with the provided assertion
assert unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]]) == {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}"
MBPP/749,sort_numeric_strings,"def sort_numeric_strings(string_list):
    # Convert the list of strings to a list of integers
    num_list = [int(num) for num in string_list]
    # Sort the list of integers
    num_list.sort()
    return num_list

# Test the function with the provided assertion
assert sort_numeric_strings(['4', '12', '45', '7', '0', '100', '200', '-12', '-500']) == [-500, -12, 0, 4, 7, 12, 45, 100, 200]"
MBPP/763,find_Min_Diff,"def find_Min_Diff(arr, n):
    # Sort the array
    arr = sorted(arr)
    
    # Initialize the minimum difference to a large value
    min_diff = float('inf')
    
    # Iterate through the sorted array to find the minimum difference
    for i in range(n - 1):
        diff = arr[i + 1] - arr[i]
        if diff < min_diff:
            min_diff = diff
            
    return min_diff

# Test the function with the provided assertion
assert find_Min_Diff((1, 5, 3, 19, 18, 25), 6) == 1"
MBPP/761,arc_length,"import math

def arc_length(radius, angle_degrees):
    # Convert angle from degrees to radians
    angle_radians = math.radians(angle_degrees)
    # Calculate arc length
    return radius * angle_radians

# Test the function with the provided assertion
assert arc_length(9, 45) == 3.5357142857142856"
MBPP/764,number_ctr,"def number_ctr(s):
    return sum(c.isdigit() for c in s)

# Test the function with the provided assertion
assert number_ctr('program2bedone') == 1"
MBPP/757,count_reverse_pairs,"def count_reverse_pairs(string_list):
    # Create a set to store the unique strings for quick lookup
    string_set = set(string_list)
    count = 0
    
    # Iterate through the list of strings
    for string in string_list:
        # Check if the reverse of the string is in the set
        reversed_string = string[::-1]
        if reversed_string in string_set:
            count += 1
            
            # Remove the reversed string from the set to avoid double counting
            string_set.remove(reversed_string)
    
    # Since each pair is counted twice, we divide the count by 2
    return str(count // 2)

# Test the function with the provided assertion
assert count_reverse_pairs([""julia"", ""best"", ""tseb"", ""for"", ""ailuj""]) == '2'"
MBPP/768,check_Odd_Parity,"def check_Odd_Parity(num):
    # Count the number of 1s in the binary representation of the number
    count_of_ones = bin(num).count('1')
    # Check if the count of 1s is odd
    return count_of_ones % 2 == 1

# Test the function with the provided assertion
assert check_Odd_Parity(13) == True"
MBPP/766,pair_wise,"def pair_wise(lst):
    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]

# Test the function with the provided assertion
assert pair_wise([1, 1, 2, 3, 3, 4, 4, 5]) == [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]"
MBPP/772,remove_length,"def remove_length(input_string, k):
    # Split the input string into words
    words = input_string.split()
    # Filter out words that have length k
    filtered_words = [word for word in words if len(word) != k]
    # Join the filtered words back into a string
    return ' '.join(filtered_words)

# Test the function with the provided assertion
assert remove_length('The person is most value tet', 3) == 'person is most value'"
MBPP/765,is_polite,"def is_power_of_two(n):
    return (n & (n - 1)) == 0 and n > 0

def is_polite(n):
    return not is_power_of_two(n)

def nth_polite_number(n):
    count = 0
    current_number = 1
    
    while count < n:
        if is_polite(current_number):
            count += 1
        current_number += 1
    
    return current_number - 1

# Test the function with the provided assertion
assert nth_polite_number(7) == 11"
MBPP/770,odd_Num_Sum,"def odd_Num_Sum(n):
    # Initialize the sum
    total_sum = 0
    
    # Loop through the first n odd natural numbers
    for i in range(n):
        odd_number = 2 * i + 1  # Generate the i-th odd number
        total_sum += odd_number ** 4  # Add the fourth power of the odd number to the sum
    
    return total_sum

# Test the function with the provided assertion
assert odd_Num_Sum(2) == 82"
MBPP/773,occurance_substring,"def occurance_substring(main_string, substring):
    start_index = main_string.find(substring)
    if start_index != -1:
        end_index = start_index + len(substring)
        return (substring, start_index, end_index)
    return None  # Return None if the substring is not found

# Test the function with the provided assertion
assert occurance_substring('python programming, python language', 'python') == ('python', 0, 6)"
MBPP/776,count_vowels,"def count_vowels(s):
    vowels = set('aeiouAEIOU')
    count = 0
    
    for i in range(len(s)):
        if (i > 0 and s[i-1] in vowels) or (i < len(s) - 1 and s[i+1] in vowels):
            count += 1
            
    return count

# Test the function with the provided assertion
assert count_vowels('bestinstareels') == 7"
MBPP/775,odd_position,"def odd_position(lst):
    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 to check odd indices
        if lst[i] % 2 == 0:  # Check if the number at the odd index is even
            return False
    return True

# Test the function with the provided assertion
assert odd_position([2, 1, 4, 3, 6, 7, 6, 3]) == True"
MBPP/769,candidate,"def Diff(list1, list2):
    return [item for item in list1 if item not in list2]

# Test the function with the provided assertion
assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 15, 20, 30]"
MBPP/771,check_expression,"def check_expression(expression):
    # Dictionary to hold matching pairs of brackets
    bracket_map = {')': '(', '}': '{', ']': '['}
    # Stack to keep track of opening brackets
    stack = []

    for char in expression:
        # If the character is a closing bracket
        if char in bracket_map:
            # Pop the topmost element from the stack if it's not empty, else assign a dummy value
            top_element = stack.pop() if stack else '#'
            # Check if the popped bracket matches the corresponding opening bracket
            if bracket_map[char] != top_element:
                return False
        # If it's an opening bracket, push onto the stack
        else:
            stack.append(char)

    # If the stack is empty, all brackets were matched; otherwise, it's unbalanced
    return not stack

# Test the function with the provided assertion
assert check_expression(""{()}[{}]"") == True"
MBPP/779,unique_sublists,"def unique_sublists(lst):
    count_dict = {}
    
    for sublist in lst:
        # Convert the list to a tuple to use it as a dictionary key
        key = tuple(sublist)
        if key in count_dict:
            count_dict[key] += 1
        else:
            count_dict[key] = 1
            
    return count_dict

# Test the function with the provided assertion
assert unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]]) == {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}"
MBPP/777,find_Sum,"def find_Sum(arr, n):
    # Create a dictionary to count occurrences of each element
    count = {}
    
    # Count each element in the array
    for num in arr:
        if num in count:
            count[num] += 1
        else:
            count[num] = 1
    
    # Calculate the sum of non-repeated elements
    non_repeated_sum = sum(num for num, cnt in count.items() if cnt == 1)
    
    return non_repeated_sum

# Test the function with the provided assertion
assert find_Sum([1, 2, 3, 1, 1, 4, 5, 6], 8) == 21"
MBPP/774,check_email,"import re

def check_email(email):
    # Define the regex pattern for a valid email
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    
    # Use re.match to check if the email matches the pattern
    if re.match(pattern, email):
        return 'Valid Email'
    else:
        return 'Invalid Email'

# Test the function with the provided assertion
assert check_email(""ankitrai326@gmail.com"") == 'Valid Email'"
MBPP/781,count_Divisors,"def count_Divisors(n):
    if n <= 0:
        return ""Invalid input""
    
    count = 0
    for i in range(1, n + 1):
        if n % i == 0:
            count += 1
            
    return ""Even"" if count % 2 == 0 else ""Odd""

# Test the function with the provided assertion
assert count_Divisors(10) == ""Even"""
MBPP/767,get_Pairs_Count,"def get_Pairs_Count(arr, n, target_sum):
    count = 0
    num_count = {}

    # Count occurrences of each number in the array
    for num in arr:
        if num in num_count:
            num_count[num] += 1
        else:
            num_count[num] = 1

    # Iterate through the array to find pairs
    for num in arr:
        complement = target_sum - num
        if complement in num_count:
            count += num_count[complement]
            # If num and complement are the same, we need to adjust the count
            if complement == num:
                count -= 1

    # Each pair is counted twice, so divide by 2
    return count // 2

# Test the function with the provided assertion
assert get_Pairs_Count([1, 1, 1, 1], 4, 2) == 6"
MBPP/785,tuple_str_int,"def tuple_str_int(tuple_str):
    # Remove the parentheses and split the string by comma
    elements = tuple_str.strip(""()"").split("","")
    # Convert each element to an integer and return as a tuple
    return tuple(int(element.strip()) for element in elements)

# Test the function with the provided assertion
assert tuple_str_int(""(7, 8, 9)"") == (7, 8, 9)"
MBPP/778,pack_consecutive_duplicates,"def pack_consecutive_duplicates(lst):
    if not lst:
        return []
    
    packed_list = []
    current_sublist = [lst[0]]
    
    for item in lst[1:]:
        if item == current_sublist[-1]:
            current_sublist.append(item)
        else:
            packed_list.append(current_sublist)
            current_sublist = [item]
    
    packed_list.append(current_sublist)  # Append the last sublist
    return packed_list

# Test the function with the provided assertion
assert pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]"
MBPP/788,new_tuple,"def new_tuple(lst, string):
    return tuple(lst) + (string,)

# Test the function with the provided assertion
assert new_tuple([""WEB"", ""is""], ""best"") == ('WEB', 'is', 'best')"
MBPP/787,text_match_three,"import re

def text_match_three(text):
    # Define the regex pattern to match 'a' followed by three 'b's
    pattern = r'a(b{3})'
    
    # Use re.fullmatch to check if the entire string matches the pattern
    if re.fullmatch(pattern, text):
        return 'Matched!'
    else:
        return 'Not matched!'

# Test the function with the provided assertion
assert text_match_three(""ac"") == 'Not matched!'"
MBPP/780,find_combinations,"def find_combinations(tuple_list):
    result = []
    n = len(tuple_list)
    
    for i in range(n):
        for j in range(n):
            if i != j:  # Ensure we are not adding the same tuple
                sum_tuple = (tuple_list[i][0] + tuple_list[j][0], tuple_list[i][1] + tuple_list[j][1])
                result.append(sum_tuple)
    
    # Remove duplicates by converting to a set and back to a list
    result = list(set(result))
    
    return result

# Test the function with the provided assertion
assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]"
MBPP/784,mul_even_odd,"def mul_even_odd(numbers):
    first_even = None
    first_odd = None
    
    for num in numbers:
        if num % 2 == 0 and first_even is None:
            first_even = num
        elif num % 2 != 0 and first_odd is None:
            first_odd = num
        
        # Break the loop if both first even and odd are found
        if first_even is not None and first_odd is not None:
            break
    
    # If either even or odd number is not found, return 0
    if first_even is None or first_odd is None:
        return 0
    
    return first_even * first_odd

# Test the function with the provided assertion
assert mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 4"
MBPP/789,perimeter_polygon,"def perimeter_polygon(num_sides, side_length):
    return num_sides * side_length

# Test the function with the provided assertion
assert perimeter_polygon(4, 20) == 80"
MBPP/786,right_insertion,"def right_insertion(sorted_list, value):
    """"""
    Locate the right insertion point for a specified value in sorted order.

    Parameters:
    sorted_list (list): A list of sorted elements.
    value: The value to be inserted.

    Returns:
    int: The index at which the value should be inserted.
    """"""
    low, high = 0, len(sorted_list)

    while low < high:
        mid = (low + high) // 2
        if sorted_list[mid] <= value:
            low = mid + 1
        else:
            high = mid

    return low

# Example usage
assert right_insertion([1, 2, 4, 5], 6) == 4"
MBPP/782,Odd_Length_Sum,"def Odd_Length_Sum(arr):
    total_sum = 0
    n = len(arr)
    
    # Iterate over all possible starting points of subarrays
    for start in range(n):
        # Iterate over all possible ending points of subarrays
        for end in range(start, n):
            # Calculate the length of the subarray
            length = end - start + 1
            # Check if the length is odd
            if length % 2 == 1:
                # Add the sum of the subarray to the total sum
                total_sum += sum(arr[start:end + 1])
    
    return total_sum

# Test the function with the provided assertion
assert Odd_Length_Sum([1, 2, 4]) == 14"
MBPP/792,count_list,"def count_list(lists):
    return len(lists)

# Test the function with the provided assertion
assert count_list([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4"
MBPP/790,even_position,"def even_position(lst):
    for i in range(0, len(lst), 2):  # Iterate over even indices
        if lst[i] % 2 != 0:  # Check if the number at the even index is odd
            return False
    return True

# Test the function with the provided assertion
assert even_position([3, 2, 1]) == False"
MBPP/796,return_sum,"def return_sum(input_dict):
    return sum(input_dict.values())

# Test the function with the provided assertion
assert return_sum({'a': 100, 'b': 200, 'c': 300}) == 600"
MBPP/783,rgb_to_hsv,"def rgb_to_hsv(r, g, b):
    # Normalize the RGB values to the range [0, 1]
    r /= 255.0
    g /= 255.0
    b /= 255.0

    # Find the maximum and minimum values of r, g, b
    mx = max(r, g, b)
    mn = min(r, g, b)
    df = mx - mn

    # Calculate the hue
    if df == 0:
        h = 0  # Achromatic
    elif mx == r:
        h = (60 * ((g - b) / df) + 360) % 360
    elif mx == g:
        h = (60 * ((b - r) / df) + 120) % 360
    else:  # mx == b
        h = (60 * ((r - g) / df) + 240) % 360

    # Calculate the saturation
    s = 0 if mx == 0 else (df / mx)

    # Calculate the value
    v = mx

    # Convert to percentage
    s *= 100
    v *= 100

    return (h, s, v)

# Test the function with the provided assertion
assert rgb_to_hsv(255, 255, 255) == (0, 0.0, 100.0)"
MBPP/798,_sum,"def _sum(array):
    return sum(array)

# Test the function
assert _sum([1, 2, 3]) == 6"
MBPP/800,remove_all_spaces,"def remove_all_spaces(input_string):
    return input_string.replace("" "", """")

# Test the function
assert remove_all_spaces('python  program') == 'pythonprogram'"
MBPP/794,text_starta_endb,"import re

def text_starta_endb(text):
    # Regular expression to match 'a' followed by anything and ending with 'b'
    pattern = r'^a.*b$'
    
    if re.match(pattern, text):
        return 'Found a match!'
    else:
        return 'No match found.'

# Test the function with the provided assertion
assert text_starta_endb(""aabbbb"") == 'Found a match!'"
MBPP/791,remove_nested,"def remove_nested(tup):
    # Use a generator expression to filter out nested tuples
    return tuple(item for item in tup if not isinstance(item, tuple))

# Test the function with the provided assertion
assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)

# You can also add more test cases to verify the function
assert remove_nested((1, (2, 3), 4, (5,))) == (1, 4)
assert remove_nested(((1, 2), (3, 4), 5)) == (5,)
assert remove_nested((1, 2, 3)) == (1, 2, 3)
assert remove_nested(()) == ()"
MBPP/797,sum_in_Range,"def sum_in_range(l, r):
    # Initialize the sum
    total_sum = 0
    
    # Iterate through the range from l to r
    for num in range(l, r + 1):
        # Check if the number is odd
        if num % 2 != 0:
            total_sum += num
            
    return total_sum

# Test the function with the provided assertion
assert sum_in_range(2, 5) == 8"
MBPP/795,cheap_items,"import heapq

def cheap_items(items, n):
    # Use a heap to find the n cheapest items
    return heapq.nsmallest(n, items, key=lambda x: x['price'])

# Test the function with the provided assertion
assert cheap_items([{'name': 'Item-1', 'price': 101.1}, {'name': 'Item-2', 'price': 555.22}], 1) == [{'name': 'Item-1', 'price': 101.1}]"
MBPP/793,last,"def last(arr, target, n):
    left, right = 0, n - 1
    last_position = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            last_position = mid  # Update last_position
            left = mid + 1  # Move to the right half to find the last occurrence
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
            
    return last_position

# Test the function with the provided assertion
assert last([1, 2, 3], 1, 3) == 0"
MBPP/801,test_three_equal,"def test_three_equal(a, b, c):
    # Initialize a counter for equal numbers
    count = 0
    
    # Check for equality and increment the counter
    if a == b:
        count += 1
    if b == c:
        count += 1
    if a == c:
        count += 1
    
    # If all three are equal, we should return 3
    if count == 3:
        return 3
    
    # Return the count of equal pairs
    return count

# Test the function with the provided assertion
assert test_three_equal(1, 1, 1) == 3"
MBPP/803,is_Perfect_Square,"def is_Perfect_Square(num):
    if num < 0:
        return False
    root = int(num**0.5)
    return root * root == num

# Test the function with the provided assertion
assert is_Perfect_Square(10) == False"
MBPP/799,left_Rotate,"def left_Rotate(n, d):
    # Assuming n is a 32-bit integer
    d = d % 32  # To handle cases where d >= 32
    return ((n << d) | (n >> (32 - d))) & 0xFFFFFFFF  # Mask to keep it 32 bits

# Test the function with the provided assertion
assert left_Rotate(16, 2) == 64"
MBPP/806,max_run_uppercase,"def max_run_uppercase(s):
    max_run = 0
    current_run = 0
    
    for char in s:
        if char.isupper():
            current_run += 1
            max_run = max(max_run, current_run)
        else:
            current_run = 0
            
    return max_run

# Test the function with the provided assertion
assert max_run_uppercase('GeMKSForGERksISBESt') == 5"
MBPP/808,check_K,"def check_K(tup, k):
    return k in tup

# Test the function with the provided assertion
assert check_K((10, 4, 5, 6, 8), 6) == True"
MBPP/807,first_odd,"def first_odd(numbers):
    for number in numbers:
        if number % 2 != 0:  # Check if the number is odd
            return number
    return None  # Return None if no odd number is found

# Test the function with the provided assertion
assert first_odd([1, 3, 5]) == 1"
MBPP/804,is_Product_Even,"def is_Product_Even(numbers, _):
    product = 1
    for number in numbers:
        product *= number
    return product % 2 == 0

# Test the function with the provided assertion
assert is_Product_Even([1, 2, 3], 3) == True"
MBPP/805,max_sum_list,"def max_sum_list(lists):
    # Initialize variables to track the maximum sum and the corresponding list
    max_sum = float('-inf')
    max_list = []

    # Iterate through each list in the list of lists
    for lst in lists:
        current_sum = sum(lst)  # Calculate the sum of the current list
        # Update max_sum and max_list if the current sum is greater
        if current_sum > max_sum:
            max_sum = current_sum
            max_list = lst

    return max_list

# Test the function with the provided assertion
assert max_sum_list([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [10, 11, 12]"
MBPP/809,check_smaller,"def check_smaller(tuple1, tuple2):
    # Check if the lengths of the tuples are the same
    if len(tuple1) != len(tuple2):
        raise ValueError(""Both tuples must have the same length."")
    
    # Check if each element in the second tuple is smaller than the corresponding element in the first tuple
    for i in range(len(tuple1)):
        if tuple2[i] >= tuple1[i]:
            return False
    return True

# Test the function with the provided assertion
assert check_smaller((1, 2, 3), (2, 3, 4)) == False"
MBPP/812,road_rd,"def road_rd(input_string):
    return input_string.replace('Road', 'Rd.')

# Test the function
assert road_rd(""ravipadu Road"") == 'ravipadu Rd.'"
MBPP/813,string_length,"def string_length(s):
    return len(s)

# Test the function
assert string_length('python') == 6"
MBPP/816,clear_tuple,"def clear_tuple(t):
    return ()

# Test the function
assert clear_tuple((1, 5, 3, 6, 8)) == ()"
MBPP/817,div_of_nums,"def div_of_nums(numbers, m, n):
    return list(filter(lambda x: x % m == 0 or x % n == 0, numbers))

# Test the function with the provided assertion
assert div_of_nums([19, 65, 57, 39, 152, 639, 121, 44, 90, 190], 19, 13) == [19, 65, 57, 39, 152, 190]"
MBPP/802,count_Rotation,"def count_Rotation(arr, n):
    # Function to find the index of the minimum element in the rotated sorted array
    def find_min_index(arr, low, high):
        if high < low:
            return 0
        if high == low:
            return low
        
        mid = (low + high) // 2
        
        # Check if mid is the minimum element
        if mid < high and arr[mid + 1] < arr[mid]:
            return mid + 1
        if mid > low and arr[mid] < arr[mid - 1]:
            return mid
        
        # Decide whether to go to the left half or the right half
        if arr[high] > arr[mid]:
            return find_min_index(arr, low, mid - 1)
        return find_min_index(arr, mid + 1, high)

    return find_min_index(arr, 0, n - 1)

# Test the function with the provided assertion
assert count_Rotation([3, 2, 1], 3) == 1"
MBPP/811,check_identical,"def check_identical(list1, list2):
    return list1 == list2

# Test the function with the provided assertion
assert check_identical([(10, 4), (2, 5)], [(10, 4), (2, 5)]) == True"
MBPP/810,count_variable,"def count_variable(*args):
    # Create a dictionary to count occurrences of each element
    count_dict = {}
    for item in args:
        if item in count_dict:
            count_dict[item] += 1
        else:
            count_dict[item] = 1
    
    # Create a list to hold the repeated elements
    result = []
    for item, count in count_dict.items():
        result.extend([item] * count)
    
    return result

# Test the function with the provided assertion
assert count_variable(4, 2, 0, -2) == [4, 4, 2, 2, 0, -2]"
MBPP/818,lower_ctr,"def lower_ctr(s):
    count = 0
    for char in s:
        if char.islower():
            count += 1
    return count

# Test the function with the provided assertion
assert lower_ctr('abc') == 3"
MBPP/820,check_monthnum_number,"def check_monthnum_number(month):
    """"""
    Check if the given month number contains 28 days.
    
    Args:
    month (int): The month number (1 for January, 2 for February, ..., 12 for December).
    
    Returns:
    bool: True if the month has 28 days, False otherwise.
    """"""
    # February is the only month that has 28 days in a non-leap year
    return month == 2

# Test the function with the provided assertion
assert check_monthnum_number(2) == True"
MBPP/814,rombus_area,"def rombus_area(d1, d2):
    return (d1 * d2) / 2

# Test the function with the provided assertion
assert rombus_area(10, 20) == 100"
MBPP/825,access_elements,"def access_elements(lst, indices):
    return [lst[i] for i in indices]

# Test the function with the provided assertion
assert access_elements([2, 3, 8, 4, 7, 9], [0, 3, 5]) == [2, 4, 9]"
MBPP/824,remove_even,"def remove_even(numbers):
    return [num for num in numbers if num % 2 != 0]

# Test the function with the provided assertion
assert remove_even([1, 3, 5, 2]) == [1, 3, 5]"
MBPP/821,merge_dictionaries,"def merge_dictionaries(dict1, dict2):
    return {**dict1, **dict2}

# Test the function with the provided assertion
assert merge_dictionaries({""R"": ""Red"", ""B"": ""Black"", ""P"": ""Pink""}, {""G"": ""Green"", ""W"": ""White""}) == {'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White'}"
MBPP/819,count_duplic,"def count_duplic(numbers):
    if not numbers:
        return [], []
    
    unique_elements = []
    counts = []
    
    current_element = numbers[0]
    current_count = 1
    
    for number in numbers[1:]:
        if number == current_element:
            current_count += 1
        else:
            unique_elements.append(current_element)
            counts.append(current_count)
            current_element = number
            current_count = 1
    
    # Append the last element and its count
    unique_elements.append(current_element)
    counts.append(current_count)
    
    return unique_elements, counts

# Test the function with the provided assertion
assert count_duplic([1, 2, 2, 2, 4, 4, 4, 5, 5, 5, 5]) == ([1, 2, 4, 5], [1, 3, 3, 4])"
MBPP/815,sort_by_dnf,"def sort_by_dnf(arr, n):
    low = 0
    mid = 0
    high = n - 1

    while mid <= high:
        if arr[mid] == 0:
            arr[low], arr[mid] = arr[mid], arr[low]
            low += 1
            mid += 1
        elif arr[mid] == 1:
            mid += 1
        else:  # arr[mid] == 2
            arr[mid], arr[high] = arr[high], arr[mid]
            high -= 1

    return arr

# Test the function with the provided assertion
assert sort_by_dnf([1, 2, 0, 1, 0, 1, 2, 1, 1], 9) == [0, 0, 1, 1, 1, 1, 1, 2, 2]"
MBPP/823,check_substring,"import re

def check_substring(main_string, substring):
    # Create a regex pattern to check if the main_string starts with the substring
    pattern = f'^{re.escape(substring)}'
    
    # Use re.match to check if the main_string starts with the substring
    if re.match(pattern, main_string):
        return 'string starts with the given substring'
    else:
        return 'string doesnt start with the given substring'

# Test the function with the provided assertion
assert check_substring(""dreams for dreams makes life fun"", ""makes"") == 'string doesnt start with the given substring'"
MBPP/822,pass_validity,"import re

def pass_validity(password):
    # Check the length of the password
    if len(password) < 8:
        return False
    
    # Check for at least one uppercase letter
    if not re.search(r'[A-Z]', password):
        return False
    
    # Check for at least one lowercase letter
    if not re.search(r'[a-z]', password):
        return False
    
    # Check for at least one digit
    if not re.search(r'[0-9]', password):
        return False
    
    # Check for at least one special character
    if not re.search(r'[!@#$%^&*(),.?"":{}|<>]', password):
        return False
    
    return True

# Test the function with the provided assertion
assert pass_validity(""password"") == False"
MBPP/827,sum_column,"def sum_column(matrix, column_index):
    """"""
    Sums the values in a specific column of a list of lists.

    :param matrix: List of lists containing numerical values
    :param column_index: Index of the column to sum
    :return: Sum of the specified column
    """"""
    return sum(row[column_index] for row in matrix)

# Example usage and assertion
assert sum_column([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]], 0) == 12"
MBPP/830,round_up,"import math

def round_up(number, digits):
    """"""
    Rounds up a number to a specified number of decimal places.

    Parameters:
    number (float): The number to round up.
    digits (int): The number of decimal places to round up to.

    Returns:
    float: The rounded up number.
    """"""
    factor = 10 ** digits
    return math.ceil(number * factor) / factor

# Example usage
assert round_up(123.01247, 0) == 124"
MBPP/828,count_alpha_dig_spl,"def count_alpha_dig_spl(input_string):
    alphabets = 0
    digits = 0
    special_chars = 0
    
    for char in input_string:
        if char.isalpha():
            alphabets += 1
        elif char.isdigit():
            digits += 1
        else:
            special_chars += 1
            
    return (alphabets, digits, special_chars)

# Test the function with the provided assertion
assert count_alpha_dig_spl(""abc!@#123"") == (3, 3, 3)"
MBPP/833,get_key,"def get_key(d):
    return list(d.keys())

# Test the function with the provided assertion
assert get_key({1: 'python', 2: 'java'}) == [1, 2]"
MBPP/829,second_frequent,"from collections import Counter

def second_frequent(strings):
    # Count the frequency of each string in the list
    frequency = Counter(strings)
    
    # Get the two most common strings
    most_common = frequency.most_common(2)
    
    # Check if there are at least two different strings
    if len(most_common) < 2:
        return None  # or raise an exception if preferred
    
    # Return the second most common string
    return most_common[1][0]

# Test the function with the provided assertion
assert second_frequent(['aaa', 'bbb', 'ccc', 'bbb', 'aaa', 'aaa']) == 'bbb'"
MBPP/832,extract_max,"import re

def extract_max(s):
    # Find all sequences of digits in the string
    numbers = re.findall(r'\d+', s)
    # Convert the found sequences to integers
    numbers = [int(num) for num in numbers]
    # Return the maximum value found, or None if no numbers were found
    return max(numbers) if numbers else None

# Test the function with the provided assertion
assert extract_max('100klh564abc365bg') == 564"
MBPP/835,slope,"def slope(x1, y1, x2, y2):
    if x2 - x1 == 0:  # Check for division by zero
        raise ValueError(""The x-coordinates must be different to calculate the slope."")
    return (y2 - y1) / (x2 - x1)

# Test the function with the provided assertion
assert slope(4, 2, 2, 5) == -1.5"
MBPP/826,check_Type_Of_Triangle,"def check_Type_Of_Triangle(a, b, c):
    # First, sort the sides to easily apply the triangle properties
    sides = sorted([a, b, c])
    a, b, c = sides[0], sides[1], sides[2]
    
    # Check for triangle inequality
    if a + b <= c:
        return ""Not a Triangle""
    
    # Determine the type of triangle
    if a**2 + b**2 > c**2:
        return ""Acute-angled Triangle""
    elif a**2 + b**2 == c**2:
        return ""Right-angled Triangle""
    else:
        return ""Obtuse-angled Triangle""

# Example assertion
assert check_Type_Of_Triangle(1, 2, 3) == ""Obtuse-angled Triangle"""
MBPP/831,count_Pairs,"def count_Pairs(arr, n):
    from collections import Counter
    
    # Count occurrences of each element
    count = Counter(arr)
    
    # Calculate the number of pairs
    pairs = 0
    for value in count.values():
        if value > 1:
            pairs += (value * (value - 1)) // 2  # Combination formula C(n, 2)
    
    return pairs

# Test the function with the provided assertion
assert count_Pairs([1, 1, 1, 1], 4) == 6"
MBPP/839,sort_tuple,"def sort_tuple(tuples_list):
    return sorted(tuples_list, key=lambda x: x[0])

# Test the function with the provided assertion
assert sort_tuple([(""Amana"", 28), (""Zenat"", 30), (""Abhishek"", 29), (""Nikhil"", 21), (""B"", ""C"")]) == [('Abhishek', 29), ('Amana', 28), ('B', 'C'), ('Nikhil', 21), ('Zenat', 30)]"
MBPP/837,cube_Sum,"def cube_Sum(n):
    return sum((2 * i + 1) ** 3 for i in range(n))

# Test the function with the provided assertion
assert cube_Sum(2) == 28"
MBPP/834,generate_matrix,"def generate_matrix(n):
    # Create an n x n matrix initialized with zeros
    matrix = [[0] * n for _ in range(n)]
    
    # Define the boundaries of the spiral
    top, bottom, left, right = 0, n - 1, 0, n - 1
    num = 1  # Start filling with 1
    
    while top <= bottom and left <= right:
        # Fill the top row
        for i in range(left, right + 1):
            matrix[top][i] = num
            num += 1
        top += 1
        
        # Fill the right column
        for i in range(top, bottom + 1):
            matrix[i][right] = num
            num += 1
        right -= 1
        
        if top <= bottom:
            # Fill the bottom row
            for i in range(right, left - 1, -1):
                matrix[bottom][i] = num
                num += 1
            bottom -= 1
        
        if left <= right:
            # Fill the left column
            for i in range(bottom, top - 1, -1):
                matrix[i][left] = num
                num += 1
            left += 1
    
    return matrix

# Test the function with the provided assertion
assert generate_matrix(3) == [[1, 2, 3], [8, 9, 4], [7, 6, 5]]"
MBPP/842,get_odd_occurence,"def get_odd_occurence(arr, n):
    # Create a dictionary to count occurrences of each number
    count = {}
    
    for num in arr:
        if num in count:
            count[num] += 1
        else:
            count[num] = 1
    
    # Find and return the number that occurs an odd number of times
    for num, cnt in count.items():
        if cnt % 2 != 0:
            return num

# Test the function with the provided assertion
assert get_odd_occurence([2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2], 13) == 5"
MBPP/838,min_Swaps,"def min_Swaps(s1: str, s2: str) -> int:
    if len(s1) != len(s2):
        raise ValueError(""Strings must be of the same length"")
    
    # Count the number of differing positions
    count_diff = 0
    count_01 = 0  # Count of '0' in s1 and '1' in s2
    count_10 = 0  # Count of '1' in s1 and '0' in s2
    
    for a, b in zip(s1, s2):
        if a != b:
            count_diff += 1
            if a == '0' and b == '1':
                count_01 += 1
            elif a == '1' and b == '0':
                count_10 += 1
    
    # The number of swaps needed is the maximum of count_01 and count_10
    return max(count_01, count_10)

# Test the function with the provided assertion
assert min_Swaps(""0011"", ""1111"") == 1"
MBPP/836,max_sub_array_sum,"def max_sub_array_sum(arr, n):
    if n == 0:
        return 0

    max_sum = float('-inf')
    current_sum = 0
    max_length = 0
    current_length = 0

    for i in range(n):
        current_sum += arr[i]
        current_length += 1

        if current_sum > max_sum:
            max_sum = current_sum
            max_length = current_length
        elif current_sum < 0:
            current_sum = 0
            current_length = 0

    return max_length

# Test the function with the provided assertion
assert max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 5"
MBPP/844,get_Number,"def get_Number(k, n):
    # Generate the first n odd numbers
    odds = [i for i in range(1, 2*n, 2)]
    # Generate the first n even numbers
    evens = [i for i in range(0, 2*n, 2)]
    # Combine odds and evens
    combined = odds + evens
    # Return the k-th element (1-based index)
    return combined[k - 1]

# Test the function with the provided assertion
assert get_Number(8, 5) == 2"
MBPP/847,lcopy,"def lcopy(singleton_tuple):
    # Ensure the input is a singleton tuple
    if len(singleton_tuple) != 1:
        raise ValueError(""Input must be a singleton tuple."")
    
    # Return a list containing the single element of the tuple
    return list(singleton_tuple[0])

# Example usage
assert lcopy((1,)) == [1]
assert lcopy((2,)) == [2]
assert lcopy((3,)) == [3]"
MBPP/845,find_Digits,"import math

def find_Digits(n):
    if n < 0:
        return 0  # Factorial is not defined for negative numbers
    if n == 0 or n == 1:
        return 1  # 0! and 1! both equal 1, which has 1 digit

    # Calculate the number of digits in n!
    digits = 0
    for i in range(2, n + 1):
        digits += math.log10(i)
    
    return math.floor(digits) + 1

# Test the function with the provided assertion
assert find_Digits(7) == 4"
MBPP/841,get_inv_count,"def merge_and_count(arr, temp_arr, left, mid, right):
    i = left    # Starting index for left subarray
    j = mid + 1 # Starting index for right subarray
    k = left    # Starting index to be sorted
    inv_count = 0

    while i <= mid and j <= right:
        if arr[i] <= arr[j]:
            temp_arr[k] = arr[i]
            i += 1
        else:
            # There are mid - i inversions, because all elements left to i in the left subarray
            # are greater than arr[j]
            temp_arr[k] = arr[j]
            inv_count += (mid - i + 1)
            j += 1
        k += 1

    # Copy the remaining elements of left subarray, if any
    while i <= mid:
        temp_arr[k] = arr[i]
        i += 1
        k += 1

    # Copy the remaining elements of right subarray, if any
    while j <= right:
        temp_arr[k] = arr[j]
        j += 1
        k += 1

    # Copy the sorted subarray into Original array
    for i in range(left, right + 1):
        arr[i] = temp_arr[i]
        
    return inv_count

def merge_sort_and_count(arr, temp_arr, left, right):
    inv_count = 0
    if left < right:
        mid = (left + right) // 2

        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)
        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)
        inv_count += merge_and_count(arr, temp_arr, left, mid, right)

    return inv_count

def get_inv_count(arr, n):
    temp_arr = [0] * n
    return merge_sort_and_count(arr, temp_arr, 0, n - 1)

# Test the function with the provided assertion
assert get_inv_count([1, 20, 6, 4, 5], 5) == 5"
MBPP/846,find_platform,"def find_platform(arrivals, departures, n):
    # Sort both the arrival and departure times
    arrivals.sort()
    departures.sort()
    
    # Initialize platform needed and result
    platform_needed = 1
    result = 1
    
    # Pointers for arrivals and departures
    i = 1  # Pointer for arrivals
    j = 0  # Pointer for departures
    
    # Process all events in sorted order
    while i < n and j < n:
        # If next event is arrival, increment platform needed
        if arrivals[i] <= departures[j]:
            platform_needed += 1
            i += 1
        # If next event is departure, decrement platform needed
        else:
            platform_needed -= 1
            j += 1
        
        # Update result if needed
        result = max(result, platform_needed)
    
    return result

# Test the function with the provided assertion
assert find_platform([900, 940, 950, 1100, 1500, 1800], [910, 1200, 1120, 1130, 1900, 2000], 6) == 3"
MBPP/840,Check_Solution,"def Check_Solution(a, b, c):
    # Check if the discriminant is zero
    discriminant = b**2 - 4*a*c
    if discriminant == 0 and b == 0:
        return ""Yes""
    else:
        return ""No""

# Test the function with the provided assertion
assert Check_Solution(2, 0, -1) == ""Yes"""
MBPP/843,nth_super_ugly_number,"import heapq

def nth_super_ugly_number(n, primes):
    # Min-heap to store the next potential super ugly numbers
    heap = []
    # Set to keep track of the unique super ugly numbers
    seen = set()
    
    # Start with the first super ugly number
    heapq.heappush(heap, 1)
    seen.add(1)
    
    # Variable to store the current super ugly number
    ugly_number = 1
    
    for _ in range(n):
        # Get the smallest super ugly number from the heap
        ugly_number = heapq.heappop(heap)
        
        # Generate new super ugly numbers by multiplying with each prime
        for prime in primes:
            new_ugly = ugly_number * prime
            if new_ugly not in seen:
                seen.add(new_ugly)
                heapq.heappush(heap, new_ugly)
    
    return ugly_number

# Test the function with the provided assertion
assert nth_super_ugly_number(12, [2, 7, 13, 19]) == 32"
MBPP/850,is_triangleexists,"def is_triangleexists(angle1, angle2, angle3):
    # Check if all angles are positive and their sum is 180
    return angle1 > 0 and angle2 > 0 and angle3 > 0 and (angle1 + angle2 + angle3) == 180

# Test the function with the provided assertion
assert is_triangleexists(50, 60, 70) == True"
MBPP/848,area_trapezium,"def area_trapezium(a, b, h):
    return 0.5 * (a + b) * h

# Test the function with the provided assertion
assert area_trapezium(6, 9, 4) == 30"
MBPP/852,remove_negs,"def remove_negs(lst):
    """"""Remove negative numbers from a list.""""""
    return [num for num in lst if num >= 0]

# Test the function with the provided assertion
assert remove_negs([1, -2, 3, -4]) == [1, 3]"
MBPP/849,Sum,"def is_prime(n):
    """"""Check if a number is prime.""""""
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def prime_divisors_sum(n):
    """"""Return the sum of all prime divisors of a given number.""""""
    prime_divisors = set()
    
    # Check for all numbers from 2 to n
    for i in range(2, n + 1):
        if n % i == 0 and is_prime(i):
            prime_divisors.add(i)
    
    return sum(prime_divisors)

# Test the function
assert prime_divisors_sum(60) == 10"
MBPP/853,sum_of_odd_Factors,"def sum_of_odd_factors(n):
    odd_factors_sum = 0
    for i in range(1, n + 1):
        if n % i == 0 and i % 2 != 0:  # Check if i is a factor and odd
            odd_factors_sum += i
    return odd_factors_sum

# Test the function with the provided assertion
assert sum_of_odd_factors(30) == 24"
MBPP/854,raw_heap,"import heapq

def raw_heap(lst):
    # Convert the list into a heap in-place
    heapq.heapify(lst)
    return lst

# Test the function with the provided assertion
assert raw_heap([25, 44, 68, 21, 39, 23, 89]) == [21, 25, 23, 44, 39, 68, 89]"
MBPP/855,check_Even_Parity,"def check_Even_Parity(number):
    # Count the number of 1s in the binary representation of the number
    count_of_ones = bin(number).count('1')
    # Check if the count of 1s is even
    return count_of_ones % 2 == 0

# Test the function with the provided assertion
assert check_Even_Parity(10) == True"
MBPP/858,count_list,"def count_list(list_of_lists):
    # Count the number of lists in the given list of lists
    count = len(list_of_lists)
    # Return the square of the count
    return count ** 2

# Test the function with the provided assertion
assert count_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 25"
MBPP/857,listify_list,"def listify_list(strings):
    return list(map(list, strings))

# Test the function with the provided assertion
assert listify_list(['Red', 'Blue', 'Black', 'White', 'Pink']) == [['R', 'e', 'd'], ['B', 'l', 'u', 'e'], ['B', 'l', 'a', 'c', 'k'], ['W', 'h', 'i', 't', 'e'], ['P', 'i', 'n', 'k']]"
MBPP/864,palindrome_lambda,"def palindrome_lambda(strings):
    return list(filter(lambda s: s == s[::-1], strings))

# Test the function with the provided assertion
assert palindrome_lambda([""php"", ""res"", ""Python"", ""abcd"", ""Java"", ""aaa""]) == ['php', 'aaa']"
MBPP/851,Sum_of_Inverse_Divisors,"def Sum_of_Inverse_Divisors(start, end):
    def inverse_divisor_sum(n):
        total = 0
        for i in range(1, n + 1):
            if n % i == 0:  # Check if i is a divisor of n
                total += 1 / i  # Add the inverse of the divisor
        return total

    total_sum = 0
    for number in range(start, end + 1):
        total_sum += inverse_divisor_sum(number)

    return total_sum

# Test the function with the provided assertion
assert Sum_of_Inverse_Divisors(6, 12) == 2"
MBPP/860,check_alphanumeric,"import re

def check_alphanumeric(s):
    # Check if the string ends with only alphanumeric characters
    if re.search(r'[^\w]$', s):
        return 'Discard'
    return 'Accept'

# Test the function with the provided assertion
assert check_alphanumeric(""dawood@"") == 'Discard'"
MBPP/861,anagram_lambda,"def anagram_lambda(words, target):
    # Sort the target string to create a reference for comparison
    sorted_target = sorted(target)
    # Use a lambda function to filter the list of words
    return list(filter(lambda word: sorted(word) == sorted_target, words))

# Test the function with the provided assertion
assert anagram_lambda([""bcda"", ""abce"", ""cbda"", ""cbea"", ""adcb""], ""abcd"") == ['bcda', 'cbda', 'adcb']"
MBPP/862,n_common_words,"from collections import Counter
import re

def n_common_words(text, n):
    # Normalize the text to lowercase and use regex to find words
    words = re.findall(r'\b\w+\b', text.lower())
    # Count the occurrences of each word
    word_counts = Counter(words)
    # Get the n most common words
    return word_counts.most_common(n)

# Example usage
assert n_common_words(""python is a programming language"", 1) == [('python', 1)]"
MBPP/863,find_longest_conseq_subseq,"def find_longest_conseq_subseq(arr, n):
    if n == 0:
        return 0
    
    # Create a set from the array to get unique elements
    unique_elements = set(arr)
    longest_streak = 0
    
    for num in unique_elements:
        # Check if it's the start of a sequence
        if num - 1 not in unique_elements:
            current_num = num
            current_streak = 1
            
            # Count the length of the consecutive sequence
            while current_num + 1 in unique_elements:
                current_num += 1
                current_streak += 1
            
            # Update the longest streak found
            longest_streak = max(longest_streak, current_streak)
    
    return longest_streak

# Test the function with the provided assertion
assert find_longest_conseq_subseq([1, 2, 2, 3], 4) == 3"
MBPP/859,sub_lists,"def sub_lists(input_list):
    result = []
    n = len(input_list)
    
    # Generate all possible combinations of the list
    for i in range(1 << n):  # 2^n combinations
        sublist = []
        for j in range(n):
            if i & (1 << j):  # Check if jth element is included
                sublist.append(input_list[j])
        result.append(sublist)
    
    return result

# Test the function with the provided assertion
assert sub_lists([10, 20, 30, 40]) == [[], [10], [20], [30], [40], 
                                        [10, 20], [10, 30], [10, 40], 
                                        [20, 30], [20, 40], [30, 40], 
                                        [10, 20, 30], [10, 20, 40], 
                                        [10, 30, 40], [20, 30, 40], 
                                        [10, 20, 30, 40]]"
MBPP/856,find_Min_Swaps,"def find_Min_Swaps(arr, n):
    # Count the number of 1's in the array
    count_ones = arr.count(1)
    
    # Initialize the number of swaps
    swaps = 0
    # Initialize the position of 1's
    position_of_ones = 0
    
    # Iterate through the array
    for i in range(n):
        # If we encounter a 1, we calculate how many 0's are to its left
        if arr[i] == 1:
            # The number of swaps needed for this 1 is equal to the number of 0's
            # that have been encountered so far
            swaps += i - position_of_ones
            position_of_ones += 1
            
    return swaps

# Test the function with the provided assertion
assert find_Min_Swaps([1, 0, 1, 0], 4) == 3"
MBPP/865,ntimes_list,"def ntimes_list(lst, n):
    return list(map(lambda x: x * n, lst))

# Test the function with the provided assertion
assert ntimes_list([1, 2, 3, 4, 5, 6, 7], 3) == [3, 6, 9, 12, 15, 18, 21]"
MBPP/868,length_Of_Last_Word,"def length_of_last_word(s: str) -> int:
    # Strip any trailing spaces and split the string into words
    words = s.strip().split()
    # Return the length of the last word if there are any words
    return len(words[-1]) if words else 0

# Test the function with the provided assertion
assert length_of_last_word(""python language"") == 8"
MBPP/866,check_monthnumb,"def check_monthnumb(month_name):
    # List of months that have 31 days
    months_with_31_days = [
        ""January"", ""March"", ""May"", ""July"", 
        ""August"", ""October"", ""December""
    ]
    
    # Check if the month name is in the list
    return month_name in months_with_31_days

# Test the function with the assertion
assert check_monthnumb(""February"") == False"
MBPP/870,sum_positivenum,"def sum_positivenum(numbers):
    return sum(filter(lambda x: x > 0, numbers))

# Test the function with the provided assertion
assert sum_positivenum([2, 4, -6, -9, 11, -12, 14, -5, 17]) == 48"
MBPP/867,min_Num,"def min_Num(arr, num):
    total_sum = sum(arr) + num
    return 1 if total_sum % 2 != 0 else 0

# Test the function with the provided assertion
assert min_Num([1, 2, 3, 4, 5, 6, 7, 8, 9], 9) == 1"
MBPP/873,fibonacci,"def fibonacci(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

# Test the function with the provided assertion
assert fibonacci(7) == 13"
MBPP/871,are_Rotations,"def are_Rotations(str1, str2):
    # Check if lengths are the same
    if len(str1) != len(str2):
        return False
    
    # Concatenate str1 with itself
    temp = str1 + str1
    
    # Check if str2 is a substring of the concatenated string
    return str2 in temp

# Test the function with the provided assertion
assert are_Rotations(""abc"", ""cba"") == False"
MBPP/877,sort_String,"def sort_String(s):
    return ''.join(sorted(s))

# Test the function
assert sort_String(""cba"") == ""abc"""
MBPP/869,remove_list_range,"def remove_list_range(lists, min_val, max_val):
    # Filter the lists to keep only those where all elements are within the specified range
    return [sublist for sublist in lists if all(min_val <= item <= max_val for item in sublist)]

# Test the function with the provided assertion
assert remove_list_range([[2], [0], [1, 2, 3], [0, 1, 2, 3, 6, 7], [9, 11], [13, 14, 15, 17]], 13, 17) == [[13, 14, 15, 17]]"
MBPP/874,check_Concat,"def check_Concat(s, sub):
    # Check if the length of s is a multiple of the length of sub
    if len(s) % len(sub) != 0:
        return False
    
    # Calculate how many times sub should repeat
    repeat_count = len(s) // len(sub)
    
    # Create the concatenated string by repeating sub
    concatenated_string = sub * repeat_count
    
    # Check if the concatenated string matches s
    return concatenated_string == s

# Test the function with the provided assertion
assert check_Concat(""abcabcabc"", ""abc"") == True"
MBPP/872,check_subset,"def check_subset(main_list, subset):
    # Convert the main list to a set of tuples for easier comparison
    main_set = set(tuple(item) for item in main_list)
    # Convert the subset to a set of tuples
    subset_set = set(tuple(item) for item in subset)
    
    # Check if the subset set is a subset of the main set
    return subset_set.issubset(main_set)

# Test the function with the provided assertion
assert check_subset([[1, 3], [5, 7], [9, 11], [13, 15, 17]], [[1, 3], [13, 15, 17]]) == True"
MBPP/876,lcm,"def lcm(a, b):
    # Function to calculate the greatest common divisor (GCD)
    def gcd(x, y):
        while y:
            x, y = y, x % y
        return x
    
    # LCM formula: lcm(a, b) = abs(a*b) // gcd(a, b)
    return abs(a * b) // gcd(a, b)

# Test the function with the provided assertion
assert lcm(4, 6) == 12"
MBPP/875,min_difference,"def min_difference(tuples):
    # Initialize min_diff to a large number
    min_diff = float('inf')
    
    # Iterate through each tuple
    for a, b in tuples:
        # Calculate the absolute difference
        diff = abs(a - b)
        # Update min_diff if the current difference is smaller
        if diff < min_diff:
            min_diff = diff
            
    return min_diff

# Test the function with the provided assertion
assert min_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 1"
MBPP/879,text_match,"import re

def text_match(string):
    # Define the regex pattern
    pattern = r'a.*b$'
    
    # Use re.match to check if the pattern matches the string
    if re.match(pattern, string):
        return 'Matched!'
    else:
        return 'Not matched!'

# Test the function
assert text_match(""aabbbbd"") == 'Not matched!'"
MBPP/883,div_of_nums,"def div_of_nums(numbers, m, n):
    return list(filter(lambda x: x % m == 0 and x % n == 0, numbers))

# Test the function with the provided assertion
assert div_of_nums([19, 65, 57, 39, 152, 639, 121, 44, 90, 190], 2, 4) == [152, 44]"
MBPP/880,Check_Solution,"def Check_Solution(a, b, c):
    # Calculate the discriminant
    D = b**2 - 4*a*c
    
    # Determine the number of solutions based on the discriminant
    if D > 0:
        return ""2 solutions""
    elif D == 0:
        return ""1 solution""
    else:
        return ""0 solutions""

# Example assertion
assert Check_Solution(2, 5, 2) == ""2 solutions"""
MBPP/882,parallelogram_perimeter,"def parallelogram_perimeter(a, b):
    return 2 * (a + b)

# Assertion to test the function
assert parallelogram_perimeter(10, 20) == 60"
MBPP/881,sum_even_odd,"def sum_even_odd(numbers):
    first_even = None
    first_odd = None
    
    for number in numbers:
        if number % 2 == 0 and first_even is None:
            first_even = number
        elif number % 2 != 0 and first_odd is None:
            first_odd = number
        
        # Break the loop if both first even and odd are found
        if first_even is not None and first_odd is not None:
            break
    
    # If either is not found, we can return 0 for that part
    return (first_even if first_even is not None else 0) + (first_odd if first_odd is not None else 0)

# Test the function with the provided assertion
assert sum_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 5"
MBPP/887,is_odd,"def is_odd(number):
    return (number & 1) == 1

# Test the function
assert is_odd(5) == True
assert is_odd(4) == False
assert is_odd(0) == False
assert is_odd(-3) == True"
MBPP/886,sum_num,"def sum_num(numbers):
    total = sum(numbers)  # Calculate the sum of the numbers
    count = len(numbers)  # Get the number of elements in the list
    return total / count  # Return the average

# Test the function with the provided assertion
assert sum_num((8, 2, 3, 0, 7)) == 4.0"
MBPP/878,check_tuples,"def check_tuples(tup, elements):
    # Convert the list of elements to a set for faster lookup
    element_set = set(elements)
    
    # Check if all elements in the tuple are in the set of specified elements
    return all(item in element_set for item in tup)

# Test the function with the provided assertion
assert check_tuples((3, 5, 6, 5, 3, 6), [3, 6, 5]) == True"
MBPP/891,same_Length,"def same_length(num1, num2):
    return len(str(abs(num1))) == len(str(abs(num2)))

# Test the function with the provided assertion
assert same_length(12, 1) == False"
MBPP/884,all_Bits_Set_In_The_Given_Range,"def all_Bits_Set_In_The_Given_Range(num, start, end):
    # Create a mask for the bits in the given range
    mask = ((1 << (end - start + 1)) - 1) << start
    
    # Check if the bits in the range are set in the number
    return (num & mask) == mask

# Test the function with the provided assertion
assert all_Bits_Set_In_The_Given_Range(10, 2, 1) == True"
MBPP/885,is_Isomorphic,"def is_Isomorphic(s1, s2):
    if len(s1) != len(s2):
        return False

    mapping_s1_to_s2 = {}
    mapping_s2_to_s1 = {}

    for char1, char2 in zip(s1, s2):
        if char1 in mapping_s1_to_s2:
            if mapping_s1_to_s2[char1] != char2:
                return False
        else:
            mapping_s1_to_s2[char1] = char2

        if char2 in mapping_s2_to_s1:
            if mapping_s2_to_s1[char2] != char1:
                return False
        else:
            mapping_s2_to_s1[char2] = char1

    return True

# Test the function with the provided assertion
assert is_Isomorphic(""paper"", ""title"") == True"
MBPP/888,substract_elements,"def substract_elements(t1, t2):
    return tuple(
        tuple(a - b for a, b in zip(inner_t1, inner_t2))
        for inner_t1, inner_t2 in zip(t1, t2)
    )

# Test the function with the provided assertion
assert substract_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((-5, -4), (1, -4), (1, 8), (-6, 7))"
MBPP/889,reverse_list_lists,"def reverse_list_lists(list_of_lists):
    return [lst[::-1] for lst in list_of_lists]

# Test the function with the provided assertion
assert reverse_list_lists([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == [[4, 3, 2, 1], [8, 7, 6, 5], [12, 11, 10, 9], [16, 15, 14, 13]]"
MBPP/890,find_Extra,"def find_Extra(arr1, arr2, n):
    # Since arr1 is longer than arr2, we can iterate through arr2
    for i in range(n):
        if arr1[i] != arr2[i]:
            return i  # Return the index of the extra element in arr1
    return n  # If no difference found, the extra element is at the end of arr1

# Example usage
assert find_Extra([1, 2, 3, 4], [1, 2, 3], 3) == 3"
MBPP/892,remove_spaces,"def remove_spaces(input_string):
    # Split the string by whitespace and join it back with a single space
    return ' '.join(input_string.split())

# Test the function with the provided assertion
assert remove_spaces('python  program') == 'python program'"
MBPP/897,is_Word_Present,"def is_Word_Present(sentence, word):
    # Check if the word is present in the sentence
    return word in sentence.split()

# Test the function with the provided assertion
assert is_Word_Present(""machine learning"", ""machine"") == True"
MBPP/896,sort_list_last,"def sort_list_last(tuples):
    return sorted(tuples, key=lambda x: x[-1])

# Test the function with the provided assertion
assert sort_list_last([(2, 5), (1, 2), (4, 4), (2, 3), (2, 1)]) == [(2, 1), (1, 2), (2, 3), (4, 4), (2, 5)]"
MBPP/900,match_num,"def match_num(s):
    # Check if the string starts with '5'
    return s.startswith('5')

# Test the function with the provided assertion
assert match_num('5-2345861') == True"
MBPP/893,Extract,"def Extract(sublists):
    return [sublist[-1] for sublist in sublists]

# Test the function with the provided assertion
assert Extract([[1, 2, 3], [4, 5], [6, 7, 8, 9]]) == [3, 5, 9]"
MBPP/894,float_to_tuple,"def float_to_tuple(float_string):
    # Split the string by commas and convert each part to a float
    float_list = [float(num) for num in float_string.split(',')]
    # Convert the list to a tuple and return it
    return tuple(float_list)

# Test the function with the provided assertion
assert float_to_tuple(""1.2, 1.3, 2.3, 2.4, 6.5"") == (1.2, 1.3, 2.3, 2.4, 6.5)"
MBPP/895,max_sum_subseq,"def max_sum_subseq(arr):
    n = len(arr)
    if n == 0:
        return 0
    if n == 1:
        return arr[0]
    
    # Create an array to store the maximum sum up to each index
    max_sum = [0] * n
    max_sum[0] = arr[0]
    max_sum[1] = max(arr[0], arr[1])
    
    for i in range(2, n):
        # Include the current element and add it to the max sum excluding the previous element
        include_current = arr[i] + max_sum[i - 2]
        # Exclude the current element
        exclude_current = max_sum[i - 1]
        # Take the maximum of including or excluding the current element
        max_sum[i] = max(include_current, exclude_current)
    
    return max_sum[-1]

# Test the function with the provided assertion
assert max_sum_subseq([1, 2, 9, 4, 5, 0, 4, 11, 6]) == 26"
MBPP/902,add_dict,"def add_dict(dict1, dict2):
    combined_dict = {}
    
    # Add values from the first dictionary
    for key, value in dict1.items():
        combined_dict[key] = value
    
    # Add values from the second dictionary
    for key, value in dict2.items():
        if key in combined_dict:
            combined_dict[key] += value
        else:
            combined_dict[key] = value
            
    return combined_dict

# Test the function with the provided assertion
assert add_dict({'a': 100, 'b': 200, 'c': 300}, {'a': 300, 'b': 200, 'd': 400}) == {'a': 400, 'b': 400, 'c': 300, 'd': 400}"
MBPP/898,extract_elements,"def extract_elements(lst, n):
    if n <= 0:
        return []
    
    result = []
    previous = None
    count = 0
    
    for element in lst:
        if element != previous:
            if count > 0:
                result.append(previous)
            previous = element
            count = 1
        else:
            count += 1
        
        if len(result) == n:
            break
    
    if count > 0 and len(result) < n:
        result.append(previous)
    
    return result

# Test the function with the provided assertion
assert extract_elements([1, 1, 3, 4, 4, 5, 6, 7], 2) == [1, 4]"
MBPP/904,even_num,"def even_num(n):
    # Check if the number is an integer and if it is even
    if isinstance(n, int):
        return n % 2 == 0
    return False

# Test the function with the provided assertion
assert even_num(13.5) == False"
MBPP/905,sum_of_square,"import math

def sum_of_square(n):
    # Calculate the binomial coefficient C(2n, n)
    return math.comb(2 * n, n)

# Test the function with the provided assertion
assert sum_of_square(4) == 70"
MBPP/899,check,"def check(arr, n):
    # If the array has less than 2 elements, it is trivially sortable
    if n < 2:
        return True
    
    # Create a new array using only the corner elements
    corner_elements = [arr[0], arr[-1]]
    
    # Sort the corner elements
    sorted_corners = sorted(corner_elements)
    
    # Check if the original array can be sorted using the corner elements
    # We can only replace the first and last elements with the sorted corners
    new_array = [sorted_corners[0]] + arr[1:-1] + [sorted_corners[1]]
    
    # Check if the new array is sorted
    return new_array == sorted(new_array)

# Test the function with the provided assertion
assert check([3, 2, 1, 2, 3, 4], 6) == True"
MBPP/901,smallest_multiple,"import math
from functools import reduce

def lcm(a, b):
    return abs(a * b) // math.gcd(a, b)

def smallest_multiple(n):
    return reduce(lcm, range(1, n + 1))

# Test the function with the provided assertion
assert smallest_multiple(13) == 360360"
MBPP/906,extract_date,"import re

def extract_date(url):
    # Regular expression to match the date pattern in the URL
    pattern = r'(\d{4})/(\d{2})/(\d{2})'
    matches = re.findall(pattern, url)
    return matches

# Test the function with the provided assertion
assert extract_date(""https://www.washingtonpost.com/news/football-insider/wp/2016/09/02/odell-beckhams-fame-rests-on-one-stupid-little-ball-josh-norman-tells-author/"") == [('2016', '09', '02')]"
MBPP/903,count_Unset_Bits,"def count_Unset_Bits(n):
    total_unset_bits = 0
    
    for i in range(1, n + 1):
        # Convert the number to binary and count the number of '0's
        binary_representation = bin(i)[2:]  # Get binary representation without '0b' prefix
        unset_bits_count = binary_representation.count('0')
        total_unset_bits += unset_bits_count
    
    return total_unset_bits

# Test the function with the provided assertion
assert count_Unset_Bits(2) == 1"
MBPP/909,previous_palindrome,"def is_palindrome(n):
    return str(n) == str(n)[::-1]

def previous_palindrome(n):
    # Start checking from the number just below n
    n -= 1
    while n >= 0:
        if is_palindrome(n):
            return n
        n -= 1
    return None  # In case there is no previous palindrome (for n = 0)

# Test the function with the provided assertion
assert previous_palindrome(99) == 88"
MBPP/907,lucky_num,"def lucky_num(n):
    # Start with a list of natural numbers
    numbers = list(range(1, n * 2))  # We need to ensure we have enough numbers
    index = 1  # Start with the second number (index 1)

    while index < len(numbers):
        # Remove every numbers[index]-th number
        step = numbers[index]
        numbers = [num for i, num in enumerate(numbers) if (i + 1) % step != 0]
        index += 1

    return numbers[:n]

# Test the function
assert lucky_num(10) == [1, 3, 7, 9, 13, 15, 21, 25, 31, 33]"
MBPP/913,end_num,"def end_num(s):
    # Check if the last character of the string is a digit
    return s[-1].isdigit() if s else False

# Test the function with the provided assertion
assert end_num('abcdef') == False"
MBPP/908,find_fixed_point,"def find_fixed_point(arr, n):
    for i in range(n):
        if arr[i] == i:
            return i
    return -1  # Return -1 if no fixed point is found

# Test the function with the provided assertion
assert find_fixed_point([-10, -1, 0, 3, 10, 11, 30, 50, 100], 9) == 3"
MBPP/912,int,"def lobb_num(n, m):
    if n == 0:
        return m + 1
    elif m == 0:
        return n + 1
    else:
        return lobb_num(n - 1, lobb_num(n, m - 1))

# Test the function with the provided assertion
assert int(lobb_num(5, 3)) == 35"
MBPP/917,text_uppercase_lowercase,"import re

def text_uppercase_lowercase(text):
    # Regular expression to match one uppercase letter followed by one or more lowercase letters
    pattern = r'[A-Z][a-z]+'
    
    # Find all matches in the input text
    matches = re.findall(pattern, text)
    
    # Check if any matches were found
    if matches:
        return 'Found a match!'
    else:
        return 'No match found.'

# Test the function with the provided assertion
assert text_uppercase_lowercase(""AaBbGg"") == 'Found a match!'"
MBPP/915,rearrange_numbs,"def rearrange_numbs(arr):
    # Use a lambda function to filter and sort the positive and negative numbers
    positives = list(filter(lambda x: x > 0, arr))
    negatives = list(filter(lambda x: x < 0, arr))
    
    # Combine the positives and negatives
    return positives + negatives

# Test the function with the provided assertion
assert rearrange_numbs([-1, 2, -3, 5, 7, 8, 9, -10]) == [2, 5, 7, 8, 9, -10, -3, -1]"
MBPP/911,maximum_product,"import heapq

def maximum_product(arr):
    if len(arr) < 3:
        raise ValueError(""Array must contain at least three numbers."")
    
    # Use heapq to find the three largest numbers
    largest_three = heapq.nlargest(3, arr)
    
    # Calculate the product of the three largest numbers
    product = largest_three[0] * largest_three[1] * largest_three[2]
    
    return product

# Test the function with the provided assertion
assert maximum_product([12, 74, 9, 50, 61, 41]) == 225700"
MBPP/919,multiply_list,"def multiply_list(items):
    result = 1
    for item in items:
        result *= item
    return result

# Test the function with the provided assertion
assert multiply_list([1, -2, 3]) == -6"
MBPP/914,is_Two_Alter,"def is_Two_Alter(s):
    # Check if the string has at least two characters
    if len(s) < 2:
        return False
    
    # Get the unique characters in the string
    unique_chars = set(s)
    
    # Check if there are exactly two unique characters
    if len(unique_chars) != 2:
        return False
    
    # Check if the characters alternate
    for i in range(len(s) - 1):
        if s[i] == s[i + 1]:
            return False
            
    return True

# Test the function with the provided assertion
assert is_Two_Alter(""abab"") == True"
MBPP/910,check_date,"def check_date(day, month, year):
    # Check if the year is a valid integer
    if not isinstance(year, int) or year < 1:
        return False
    
    # Check if the month is valid
    if month < 1 or month > 12:
        return False
    
    # Days in each month
    days_in_month = [31, 29 if (year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)) else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    
    # Check if the day is valid
    if day < 1 or day > days_in_month[month - 1]:
        return False
    
    return True

# Test the function
assert check_date(11, 11, 2002) == True"
MBPP/916,find_triplet_array,"def find_triplet_array(arr, n, target_sum):
    # Sort the array to use the two-pointer technique
    arr.sort()
    
    # Iterate through the array
    for i in range(n - 2):
        # Initialize two pointers
        left = i + 1
        right = n - 1
        
        while left < right:
            current_sum = arr[i] + arr[left] + arr[right]
            if current_sum == target_sum:
                return (arr[i], arr[left], arr[right])
            elif current_sum < target_sum:
                left += 1
            else:
                right -= 1
                
    return None

# Example usage
assert find_triplet_array([1, 4, 45, 6, 10, 8], 6, 22) == (4, 10, 8)"
MBPP/921,chunk_tuples,"def chunk_tuples(input_tuple, n):
    # Use a list comprehension to create chunks of size n
    return [input_tuple[i:i + n] for i in range(0, len(input_tuple), n)]

# Test the function with the provided assertion
assert chunk_tuples((10, 4, 5, 6, 7, 6, 8, 3, 4), 3) == [(10, 4, 5), (6, 7, 6), (8, 3, 4)]"
MBPP/925,mutiple_tuple,"def multiple_tuple(numbers):
    product = 1
    for number in numbers:
        product *= number
    return product

# Test the function with the provided assertion
assert multiple_tuple((4, 3, 2, 2, -1, 18)) == -864"
MBPP/924,max_of_two,"def max_of_two(a, b):
    """"""Return the maximum of two numbers.""""""
    return a if a > b else b

# Test the function
assert max_of_two(10, 20) == 20"
MBPP/922,max_product,"def max_product(arr):
    if len(arr) < 2:
        raise ValueError(""Array must contain at least two elements."")
    
    # Initialize variables to keep track of the two largest numbers
    max1 = max2 = float('-inf')
    
    for num in arr:
        if num > max1:
            max2 = max1
            max1 = num
        elif num > max2:
            max2 = num
    
    return (max2, max1)

# Test the function with the provided assertion
assert max_product([1, 2, 3, 4, 7, 0, 8, 4]) == (7, 8)"
MBPP/928,change_date_format,"def change_date_format(date_str):
    # Split the input date string by '-'
    year, month, day = date_str.split('-')
    # Rearrange the components to the desired format
    return f""{day}-{month}-{year}""

# Test the function with the provided assertion
assert change_date_format('2026-01-02') == '02-01-2026'"
MBPP/918,coin_change,"def coin_change(coins, num_coins, amount):
    # Create a list to store the number of ways to make change for each amount
    dp = [0] * (amount + 1)
    
    # There is one way to make change for 0 amount: use no coins
    dp[0] = 1
    
    # Iterate over each coin
    for coin in coins:
        # Update the dp array for all amounts from coin to the target amount
        for x in range(coin, amount + 1):
            dp[x] += dp[x - coin]
    
    return dp[amount]

# Test the function with the provided assertion
assert coin_change([1, 2, 3], 3, 4) == 4"
MBPP/920,remove_tuple,"def remove_tuple(tuple_list):
    # Filter out tuples that are all None
    filtered_tuples = [t for t in tuple_list if any(value is not None for value in t)]
    return str(filtered_tuples)

# Test the function with the provided assertion
assert remove_tuple([(None, 2), (None, None), (3, 4), (12, 3), (None, )]) == '[(None, 2), (3, 4), (12, 3)]'"
MBPP/931,sum_series,"def sum_series(n):
    return sum(i**3 for i in range(1, n + 1))

# Test the function with the provided assertion
assert sum_series(7) == 784"
MBPP/929,count_tuplex,"def count_tuplex(tup, item):
    return tup.count(item)

# Test the function with the provided assertion
assert count_tuplex((2, 4, 5, 6, 2, 3, 4, 4, 7), 4) == 3"
MBPP/930,text_match,"import re

def text_match(string):
    # Define the regex pattern for 'a' followed by zero or more 'b's
    pattern = r'a(b*)'
    
    # Use re.fullmatch to check if the entire string matches the pattern
    if re.fullmatch(pattern, string):
        return 'Matched!'
    else:
        return 'Not matched!'

# Test the function
assert text_match(""msb"") == 'Not matched!'"
MBPP/932,remove_duplic_list,"def remove_duplic_list(words):
    # Use a set to track seen words and maintain order
    seen = set()
    result = []
    for word in words:
        if word not in seen:
            seen.add(word)
            result.append(word)
    return result

# Test the function with the provided assertion
assert remove_duplic_list([""Python"", ""Exercises"", ""Practice"", ""Solution"", ""Exercises""]) == ['Python', 'Exercises', 'Practice', 'Solution']"
MBPP/935,series_sum,"def series_sum(n):
    return sum(i**2 for i in range(1, n + 1))

# Test the function with the provided assertion
assert series_sum(6) == 91"
MBPP/926,rencontres_number,"def rencontres_number(n, k):
    # Create a 2D list to store the rencontres numbers
    R = [[0] * (k + 1) for _ in range(n + 1)]
    
    # Base case
    R[0][0] = 1  # R(0, 0) = 1
    
    # Fill the table using the recursive formula
    for i in range(1, n + 1):
        for j in range(1, min(i, k) + 1):
            R[i][j] = j * R[i - 1][j - 1] + (i - j) * R[i - 1][j]
    
    return R[n][k]

# Test the function with the provided assertion
assert rencontres_number(7, 2) == 924"
MBPP/933,camel_to_snake,"import re

def camel_to_snake(camel_str):
    # Use regex to find the positions where a lowercase letter is followed by an uppercase letter
    # and replace it with the lowercase letter followed by an underscore and the lowercase version of the uppercase letter
    snake_str = re.sub(r'(?<!^)(?=[A-Z])', '_', camel_str).lower()
    return snake_str

# Test the function
assert camel_to_snake('GoogleAssistant') == 'google_assistant'"
MBPP/936,re_arrange_tuples,"def re_arrange_tuples(tuples_list, order):
    # Create a dictionary to map the first element of each tuple to the tuple itself
    tuple_dict = {t[0]: t for t in tuples_list}
    
    # Use the order list to create a new list of tuples in the specified order
    arranged_tuples = [tuple_dict[i] for i in order if i in tuple_dict]
    
    return arranged_tuples

# Example usage
assert re_arrange_tuples([(4, 3), (1, 9), (2, 10), (3, 2)], [1, 4, 2, 3]) == [(1, 9), (4, 3), (2, 10), (3, 2)]"
MBPP/927,candidate,"class TreeNode:
    def __init__(self, value=0, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

def max_height(root):
    if root is None:
        return -1  # Return -1 for null nodes to count edges correctly
    else:
        left_height = max_height(root.left)
        right_height = max_height(root.right)
        return 1 + max(left_height, right_height)

# Example usage:
if __name__ == ""__main__"":
    # Constructing a binary tree
    #       1
    #      / \
    #     2   3
    #    / \
    #   4   5
    #  /
    # 6
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    root.left.left.left = TreeNode(6)

    assert (max_height(root)) == 3  # The height of this tree is 3"
MBPP/937,max_char,"from collections import Counter

def max_char(s):
    # Count the occurrences of each character in the string
    char_count = Counter(s)
    # Find the character with the maximum count
    most_common_char = char_count.most_common(1)[0][0]
    return most_common_char

# Test the function with the provided assertion
assert max_char(""hello world"") == 'l'"
MBPP/939,sorted_models,"def sorted_models(models):
    return sorted(models, key=lambda x: x['model'])

# Test the function with the provided assertion
assert sorted_models([
    {'make': 'Nokia', 'model': 216, 'color': 'Black'},
    {'make': 'Mi Max', 'model': 2, 'color': 'Gold'},
    {'make': 'Samsung', 'model': 7, 'color': 'Blue'}
]) == [
    {'make': 'Nokia', 'model': 216, 'color': 'Black'},
    {'make': 'Samsung', 'model': 7, 'color': 'Blue'},
    {'make': 'Mi Max', 'model': 2, 'color': 'Gold'}
]"
MBPP/923,super_seq,"def lcs_length(str1, str2):
    m = len(str1)
    n = len(str2)
    
    # Create a 2D array to store lengths of longest common subsequence
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Build the dp array
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    
    return dp[m][n]

def super_seq(str1, str2, len1, len2):
    lcs_len = lcs_length(str1, str2)
    return len1 + len2 - lcs_len

# Test the function with the provided assertion
assert super_seq(""AGGTAB"", ""GXTXAYB"", 6, 7) == 9"
MBPP/941,count_elim,"def count_elim(lst):
    count = 0
    for element in lst:
        if isinstance(element, tuple):
            break
        count += 1
    return count

# Test the function with the provided assertion
assert count_elim([10, 20, 30, (10, 20), 40]) == 3"
MBPP/942,check_element,"def check_element(elements, lst):
    return any(elem in lst for elem in elements)

# Test the function with the provided assertion
assert check_element((4, 5, 7, 9, 3), [6, 7, 10, 11]) == True"
MBPP/934,dealnnoy_num,"def delannoy_num(m, n):
    # Create a 2D array to store the Delannoy numbers
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Base cases
    for i in range(m + 1):
        dp[i][0] = 1  # Only one way to reach any cell in the first column
    for j in range(n + 1):
        dp[0][j] = 1  # Only one way to reach any cell in the first row
    
    # Fill the dp table using the recursive relation
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] + dp[i - 1][j - 1]
    
    return dp[m][n]

# Test the function with the provided assertion
assert delannoy_num(3, 4) == 129"
MBPP/945,tuple_to_set,"def tuple_to_set(input_tuple):
    return set(input_tuple)

# Test the function with the provided assertion
assert tuple_to_set(('x', 'y', 'z')) == {'y', 'x', 'z'}"
MBPP/943,combine_lists,"import heapq

def combine_lists(list1, list2):
    return list(heapq.merge(list1, list2))

# Test the function with the provided assertion
assert combine_lists([1, 3, 5, 7, 9, 11], [0, 2, 4, 6, 8, 10]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]"
MBPP/946,most_common_elem,"from collections import Counter

def most_common_elem(text, n):
    # Count the frequency of each character in the text
    counter = Counter(text)
    # Get the n most common elements
    most_common = counter.most_common(n)
    return most_common

# Test the function with the provided assertion
assert most_common_elem('lkseropewdssafsdfafkpwe', 3) == [('s', 4), ('e', 3), ('f', 3)]"
MBPP/940,heap_sort,"def heapify(arr, n, i):
    largest = i  # Initialize largest as root
    left = 2 * i + 1  # left = 2*i + 1
    right = 2 * i + 2  # right = 2*i + 2

    # If left child is larger than root
    if left < n and arr[left] > arr[largest]:
        largest = left

    # If right child is larger than largest so far
    if right < n and arr[right] > arr[largest]:
        largest = right

    # If largest is not root
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # swap

        # Recursively heapify the affected sub-tree
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    # Build a maxheap
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # One by one extract elements from heap
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # swap
        heapify(arr, i, 0)

    return arr

# Test the function
assert heap_sort([12, 2, 4, 5, 2, 3]) == [2, 2, 3, 4, 5, 12]"
MBPP/947,len_log,"def len_log(words):
    if not words:
        return 0  # Return 0 if the list is empty
    return min(len(word) for word in words)

# Example usage
assert len_log([""win"", ""lose"", ""great""]) == 3"
MBPP/938,find_closet,"def find_closet(arr1, arr2, arr3, n1, n2, n3):
    # Initialize pointers for each array
    i, j, k = 0, 0, 0
    # Initialize the result to store the closest elements
    closest = (0, 0, 0)
    # Initialize the minimum difference to a large value
    min_diff = float('inf')

    while i < n1 and j < n2 and k < n3:
        # Get the current elements from each array
        a, b, c = arr1[i], arr2[j], arr3[k]
        # Find the maximum and minimum of the three elements
        current_max = max(a, b, c)
        current_min = min(a, b, c)
        # Calculate the difference
        current_diff = current_max - current_min
        
        # Update the closest elements if the current difference is smaller
        if current_diff < min_diff:
            min_diff = current_diff
            closest = (a, b, c)
        
        # Move the pointer of the array with the smallest element
        if current_min == a:
            i += 1
        elif current_min == b:
            j += 1
        else:
            k += 1

    return closest

# Test the function with the provided assertion
assert find_closet([1, 4, 10], [2, 15, 20], [10, 12], 3, 3, 2) == (10, 15, 10)"
MBPP/948,get_item,"def get_item(tup, index):
    return tup[index:index+1]

# Test the function with the provided assertion
assert get_item((""w"", 3, ""r"", ""e"", ""s"", ""o"", ""u"", ""r"", ""c"", ""e""), 3) == ('e',)"
MBPP/944,num_position,"def num_position(s):
    # Initialize a list to hold the positions of numbers
    positions = []
    
    # Split the string into words
    words = s.split()
    
    # Iterate through the words and their indices
    for index, word in enumerate(words):
        # Check if the word is a digit
        if word.isdigit():
            # Print the number and its position
            print(f""Number: {word}, Position: {index}"")
            # Append the position to the list
            positions.append(index)
    
    # Return the count of numbers found
    return len(positions)

# Example usage
assert num_position(""there are 70 flats in this apartment"") == 1"
MBPP/950,chinese_zodiac,"def chinese_zodiac(year):
    zodiac_signs = [
        'Rat', 'Ox', 'Tiger', 'Rabbit', 'Dragon', 
        'Snake', 'Horse', 'Goat', 'Monkey', 'Rooster', 
        'Dog', 'Pig'
    ]
    return zodiac_signs[(year - 4) % 12]

# Test the function with the provided assertion
assert chinese_zodiac(1997) == 'Ox'"
MBPP/954,profit_amount,"def profit_amount(selling_price, cost_price):
    profit = selling_price - cost_price
    return profit if profit > 0 else None

# Test the function with the provided assertion
assert profit_amount(1500, 1200) == 300"
MBPP/956,split_list,"import re

def split_list(s):
    # Use regex to split the string at uppercase letters
    return re.findall(r'[A-Z][a-z]*|[a-z]+', s)

# Test the function with the provided assertion
assert split_list(""LearnToBuildAnythingWithGoogle"") == ['Learn', 'To', 'Build', 'Anything', 'With', 'Google']"
MBPP/949,sort_list,"def sort_list(tuples_list):
    # Function to calculate the total number of digits in a tuple
    def total_digits(tup):
        return sum(len(str(abs(num))) for num in tup)
    
    # Sort the list of tuples based on the total number of digits
    sorted_list = sorted(tuples_list, key=total_digits)
    
    # Return the sorted list as a string
    return str(sorted_list)

# Test the function with the provided assertion
assert sort_list([(3, 4, 6, 723), (1, 2), (12345,), (134, 234, 34)]) == '[(1, 2), (12345,), (3, 4, 6, 723), (134, 234, 34)]'"
MBPP/955,is_abundant,"def is_abundant(n):
    if n < 1:
        return False
    
    # Calculate the sum of proper divisors
    sum_of_divisors = sum(i for i in range(1, n) if n % i == 0)
    
    # Check if the sum of divisors is greater than the number
    return sum_of_divisors > n

# Test the function with the provided assertion
assert is_abundant(12) == True"
MBPP/953,subset,"def subset(arr, n):
    from collections import Counter
    
    # Count the frequency of each element in the array
    frequency = Counter(arr)
    
    # The minimum number of subsets needed is the maximum frequency
    return max(frequency.values())

# Test the function with the provided assertion
assert subset([1, 2, 3, 4], 4) == 1"
MBPP/959,Average,"def Average(numbers):
    if not numbers:  # Check if the list is empty
        return 0
    return sum(numbers) / len(numbers)

# Test the function with the provided assertion
assert Average([15, 9, 55, 41, 35, 20, 62, 49]) == 35.75"
MBPP/951,max_similar_indices,"def max_similar_indices(list1, list2):
    # Ensure both lists are of the same length
    if len(list1) != len(list2):
        raise ValueError(""Both lists must have the same length."")
    
    # Create a new list to store the maximum tuples
    max_tuples = []
    
    # Iterate through both lists simultaneously
    for tuple1, tuple2 in zip(list1, list2):
        # Append the maximum of the two tuples to the result list
        max_tuples.append(max(tuple1, tuple2))
    
    return max_tuples

# Test the function with the provided assertion
assert max_similar_indices([(2, 4), (6, 7), (5, 1)], [(5, 4), (8, 10), (8, 14)]) == [(5, 4), (8, 10), (8, 14)]"
MBPP/957,get_First_Set_Bit_Pos,"def get_First_Set_Bit_Pos(n):
    if n == 0:
        return -1  # Return -1 if there are no set bits
    position = 1
    while (n & 1) == 0:
        n >>= 1
        position += 1
    return position

# Test the function with the provided assertion
assert get_First_Set_Bit_Pos(12) == 3"
MBPP/952,nCr_mod_p,"def factorial_mod(n, p):
    """"""Compute n! % p for n >= 0.""""""
    if n == 0:
        return 1
    result = 1
    for i in range(2, n + 1):
        result = (result * i) % p
    return result

def mod_inverse(a, p):
    """"""Compute the modular inverse of a under modulo p using Fermat's Little Theorem.""""""
    return pow(a, p - 2, p)

def nCr_mod_p(n, r, p):
    """"""Compute nCr % p.""""""
    if r > n:
        return 0
    if r == 0 or r == n:
        return 1
    
    # Calculate n!, r!, and (n-r)!
    num = factorial_mod(n, p)
    denom = (factorial_mod(r, p) * factorial_mod(n - r, p)) % p
    
    # Calculate the modular inverse of denom
    denom_inv = mod_inverse(denom, p)
    
    # Calculate nCr % p
    return (num * denom_inv) % p

# Test the function with the provided assertion
assert nCr_mod_p(10, 2, 13) == 6"
MBPP/958,int_to_roman,"def int_to_roman(num):
    # Define the mapping of integers to Roman numerals
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
    ]
    syms = [
        ""M"", ""CM"", ""D"", ""CD"",
        ""C"", ""XC"", ""L"", ""XL"",
        ""X"", ""IX"", ""V"", ""IV"",
        ""I""
    ]
    
    roman_numeral = """"
    i = 0
    while num > 0:
        for _ in range(num // val[i]):
            roman_numeral += syms[i]
            num -= val[i]
        i += 1
    return roman_numeral

# Test the function with the provided assertion
assert int_to_roman(1) == ""I"""
MBPP/966,remove_empty,"def remove_empty(tuples_list):
    return [t for t in tuples_list if t]

# Test the function with the provided assertion
assert remove_empty([(), (), ('',), ('a', 'b'), ('a', 'b', 'c'), ('d')]) == [('',), ('a', 'b'), ('a', 'b', 'c'), 'd']"
MBPP/964,word_len,"def word_len(word):
    return len(word) % 2 == 0

# Test the function with the provided assertion
assert word_len(""program"") == False"
MBPP/962,sum_Even,"def sum_Even(l, r):
    # Ensure l is even; if not, increment it by 1
    if l % 2 != 0:
        l += 1
    # Ensure r is even; if not, decrement it by 1
    if r % 2 != 0:
        r -= 1
    # Calculate the sum of even numbers in the range
    return sum(range(l, r + 1, 2))

# Test the function with the provided assertion
assert sum_Even(2, 5) == 6"
MBPP/965,camel_to_snake,"def camel_to_snake(camel_str):
    # Initialize an empty list to hold the characters
    snake_str = []
    
    for char in camel_str:
        # If the character is uppercase, add an underscore before it (if it's not the first character)
        if char.isupper() and snake_str:
            snake_str.append('_')
        # Append the lowercase version of the character
        snake_str.append(char.lower())
    
    # Join the list into a string and return
    return ''.join(snake_str)

# Test the function
assert camel_to_snake('PythonProgram') == 'python_program'"
MBPP/961,roman_to_int,"def roman_to_int(s: str) -> int:
    roman_numerals = {
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000
    }
    
    total = 0
    prev_value = 0
    
    for char in reversed(s):
        current_value = roman_numerals[char]
        if current_value < prev_value:
            total -= current_value
        else:
            total += current_value
        prev_value = current_value
    
    return total

# Test the function with the provided assertion
assert roman_to_int('MMMCMLXXXVI') == 3986"
MBPP/963,discriminant_value,"def discriminant_value(a, b, c):
    D = b**2 - 4*a*c  # Calculate the discriminant
    if D > 0:
        return (""Two solutions"", D)
    elif D == 0:
        return (""One solution"", D)
    else:
        return (""No real solutions"", D)

# Test the function with the provided assertion
assert discriminant_value(4, 8, 2) == (""Two solutions"", 32)"
MBPP/967,check,"def check(s):
    # Define a set of vowels
    vowels = set('aeiou')
    # Convert the input string to lowercase and create a set of characters
    input_set = set(s.lower())
    # Check if all vowels are in the input set
    if vowels.issubset(input_set):
        return 'accepted'
    else:
        return 'not accepted'

# Test the function with the provided assertion
assert check(""SEEquoiaL"") == 'accepted'"
MBPP/960,get_noOfways,"def get_noOfways(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    elif n == 2:
        return 2
    
    # Initialize the first two values
    prev2 = 1  # This is F(1)
    prev1 = 2  # This is F(2)
    
    # Use dynamic programming to calculate the number of ways
    for i in range(3, n + 1):
        current = prev1 + prev2
        prev2 = prev1
        prev1 = current
    
    return prev1

# Test the function with the provided assertion
assert get_noOfways(4) == 3"
MBPP/969,join_tuples,"def join_tuples(tuples):
    from collections import defaultdict

    # Create a dictionary to hold lists of tuples by their first element
    grouped = defaultdict(list)

    # Group tuples by their first element
    for t in tuples:
        grouped[t[0]].append(t[1])

    # Create the result list by joining the first element with the corresponding values
    result = []
    for key, values in grouped.items():
        result.append((key,) + tuple(values))

    return result

# Test the function with the provided assertion
assert join_tuples([(5, 6), (5, 7), (6, 8), (6, 10), (7, 13)]) == [(5, 6, 7), (6, 8, 10), (7, 13)]"
MBPP/970,min_of_two,"def min_of_two(a, b):
    """"""Return the minimum of two numbers.""""""
    return a if a < b else b

# Test the function with the provided assertion
assert min_of_two(10, 20) == 10"
MBPP/968,floor_Max,"def floor_Max(a, b, c):
    return max(a, b, c)

# Test the function with the provided assertion
assert floor_Max(11, 10, 9) == 11"
MBPP/973,left_rotate,"def left_rotate(s, n):
    # Ensure n is within the bounds of the string length
    n = n % len(s) if s else 0
    return s[n:] + s[:n]

# Test the function with the provided assertion
assert left_rotate(""python"", 2) == ""thonpy"""
MBPP/972,concatenate_nested,"def concatenate_nested(tuple1, tuple2):
    return tuple1 + tuple2

# Test the function with the provided assertion
assert concatenate_nested((3, 4), (5, 6)) == (3, 4, 5, 6)"
MBPP/974,min_sum_path,"def min_sum_path(triangle):
    # Start from the second to last row and move upwards
    for row in range(len(triangle) - 2, -1, -1):
        for col in range(len(triangle[row])):
            # Update the current element to be the sum of itself and the minimum of the two elements below it
            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])
    
    # The top element now contains the minimum path sum
    return triangle[0][0]

# Test the function with the provided assertion
assert min_sum_path([[2], [3, 9], [1, 6, 7]]) == 6"
MBPP/971,maximum_segments,"def maximum_segments(n, a, b, c):
    # Create a dp array initialized to -1
    dp = [-1] * (n + 1)
    dp[0] = 0  # Base case: 0 length can be formed with 0 segments

    # Iterate through each length from 1 to n
    for i in range(1, n + 1):
        # Check if we can form a segment of length a
        if i >= a and dp[i - a] != -1:
            dp[i] = max(dp[i], dp[i - a] + 1)
        # Check if we can form a segment of length b
        if i >= b and dp[i - b] != -1:
            dp[i] = max(dp[i], dp[i - b] + 1)
        # Check if we can form a segment of length c
        if i >= c and dp[i - c] != -1:
            dp[i] = max(dp[i], dp[i - c] + 1)

    return dp[n] if dp[n] != -1 else 0

# Test the function with the provided assertion
assert maximum_segments(7, 5, 2, 5) == 2"
